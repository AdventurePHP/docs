<doku:title parent="119" tags="frontcontroller,front-controller,front controller,klassen,implementierung,action,input,bootstrap,url manipulation,timing model" title="Front-Controller" urlname="Frontcontroller">
   Die Front-Controller-Implementierung des Adventure PHP Frameworks bietet dem Entwickler die
   Möglichkeit generische Actions zu erstellen um nach dem Front-Controller-Entwurfsmuster die
   Business-Schicht als Steuerungsschicht der Web-Anwendung einzusetzen.
</doku:title>
<h3 id="Chapter-1-Einleitung"><a href="#Chapter-1-Einleitung">1. Einleitung</a></h3>
<p>
   Wie im Kapitel <int:link pageid="013" anchor="Chapter-2-Prinzipien-und-Paradigmen"/> beschrieben arbeitet die
   Anfrage-Bearbeitung des Adventure PHP Framework nach dem <em>Bootstrapping</em>-Prinzip. Dies bedeutet, dass alle
   Anfragen an eine Webseite oder Applikation von einer zentralen Datei beantwortet werden. Das APF folgt diesem
   Paradigma, da es Ihnen ermöglicht Initialisierung, Konfiguration und Auslieferung zentral zu steuern.
</p>
<p>
   Innerhalb der Bootstrap-Datei hilft Ihnen der <em>Frontcontroller</em> die wiederkehrenden Aufgaben der
   Anfrage-Verarbeitung ohne Entwicklungsaufwand zu erledigen. Als zentraler und interaler kümmert er sich um
</p>
<ul>
   <li>... die Entgegennahme einer Anfrage,</li>
   <li>... die Ausführung der <int:link pageid="137">Input- und Output-Filter</int:link>,</li>
   <li>... die Steuerung und Ausführung des <int:link pageid="098" /> und</li>
   <li>... die Ausführung von Anwendungslogik (<em>Actions</em>) zur Unterstützung der Anwendung.</li>
</ul>

<h3 id="Chapter-2-Timing-Modell"><a href="#Chapter-2-Timing-Modell">2. Timing-Modell</a></h3>
<p>
   Die Implementierung des <em>Frontcontroller</em> im Adventure PHP Framework basiert auf der gleichnamigen
   Pattern-Definition von
   <a class="external" href="http://www.martinfowler.com/eaaCatalog/frontController.html" title="Martin Fowler">Martin Fowler</a>.
   Das APF setzt mit dem <int:link pageid="098" /> auf das <em>HMVC</em>-Pattern für die Komposition und Erzeugung der
   Präsentations-Schicht. Aus diesem Grund unterscheidet sich die Implementierung von reinen <em>MVC</em>-Frameworks,
   bei denen der Front-Controller lediglich ein Mapping eines Requests auf <em>einen</em> Controller versteht.
</p>
<p>
   Das nachfolgend abgebildete Timing-Modell beschreibt den Prozess der Request-Verarbeitung des Frameworks und die
   Eingriffsmöglichkeiten durch <em>Actions</em>.
</p>
<p>
   <a id="FrontController-Timing-Model" title="Front-Controller timing model - zum Vergrößern klicken!" target="_blank" href="http://media.adventure-php-framework.org/content/frontcontroller_timing_model_2.X.png">
      <img src="http://media.adventure-php-framework.org/content/frontcontroller_timing_model_2.X.png" alt="Front-Controller timing model" style="width: 46em;"/>
   </a>
</p>
<p>
   Da der Front-Controller als zentrale Instanz für die Verarbeitung einer Anfrage genutzt wird, existiert jeweils nur
   eine Instanz der Klasse <em>Frontcontroller</em>. Diese wird in der Bootstrap-Datei mit Hilfe der
   <int:link pageid="030" />-Implementierung erzeugt und mit der Methode <em>start()</em> gestartet.
</p>
<div class="hint">
   Die Wiki-Seite
   <a class="wiki" href="http://wiki.adventure-php-framework.org/Unterschied_Frontcontroller_und_Pagecontroller">Unterschied Front-Controller und Page-Controller</a>
   greift nochmals wesentliche Merkmale des Front-Controller auf und beschreibt mögliche Anwendungsgebiete.
</div>

<h3 id="Chapter-3-Actions"><a href="#Chapter-3-Actions">3. Actions</a></h3>
<p>
   Front-Controller-Actions sind dazu gedacht, Logik auszuführen, die für einem bestimmten Zeitpunkt der Anwendung
   gedacht sind. Dies ist der Fall, wenn mehrere HMVC-Elemente auf gemeinsame Daten zugreifen, die Reihenfolge der
   Ausführung der Elemente jedoch nicht zur Entwickungszeit definiert werden kann - beispielsweise weil ein Redakteur
   die Inhalte zur Laufzeit verändern kann.
</p>
<p>
   Ein weiterer Anwendungsfall ist die Kapselung und Wiederverwendung von Logik zur Initialisierung einer Anwendung
   (z.B. Füllen eines (View-)Models) oder zur Ausführung von View-Logik (z.B. Prüfung der Berechtigungen eines Benutzers).
   Neben der Ausführung von View-Logik lassen sich <em>TYPE_PRE_PAGE_CREATE</em>-Actions auch dazu nutzen dynamische Ressourcen
   (z.B. Bilder) auszuliefern oder in der <em>TYPE_POST_TRANSFORM</em>-Phase während der Applikationsausführung zu
   Tracking-Zwecken gesammelte Inhalte zu verarbeiten.
</p>

<h4 id="Chapter-3-1-Definition"><a href="#Chapter-3-1-Definition">3.1. Definition</a></h4>
<p>
   Das Timing-Diagramm in <a href="#Chapter-2-Timing-Modell">Kapitel 2</a> definiert vier unterschiedliche Zeitpunkte,
   zu denen Actions ausgeführt werden. Diese können dazu genutzt werden, um verschiedene Aufgaben innerhalb der
   Applikation zu erledigen. Die genannten Zeitpunkte sind durch folgenden Konstanten der Klasse
   <em>AbstractFrontcontrollerAction</em> definiert:
</p>
<ul>
   <li>
      <strong><em>TYPE_PRE_PAGE_CREATE</em></strong>: die Action wird nach dem Ausführen der
      <int:link pageid="137">Input-Filter</int:link> und vor dem Erzeugen des <int:link pageid="098" /> ausgeführt.
   </li>
   <li>
      <strong>TYPE_PRE_TRANSFORM</strong>: die Action wird vor der Transformation
      der Seite (<em>transform()</em>) durch den <int:link pageid="098" /> ausgeführt.
   </li>
   <li>
      <strong>TYPE_POST_TRANSFORM</strong>: die Action wird nach der Transformation
      der Seite (<em>transform()</em>) und vor der Ausführung der <int:link pageid="137">Output-Filter</int:link>
      ausgeführt.
   </li>
</ul>
<p>
   Weitere Hinweise zum Page-Controller und dessen Timing-Modell finden sich unter <int:link pageid="098" /> bzw. im
   <a class="wiki" href="http://wiki.adventure-php-framework.org/Timing-Modell_des_Page-Controller">Wiki</a>.
</p>
<p>
   Die in der zuvor aufgeführten Konstanten lassen sich bei der Implementierung von Actions wie folgt zur Definition des
   Ausführungszeitpunktes verwenden:
</p>
<gen:highlight type="php">
class HeadlineImageGenerationAction extends AbstractFrontcontrollerAction {

   // Ausführungszeitpunkt in der Klassen-Deklaration festlegen
   protected $type = self::TYPE_PRE_PAGE_CREATE;

   public function __construct() {

      // Ausführungszeitpunkt bei der Erzeugung festlegen
      $this->type = self::TYPE_PRE_PAGE_CREATE
   }

   public function run() {
      ...
   }

}
</gen:highlight>
<div class="hint">
   Bitte beachten Sie, dass der Ausführungszeitpunkt nur zur Implementierungszeit der Action-Klasse durch das Befüllen
   der Klassen-Variable <em>$this->type</em> definiert werden kann. Eine Änderung zur Laufzeit ist nicht vorgesehen!
</div>

<h4 id="Chapter-3-2-Konfiguration"><a href="#Chapter-3-2-Konfiguration">3.2. Konfiguration</a></h4>
<p>
   Der Front-Controller des APF bietet Ihnen zwei Arten von Actions:
</p>
<ul>
   <li><em>Statische</em> Actions, die in der Bootstrap-Datei für alle Requests registriert werden.</li>
   <li><em>Dynamische</em> Actions, die über URL-Parameter bei Bedarf ausgeführt werden.</li>
</ul>
<p>
   Statische Actions kommen beispielsweise dann zum Einsatz, wenn Sie für die Ausführung Ihrer Anwendung ein von
   mehreren HMVC-Elementen genutztes View-Model initialisieren oder der aus Sicherheitsgründen der Login-Zustand Ihrer
   Benutzer vor Ausführung der eigentlichen Applikation geprüft werden soll.
</p>
<p>
   Dynamische Actions werden beispielsweise dann eingesetzt, wenn Sie Komponenten Ihrer Anwendung (z.B. dynamisch
   erzeugte Bilder) auch über die zentrale Bootstrap-Datei ausliefern möchten oder die in einer Action enthaltene
   View-Logik nur unter bestimmten Bedingungen ausgeführt werden soll (z.B. Ausführung einer Suche).
</p>
<p>
   Die folgenden beiden Kapitel zeigen die Konfiguration bzw. den Aufruf von statischen und dynamischen Actions.
</p>

<h5 id="Chapter-3-2-1-Statische-Actions"><a href="#Chapter-3-2-1-Statische-Actions">3.2.1. Statische Actions</a></h5>
<p>
   <em>Statische</em> Actions können in der Bootstrap-Datei <em>vor</em> dem Start des Front-Controller registriert
   werden. Die Reihenfolge der Ausführung hängt dabei von der Reihenfolge der Registrierung ab.
</p>
<p>
   Im folgenden Code-Beispiel werden zwei Actions registriert, die für die Initialsierung eines View-Models und die
   Prüfung der Benutzerberechtigungen zuständig sind:
</p>
<gen:highlight type="php">
include('../apps/core/bootstrap.php');

use APF\core\singleton\Singleton;
use APF\core\frontcontroller\Frontcontroller;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');

...

$fC->registerAction('APF\site\actions', 'init-model');
$fC->registerAction('APF\site\actions', 'check-permissions');

...
</gen:highlight>
<p>
   Die Methode <em>registerAction()</em> besitzt zwei Argumente: den Namespace in der die Action-Konfiguration abgelegt
   ist und den Namen der Action. Details zur Konfiguration und Adressierung entnehmen Sie bitte
   <a href="#Chapter-5-1-Konfiguration">Kapitel 5.1</a>.
</p>
<p>
   Die Actions <em>init-model</em> und <em>check-permissions</em> werden nun bei jeder Anfrage in der genannten
   Reihenfolge ausgeführt.
</p>
<p>
   Soll eine Action für einen speziellen Anwendungsfall konfiguriert werden oder möchten Sie aus einem anderen Grund der
   registrierten Action dynamische oder statische Parameter mitgeben, so können Sie hierzu das dritte Argument der
   Methode <em>registerAction()</em> nutzen:
</p>
<gen:highlight type="php">
include('../apps/core/bootstrap.php');

use APF\core\singleton\Singleton;
use APF\core\frontcontroller\Frontcontroller;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');

...

$fC->registerAction(
   'APF\site\actions',
   'init-model',
   array(
      'foo' => 'bar',
      'baz' => $_REQUEST['baz']
   )
);

...
</gen:highlight>

<h5 id="Chapter-3-2-2-Dynamische-Actions"><a href="#Chapter-3-2-2-Dynamische-Actions">3.2.2. Dynamische Actions</a></h5>
<p>
   <em>Dynamische</em> Actions lassen sich über URL-Parameter ansteuern und damit bei Bedarf ausführen. Dieser Mechanismus
   ist über die mit dem APF ausgelieferten <int:link pageid="137">Input-Filter</int:link> realisiert. Diese analysieren
   die aktuelle URL, extrahieren die darin enthaltenen Action-Aufrufe und übergeben diese an den Front-Controller.
</p>
<p>
   Wie im <int:link pageid="069" /> beschrieben bietet das APF zwei Typen von Input-Filtern an: den
   <em>ChainedStandardInputFilter</em>, der sich um die Filterung von Standard-URLs kümmert und den
   <em>ChainedUrlRewritingInputFilter</em>, der umgeschriebene URLs decodieren und in eine interne Repräsentation
   umwandeln kann. Die Adressierung von Actions für Standard-URLs gestaltet sich wie folgt:
</p>
<gen:highlight type="code">
{namespace}-action:{action-name}={param1}:{value1}|{param2}:{value2}|...
</gen:highlight>
<p>
   Dabei entspricht <em>{namespace}</em> dem Namespace der Action-Konfigurations-Datei und <em>{action-name}</em> dem
   Namen der Action. Die Parameter-Sätze sind jeweils durch &quot;|&quot; (Pipe) getrennt, Name und Wert durch
   &quot;:&quot;. Innerhalb der URL ist es möglich, mehrere Action-Anweisungen und Standard-Request-Parameter zu
   platzieren. Die folgende URL besitzt zwei Action-Anweisungen und weitere Steuer-Parameter:
</p>
<gen:highlight type="code">
?VENDOR_projects_projectone-action:setModel=pageid:1|lang:de&amp;news-page=3&amp;VENDOR_projects_projectone-action:stat=action:view|referer:32
</gen:highlight>
<div class="hint">
   Bitte beachten Sie, dass die Reihenfolge der Action-Definitionen die Reihenfolge der Ausführung
   <em>für Actions gleichen Typs</em> vorgibt! Details zu Action-Typen entnehmen Sie bitte
   <a href="#Chapter-3-1-Definition">Kapitel 3.1.</a>.
</div>
<p>
   Das Schema für umgeschriebene URLs ist so gewählt, dass weiterhin eine Trennung zwischen &quot;normalen&quot;
   Parametern und Action-Anweisungen möglich ist. Aus diesem Grund wurde das Trennzeichen &quot;/~/&quot; zwischen
   Parametern und Action-Anweisungen als auch zwischen mehreren Action-Anweisungen eingeführt. Die Adressierung von
   Actions für umgeschriebene URLs gestaltet sich wie folgt:
</p>
<gen:highlight type="code">
/~/{namespace}-action/{config-name}/{param1}/{value1}/{param2}/{value2}/...
</gen:highlight>
<p>
   Das zuvor aufgeführte Beispiel sieht für umgeschriebene URLs wie folgt aus:
</p>
<gen:highlight type="code">
/~/VENDOR_projects_projectone-action/setModel/pageid/1/lang/de/~/news-page/3/~/VENDOR_projects_projectone-action/stat/action/view/referer/32
</gen:highlight>
<div class="hint">
   Der hier gewählte Ansatz ist auf Allgemeingültigkeit ausgelegt. Soll aus SEO- oder anderen Gründen ein anderes
   URL-Layout gewählt werden, ist dies auf Basis von Input-Filtern jederzeit möglich. Action-Aufrufe können sowohl mit
   Hilfe von <em>RewriteRule</em>s als auch durch Anpassung der Filter generiert werden, die die Informationen aus der
   URL decodieren. Hinweise zur Implementierung von eigenen Filtern finden Sie im
   <a class="wiki" href="http://wiki.adventure-php-framework.org/Implementierung_von_eigenen_URL-Layouts">Wiki</a>.
</div>

<h5 id="Chapter-3-2-3-Action-URL-Mapping"><a href="#Chapter-3-2-3-Action-URL-Mapping">3.2.3. Action-URL-Mapping</a></h5>
<div class="hint">
   Bitte beachten Sie, dass das in diesem Kapitel beschriebene Feature erst ab Version 2.1 verfügbar ist.
</div>
<p>
   Das in <a href="#Chapter-3-2-2-Dynamische-Actions">Kapitel 3.2.2.</a> beschriebene URL-Schema ist auf Allgemeingültigkeit
   ausgelegt. Gleichzeitig kann es aus SEO-Gesichtspunkten für Ihr Projekt suboptimal sein, da die URLs durch darin
   enthaltene Actions lang oder unschön werden.
</p>
<p>
   Um URLs mit Action-Anweisungen kürzer und attraktiver zu gestalten, lassen sich für statische und dynamische Actions
   URL-Mappings definieren. Diese Trivial-Namen werden von den mit dem APF mitgelieferten Eingabe-Filtern
   <em>ChainedStandardInputFilter</em> und <em>ChainedUrlRewritingInputFilter</em> erkannt und in das interne Format
   umgewandelt. Bei der Link-Generierung durch den <em>LinkGenerator</em> nutzen die ebenfalls mitgelieferten
   <em>LinkScheme</em>-Implementierungen <em>DefaultLinkScheme</em> und <em>RewriteLinkScheme</em> die beim
   <em>Frontcontroller</em> registrieren Mappings um die relevanten Action-Anweisungen in ein externes Format zu
   konvertieren.
</p>
<div class="hint">
   Die Anzahl der <em>Action-Mappings</em> ist technisch nicht begrenzt. Sie können daher für mehrere oder alle Actions
   pro URL ein Mapping definieren.
</div>
<p>
   Nutzen Sie zur Ausführung einer Suche eine Front-Controller-Action, so lautet die dafür generierte URL in der
   Standard-Konfiguration wie folgt:
</p>
<gen:highlight type="code">
?VENDOR_components_search-action:executeSearch=type:faq
</gen:highlight>
<p>
   Nutzen Sie umgeschriebene URLs (Details siehe <int:link pageid="069" />), so generiert der <em>LinkGenerator</em>
   daraus
</p>
<gen:highlight type="code">
/~/VENDOR_components_search-action/executeSearch/type/faq
</gen:highlight>
<p>
   Möchten Sie sie generierten Links kürzer und damit attraktiver gestalten, so haben Sie die Möglichkeit ein
   <em>ActionUrlMapping</em> zu registrieren. Erweitern Sie Ihre Bootstrap-Datei (<em>index.php</em>) dazu wie folgt:
</p>
<gen:highlight type="php">
use APF\core\singleton\Singleton;
use APF\core\frontcontroller\Frontcontroller;
use APF\core\frontcontroller\ActionUrlMapping;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');

...

$fC->registerAction('VENDOR\components\search', 'executeSearch');
$fC->registerActionUrlMapping(
   new ActionUrlMapping('search', 'VENDOR\components\search', 'executeSearch')
);

...
</gen:highlight>
<p>
   Nutzen Sie zur Generierung der URL den folgenden Code, so nutzt das registrierte <em>LinkScheme</em> die beim
   Front-Controller gemeldeten Mappings um eine verkürzte URL zu erzeugen:
</p>
<gen:highlight type="php">
use APF\tools\link\LinkGenerator;
use APF\tools\link\Url;

$link = LinkGenerator::generateActionUrl(
      Url::fromCurrent(),
      'VENDOR\components\search',
      'executeSearch',
      array('type' => 'faq')
);
</gen:highlight>
<p>
   Die Suche kann nun per
</p>
<gen:highlight type="code">
?search=type:faq
</gen:highlight>
<p>
   bzw.
</p>
<gen:highlight type="code">
/search/type/faq
</gen:highlight>
<p>
   bei Nutzung von umgeschriebenen URLs ausgelöst werden.
</p>
<div class="warn">
   Bitte achten Sie bei der Definition der Trivial-Namen auf mögliche Überschneidungen mit normalen URL-Parametern.
   Im Fall von Überschneidungen kann die korrekte Analyse und Generierung der URL vom Framework nicht garantiert werden!
</div>
<p>
   Zusätzlich zur klassischen Registrierung von <em>Action-Mappings</em> stehen Ihnen noch zei weitere Möglichkeiten zur
   Verfügung: Übergabe eines URL-Parameters bei der Registrierung der Action (<em>Frontcontroller::registerAction()</em>)
   oder Definition einer oder mehrerer Konfigurations-Dateien.
</p>
<p>
   Registrieren Sie Ihre Action statisch in der Bootstrap-Datei, so bietet sich die Nutzung des vierten Arguments der
   Methode <em>registerAction()</em> an. Die Registrierung der Action und des zugehörigen Mappings verkürzt sich dann
   auf
</p>
<gen:highlight type="php">
$fC->registerAction('VENDOR\components\search', 'executeSearch', array(), 'search');
</gen:highlight>
<div class="hint">
   Bitte beachten Sie, dass das dritte Argument optional ist. Möchten Sie Ihre Action bei der Registrierung
   vorkonfigurieren, so können Sie bereits an dieser Stelle beliebige Parameter übergeben. Diese können Sie dann
   innerhalb der Action über das <em>Input</em>-Objekt abrufen.
</div>
<div class="warn">
   Bitte beachten Sie, dass die Registrierung von Actions und Mappings <strong>vor</strong> dem Start des Front-Controller
   über die Methode <em>Frontcontroller::start()</em> erfolgen muss!
</div>
<p>
   Möchten Sie die Konfiguration von <em>Action-Mappings</em> auslagern, so können Sie dem Front-Controller eine
   Konfigurations-Datei mitgeben aus der das Mapping gelesen wird.
</p>
<p>
   Hierzu bietet der Front-Controller die Methode <em>registerActionUrlMappings()</em> an. Diese nimmt den Namespace und
   den Namen der Konfiguration entgegen. Das Schema der Konfiguration ist wie folgt definiert:
</p>
<gen:highlight type="ini">
[{Url-Token}]
ActionNamespace = ""
ActionName = ""
</gen:highlight>
<p>
   Die folgende Code-Box zeigt Ihnen die erforderliche Konfigurations-Sektion für das in diesem Kapitel besprochene
   Anwendungsbeispiel:
</p>
<gen:highlight type="ini">
; search <-> VENDOR_components_search-action:search
[search]
ActionNamespace = "VENDOR\components\search"
ActionName = "executeSearch"
</gen:highlight>
<div class="hint">
   Innerhalb einer Konfigurations-Datei lassen sich eine beliebige Anzahl an <em>Action-Mappings</em> definieren. Der
   Front-Controller nimmt eine beliebige Anzahl von Dateien zur Konfiguration von <em>Action-Mappings</em> entgegen. Es
   steht Ihnen daher frei die Struktur der Konfigurations-Dateien nach den Vorgaben Ihres Projekts zu strukturieren.
</div>
<p>
   Die Registrierung des oben beschriebenen <em>Action-Mappings</em> lässt sich wie folgt in der Bootstrap-Datei
   erledigen:
</p>
<gen:highlight type="php">
use APF\core\singleton\Singleton;
use APF\core\frontcontroller\Frontcontroller;
use APF\core\frontcontroller\ActionUrlMapping;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');

...

$fC->registerActionUrlMappings('VENDOR\components\search', 'url-mappings.ini');

...
</gen:highlight>
<div class="hint">
   Bitte beachten Sie, dass die Registierung der <em>Action-Mappings</em> in einer eigenständigen Konfiguration definiert
   werden muss. Dies ist notwendig, da die Analyse der URL gemäß des <a href="#Chapter-2-Timing-Modell">Timing-Modell</a>
   zu einem früheren Zeitpunkt stattfinden als die Ausführung einer Action.
</div>
<div class="warn">
   Beachten Sie ferner, dass aus dem zuvor genannten Grund die Registrierung von <em>Action-Mappings</em> vor dem
   Starten des Front-Controller vorgenommen werden muss.
</div>

<h4 id="Chapter-3-3-Erzeugen-einer-Action-ueber-den-DI-Container"><a href="#Chapter-3-3-Erzeugen-einer-Action-ueber-den-DI-Container">3.3 Erzeugen einer Action über den DI-Container</a></h4>
<p>
   Neben der der Möglichkeit, Actions vom Frontcontroller erzeugen zu lassen und dazu den Klassen-Namen der Action anzugeben,
   besteht auch die Möglichkeit die Action durch den DI-Service-Manager erzeugen zu lassen. Dies bietet sich vor allem bei
   komplexen Aufgabenstellungen an, in denen die Action von anderen Anwendungskomponenten abhängig ist. Die abhängigen Objekte
   können hier einfach vom <em>DIServiceManager</em> in die Action injiziert werden. Details zur Konfiguration und
   Anwendung finden Sie unter <int:link pageid="107" anchor="Chapter-4-DIServiceManager" />.
</p>
<p>
   Die Action-Konfiguration unterscheidet sich im Wesentlichen nicht von der oben aufgeführten Variante (siehe
   <a href="#Chapter-3-2-Konfiguration">Kapitel 3.2</a>). In diesem Fall wird statt
   des Parameters <em>ActionClass</em> jedoch der Namespace und Name des Services angegeben:
</p>
<gen:highlight type="ini">
[{Action-Name}]
ActionServiceNamespace = ""
ActionServiceName = ""
[InputClass = ""]
[InputParams = ""]
</gen:highlight>
<ul>
    <li>
        <strong>ActionServiceNamespace</strong>:
        Gibt den Namespace an, in dem die Service-Konfiguration für die Action abgelegt wird. (Beispiel: <em>APF\project\biz\actions</em>)
    </li>
    <li>
        <strong>ActionServiceName</strong>:
        Der Name des Services für die Action. (Beispiel: <em>initialize-model</em>)
    </li>
</ul>
<div class="warn">
   Bitte beachten Sie, dass die Konfigurations-Direktiven in der Version 2.0 mit dem Präfix <em>FC.</em> definiert werden
   müssen. Für die Erzeugung einer Action mit dem <em>DIServiceManager</em> lautet das Schema einer Action-Definition
   wie folgt:
<gen:highlight type="ini">
[{Action-Name}]
FC.ActionServiceNamespace = ""
FC.ActionServiceName = ""
[FC.InputClass = ""]
[FC.InputParams = ""]
</gen:highlight>
</div>
<p>
   Für das obige Beispiel erwartet der Front-Controller die Konfigurations-Datei
   <em>config/project/biz/action/{CONTEXT}/{ENVIRONMENT}_serviceobjects.ini</em>, die eine Service-Definition
   <em>initialize-model</em> beinhaltet. Der Inhalt der Datei kann wie folgt aussehen:
</p>
<gen:highlight type="ini">
[initialize-model]
class = "APF\project\biz\actions\LoadModelAction"
servicetype = "NORMAL"

init.model.method = "setModel"
init.model.namespace = "APF\project\biz\model"
init.model.name = "ApplicationModel"
</gen:highlight>

<h3 id="Chapter-4-Bootstrap-Datei"><a href="#Chapter-4-Bootstrap-Datei">4. Bootstrap-Datei</a></h3>
<p>
   Wie bereits in der <a href="#Chapter-1-Einleitung">Einleitung</a> beschrieben setzt das APF auf das
   <em>Bootstrapping</em> Paradigma. Innerhalb der Bootstrap-Datei spielt der Front-Controller eine zentrale Rolle bei
   der Entgegennahme und Verarbeitung von Anfragen.
</p>
<p>
   Die folgende Code-Box zeigt eine minimale Bootstrap-Datei, die als Start für jede Anwendung genutzt werden muss:
</p>
<gen:highlight type="php">
include('./APF/core/bootstrap.php');

use APF\core\singleton\Singleton;
use APF\core\frontcontroller\Frontcontroller;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');
echo $fC->start('...', '...');
</gen:highlight>
<p>
   Die erste Zeile bindet die Datei <em>bootstrap.php</em> ein, die die notwendigen APF-Komponenten läd und das Framework
   initial konfiguriert. Sofern für Ihre Applikation eine davon abweichende Konfiguration verschiedener Komponenten
   vorgenommen werden soll, kann dies vor dem Start des Front-Controller erfolgen.
</p>
<p>
   Der Front-Controller selbst kann mit folgenden Methoden konfiguriert werden:
</p>
<ul>
   <li>
      <strong>setContext()</strong>:
      Definiert den Kontext der Anwendung und damit aller innerhalb der Anwendung über das APF erzeugten Objekte. Dieser
      Parameter wird vor allem für die <int:link pageid="134" /> genutzt.
   </li>
   <li>
      <strong>setLanguage()</strong>:
      Definiert die aktuelle Sprache der Anwendung. Diese kann in mehrsprachigen Anwendungen für die Anzeige von
      Sprach-abhänigen Inhalten genutzt werden.
   </li>
</ul>
<p>
   Weitere Konfigurationen in der Bootstrap-Datei sind unter
   <int:link pageid="013" anchor="Chapter-5-1-Aufbau-der-Bootstrap-Datei" /> aufgeführt.
</p>

<h3 id="Chapter-5-Implementierung-von-Actions"><a href="#Chapter-5-Implementierung-von-Actions">5. Implementierung von Actions</a></h3>
<p>
   Eine Front-Controller-Action im APF zeichnet sich durch eine Konfiguration und eine Implementierung in Form einer
   PHP-Klasse, die von <em>AbstractFrontcontrollerAction</em> erbt, aus. Die Trennung zwischen Implementierung und
   Konfiguration sorgt dafür, dass die Implementierung selbst nach aussen versteckt wird und zusätzliche Abhängigkeiten
   und Konfigurationen transparent aufgelöst werden können. Zusätzlich dazu bietet die Abstraktion von Action-Aufrufen
   über die URL ein erhöhtes Maß an Sicherheit, da die interne Struktur einer Applikation nicht nach aussen sichtbar ist.
</p>
<p>
   Die Eingabe-Parameter einer Action stellt der Front-Conroller in einer Instanz der Klasse <em>FrontcontrollerInput</em>
   oder einer davon abgeleiteten Klasse zur Laufzeit zur Verfügung. Sie haben damit die Möglichkeit, auf alle Parameter,
   die entweder in der URL oder der Konfiguration definiert sind innerhalb der Action zuzugreifen.
</p>

<h4 id="Chapter-5-1-Konfiguration"><a href="#Chapter-5-1-Konfiguration">5.1. Konfiguration</a></h4>
<p>
   Jede Action wird durch eine Konfigurations-Sektion definiert. Zur Adressierung einer Action wird der Namespace und
   der Name der Konfigurations-Sektion genutzt. Der Name der Konfigurations-Datei lautet per Konvention immer
   <em>{ENVIRONMENT}_actionconfig.ini</em>.
</p>
<p>
   Die Konfigurations-Sektion beinhaltet die Definition der Action-Implementierung und optional eine eigene
   Input-Implemenierung sowie optionale, statische Konfigurations-Parameter. Die Konfigurations-Parameter können dazu
   genutzt werden um eine konkrete Action-Implementierung für unterschiedliche Anwendungsfälle zu konfigurieren und
   so den Code in mehreren Anwendungen einsetzbar zu gestalten.
</p>
<p>
   Die Ablage der Konfigurations-Dateien folgt dem unter <int:link pageid="134" /> beschriebenen Schema.
</p>
<p>
   Wird eine Action mit dem Namespace <em>APF\modules\captcha\biz</em> und dem Namen <em>showCaptcha</em> beim
   Front-Controller zur Ausführung angefordert, so erwartet diser eine Konfigurations-Datei mit dem Namen
   <em>{ENVIRONMENT}_actionconfig.ini</em> unter dem genannten Namespace. Ist die aktuelle Applikation mit dem
   Context <em>projectone</em> und dem Standard-Einstellungen für die Umgebung konfiguriert, so wird die Konfiguration
   unter
</p>
<gen:highlight type="code">
/APF/config/modules/captcha/biz/projectone/DEFAULT_actionconfig.ini
</gen:highlight>
<p>
   erwartet. Die Konfigurations-Datei beinhalten dabei eine Sektion mit folgendem Inhalt:
</p>
<gen:highlight type="ini">
[showCaptcha]
ActionClass = "APF\modules\captcha\biz\ShowCaptchaImageAction"
</gen:highlight>
<p>
   Der Front-Controller nutzt diese Information nun um die Instanz der Klasse <em>ShowCaptchaImageAction</em> zu
   erzeugen und gemäß der Timing-Konfiguration (siehe <a href="#Chapter-3-1-Definition">Kapitel 3.1</a>) auszuführen.
</p>
<p>
   Das Schema einer Action-Konfiguration besteht aus folgenden Elementen:
</p>
<gen:highlight type="ini">
[{Action-Name}]
ActionClass = ""
[InputClass = ""]
[InputParams = ""]
</gen:highlight>
<p>
   Die aufgeführten Parameter haben folgende Bedeutungen:
</p>
<ul>
   <li>
      <strong>Action-Name</strong>:
      Externer Bezeichner der Action. Dieser Name wird sowohl in der URL als auch bei der statischen Konfiguration
      über die Methode <em>registerAction()</em> genutzt (Beispiel: <em>setModel</em>).
   </li>
   <li>
      <strong>ActionClass</strong>:
      Voll-qualifizierter Klassen-Name der Action-Implementierung (Beispiel: <em>APF\project\biz\actions\LoadModelAction</em>).
   </li>
   <li>
      <strong>InputClass</strong>:
      Voll-qualifizierter Klassen-Name der Input-Implementierung (Beispiel: <em>APF\project\biz\actions\DemositeModel</em>).
      Standard-Wert bei nicht definierter Konfigurations-Direktive ist <em>APF\core\frontcontroller\FrontcontrollerInput</em>.
   </li>
   <li>
      <strong>InputParams</strong>:
      Enthält Parameter, die bei der Erzeugung der Action in die Instanz der Input-Implementierung injiziert werden.
      Schlüssel und Wert werden durch &quot;:&quot; getrennt, mehrere Werte-Paare durch &quot;|&quot; (Beispiel:
      <em>login:true|headview:menu</em>). Ist die Konfigurations-Direktive nicht vorhanden, wird das Input-Objekt
      nicht initialisiert.
   </li>
</ul>
<div class="warn">
   Bitte beachten Sie, dass die Konfigurations-Direktiven in der Version 2.0 mit dem Präfix <em>FC.</em> definiert werden
   müssen. Für die Erzeugung einer Action mit dem <em>Front-Controller</em> lautet das Schema einer Action-Definition
   wie folgt:
<gen:highlight type="ini">
[{Action-Name}]
FC.ActionClass = ""
[FC.InputClass = ""]
[FC.InputParams = ""]
</gen:highlight>
</div>
<div class="hint">
   Die Nutzung einer eigenen Input-Implementierung ist empfehlenswert, wenn Sie die Verarbeitung von URL- oder
   Input-Parametern kapseln möchten.
</div>
<div class="hint">
   Die in der Direktive <em>InputParams</em> definierten Eingabe-Parameter können über die URL überschrieben werden.
   Dies ist insbesondere dann sinnvoll, wenn Sie beabsichtigen eine Action mit Basis-Werten konfigurieren und in einem konkreten
   Anwendungsfall mit einem anderen Verhalten zu starten. Die hierzu notwendige Logik ist bereits in der Methode
   <em>Frontcontroller::addAction()</em> vorhanden.
</div>

<h4 id="Chapter-5-2-Action-Implementierung"><a href="#Chapter-5-2-Action-Implementierung">5.2. Action-Implementierung</a></h4>
<p>
   Eine Front-Controller-Action definiert sich durch eine PHP-Klasse, die von <em>AbstractFrontcontrollerAction</em>
   erbt. Zur Ausführung der Logik muss die Methode <em>run()</em> implementiert werden.
</p>
<p>
   Das folgende Code-Beispiel zeigt eine Action, die Sie mit <em>Hallo Welt!</em> begrüßt und die Verarbeitung der
   Anfrage anschließend beendet:
</p>
<gen:highlight type="php">
namespace ACME\project\actions;

use APF\core\frontcontroller\AbstractFrontcontrollerAction;

class GreetMeAction extends AbstractFrontcontrollerAction {

   public function __construct() {
      $this->type = self::TYPE_PRE_PAGE_CREATE;
   }

   public function run() {
      echo 'Hallo Welt!';
      exit();
   }

}
</gen:highlight>
<p>
   Rufen Sie die in <a href="#Chapter-4-Bootstrap-Datei">Kapitel 4</a> definierte Bootstrap-Datei mit der URL
</p>
<gen:highlight type="code">
?ACME_project-action:greetMe
</gen:highlight>
<p>
   auf, so werden Sie - vorausgesetzt Sie haben die entsprechende <a href="#Chapter-5-1-Konfiguration">Konfiguration</a>
   angelegt - mit dem Satz <em>Hallo Welt!</em> begrüßt.
</p>
<div class="hint">
   Bitte beachten Sie, dass der in der URL angegebene Namespace nicht mit dem Namespace der Action-Implementierung
   übereinstimmen muss! Daher wählt das Beispiel bewusst einen unterschiedlichen Namespace.
</div>
<p>
   Bei der Erzeugung von Actions werden Kontext und Sprache der Applikation injiziert. Aus diesem Grund können Sie in
   Actions beliebige Applikations-Logik verpacken. Kontext-abhängige Aktionen wie beispielsweise das Laden einer
   <int:link pageid="134" /> sind daher ohne Probleme möglich. Ebenso verhält es sich mit dem Zugriff auf gemeinsam
   genutzte Ressourcen wie einem View-Model.
</p>
<p>
   Weitere Beispiele für Action-Implementierungen finden Sie im <a href="#Chapter-8-Weiterfuehrende-Beispiele">Kapitel 8</a>.
</p>

<h4 id="Chapter-5-3-Input-Implementierung"><a href="#Chapter-5-3-Input-Implementierung">5.3. Input-Implementierung</a></h4>
<p>
   Input-Klassen kapseln die Eingabe-Parameter einer Action und sind hinsichtlich der Konfiguration als optional zu
   betrachten. Wird für eine Action in der Konfiguration keine Input-Implementierung angegeben, so nutzt der
   Front-Controller eine Instanz der Klasse <em>FrontcontrollerInput</em> als Standard.
</p>
<div class="hint">
   Ist die Logik der Input-Klasse auf das Aufnehmen und Wiedergeben von Action-Parametern beschränkt, so ist es nicht
   notwendig eine eigene Klasse zu implementieren. Sie können auch in diesem Fall auf die Standard-Implementierung
   <em>FrontcontrollerInput</em> zurück greifen.
</div>
<p>
   Möchten Sie von der Action in <a href="#Chapter-5-2-Action-Implementierung">Kapitel 5.2.</a> persönlich begrüßt
   werden, so können Sie dies mit der folgenden Implementierung erreichen:
</p>
<gen:highlight type="php">
namespace ACME\project\actions;

use APF\core\frontcontroller\AbstractFrontcontrollerAction;

class GreetMeAction extends AbstractFrontcontrollerAction {

   public function __construct() {
      $this->type = self::TYPE_PRE_PAGE_CREATE;
   }

   public function run() {
      $input = $this->getInput();

      echo 'Hallo ' . $input->getAttribute('name') . '!';
      exit();
   }

}
</gen:highlight>
<p>
   Der abgebildete Code der Methode <em>run()</em> setzt voraus, dass Sie die Action mit dem Parameter <em>name</em>
   ausstatten. Rufen Sie die in <a href="#Chapter-4-Bootstrap-Datei">Kapitel 4</a> definierte Bootstrap-Datei mit der URL
</p>
<gen:highlight type="code">
?ACME_project-action:greetMe=name:Harry
</gen:highlight>
<p>
   auf, so werden Sie - vorausgesetzt Sie haben die entsprechende <a href="#Chapter-5-1-Konfiguration">Konfiguration</a>
   angelegt - mit dem Satz <em>Hallo Harry!</em> begrüßt.
</p>
<p>
   Wir kein Name übergeben, so wird keine korrekte Begrüßung ausgegeben. Mit einer eigenen Input-Implementierung haben
   Sie die Möglichkeit, eine Verarbeitung der Eingabe-Parameter zu implementieren, die beispielsweise dafür sorgt, dass
   fehlende Eingaben durch Standard-Werte ersetzt werden:
</p>
<gen:highlight type="php">
namespace ACME\project\actions;

use APF\core\frontcontroller\FrontcontrollerInput;

class GreetMeInput extends FrontcontrollerInput {
   public function getName() {
      return $this->getAttribute('name', 'Welt');
   }
}
</gen:highlight>
<p>
   Schreiben Sie die Action nun wie folgt um, so werden Sie sowohl mit als auch ohne Übergabe eines Namens korrekt
   begrüßt:
</p>
<gen:highlight type="php">
namespace ACME\project\actions;

use APF\core\frontcontroller\AbstractFrontcontrollerAction;

class GreetMeAction extends AbstractFrontcontrollerAction {

   public function __construct() {
      $this->type = self::TYPE_PRE_PAGE_CREATE;
   }

   public function run() {
      $input = $this->getInput();

      echo 'Hallo ' . $input->getName() . '!';
      exit();
   }

}
</gen:highlight>

<h3 id="Chapter-6-Action-Steuerung"><a href="#Chapter-6-Action-Steuerung">6. Action-Steuerung</a></h3>

<h4 id="Chapter-6-1-Aktivierung-Deaktivierung"><a href="#Chapter-6-1-Aktivierung-Deaktivierung">6.1. Aktivierung/Deaktivierung</a></h4>
<p>
   Neben der Definition der Ausführungszeit (Details siehe <a href="#Chapter-3-1-Definition">Kapitel 3.1</a>) stellt
   der Front-Controller noch eine weitere Möglichkeit bereit die Ausführung von Actions zu beeinflussen. Möchten Sie
   die Ausführung einer Action unter bestimmten Umständen unterbinden, so können Sie dies durch Überschreiben der
   Methode <em>AbstractFrontcontrollerAction::isActive()</em> realisieren.
</p>
<p>
   Gibt <em>isActive()</em> Ihrer Implementierung <em>true</em> zurück, wird die <em>run()</em>-Methode ausgeführt,
   im Fall von <em>false</em> nicht. Dies ermöglicht Ihnen die Action nicht oder erst dann auszuführen, wenn eine
   andere Action auf dem Action-Stack geladen ist oder eine andere Bedingung zutrifft.
</p>
<p>
   Das folgende Beispiel sorgt dafür, dass die Action nur dann ausgeführt wird, denn eine bestimmte Action nicht auf dem
   Action-Stack vorhanden ist:
</p>
<gen:highlight type="php">
public function isActive() {
   $captcha = $this->getFrontController()->getActionByName('showCaptcha');
   return $captcha === null;
}
</gen:highlight>

<h4 id="Chapter-6-2-Priorisierung"><a href="#Chapter-6-2-Priorisierung">6.2. Priorisierung</a></h4>
<div class="hint">
   Bitte beachten Sie, dass dieses Feature erst ab Version 2.1 zur Verfügung steht.
</div>
<p>
   In manchen Situationen ist es notwendig, die Reihenfolge der Action-Ausführung festlegen zu können. Dies ist beispielsweise
   dann der Fall, wenn Sie eine Action zur Initialisierung ihrer Applikation nutzen und zusätzlich Teile der
   Applikations-Logik als Actions abbilden (z.B. Suche). Vertraut die Logik der Suche auf einer initialisierten
   Appikation, so muss sichergestellt sein, dass die Suche erst nach der Initialisierung stattfindet.
</p>
<p>
   Für diesen Fall bietet das APF die Möglichkeit an, Actions nach einer bestimmten Reihenfolge zu sortieren. In
   Auslieferungs-Zustand erhält jede Action die Priorität <em>10</em>. Besitzt eine Action die Priorität <em>20</em>, so
   wird diese vorher ausgeführt, sofern sie eine Zahl kleiner <em>10</em> - z.B. <em>1</em> - besitzt, danach.
</p>
<p>
   Der Front-Controller nutzt die Methode <em>AbstractFrontcontrollerAction::getPriority()</em> zur Bestimmung der Priorität
   und zur entsprechenden Sortierung auf dem Action-Stack. Möchten Sie die Priorität Ihrer Action beeinflussen, so
   überschreiben Sie bitte die genannte Methode. Beispiel:
</p>
<gen:highlight type="php">
use APF\core\frontcontroller\AbstractFrontcontrollerAction;

class SearchAction extends AbstractFrontcontrollerAction {

   ...

   public function getPriority() {
      return 9;
   }

   ...

}
</gen:highlight>
<p>
   Wird die <em>SearchAction</em> zusammen mit einer Action zur Initialisierung Ihrer Applikation ausgeführt, so
   kommt diese erst als zweite an die Reihe.
</p>
<div class="warn">
   <p>
      Die Reihenfolge der Ausführung Ihrer Aktions ist zunächst abhängig von ihrem Typ (<em>prepagecreate</em>,
      <em>pretransform</em> und <em>posttransform</em>), die gemäß <a href="#Chapter-2-Timing-Modell">Timing-Modell</a>
      zu unterschiedlichen Zeitpunkten ausgeführt werden.
   </p>
   <p>
      Bei Actions gleichen Typs entscheidet dann die von der Methode <em>getPriority()</em> zurückgegebene Zahl.
      Bei wiederum gleichen Werten entscheidet der Registrierungszeitpunkt. Dieser wird entweder durch die statische
      Registrierung in der Bootstrap-Datei (<em>index.php</em>) oder für dynamische Actions über die Position in der URL
      bestimmt.
   </p>
</div>
<p>
   Da die Priorität von der Methode <em>getPriority()</em> zurück gegeben wird, lässt sich diese auch auf Basis von
   weiteren Faktoren berechnen. Soll eine Action beispielsweise abhängig von einer anderen Action auf dem Stack früher
   oder - falls diese vorhanden ist - später ausgeführt werden, so lässt sich dies wie folgt realisieren:
</p>
<gen:highlight type="php">
public function getPriority() {
   $relatedAction = $this->getFrontController()->getActionByName('relatedAction');
   if ($relatedAction === null) {
      return 12;
   }

   return $relatedAction->getPriority() - 1;
}
</gen:highlight>
<p>
   Mit Hilfe der Methode <em>getActions()</em> lässt sich beispielsweise an Hand der Liste die höchste Priorität
   feststellen und als Grundlage für eine Berechung nutzen:
</p>
<gen:highlight type="php">
public function getPriority() {

   $max = 0;

   foreach ($this->getFrontController()->getActions() as $action) {
      $max = max($max, $action->getPriority());
   }

   return $max + 1;
}
</gen:highlight>

<h3 id="Chapter-7-Generierung-von-Links"><a href="#Chapter-7-Generierung-von-Links">7. Generierung von Links</a></h3>
<p>
   Die Gestaltung des URL-Layouts übernehmen im APF die <int:link pageid="137">Input- und Output-Filter</int:link> sowie
   die zugehörigen <int:link pageid="138" anchor="Chapter-2-3-LinkScheme">LinkScheme</int:link>-Implementierungen.
</p>
<p>
   Die Eingabe-Filter sind - wie in <a href="#Chapter-3-2-2-Dynamische-Actions">Kapitel 3.2.2.</a> beschrieben - dafür
   verantwortlich die URL zu analysieren, darin enthaltene Front-Controller-Anweisungen zu extrahieren und an den
   Front-Controller zu übergeben. Das APF liefert hierzu die Filter <em>ChainedStandardInputFilter</em> für einfache URLs
   und <em>ChainedUrlRewritingInputFilter</em> für umgeschriebene URLs mit.
</p>
<p>
   Die jeweils genutzte <em>LinkScheme</em>-Implementierung bietet Ihnen mit der <em>formatActionLink()</em>-Methode
   eine Schnittstelle an um Action-URLs automatisiert und jeweils passend zum Eingabe-Filter zu generieren. Das APF
   liefert hierzu die Implementierungen <em>DefaultLinkScheme</em> für einfache URLs und <em>RewriteLinkScheme</em> für
   umgeschriebene URLs mit.
</p>
<div class="warn">
   <p>
      Bei der Generierung von URLs über die Methode <em>LinkGenerator::generateActionUrl()</em> werden auf dem Action-Stack
      vorhandene Actions <em>nicht</em> automatisch in die generierte URL inkludiert. Dies hat den Grund, dass nur der
      Entwickler selbst entscheiden kann, welche Action in der URL repräsentiert sein soll und damit bei der nächsten
      Anfrage dynamisch ausgeführt werden soll.
   </p>
   <p>
      Möchten Sie eine Action bewusst bei der URL-Generierung einbeziehen, so haben Sie die Möglichkeit diese über die
      Variable <em>$keepInUrl</em> zu markieren. Beispiel:
   </p>
<gen:highlight type="php">
namespace ACME\project\actions;

use APF\core\frontcontroller\AbstractFrontcontrollerAction;

class GreetingAction extends AbstractFrontcontrollerAction {

   public function __construct() {
      $this->type = self::TYPE_PRE_PAGE_CREATE;
      $this->setKeepInUrl(true);
   }

   ...

}
</gen:highlight>
   <p>
      Um dynamisch zu entscheiden - beispielsweise an Hand von Parametern eines View-Models Ihrer Anwendung - ob die
      Action bei der URL-Generierung berücksichtigt werden soll oder nicht, können Sie auch die Methode <em>getKeepInUrl()</em>
      direkt überschreiben. Diese wird vom jeweiligen <em>LinkScheme</em> dazu genutzt um Actions explizit einzuschließen:
   </p>
<gen:highlight type="php">
namespace ACME\project\actions;

use APF\core\frontcontroller\AbstractFrontcontrollerAction;

class GreetingAction extends AbstractFrontcontrollerAction {

   public function __construct() {
      $this->type = self::TYPE_PRE_PAGE_CREATE;
   }

   public function getKeepInUrl() {
      $model = $this->getViewModel();
      return $model->getFoo() === true;
   }

   ...

}
</gen:highlight>
</div>
<p>
   Details zur Generierung von URLs können Sie dem Kapitel <int:link pageid="138" /> entnehmen.
</p>

<h3 id="Chapter-8-Weiterfuehrende-Beispiele"><a href="#Chapter-8-Weiterfuehrende-Beispiele">8. Weiterführende Beispiele</a></h3>
<p>
   Konkrete Anwendungsfälle wie die dynamische Auslieferung von Bildern, der Prüfung des Login-Zustands eines
   Benutzers oder der Sprach-Umschaltung werden im Kapitel <int:link pageid="056" /> beschrieben.
</p>
<p>
   Ein weiteres Beispiel für die Anwendung von Actions können Sie im Artikel <int:link pageid="082" lang="en"/>
   (English) nachlesen.
</p>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_012" />
