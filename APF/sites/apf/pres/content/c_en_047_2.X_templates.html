<doku:title parent="119" tags="templates,hmvc,page-controller,tags,darstellung von listen,controller" title="Templates" urlname="Templates">
   Templates are used by the template-centric implementation of the HMVC pattern of the Adventure PHP Framework to
   define the UI. Besides, they are designed to help to separate logic and look &amp; feel.
</doku:title>
<h3 id="Chapter-1-Definition-of-templates"><a href="#Chapter-1-Definition-of-templates">1. Definition of templates</a></h3>
<p>
   The Adventure PHP Framework (APF) uses several meanings of <em>template</em>:
</p>
<ul>
   <li>
      Templates are the basis of the <em>HMVC pattern</em> implementation of the <int:link pageid="098" />. This
      component creates a DOM structure using template files (HTML files) or tags and enables the developer to dynamically
      create the surface of a website or an application according to the requirements.
   </li>
   <li>
      Besides, templates are often referred to as re-usable elements within template files. A common representative is
      the <int:link pageid="046" anchor="Chapter-2-3-Template">&lt;html:template /&gt;</int:link> tag that can be used
      to realize conditional output or to display repetitive content within template files.
   </li>
</ul>
<p>
   The definition of the <em>MVC pattern</em> describes the meaning of <em>model</em>, <em>view</em>, and
   <em>controller</em>. The <em>HMVC pattern</em> defines a hierarchical structure of MVC DOM elements that is created
   based on template content. The <int:link pageid="098" /> uses the information that are contained within the template
   files and created child nodes within the current node.
</p>
<p>
   Each template, or each node of the HMVC DOM tree respectively, may define a <int:link pageid="006" /> according to
   the definition of the MVC pattern.
</p>

<h3 id="Chapter-2-Content-of-templates"><a href="#Chapter-2-Content-of-templates">2. Content of templates</a></h3>
<p>
   Template files typically contain three types of content:
</p>
<ul>
  <li>APF tags (e.g. <em>&lt;html:placeholder /&gt;</em>)</li>
  <li>HTML code (e.g. <em>&lt;p&gt;...&lt;/p&gt;</em>)</li>
  <li>Any text</li>
</ul>
<p>
   Tags are XML tags that are known to the APF parser such as <em>&lt;prefix:name /&gt;</em>. They can define any number
   of attributes - e.g. <em>attribute="value"</em>. Explicitly closing tags may contain further tags or simple textual
   content.
</p>
<p>
   HTML code and any kind of text can be used to fill the content of your web site or application and are not treated
   by the APF parser. Thus, you can use both as content of attributes and tags.
</p>
<div class="warn">
   <p>
      Please be aware that HTML code within tag attributes can only be processed in case there are no quotes (&quot;).
   </p>
   <p>
      Within APF tags any kind of HTML code can be placed as long as the code does not interfere with the nested tag
      structure.
   </p>
   <p>
      Details on the APF parser can be read about under <int:link pageid="147" anchor="Chapter-6-Tag-hierarchies" />.
   </p>
</div>

<h4 id="Chapter-2-1-Template-files"><a href="#Chapter-2-1-Template-files">2.1. Template files</a></h4>
<p>
   Template files are used within the Adventure PHP Framework to create the UI of a web site or application and the
   <int:link pageid="012" /> is always started with an initial template.
</p>
<p>
   Within template files APF tags (see <int:link pageid="046"/>), HTML code or any kind of text can be placed.
   In most cases the template - e.g. the initial template - contains the basic frame of a web site or an application
   and defines place holders for dynamic content or includes further templates. Displaying dynamic content, each template
   may define a <int:link pageid="006" /> that is executed on transformation.
</p>
<p>
   The following code box contains the basic frame of a web site:
</p>
<gen:highlight type="apf-xml">
&lt;@controller
   class="VENDOR\pres\controller\MainController"
@&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;title&gt;&lt;html:placeholder name="title" /&gt;&lt;/title&gt;
      &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;header&gt;
         &lt;h1&gt;&lt;html:placeholder name="title" /&gt;&lt;/h1&gt;
         &lt;core:importdesign
            namespace="VENDOR\pres\templates"
            template="navi"
         /&gt;
      &lt;/header&gt;
      &lt;div id="content"&gt;
         &lt;core:importdesign
            namespace="VENDOR\pres\templates"
            template="content"
         /&gt;
      &lt;/div&gt;
      &lt;footer&gt;
         &lt;core:importdesign
            namespace="VENDOR\pres\templates"
            template="footer"
         /&gt;
      &lt;/footer&gt;
   &lt;/body&gt;
&lt;/html&gt;
</gen:highlight>
<p>
   The above template defines two <int:link pageid="046" anchor="Chapter-2-1-Placeholder">place holder tags</int:link>
   that are filled by the <em>MainController</em> and includes further templates using three
   <int:link pageid="046" anchor="Chapter-1-2-Importdesign">&lt;core:importdesign /&gt;</int:link> tag
   that take care of navigation, content, and footer.
</p>
<p>
   A list of known tags can be found under <int:link pageid="046" /> or <int:link pageid="078" /> respectively. The
   <int:link pageid="147" /> tutorial describes how to create custom tags and functions for your web site or application.
</p>

<h4 id="Chapter-2-2-HTML-templates"><a href="#Chapter-2-2-HTML-templates">2.2. HTML templates</a></h4>
<p>
   HTML templates are used to define reusable HTML fragments to display conditional content or to create lists. It is
   recommended to create one template per element that can be used by the controller. HTML templates are not automatically
   displayed where they are defined but are structural elements that are used to generate content.
</p>
<p>
   The following code box shows an HTML template that is used to create a dynamic table:
</p>
<gen:highlight type="apf-xml">
&lt;@controller
   class="VENDOR\pres\controller\ListController"
@&gt;
&lt;table&gt;
   &lt;thead&gt;
      &lt;tr&gt;
         &lt;td&gt;Frage&lt;/td&gt;
         &lt;td&gt;Antwort&lt;/td&gt;
      &lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
      &lt;html:placeholder name="table-rows" /&gt;
   &lt;/tbody&gt;
&lt;/table&gt;

&lt;html:template name="table-row"&gt;
&lt;tr&gt;
   &lt;td&gt;&lt;template:placeholder name="question" /&gt;&lt;/td&gt;
   &lt;td&gt;&lt;template:placeholder name="answer" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/html:template&gt;
</gen:highlight>
<p>
   The template itself contains the frame of the table and the <em>&lt;html:template /&gt;</em> tag defines one
   line of the table. Generating the content the following controller can be used:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class ListController extends BaseDocumentController {

   public function transformContent() {

      $row = $this->getTemplate('table-row');

      $buffer = '';
      foreach ($this->getItems() as $item) {
         $row->setPlaceHolder('question', $item->getQuestion());
         $row->setPlaceHolder('answer', $item->getAnswer());
         $buffer .= $row->transformTemplate();
      }

      $this->setPlaceHolder('table-rows', $buffer)

   }

   /**
    * @return FaqEntry[]
    */
   private function getItems() {
      ...
   }

}
</gen:highlight>
<div class="hint">
   Templates that are not used for list generation or for repetitive content can be displayed directly where they are
   defines. For that reason, please use <em>transformOnPlace()</em> within your document controller. Example:
<gen:highlight type="php">
class MainController extends BaseDocumentController {
   public function transformContent(){
      $tmpl = &$this->getTemplate('template-name');
      $tmpl->transformOnPlace();
   }
}
</gen:highlight>
</div>
<p>
   In order to simplify display of lists you may want to directly fill place holders. Fur this reason, you can combine
   two features: the third parameter of the <em>setPlaceHolder()</em> method allows to append content to a place holder
   and the <em>TemplateTag</em> supports direct output generation implementing the <em>__toString()</em>-Method which
   internally transforms the template.
</p>
<p>
   The controller implementation can be rewritten as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class ListController extends BaseDocumentController {

   public function transformContent() {

      $row = $this->getTemplate('table-row');

      foreach ($this->getItems() as $item) {
         $row->setPlaceHolder('question', $item->getQuestion());
         $row->setPlaceHolder('answer', $item->getAnswer());
         $this->setPlaceHolder('table-rows', $row, true);
      }

   }

   /**
    * @return FaqEntry[]
    */
   private function getItems() {
      ...
   }

}
</gen:highlight>

<h3 id="Chapter-3-Extended-templating"><a href="#Chapter-3-Extended-templating">3. Extended templating</a></h3>
<div class="hint">
   Bitte beachten Sie, dass die in diesem Kapitel beschriebe Funktionalität erst im Release 2.1. verfügbar ist!
</div>
<p>
   Zusätzlich zu den im <a href="#Chapter-2-Aufbau-von-Templates">Kapitel 2</a> beschriebenen Funktionen lassen sich
   innerhalb von APF-Templates auch dynamische Template-Ausdrücke nutzen. Diese bieten Ihnen eine Kurzschreibweise für
   Platzhalter wie z.B. <em>&lt;html:placeholder /&gt;</em> sowie eine Pseudo-Sprache für den Zugriff auf Data-Attribute
   von APF-DOM-Knoten. Darüber hinaus lassen sich auch Methoden-Aufrufe und Listen-Zugriffe auf Data-Attribute realisieren.
</p>
<p>
   Die folgenden Kapitel zeigen Ihnen die Nutzung der beiden Funktionen und geben Ihnen Anwendungsbeispiele.
</p>

<h4 id="Chapter-3-1-Platzhalter"><a href="#Chapter-3-1-Platzhalter">3.1. Platzhalter</a></h4>
<p>
   Neben den bekannten APF-Tags für Platzhalter wie beispielsweise
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="foo" /&gt;
</gen:highlight>
<p>
   lässt sich auch die Kurzformen
</p>
<gen:highlight type="apf-xml">
${foo}
</gen:highlight>
<p>
   nutzen. Dies hilft die Größe Ihres Template-Codes zu reduzieren und gegebenfalls Probleme mit der IDE-Unterstützung
   für HTML-Dateien zu vermeiden.
</p>
<div class="hint">
   Die Kurzschreibweise von Platzhaltern setzt sich aus <em>${</em>, einem eindeutigen Bezeichner und einer schließenden
   Klammer - <em>}</em> - zusammen. Der Bezeichner darf keine weiteren Klammern enthalten. Erlaubt sind große und kleine
   Buchstaben sowie Binde- und Unterstriche.
</div>
<p>
   Der Zugriff auf Platzhalter in der Kurzform unterscheidet sich nicht von der herkömmlichen Notation. Möchten Sie die
   Platzhalter des Templates
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="${css-class}">
   <p>
      ${intro-text}
   </p>
   <p>
      ${detail-text}
   </p>
   <p>
      <a href="${link-target}">${link-label}</a>
   </p>
</div>
</gen:highlight>
<p>
   füllen, so können Sie dazu den folgenen Controller-Code nutzen:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      $this->setPlaceHolder('css-class', $model->getCssClass());
      $this->setPlaceHolder('intro-text', $model->getIntroText());
      $this->setPlaceHolder('detail-text', $model->getDetailText());
      $this->setPlaceHolder('link-target', $model->getMoreLink()->getTarget());
      $this->setPlaceHolder('link-label', $model->getMoreLink()->getLabel());

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>

<h4 id="Chapter-3-2-Objekt-Zugriff"><a href="#Chapter-3-2-Objekt-Zugriff">3.2. Objekt-Zugriff</a></h4>
<p>
   Die <em>Pseudo-Template-Sprache</em> des APF ermöglicht Ihnen, mit einem dynamischen Ausdruck auf Data-Attribute von
   APF-DOM-Knoten zuzugreifen und die dort abgelegten Inhalte innerhalb von Templates auszugeben.
</p>
<p>
   Das in <a href="#Chapter-3-1-Platzhalter">Kapitel 3.1</a> beschriebene Template-Beispiel lässt sich mit Hilfe der
   <em>Pseudo-Sprache</em> wie folgt vereinfachen:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="${news->getCssClass()}">
   <p>
      ${news->getIntroText()}
   </p>
   <p>
      ${news->getDetailText()}
   </p>
   <p>
      <a href="${news->getMoreLink()->getLinkTarget()}">
         ${news->getMoreLink()->getLinkLabel()}
      </a>
   </p>
</div>
</gen:highlight>
<p>
   Der Controller verkürzt sich ebenfalls:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<p>
   Auf diese Weise lässt sich wiederholender Code aus Controllern entfernen und damit die Übersichtlichkeit erhöhen.
</p>
<p>
   Grundlage für die <em>Pseudo-Template-Sprache</em> ist das APF-DOM-Modell. Dieses ermöglicht - analog zu HTML-Knoten
   - Data-Attribute zu definieren. Die Klasse <em>Document</em> stellt hierzu die Methoden <em>setData()</em> und
   <em>getData()</em> zur Verfügung. Innerhalb des <em>BaseDocumentController</em> können Sie mit den gleichnamigen
   Methoden ebenfalls auf die Data-Attribute des aktuellen Knotens zuzugreifen.
</p>
<p>
   Die folgenden Kapitel stellen Ihnen die Funktionalitäten der Template-Sprache genauer vor.
</p>

<h5 id="Chapter-3-2-1-Listen-Zugriff"><a href="#Chapter-3-2-1-Listen-Zugriff">3.2.1. Listen-Zugriff</a></h5>
<p>
   Mit der <em>Pseudo-Template-Sprache</em> des APF lassen Sich Listen-Zugriffe für Data-Attribute analog zur PHP-Syntax
   realisieren. Dabei werden einfach, sowie mehrfach verschachtelte Arrays mit nummerischen und alphanummerischen
   Adressen unterstützt.
</p>
<p>
   Sie können im Template auf einfache und verschachtelte Listen mit einfachen Inhalten, aber auch auf Listen mit
   komplexen Inhalten (Objekte) zugreifen. Der Zugriff auf komplexe Inhalte erfordert gegebenenfalls weitere Schritte.
   Beachten Sie hierzu bitte <a href="#Chapter-3-2-2-Objekt-Zugriff">Kapitel 3.2.2</a> und
   <a href="#Chapter-3-2-3-Kombinierter-Zugriff">Kapitel 3.2.3</a>.
</p>
<p>
   Die folgende Code-Box zeigt Ihnen den Zugriff auf Listen im Template:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Zugriff auf das erste, nummerische Offset --&gt;
${news[0]}

&lt;!-- Zugriff auf das Offset xyz --&gt;
${news['xyz']}

&lt;!-- Zugriff auf das nummerische Offset 1 und darin auf das nummerische Offset 2 --&gt;
${news[1][2]}

&lt;!-- Zugriff auf das nummerische Offset 1 und darin auf das alphanummerische Offset xyz --&gt;
${news[1]['xyz']}

&lt;!-- Zugriff mit Mischformen --&gt;
${news[1][2][3][4]}
${news[1]['two'][3]['four']}
</gen:highlight>
<p>
   Um mit den beschriebenen Ausdrücken auf Inhalte zugreifen zu können sind die Data-Attribute im Controller wie
   folgt zu befüllen:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      // Zugriff auf das erste, nummerische Offset
      $this->setData(
         'news',
         array(
            0 => $model
         )
      );

      // Zugriff auf das Offset xyz
      $this->setData(
         'news',
         array(
            'xyz' => $model
         )
      );

      // Zugriff auf das nummerische Offset 1 und darin auf das nummerische Offset 2
      $this->setData(
         'news',
         array(
            1 => array(
               2 => $model
            )
         )
      );

      // Zugriff auf das nummerische Offset 1 und darin auf das alphanummerische Offset xyz
      $this->setData(
         'news',
         array(
            1 => array(
               'xyz' => $model
            )
         )
      );

      // Zugriff mit Mischformen
      $this->setData(
         'news',
         array(
            1 => array(
               2 => array(
                  3 => array(
                     4 => $model
                  )
               )
            )
         )
      );
      $this->setData(
         'news',
         array(
            1 => array(
               'two' => array(
                  3 => array(
                     'four' => $model
                  )
               )
            )
         )
      );

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<div class="hint">
   Implementieren die in der Liste befindlichen Objekte die <em>__toString()</em>-Methode, so können Sie die Ausgabe
   der Objekte durch einen Listen-Zugriff erzeugen ohne weitere Methoden-Aufrufe zu definieren.
</div>

<h5 id="Chapter-3-2-2-Objekt-Zugriff"><a href="#Chapter-3-2-2-Objekt-Zugriff">3.2.2. Objekt-Zugriff</a></h5>
<p>
   Neben dem Zugriff auf Listen, bietet die <em>Pseudo-Template-Sprache</em> des APF auch den Zugriff auf Objekte in
   Data-Attributen. Die Syntax folgt auch hier der PHP-Syntax.
</p>
<p>
   Methoden-Aufrufe lassen sich in beliebiger Anzahl und Abfolge definieren und können auch in Verbindung mit Listen
   genutzt werden. beachten Sie hierzu bitte die Dokumentation in
   <a href="#Chapter-3-2-3-Kombinierter-Zugriff">Kapitel 3.2.3</a>.
</p>
<p>
   Die folgende Code-Box zeigt Ihnen Beispiele für Methoden-Aufrufe:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Zugriff auf die Methode getCssClass() der Klasse ContentModel --&gt;
${news->getCssClass()}

&lt;!--
   Zugriff auf die Methode getLinkLabel() der Klasse LinkModel, das von der
   Methode getMoreLink() der Klasse ContentModel zurückgegeben wird
--&gt;
${news->getMoreLink()->getLinkLabel()}
</gen:highlight>
<p>
   Um mit den beschriebenen Ausdrücken auf Inhalte zugreifen zu können muss das Data-Attribute <em>news</em> im
   Controller wie folgt zu befüllt werden:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

}
</gen:highlight>

<h5 id="Chapter-3-2-3-Kombinierter-Zugriff"><a href="#Chapter-3-2-3-Kombinierter-Zugriff">3.2.3. Kombinierter-Zugriff</a></h5>
<p>
   Die in <a href="#Chapter-3-2-1-Listen-Zugriff">Kapitel 3.2.1</a> und
   <a href="#Chapter-3-2-2-Objekt-Zugriff">Kapitel 3.2.2</a> beschriebenen Listen- und Methoden-Zugriffe lassen sich
   auch zu komplexeren Abfragen kombinieren. So kann durch eine Kombination eines Listen- und ein oder mehrerer
   Methoden-Aufrufe der Zugriff auf eine Liste von Einträgen und deren Eigenschaften realisieren.
</p>
<div class="hint">
   Bitte beachten Sie, dass mehrere Methoden-Aufrufe bzw. Listen-Zugriffe jeweils durch <em>-&gt;</em> getrennt sind.
</div>
<p>
   Beabsichtigen Sie in einem Template die ersten drei News-Einträge auszugeben, so lässt sich dies mit dem folgenden
   Template realisieren:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<ul class="news-list">
   <li>${news[0]->getIntroText()}</li>
   <li>${news[1]->getIntroText()}</li>
   <li>${news[2]->getIntroText()}</li>
</ul>
</gen:highlight>
<p>
   Zur Erzeugung der Ausgabe ist folgender Controller-Code notwendig:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getNews());
   }

   /**
    * @return ContentModel[]
    */
   private function getNews() {
      ...
   }

}
</gen:highlight>
<p>
   Die Methode <em>getNews()</em> liefert dabei eine Liste von <em>ContentModel</em>-Objekten zurück.
</p>
<p>
   Die Implementierung der <em>Pseudo-Template-Sprache</em> ermöglicht darüber hinaus weitere Kombinationen von Ausdrücken:
</p>
<gen:highlight type="apf-xml">
&lt;!-- Aufruf von getBar() auf das dritte von getFoo() zurückgegebene Element --&gt;
${news->getFoo()->[3]->getBar()}

&lt;!--
   Aufruf von getBaz() auf das Ergebnis von getBar(), das im Offset foo des
   5.ten Elements im Data-Attribut news steht
--&gt;
${news[5]['foo']->getBar()->getBaz()}
</gen:highlight>
<div class="warn">
   Bitte beachten Sie, dass die im letzen Code-Block aufgeführten Beispiele jeweils eine entsprechende Daten-Struktur
   voraussetzen! Fehlerhafte Ausdrücke führen zu Fehlern und damit zum Abbruch der Applikation.
</div>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="en_047" />