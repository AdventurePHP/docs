<doku:title tags="documentation,class reference,classes,reference,mysqlhandler" title="Class reference table - MySQLHandler" urlname="Class-reference-table-MySQLHandler">
  The MySQLHandler serves abstraction of a MySQL database against the application. It takes care
  of the database specific issues like configuration, connecting and standardises execution of
  statements.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
The <strong>MySQL-Handler</strong> serves abstraction of a MySQL database against the application.
It takes care of the database specific issues like configuration, connecting and standardises
execution of statements. Besides, two methods are available for the latter:
On the one hand <strong>executeTextStatement()</strong> can execute any SQL statement. If the developer
would like to use the statements in his application several times and at different places, statements
can also be stored in external statement files and be executed by the <strong>executeStatement()</strong>
method. The parameter description of these two methods can be found in the
<a href="./?Page=002-API-Documentation" title="API documentation">API documentation</a>.
<br />
<br />
<br />
<a name="1-General-usage"></a><h3>1. General usage</h3>
To be able to use the <strong>MySQLHandler</strong> it must be imported into the currend application
using
<php:highlight>
  import('core::database','MySQLHandler');
</php:highlight>
Further the code fragment
<php:highlight>
   $SQL = &$this->__getServiceObject('core::database','MySQLHandler');
</php:highlight>
creates the service layer and gives back a reference on it. Due to the fact, that this code snippet
makes use of the private method <em>__getServiceObject()</em> the developer can be save, that the
service is created just once within the application. This has not only an administrative advantages,
but in the case of database access, good performance impact. Inside, for example, database
connections must be produced only once and configurations must be read only once.
<br />
<br />
To provide configuration to the component, the configuration file
<code:highlight>
  /apps/config/core/database/{CONTEXT}/{ENVIRONMENT}_connections.ini
</code:highlight>
must be present. The place holder <strong>{CONTEXT}</strong> indicates the current application's
context and <strong>{ENVIRONMENT}</strong> must be filled with the value of the environment variable
stored in the global registry. Details on configuration can be read about in the
<a href="./Page=033-configuration" title="configuration">configuration chapter</a>. This file defines
which server to use, which credentials provide successful login and which database should be utilized
by the <em>MySQLHandler</em>. Typically the configuration file contains the following content:
<code:highlight>
  [MySQL]
  DB.Host = ""
  DB.User = ""
  DB.Pass = ""
  DB.Name = ""
  DB.DebugMode = "true|false"
</code:highlight>
<strong>DB.DebugMode</strong> indicates if the <em>MySQLHandler</em> creates a logfile with debug
information if an error occures or not. Default value is <strong>false</strong>. Set to
<strong>true</strong> the logfile will be created.
<br />
<br />
To read records from a database the following lines can be copied to an application:
<php:highlight>
   $select = 'SELECT somefield, anotherfield
              FROM mytable
              WHERE somefield = \'somevalue\';';
   $result = $SQL->executeTextStatement($select);
</php:highlight>
The records selected by the statement above can now be fetched using a while loop:
<br />
<php:highlight>
   while($data = $SQL->fetchData($result)){

      // ... //

    // end while
   }
</php:highlight>
<br />
<a name="2-Statement-outsourcing"></a><h3>2. Statement outsourcing</h3>
To use the statement posted above by an other application or at another place the method
<strong>executeStatement()</strong> can be used for this task. For this reason the statement must be
stored in a file named
<code:highlight>
   {ENVIRONMENT}_{StatementFileName}.sql
</code:highlight>
The MySQLHandler class expects this file to be stored in the folder
<code:highlight>
   {Namespace}/{CONTEXT}
</code:highlight>
similar to the configuration files. Under the acceptance that the statement "belongs" to a module
under the namespace <em>modules::testmodule</em>, the environment variable was not adjusted and the
context of the application is "sites::demosite" the file has to be named
<code:highlight>
  DEFAULT_mystatement.sql
</code:highlight>
and stored in the folder
<code:highlight>
  /apps/config/modules/testmodule/sites/demosite
</code:highlight>
To run this statement the method <strong>executeStatement()</strong> must be called as follows:
<php:highlight>
   $params = array(
                   'somefield' => 'somevalue'
                   );
   $result = $SQL->executeStatement('modules::testmodule','mystatement',$params);
</php:highlight>
The third parameter of this method aims to configure the place holders provided within the statement.
Each place holder is marked with a leading "[", a name without blanks and a tailing "]" to end the
place holder. The name between the two brackets is the name of the place holder and must be used to
specify the value of this place holder. If one continues the example presented above the file
<strong>DEFAULT_mystatement.sql</strong> must contain the following SQL code:
<code:highlight>
  SELECT somefield, anotherfield
  FROM mytable
  WHERE somefield = '[somefield]';
</code:highlight>
An application example is found in the
<a href="./?Page=032-Comment-function" title="contact form tutorial">contact form tutorial</a> under
chapter 4.3.
<br />
<br />
<br />
<a name="3-Debugging"></a><h3>3. Debugging</h3>
Sometimes, it is necessary to track the statements, that are sent to the database. For this reason,
the <strong>MySQLHandler</strong> features an additional parameter within the
<strong>executeTextStatement()</strong> and <strong>executeStatement()</strong> methods. Set to
<em>true</em>, the statement logging can be activated. Details can be taken from the
<a href="./?Page=002-API-Documentation" title="API documentation">API documentation</a>.
<br />
<br />
<br />
<a name="4-More-features"></a><h3>4. More features</h3>
The MySQLHandler provides some more methods to assist implementation. During inserts the LAST_INSERT_ID
is stored automatically. After execution the value can be gathered by calling the
<strong>getLastID()</strong> method.
<br />
<br />
Moreover methods like <strong>getNumRows()</strong> and <strong>getAffectedRows()</strong> provide
access to the amount of rows that are affected during selects or updates of MySQL tables.
<strong>fetchData()</strong> was implemented to fetch the selected data from the database.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_018" />