
<font style="font-size: 26px; font weight: bold;">Enhancement of existing functionalities</font>
<br />
<br />
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<a name="1-Introduction"></a><h3>1. Introduction</h3>
I'm sure, every developer was once faced with the situation, that an existing library helped to solve
most of the previous tasks, but is not able to handle the current special case. Many developers then
tend to implement a completely new function to meet the current case's needs. Others try to convulsively
find another library that handles this case. All of these possibilities help you to get the goal, but
reduce the maintainability of your software and increase error rate due to a "wild" combination of
various external libraries and special functions for several special cases. Furthermore, each developer
should keep in mind, that API changes originate changes to every function that uses the libray and
is this equal to leaving the update path of the external library. Perhaps, even quick hacks won't
work in the next version of the third party library.
<br />
<br />
This tutorial wants to explain a method to enhance existing functionalities without changing the
provided library. The tutorial assumes, that the used library is third party code. Otherwise, this
method doesn't make sense.
<br />
<br />
Maybe you now think, that an API change means, that the API was not designed well. In many cases you
are right, but there are many APIs, that are not designed to meet every special case of your
application.
<br />
<br />
<br />
<a name="2-Taglib-example"></a><h3>2. Taglib example</h3>
The following example shows you how to enhance the <strong>socialbookmark</strong> library delivered
with each release to meet your demands.
<br />
<br />
<br />
<a name="2-1-Problem-description"></a><h4>2.1. Problem description</h4>
The socialbookmark library contained in each <strong>adventure-codepack-*</strong> release are
intended to be included in the content area of your application via XML tag. For this reason, the
module includes a taglib, whose characteristics are described on the
<a href="./?Page=039-Builtin-Modules" title="builtin modules">builtin modules</a> page. The tag
definition allows you to specify a page title within the tag definition, that is used as a title
when bookmarking the current page. This definition is statically, because it is specified on tag
definition time and not on execution time. This is problematically with CMS webpages, because there,
titles must be dynamic!
<br />
<br />
<br />
<a name="2-2-Analysis-of-the-existing-API"></a><h4>2.2. Analysis of the existing API</h4>
To analyze the existing API you must ask yourself the question: "<strong>What is already possible and
what is really missing?</strong>". In case of the socialbookmark module, the answer is quite obvious:
<strong>static titles</strong> are possible, <strong>dynamic titles</strong> not!
<br />
<br />
<br />
<a name="2-3-API-extension-by-wrapping"></a><h4>2.3. API extension by wrapping</h4>
A very common way of extending a API is to wrap it. <strong>Wrapping</strong> means, that you build
a layer around the existing library - in this case a taglib - to enhance the functionality without
changing the library itself.
<br />
<br />
Let's at first have a look at the existing library. The taglib implements the coreObject's
<strong>transform()</strong> method. Within this function the class passes the necessary attributes
to the <strong>socialbookmarkManager</strong> and asks him to give back the bookmark elements. The
source code of the taglib (please refer to the <em>/apps/modules/socialbookmark/pres/taglib</em>
folder in the <em>adventure-codepack-*</em> release) is displayed in the following code box (comments
werde dropped):
<php:highlight>
   class social_taglib_bookmark extends Document
   {

      function social_taglib_bookmark(){
         $this->__Attributes['width'] = '20';
         $this->__Attributes['height'] = '20';
         $this->__Attributes['title'] = null;
         $this->__Attributes['url'] = null;
         $this->__Attributes['target'] = null;
       // end function
      }

      function transform(){

         // get bookmark manager
         $sBM = &$this->__getServiceObject('modules::socialbookmark::biz','socialBookmarkManager');

         // configure width and height
         $sBM->set('Width',$this->__Attributes['width']);
         $sBM->set('Height',$this->__Attributes['height']);

         // konfigure URL parameters
         if($this->__Attributes['url'] != null){
            $sBM->set('URL',$this->__Attributes['url']);
          // end if
         }
         if($this->__Attributes['title'] != null){
            $sBM->set('Title',$this->__Attributes['title']);
          // end if
         }
         if($this->__Attributes['target'] != null){
            $sBM->set('Target',$this->__Attributes['target']);
          // end if
         }

         // return bookmark HTML code
         return $sBM->getBookmarkCode();

       // end function
      }

    // end class
   }
</php:highlight>
In order to make the title passed to the bookmark service dynamic, ist is well to define another
tag library, that only contains the difference of functionality, but uses the existing library. To
make it easier to show the proceeding to you, I define, that the tag should be named
<strong>my:bookmark</strong>. Hence, as described in the
<a href="./?Page=045-User-specific-taglibs-tutorial" title="User specific taglibs tutorial">user specific taglibs tutorial</a>,
the class name of the taglib must be <strong>my_taglib_bookmark</strong>. The taglib then contains the
following source code:
<php:highlight>
   import('modules::socialbookmark::pres::taglib','social_taglib_bookmark');

   class my_taglib_bookmark extends social_taglib_bookmark
   {

      function my_taglib_bookmark(){
         // execute the constructor of the parent class
         parent::social_taglib_bookmark();
       // end function
      }

      function transform(){

         // gather the title of the current page
         $Title = /* current title */;

         // fill the title attribute, that is used by the parent class
         $this->__Attributes['title'] = $Title;

         // generate output with aid of the parent class
         return parent::transform();

       // end function
      }

    // end class
   }
</php:highlight>
As you can see in the code box above, the <strong>transform()</strong> only contains the gathering
of the page's title. There, the title is assigned to the attributes offset used by the parent class.
The core function is still done by the <strong>social_taglib_bookmark</strong> class. Because of the
fact, that our wrapper class inherits from <strong>social_taglib_bookmark</strong>, it is still
possible to use the
<ul style="font-weight: bold;">
  <li>width</li>
  <li>height</li>
  <li>target</li>
</ul>
attributes within the tag definition. The following code shows you how to include the new taglib into
your templates:
<pre class="tagexample">
  &lt;core:addtaglib namespace="dein::namespace" prefix="my" class="bookmark" /&gt;
  &lt;my:bookmark width="16" height="16" target="_blank" /&gt;
</pre>
<br />
<a name="2-4-Update-handling"></a><h4>2.4. Update handling</h4>
In case of API changes to the third-party library, adaptation to the new API is limited to filling
the attribute <em>title</em>, because the call of the parent <strong>transform()</strong> is still
the same. A second advantage is, that the API of the wrapper class <strong>my_taglib_bookmark</strong>
remains the same and the components using the API of the wrapper class must not be changed. The
example described in the present tutorial only contained the enhancement of taglibs, but this principle
can be adopted to any other domain.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="tut_wrapping_en" />