<font style="font-size: 26px; font weight: bold;">G&auml;stebuch</font>
<br />
<br />
<core:importdesign namespace="sites::demosite::pres::templates::voting" template="voting" />
Die folgenden Zeilen beschreiben ein weiteres komplettes Anwendungsbeispiel, das in Zusammenarbeit mit
Alexander Heim (<a href="http://www.promadesign.com/">http://www.promadesign.com/</a>) entstanden ist.
Es gibt einen Einblick &uuml;ber das Design von Software und besch&auml;ftigt sich mit den
Implementierungs-Details, die das vorliegende Framework angehen.
<br />
<br />
Die Beschreibungen werden nach und nach um Kommentare erg&auml;nzt und nach Fertigstellung wird die
Software hier verf&uuml;gbar gemacht.
<br />
<br />
<br />
<div style="border: 1px solid red; background-color: #eeeeee; padding: 10px; margin: 10px;">
  <font style="font-weight: bold; color: red;">Wichtig:</font>
  Die eingesetzte Software ist z.Z. nicht mit einem SPAM-Schutz ausgestattet. Diese Feature wird zu
  einem sp&auml;teren Zeitpunkt hinzugef&uuml;gt und in der Dokumentation erg&auml;nzt.
</div>
<br />
<br />
<a name="1-Einleitung"></a><h3>1. Einleitung</h3>
Ein G&auml;stebuch ist wahrscheinlich die &auml;lteste Anwendung von dynamischen Webseiteninhalten,
die ich kennengerlernt habe, jedoch ist das Beispiel auch sehr umfassend und beinhaltet viele Design-
Paradigmen und Pattern. Das G&auml;stebuch basiert auf einer MySQL-Datenbank f&uuml;r die Daten-
Speicherung, das Front- und Backend basiert auf dem hier dokumentierten und eingesetzten Framework.
Das Grafik-Design ist bewusst sehr schlicht gehalten, damit die Anwendung in jede beliebige Webseite
eingebunden werden kann und die eigentliche Funktion nicht zu sehr in den Hintergrund r&uuml;cken
l&auml;sst.
<br />
<br />
<strong>Hinweis:</strong> Die hier eingesetzte Software-Entwurfs-Methode mit Hilfe von UML ist nur eine gek&uuml;rzte
Form der sonst in der Industrie &uuml;blichen Form des Entwurfs. Weiterf&uuml;hrende Literatur
dazu ist auf <a href="http://www.amazon.de/Softwaretechnik-Praxiswissen-Softwareingenieure-Johannes-Siedersleben/dp/3446218432/ref=pd_bbs_sr_1/303-3160127-7394660?ie=UTF8&s=books&qid=1176130372&sr=8-1" target="_blank" title="Softwaretechnik von Johannes Siedersleben">amazon.de</a>
(Softwaretechnik von Johannes Siedersleben) erh&auml;ltlich.
<br />
<br />
<br />
<a name="2-Anforderungen"></a><h3>2. Anforderungen</h3>
Zu Beginn sollte der Entwickler zusammen mit dem Kunden - falls dies zwei unterschiedliche
Personen sind - die Anforderungen an die Software spezifizieren. Ist der Kunde der Entwickler selbst
ist es ebenso ratsam die Anforderungen an die Software zu dokumentieren. &Uuml;blicherweise werden
Anforderungen in sog. "functional requirements" und "non-functional requirements" gruppiert. Das
Software-Design soll sich hier durch folgende Punkte auszeichnen:
<ul>
  <li>
    <strong>Functional Requirements</strong>
    <ul>
      <li>Anzeigen der Eintr&auml;ge mit Paging</li>
      <li>Erstellen eines neuen Eintrags</li>
      <li>Administration des G&auml;stebuchs (Kommentieren, Editieren, L&Ouml;schen)</li>
      <li>Einbindung per Tag in eine bestehende Oberfl&auml;che</li>
    </ul>
  </li>
  <li>
    <strong>Non-Functional Requirements</strong>
    <ul>
      <li>M&ouml;glichkeit mehrere G&auml;steb&uuml;cher mit einem Code betreiben</li>
      <li>Modulerer Aufbau</li>
      <li>Von der Anwendung getrenntes Datenhaltungs-Modell</li>
      <li>Gute Performance</li>
    </ul>
  </li>
</ul>
Der in der Liste genannte Pager ist ein weiteres mit dem Framework ausgeliefertes Modul im "modules"-
Namespace. Er ist eine fertig einsetzbare Business-Komponente, die nur noch f&uuml;r den Einsatzzweck
konfiguriert werden muss. Er unterst&uuml;tzt eine generische Schnittstelle zur Implementierung einer
eigenen Ausgabe-Logik. F&uuml;r den aktuellen Anwendungsfall kann jedoch die bereits mitgelieferte
Ausgabe eingesetzt werden.
<br />
<br />
<br />
<br />
<a name="3-Anwendungsfaelle"></a><h3>3. Anwendungsf&auml;lle</h3>
Eine weitere Form, die Anforderungen auf Basis von Rollen auszudr&uuml;cken ist das "Use Case"-Diagramm.
Diese spiegeln die Interaktions-Punkte von Personen mit dem Systen wieder und gruppieren Funktionen.
Die hier gezeigten Diagramme wurden mit dem <a href="http://www.sparxsystems.at/" target="_blank" title="Enterprise Architect">Enterprise Architect</a>
erstellt, ein Entwurfs-Tool, mit dem der komplette Entwurfszyklus elektronisch in UML dokumentiert
werden kann. Ebenso ist Code-Generation aus bestehenden Klassen-Diagrammen in viele Programmiersprachen
(u.a. PHP) m&ouml;glich.
<br />
<br />
<br />
<strong>&Uuml;bersicht</strong>
<br />
<br />
<img src="/frontend/media/use_case__overview.png" border="0" alt="Use Case &Uuml;bersicht G&auml;stebuch-Tutorial Adventure PHP Framework" />
<br />
<br />
<br />
<strong>Aktoren</strong>
<br />
<br />
<img src="/frontend/media/use_case__actors.png" border="0" alt="Use Case Akt&ouml;re G&auml;stebuch-Tutorial Adventure PHP Framework" />
<br />
<br />
<br />
<strong>Anwendungsf&auml;lle</strong>
<br />
<br />
<img src="/frontend/media/use_case__cases.png" border="0" alt="Use Case F&auml;lle G&auml;stebuch-Tutorial Adventure PHP Framework" />
<br />
<br />
<br />
<br />
<a name="4-Businessschicht-und-Datenmodell"></a><h3>4. Design der Business-Schicht / Datenmodell der Anwendung</h3>
Die Business-Schicht einer Anwendung beinhaltet die Definition der Workflows und der Definition der
Daten-Objekte. Da sich der/die Workflow/s im G&auml;stebuch auf realtiv wenige Aktionen und Folgen
von Aktionen (Eintragen -> Speichern -> Weiterleitung auf Anzeige-/Auswahl-Seite) beschr&auml;nkt,
sei hier mehr auf das Daten-Design eingegangen.
<br />
<br />
Die Autoren gehen davon aus, dass das folgende Datenmodell f&uuml;r alle Anwendungsf&auml;lle
ausreichend ist:
<br />
<br />
<img src="/frontend/media/domain_model__domain_objects.png" border="0" alt="Dom&auml;nen Objekte G&auml;stebuch-Tutorial Adventure PHP Framework" />
<br />
<br />
Alle f&uuml;r die Anwendung relevanten Objekte (<strong>Guestbook</strong>, <strong>Entry</strong>
und <strong>Comment</strong>) erben vom Basis-Objekt <em>coreObject</em>. Damit erben diese bereits
die generischen <em>get()</em>- und <em>set()</em>-Methoden. Die Objekte im Einzelnen:
<br />
<br />
<strong>Guestbook:</strong>
<br />
Das Objekt, dass das G&auml;stebuch repr&auml;sentieren besitzt Attribute f&uuml;r die Darstellung
(<strong>Name</strong>, <strong>Description</strong>), <strong>Admin_Username</strong> und
<strong>Admin_Password</strong> f&uuml;r die Administration des G&auml;stebuchs und das komplexe
Attribut <strong>Entries</strong>, das eine Liste von <strong>Entry</strong>-Objekten h&auml;lt.
<br />
<br />
<strong>Entry:</strong>
<br />
Das Objekt <strong>Entry</strong> repr&auml;sentiert einen Eintrag in einem G&auml;stebuch. Es sind
sowohl Attribute f&uuml;r die Darstellung als auch f&uuml;r die Sortierung enthalten. Zudem enth&auml;lt
es das komplexe Attribut <strong>Comments</strong> in dem eine Liste von Kommentaren enthalten ist,
sofern Kommentare zu einem Eintrag hinzugef&uuml;gt wurden.
<br />
<br />
<strong>Comment:</strong>
<br />
Das Objekt <strong>Comment</strong> tr&auml;gt die Inhalte eines Kommentars, der an einen G&auml;stebuch-
Eintrag geh&auml;ngt wurde.
<br />
<br />
<br />
Hier das Objekt-Modell der Anwendung:
<br />
<br />
<img src="/frontend/media/class_model__system_diagram.png" border="0" alt="System Diagramm G&auml;stebuch-Tutorial Adventure PHP Framework" />
<br />
<br />
Das Diagramm beschreibt aktuell vier Komponenten, die implementiert werden m&uuml;ssen. Das sind je
ein DocumentController f&uuml;r die Ausgabe der Liste und einer f&uuml;r das Handling des Formulars,
eine Business- (<em>guestbookManager</em>) und eine Daten-Schicht-Komponente (<em>guestbookMapper</em>).
Der Manager kapselt den Workflow, der im Wesntlichen aus der Methode <em>saveEntry()</em> besteht.
<br />
<br />
<br />
<br />
<a name="5-Datenschicht"></a><h3>5. Datenschicht und DataMapper</h3>
Wie bereits angesprochen differieren in der Regel das Datenmodell der Anwendung und das der Datenhaltung.
In diesem Fall wird ein normalisiertes Datenmodell in der dritten erweiterten dritten Normalform
eingesetzt. Das bedeutet, dass die Objekte jeweils in einer eigenen Tabelle gespeichert werden und die
Beziehungen (in diesem Beispiel nur Kompositionen) &uuml;ber Relations-Tabellen. Siehe auch
<a href="http://de.wikipedia.org/wiki/Normalisierung_%28Datenbank%29" target="_blank" title="Normalisierung bei Wikipedia">http://de.wikipedia.org/wiki/Normalisierung (Datenbank)</a>.
Das ergibt unter Ber&uuml;cksichtigung des obigen Anwendungs-Daten-Modells folgende Tabellen-Struktur:
<br />
<br />
<img src="/frontend/media/database_model.png" border="0" alt="Datenmodell G&auml;stebuch-Tutorial Adventure PHP Framework" />
<br />
<br />
Der <strong>DataMapper</strong> hat nun gem&auml;&szlig; Pattern-Definition eines DataMappers die
Aufgabe zwischen dem Datenmodell der Datenhaltung und der Anwendung zu vermitteln. Dazu dienen
einerseits die Methoden <em>__mapEntry2DomainObject()</em>, <em>__mapGuestbook2DomainObject()</em>
und <em>__mapComment2DomainObject()</em>, mit denen die Result-Sets eines Datenbank-Queries in Objekte
&uuml;berf&uuml;hrt werden, andererseits <em>loadGuestbookByID()</em>, mit dem ein komplettes
G&auml;stebuch incl. alles aktuell geforderten Eintr&auml;ge und Kommentare geladen werden kann.
<br />
<br />
<br />
<strong>Fortsetzung:</strong>
Das Design der Anwendung ist nun abgeschlossen. <a href="./?Seite=058-Gaestebuch-Tutorial-2" title="Implementierungsdetails">Seite 2</a> widmet sich
den Implementierungsdetails.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="tut_guestbook" />