<doku:title tags="dokumentation,klassen referenz,klassen,referenz,mysqlhandler" title="Klassen-Referenz - MySQLHandler" urlname="Klassenreferenz-MySQLHandler">
  Der MySQL-Handler dient zur Abstraktion einer MySQL-Datenbank gegen die Anwendung. Er nimmt dem
  Entwickler die Sorge um Datenbank-Spezifika wie Konfiguration, Verbindungsaufbau und
  standardisiertes Ausf&uuml;hren von Statements ab.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
Der <strong>MySQL-Handler</strong> dient zur Abstraktion einer MySQL-Datenbank gegen die Anwendung.
Er nimmt dem Entwickler die Sorge um Datenbank-Spezifika wie Konfiguration, Verbindungsaufbau und
standardisiertes Ausf&uuml;hren von Statements ab. F&uuml;r letzteres stehen dabei zwei Methoden zur
Verf&uuml;gung: Einerseits kann per <strong>executeTextStatement()</strong> jedes beliebige
SQL-Statement ausgef&uuml;hrt werden, m&ouml;chte der Entwickler die Statements in seiner Anwendung
mehrfach und an unterschiedlichen Stellen verwenden, so k&ouml;nnen Statements ebenso in externe
Statement-Dateien ausgelagert und per <strong>executeStatement()</strong> ausgef&uuml;hrt werden.
Die hier relevanten Parameter k&ouml;nnen in der
<a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a> nachgelesen werden.
<br />
<br />
<br />
<a name="1-Allgemeine-Verwendung"></a><h3>1. Allgemeine Verwendung</h3>
Um den <strong>MySQLHandler</strong> nutzen zu k&ouml;nnen muss dieser zuerst per
<php:highlight>
  import('core::database','MySQLHandler');
</php:highlight>
in die Applikation eingebunden werden. Anschlie&szlig;end kann mit dem Code-Fragment
<php:highlight>
   $SQL = &$this->__getServiceObject('core::database','MySQLHandler');
</php:highlight>
eine Referenz auf den Service erzeugt werden. Da hier die private Methode <em>__getServiceObject()</em>
Verwendung findet ist sichergestellt, dass der angefragte Service nur einmal innerhalb der Anwendung
erzeugt wird. Dies hat nicht nur einen verwaltungstechnischen, sondern im Fall des Datenbankzugriffs
vor allem performancetechnische Vorteile. Intern m&uuml;ssen beispielsweise Datenbank-Verbindungen
nur einmal hergestellt und Konfigurationen nur einmal gelesen werden.
<br />
<br />
Zur Konfiguration der Komponente muss die Konfigurationsdatei
<code:highlight>
  /apps/config/core/database/{CONTEXT}/{ENVIRONMENT}_connections.ini
</code:highlight>
vorhanden sein. <strong>{CONTEXT}</strong> ist dabei der Context der aktuellen Applikation,
<strong>{ENVIRONMENT}</strong> der Wert der Umgebungsvariable aus der Registry. Details hierzu
k&ouml;nnen im Kapitel
<a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a> nachgelesen werden.
Diese konfiguriert den zu benutzenden Server, Benutzerdaten und die Datenbank. Eine
typische Konfigurationsdatei hat folgenden Inhalt:
<code:highlight>
  [MySQL]
  DB.Host = ""
  DB.User = ""
  DB.Pass = ""
  DB.Name = ""
  DB.DebugMode = "true|false"
</code:highlight>
Falls der Parameter <strong>DB.DebugMode</strong> auf den Wert <strong>true</strong> eingestellt ist,
legt der MySQLHandler ein Logfile an und notiert Fehler, die w&auml;hrend der Benutzung auftreten.
<br />
<br />
Um nun Daten aus einer Datenbank zu lesen können folgende Zeilen in die Applikation eingebaut werden:
<php:highlight>
   $select = 'SELECT somefield, anotherfield
              FROM mytable
              WHERE somefield = \'somevalue\';';
   $result = $SQL->executeTextStatement($select);
</php:highlight>
Die mit dem Select angefragten Daten k&ouml;nnen anschlie&szlig;end mit einer while-Schleife abgeholt
werden:
<br />
<php:highlight>
   while($data = $SQL->fetchData($result)){

      // ... //

    // end while
   }
</php:highlight>
<br />
<a name="2-Statement-Auslagerung"></a><h3>2. Statement-Auslagerung</h3>
Soll das gezeigte Statement ausgelagert werden, um von einer weiteren Applikation oder der selben an
anderer Stelle verwendet zu werden, so kann die Methode <strong>executeStatement()</strong>
daf&uuml;r herangezogen werden. Dazu muss das Select in einer Datei mit dem Namen
<code:highlight>
   {ENVIRONMENT}_{StatementDateiName}.sql
</code:highlight>
abgelegt werden. Der MySQLHandler sucht diese Datei dann im Ordner
<code:highlight>
   {Namespace}/{CONTEXT}/statements/
</code:highlight>
Unter der Annahme, dass das Statement einem Modul unter dem Namespace <em>modules::testmodule</em>
"geh&ouml;rt", die Umgebungsvariable nicht angepasst wurde und der Context der Applikation
"sites::demosite" lautet muss die Datei den Namen
<code:highlight>
  DEFAULT_mystatement.sql
</code:highlight>
tragen und im Ordner
<code:highlight>
  /apps/config/modules/testmodule/sites/demosite/statements
</code:highlight>
abgelegt sein. Um das Statement auszuf&uuml;hren muss die Methode <strong>executeStatement()</strong>
wie folgt verwendet werden:
<php:highlight>
   $params = array(
                   'somefield' => 'somevalue'
                   );
   $result = $SQL->executeStatement('modules::testmodule','mystatement',$params);
</php:highlight>
Der dritte Parameter der Methode <em>executeStatement()</em> dient dazu Platzhalter im Statement
zu f&uuml;llen. Platzhalter werden mit "[" einem Namen und "]" gekennzeichnet. Der in den Klammern
stehende Name ist gleichzeitig der Name des Platzhalters, der im Parameter-Array verwendet wird.
F&uuml;hrt man das obige Beispiel weiter, so hat die Datei <strong>DEFAULT_mystatement.sql</strong>
folgende Gestalt:
<code:highlight>
  SELECT somefield, anotherfield
  FROM mytable
  WHERE somefield = '[somefield]';
</code:highlight>
Ein Anwendungsbeispiel findet sich im
<a href="./?Seite=032-Kommentarfunktion" title="Kontaktformular-Tutorial">Kontaktformular-Tutorial</a> unter
Kapitel 4.3.
<br />
<br />
<br />
<a name="3-Weitere-Features"></a><h3>3. Weitere Features</h3>
Der MySQLHandler besitzt weitere Tools zur Unterst&uuml;tzung der Implementierung. Bei Inserts wird
die LAST_INSERT_ID automatisch eingelesen und vorgehalten. Diese kann nach dem Ausf&uuml;hren eines
Inserts per <strong>getLastID()</strong> ausgelesen werden.
<br />
<br />
Dar&uuml;ber hinaus bietet der MySQLHandler Methoden wie <strong>getNumRows()</strong> und
<strong>getAffectedRows()</strong> um die Ergebnis-Menge eines Selects oder Updates abfragen zu
k&ouml;nnen und <strong>fetchData()</strong> um Daten von der MySQL abholen zu k&ouml;nnen.
<br />
<br />
F&uuml;r automatisierte Full-Backups Full-Restores k&ouml;nnen die Methoden <strong>backupDatabase()</strong>
und <strong>restoreDatabase()</strong> genutzt werden. Diese basieren auf den CLI-Programmen
<strong>mysql</strong> und <strong>mysqldump</strong> und erfordern f&uuml;r Dump- und Restore-Aktionen
einen priviligierten Datenbank-Benutzer.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_018" />