<font style="font-size: 26px; font weight: bold;">Generischer OR-Mapper - Manuelles Setup der Datenbank (beta)</font>
<br />
<br />
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<a name="1-Einleitung"></a><h3>1. Einleitung</h3>
Der OR-Mapper h&auml;lt sich beim Design des Datenbank-Layouts an eine einfache Konvention:
<strong>Jedes Objekt wird in einer Tabelle abgebildet, jede Beziehung in eine weitere</strong>. Dieses
Vorgehen ist ein guter Mittelweg zwischen Normalisierung und guter Performance, da das Laden von
Objekten auf Tabellenebene schnell abgebildet werden kann, das Modell jedoch trotzdem die Generik
mitbringt, weitere Objekte hinzuzuf&uuml;gen - etwa wegen weiteren Modulen - und die Beziehung zwischen
diesen neuen Objekten das bisherige Layout nicht st&ouml;rt.
<br />
<br />
Das folgende Kapitel erkl&auml;rt nun, wie die Definition der Objekte und deren Beziehungen in
Datenbank-Tabellen umgesetzt werden.
<br />
<br />
<br />
<a name="2-Objektdefinitionen"></a><h3>2. Umsetzung der Objektdefinitionen</h3>
Die Konfiguration der Objekte enth&auml;lt im wesentlichen den Namen und die Attribute eines Objekts.
Eine typische Konfigurationsdatei enth&auml;lt dabei eine beliebige Anzahl folgender Definitionen:
<pre class="tagexample">
[{SektionsName}]
{AttributName} = "{AttributTyp}"
...
</pre>
<strong>{SektionsName}</strong> ist dabei der Name des Objekts (z.B. <strong>User</strong>),
<strong>{AttributName}</strong> der Name eines Attributs des Objekts (z.B. <strong>FirstName</strong>)
und <strong>{AttributTyp}</strong> der Daten-Typ des Attributs. Beim automatischen Setup werden die
Daten-Typen
<ul>
  <li>VARCHAR(<strong>{LENGTH}</strong>)</li>
  <li>TEXT</li>
  <li>DATE</li>
</ul>
jeweils in die richtigen SQL-Statements &uuml;bersetzt. <strong>{LENGTH}</strong> ist dabei durch
eine entsprechende Zahl (gew&uuml;nschte L&auml;nge der Zeichenkette) zu ersetzen. Alle weiteren
Datentypen-Deklarationen m&uuml;ssen ausformuliert werden.
<br />
<br />
F&uuml;r die Umsetzung der Konfiguration in einzelne Tabellen gelten folgende Regeln:
<ul>
  <li>
    Der Name der Tabelle ergibt sich aus dem Namen des Objektes in Kleinbuchstaben mit dem
    Prefix "ent_". Im Fall des Objekts <strong>User</strong> ergibt sich somit ein Tabellenname
    <strong>ent_user</strong>.
  </li>
  <li>
    Die Beziehungen zwischen Objekten werden in einer eigenen Konfiguration definiert
    (siehe Kapitel 3).
  </li>
  <li>
    Die Namen der Attribute eines Objekts sind identisch mit den Attributen der Konfigurationssektion.
    Die Werte der Attribut-Definitionen werden zur Auslegung des Datentyps verwendet.
  </li>
  <li>
    Die Namen der Attribute d&uuml;rfen nicht mit reservierten W&ouml;rtern der verwendeten Datenbank
    &uuml;bereinstimmen. Im Fall von MySQL, kann diese Liste unter
    <doku:link>http://dev.mysql.com/doc/refman/4.1/en/reserved-words.html</doku:link> eingesehen
    werden.
  </li>
  <li>
    Der Name des Prim&auml;rschl&uuml;ssels der Tabelle wird aus dem Namen des Objekts und dem
    Suffix <strong>ID</strong> generiert. Im Fall des Objekts strong>User</strong> ergibt sich somit
    der Name <strong>UserID</strong>.
  </li>
</ul>
<br />
<a name="3-Beziehungsdefinitionen"></a><h3>3. Umsetzung der Beziehungsdefinitionen</h3>
Die Konfiguration der Objekte enth&auml;lt im wesentlichen den Namen und die Qualit&auml;t der
Beziehung sowie das referenzierte Quell- und Zielobjekt. Bei der Auslegung der Beziehungsrichtung
muss auf die Bedeutung der Beziehung im Objektmodell geachtet werden (siehe hierzu
<a href="./?Seite=063-Generischer-OR-Mapper" title="Generischer OR-Mapper">Dokumentation OR-Mapper, 2.3.2. Beziehungsdefinition</a>).
Eine typische Konfigurationsdatei enth&auml;lt dabei eine beliebige Anzahl folgender Definitionen:
<pre class="tagexample">
[{SektionsName}]
Type = "{BeziehungsTyp}"
SourceObject = "{SourceObjektName}"
TargetObject = "{TargetObjektName}"
</pre>
<strong>{SektionsName}</strong> ist dabei der Name der Beziehung (z.B. <strong>User2Group</strong>),
<strong>{BeziehungsTyp}</strong> die Qualit&auml;t der Beziehung und <strong>{SourceObjektName}</strong>
sowie <strong>{TargetObjektName}</strong> Namen von Objekten der Objekt-Konfigurationsdatei.
G&uuml;ltige Werte f&uuml;r Beziehungsqualit&auml;ten (<strong>{BeziehungsTyp}</strong>) sind
<strong>COMPOSITION</strong> f&uuml;r eine Komposition und <strong>ASSOCIATION</strong> f&uuml;r
Assoziationen.
<br />
<br />
F&uuml;r die Umsetzung der Konfiguration in einzelne Tabellen gelten folgende Regeln:
<ul>
  <li>
    Der Name der Tabelle ergibt sich aus dem Namen der Beziehung in Kleinbuchstaben und dem Pr&auml;fix
    <strong>cmp__</strong> (f&uuml;r Kompositionsbeziehungen) oder <strong>ass__</strong> (f&uuml;r
    Assoziationsbeziehungen).
  </li>
  <li>
    Der Prim&auml;rschl&uuml;ssel der Beziehungstabelle ergibt sich aus der Qualit&auml;t der Beziehung.
    Er lautet <strong>CMPID</strong> (f&uuml;r Kompositionsbeziehungen) oder <strong>ASSID</strong>
    (f&uuml;r Assoziationsbeziehungen).
  </li>
  <li>
    Die Beziehungstabelle muss jeweils eine Refrenz auf den Prim&auml;rschl&uuml;ssel der Quell- und
    Ziel-Objekt-Tabelle besitzen. Die Namen der Fremdschl&uuml;sselspalten werden identisch den
    Namen der Fremdschl&uuml;ssel-IDs gew&auml;hlt.
  </li>
  <li>
    &Uuml;ber die beiden Fremdschl&uuml;ssel-Spalten wird ein Index gelegt, der den JOIN-Index
    darstellt. Hier ist wichtig, dass der Index &uuml;ber beide Spalten gelegt wird, da somit eine
    h&ouml;here Selektivit&auml;t des Indizes beim JOIN erreicht werden kann.
  </li>
</ul>
<br />
<a name="4-Beispiel"></a><h3>4. Beispiel</h3>
Das vorliegende Kapitel m&ouml;chte je ein Beispiel f&uuml;r die Umsetzung von Objekt- und
Beziehungsdefinition in Datenbanktabellen geben.
<br />
<br />
<a name="4-1-Objektdefinition"></a><h4>4.1. Objektdefinition</h4>
F&uuml;r die Objektdefinition
<pre class="tagexample">
[Application]
DisplayName = "VARCHAR(100)"

[User]
DisplayName = "VARCHAR(100)"
FirstName = "VARCHAR(100)"
LastName = "VARCHAR(100)"
StreetName = "VARCHAR(100)"
StreetNumber = "VARCHAR(100)"
ZIPCode = "VARCHAR(100)"
City = "VARCHAR(100)"
EMail = "VARCHAR(100)"
Phone = "VARCHAR(100)"
Mobile = "VARCHAR(100)"
Username = "VARCHAR(100)"
Password = "VARCHAR(100)"

[Group]
DisplayName = "VARCHAR(100)"
</pre>
erwartet der OR-Mapper die Tabellen-Definition
<pre class="tagexample">
CREATE TABLE IF NOT EXISTS `ent_application` (
  `ApplicationID` tinyint(5) NOT NULL auto_increment,
  `DisplayName` varchar(100) NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY  (`ApplicationID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `ent_group` (
  `GroupID` tinyint(5) NOT NULL auto_increment,
  `DisplayName` varchar(100) NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY  (`GroupID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `ent_user` (
  `UserID` tinyint(5) NOT NULL auto_increment,
  `DisplayName` varchar(100) NOT NULL default '',
  `FirstName` varchar(100) NOT NULL default '',
  `LastName` varchar(100) NOT NULL default '',
  `StreetName` varchar(100) NOT NULL default '',
  `StreetNumber` varchar(100) NOT NULL default '',
  `ZIPCode` varchar(100) NOT NULL default '',
  `City` varchar(100) NOT NULL default '',
  `EMail` varchar(100) NOT NULL default '',
  `Phone` varchar(100) NOT NULL default '',
  `Mobile` varchar(100) NOT NULL default '',
  `Username` varchar(100) NOT NULL default '',
  `Password` varchar(100) NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY  (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
</pre>
Als Storage-Engine kann auch <strong>INNODB</strong> verwendet werden.
<br />
<br />
<br />
<a name="4-2-Beziehungsdefinition"></a><h4>4.2. Beziehungsdefinition</h4>
F&uuml;r die Beziehungsdefinition
<pre class="tagexample">
[Application2Group]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Group"

[Group2User]
Type = "ASSOCIATION"
SourceObject = "Group"
TargetObject = "User"

[Application2User]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "User"
</pre>
erwartet der OR-Mapper die Tabellen-Definition
<pre class="tagexample">
CREATE TABLE IF NOT EXISTS `ass_group2user` (
  `ASSID` tinyint(5) NOT NULL auto_increment,
  `GroupID` tinyint(5) NOT NULL default '0',
  `UserID` tinyint(5) NOT NULL default '0',
  PRIMARY KEY  (`ASSID`),
  KEY `JOININDEX` (`GroupID`,`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `cmp_application2group` (
  `CMPID` tinyint(5) NOT NULL auto_increment,
  `ApplicationID` tinyint(5) NOT NULL default '0',
  `GroupID` tinyint(5) NOT NULL default '0',
  PRIMARY KEY  (`CMPID`),
  KEY `JOININDEX` (`ApplicationID`,`GroupID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `cmp_application2user` (
  `CMPID` tinyint(5) NOT NULL auto_increment,
  `ApplicationID` tinyint(5) NOT NULL default '0',
  `UserID` tinyint(5) NOT NULL default '0',
  PRIMARY KEY  (`CMPID`),
  KEY `JOININDEX` (`ApplicationID`,`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
</pre>
Als Storage-Engine kann auch <strong>INNODB</strong> verwendet werden.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="manual_orm_mandbsetup_de" />