<doku:title tags="forums,forums,design,validation,manipulation,presetting,redout,dynamic forms,controller" title="Forms" urlname="Forms">
  Ths forms documentation page describes the design and usage of APF form tags as well as the
  possibilities the devloper is given. Here, you can find a specification of the validation and
  presetting features. Further, the form manipulation and generation is decribed. An exended section
  gives you an introduction into the dynamic form generation.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
The adventure php framework supports the dynamic generation and abstraction of forms out-of-the-box.
Owing to the generic tag parser forms can be mapped by XML tags in template files and thus are embedded
in the DOM tree of the presentation layer. Thereby it is possible to give "internal intelligence" to
form elements. This implies automatic filling with the help of an URL parameter and the validation
of user inputs. The behaviour of these features can be influenced by configuring the form elements
via tag attributes. It is not necessary to implement functionality of these elements for the current
application.
<br />
<br />
<br />
<a name="1-Contruction-of-forms"></a><h3>1. Construction of forms</h3>
APF forms are simily to the HTML templates discussed under <a href="./?Page=047-Templates" title="templates">templates</a>.
Each form can be seen as a child object of the current DOM node. To get a reference on this object
each document controller feature the <strong>__getForm()</strong> method. The form class has the
following API:
<ul>
  <li>
    <strong>addFormElement()</strong>
    <br />
    Adds a form element at the end of the current form. This method can be used for dynamic form
    creation.
  </li>
  <li>
    <strong>addFormContent()</strong>
    <br />
    Adds content (HTML or text) to the end of the currend form. This method can be used for dynamic
    form creation.
  </li>
  <li>
    <strong>addFormContentBeforeMarker()</strong>
    <br />
    Adds content (HTML or text) before a marker tag to the current form. This method can be used for
    dynamic form creation.
  </li>
  <li>
    <strong>addFormContentAfterMarker()</strong>
    <br />
    Adds content (HTML or text) after a marker tag to the current form. This method can be used for
    dynamic form creation.
  </li>
  <li>
    <strong>addFormElementBeforeMarker()</strong>
    <br />
    Adds a form element before a marker tag to the current form. This method can be used for dynamic
    form creation.
  </li>
  <li>
    <strong>addFormElementAfterMarker()</strong>
    <br />
    Adds a form element after a marker tag to the current form. This method can be used for dynamic
    form creation.
  </li>
  <li>
    <strong>setPlaceHolder()</strong>
    <br />
    Fills a place holder defined within the form. Please refer to
    <a href="./?Page=046-Standard-TagLibs" title="standard taglibs">standard taglibs</a> for more details.
  </li>
  <li>
    <strong>setAction()</strong>
    <br />
    Sets the "action" attribute do define the target to POST or GET against.
  </li>
  <li>
    <strong>getFormElementByName()</strong>
    <br />
    Returns a reference an any form object defined by a name.
  </li>
  <li>
    <strong>getFormElementByID()</strong>
    <br />
    Returns a reference an any form object defined by an id.
  </li>
  <li>
    <strong>getFormElementByObjectID()</strong>
    <br />
    Returns a reference an any form object defined by an internal object id.
  </li>
  <li>
    <strong>getFormElementsByTagName()</strong>
    <br />
    Returns a list of form element references, that correspond to the given tag name (e.g.
    <em>form:text</em>).
  </li>
  <li>
    <strong>transformForm()</strong>
    <br />
    Creates the HTML output of a form and returns it.
  </li>
  <li>
    <strong>transformOnPlace()</strong>
    <br />
    Indicates, that the form will be displayed where it was defined within the template file. Though
    it is not necessary to transform the form object with <em>transformForm()</em> and assign the
    content to a place holder.
  </li>
</ul>
To use the tag it must be announced using the
<pre class="tagexample">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
</pre>
directive before using it. After that a login form may be defined like this:
<pre class="tagexample">
  &lt;html:form name="AdminLogin" method="post" action=""&gt;
    &lt;form:placeholder name="LogInError" /&gt;
    Username: &lt;form:text name="Username" class="input_feld" style="width: 200px; margin-left: 20px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    Password: &lt;form:password name="Password" class="input_feld" style="width: 200px; margin-left: 16px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="AdminLogin" value="Login" class="input_feld" style="margin-left: 227px;"/&gt;
  &lt;/html:form&gt;
</pre>
In detail: the <strong>&lt;html:form /&gt;</strong> XML tag possesses the attribute <strong>name</strong>
to be able to get reference on the form and the attribute <strong>method</strong> to define the
send mode. <strong>action</strong> defines the target to send the form to. This attribute most not be
defined due to the fact, that the taglib behind the form tag adds the <strong>action</strong> automatically
if the attribute is not present in the template file.
<br />
<br />
Within forms many form elements can bedefined: place holders to display hints or legends, text or
password fields or buttons. Please refer to <a href="./?Page=046-Standard-TagLibs" title="standard taglibs">standard taglibs</a>
to find a detailed description of the available tag libs. To use the previously defined form the
following code can be used:
<php:highlight>
  $Form__AdminLogin = &$this->__getForm('AdminLogin');
</php:highlight>
The variable <strong>$Form__AdminLogin</strong> now contains a reference on the form object. Further
the place holder's content of the previously defined form can be filled by
<php:highlight>
  $Form__Placeholder_LogInError = &$Form__AdminLogin->getFormElementByName('LogInError');
  $Form__Placeholder_LogInError->setPlaceHolder('Login failed!');
</php:highlight>
The form object internally stores the current status of the form. To gather the information whether
a form was sent or filled correctly concerning the defined validation methods the subsequent lines of
code help to achieve this:
<php:highlight>
  if($Form__AdminLogin->get('isValid') && $Form__AdminLogin->get('isSent')){

     // Do something that should be done if the form is sent and valid ...

   // end if
  }
</php:highlight>
In order to display a form you have two possibilities: assigning the content to any place holder
defined within the template file of make use of the <em>transformOnPlace()</em> function:
<php:highlight>
   function transformContent(){

      ...

      // Transform and output form by assigning the content to any placeholder ...
      $this->setPlaceHolder('...',$Form__AdminLogin->transformForm());

      // ... display the form in place
      $Form__AdminLogin->tranformOnPlace();

      ...

    // end function
   }
</php:highlight>
<br />
<a name="2-Validation"></a><h3>2. Validation</h3>
As mentioned above validation of form elements can be configured out-of-the-box. For this purpose the
attributes
<ul>
  <li>validate</li>
  <li>validator</li>
  <li>button</li>
</ul>
must be added to a form element. For details please refer to the XML tag definition under
<a href="./?Page=046-Standard-TagLibs" title="standard taglibs">standard taglibs</a>, Kapitel 2.3. In order to
validate the fields of the above defined form the text field must be adjusted as performed afterwards:
<pre class="tagexample">
  &lt;form:text name="Username" validate="true" button="AdminLogin" /&gt;
</pre>
Please note that for correct validation the name of the button must be present. If the attribute
<strong>button</strong> is not set the taglib implementation raises an error. In order to format a
form element with CSS attributes, the attributes "style" or "class" can be used as desired.
<pre class="tagexample">
  &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
  validate="true" button="AdminLogin" /&gt;
</pre>
If the attribute "validator" is not set the standard validator (<em>validateText</em>) is used instead.
This method checks, whether the value of the field is at least 3 signs long.
<br />
<br />
<br />
<a name="3-Manipulation-of-form-elements"></a><h3>3. Manipulation of form elements</h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige M&ouml;glichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen h&auml;ufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<a name="3-1-Prefilling-of-forms"></a><h4>3.1. Prefilling of forms</h4>
In order to prefill forms (e.g. in edit dialoges) the methods <strong>getFormElementByID()</strong>,
<strong>getFormElementByID()</strong> or <strong>getFormElementByObjectID()</strong> can be used to
get a reference on the desired form element. Subsequently, the standard methods <strong>get()</strong>
and <strong>getAttribute()</strong> and <strong>set()</strong> and <strong>setAttribute()</strong>
respectivly are avaliable for data manipulation of an form element.
<br />
<br />
The following box defines an example form, that will be filled by the PHP code printed below:
<br />
<pre class="tagexample">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserEdit" method="post"&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</pre>
<php:highlight>
   // get the form object
   $Form__Edit = &$this->__getForm('UserEdit');

   // get the hidden field object and fill the value
   $UserID = &$Form__Edit->getFormElementByName('userid');
   $UserID->setAttribute('value','...');

   // get the FirstName field and fill the value
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   $FirstName->setAttribute('value','...');

   // get the LastName field and fill the value
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   $LastName->setAttribute('value','...');
</php:highlight>
<br />
<a name="3-2-Prefilling-of-select-fields"></a><h4>3.2. Prefilling of select fields</h4>
Dealing with select or multiselect fields is a little bit different to "normal" form elements. But the
framework provides common methods to fill these types of fields as well. The following form contains
two select fields in addition to the four "normal" form elements:
<pre class="tagexample">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserCreate" method="post"&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;form:select name="Salutation" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;br /&gt;
    &lt;form:multiselect name="Group[]" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</pre>
As the tag definition of the <strong>Groups[]</strong> fiels shows, the name of a multiselect field
must contain brackets. If the template developer forgets to put them in, a error message will be
displayed.
<br />
<br />
In order to fill the select fields, the following PHP code can be used:
Der folgende PHP-Code bef&uuml;llt das Formular:
<php:highlight>
   // get the form object
   $Form__Create = &$this->__getForm('UserCreate');

   ...

   // get the Salutation field and add some options
   $Salutation = &$Form__Create->getFormElementByName('Salutation');

   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }


   // get the Groups[] field and add some options
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   ...
</php:highlight>
<strong>Note:</strong> If several options should be preselected using multi select fields, the
<strong>setOption2Selected()</strong> method could be used. The following code depicts how to prefill
a permission list and afterwards preselect the desired options. This example is taken from the
<a href="./?Page=095-Module-usermanagement" title="Usermanagement module">usermanagement module</a>
delivered with the APF release.
<php:highlight>
// reference the form
$form = &$this->__getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</php:highlight>
<br />
<a name="3-3-Readout-of-form-elements"></a><h4>3.3. Readout form element values</h4>
Readout of form elements is similar to the filling of form elements. In both situations, the
<strong>getFormElementByName()</strong> method can be used to obtain a reference on any form element.
Please note, that select and multiselect fields are here also treated a little bit different. The
next few lines describe, how to gather values of form elements:
<php:highlight>
   // get the form object
   $Form__Edit = &$this->__getForm('UserEdit');

   // get the value of the hidden field
   $UserID = &$Form__Edit->getFormElementByName('userid');
   echo $UserID->getAttribute('value');

   // read the content of the FirstName field
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   echo $FirstName->getAttribute('value');

   // read the content of the LastName field
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   echo $LastName->getAttribute('value');
</php:highlight>
To read the content of select or multiselect fields the <strong>getSelectedOption()</strong> and
<strong>getSelectedOptions()</strong> function can be used:
<php:highlight>
   // get the form object
   $Form__Create = &$this->__getForm('UserCreate');

   // prefill the Salutation field
   $Salutation = &$Form__Create->getFormElementByName('Salutation');
   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }

   // get the selected option of the Salutation field and print it to screen
   $Option = &$Salutation->getSelectedOption();
   echo $Option->getAttribute('value').', '.$Option->get('Content');


   // prefill the Group field
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   // get the selected options of the Groups[] field and print them to screen
   $SelectedGroups = &$Group->getSelectedOptions();
   for($i = 0; $i < count($SelectedGroups); $i++){
      echo $SelectedGroups[$i]->getAttribute('value').', '.$SelectedGroups[$i]->get('Content');
    // end for
   }
</php:highlight>
<br />
<br />
<a name="4-Dynamic-Forms"></a><h3>4. Dynamic Forms</h3>
In some cases it is necessary to generate forms dynamically. For this reason, the form taglib
(<em>html_taglib_form</em>) features the methods
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
and as of release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
The first two functions can be used to add content (i.e. plain text or html) or form elements at the
end of the form. The latter ones are intended to add content or form at certain positions. For this
reason, the <strong>&lt;form:marker /&gt;</strong> tag was introduced. The tag itself does not generate
any output, but can be used for positioning purposes along with the "<em>addForm*[Before|After]Marker()</em>"
methods.
<br />
<br />
The following chapters describe, how a dynamic form can be generated displaying form coordinate fields
(triangle, square, ...). Depending on the type, the corresponding fields are displayed. If the type
is set to "square", four fields are displayed ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - dynamische Form generation; selection of the 'square' type" />
<br />
<br />
... in case of "triangle" three fields are presented:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - dynamische Form generation; selection of the 'triangle' type" />
<br />
<br />
<br />
<a name="4-1-Form-definition"></a><h4>4.1. Form definition</h4>
As already mentioned, the dynamic definition can be done in two flavours. While using
<em>addFormElement()</em> and/or <em>addFormContent()</em>, no marker is needed. Instead, the
following example uses marker, because the form already contains structural elements (e.g. table).
<br />
<br />
The following code box shows the form definition needed to display the form denoted above. To keep
things simple, no CSS was added. Taking a closer look at the definition, you can see, that the form
consists of a static select field, that defines the types available and a marker tag for positioning.
Further, a document controller is specified, to add the desired form elements in front of the marker:
<pre class="tagexample">
&lt;@controller namespace="..." file="..." class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</pre>
<br />
<a name="4-2-Controller"></a><h4>4.2. Controller</h4>
The document controller is responsible for generating the form field, that depends on the type of
the geometrical shape. For this reason, the constructor contains a definition of the form fields
that should be displayed for a concrete type. Afterwards, the typ is read from the select field and
the form is enhanced with additional content and fields. The following code box presents the
implementation of the document controller needed for this functionality:
<php:highlight>
class select_controller extends baseController
{

   // specify form element container
   var $__FormElements = array();


   function select_controller(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

    // end function
   }


   function transformContent(){

      // get form reference
      $Form = &$this->__getForm('type');

      // get current decision
      $Select = &$Form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
       // end if
      }
      else{
         $CurrentType = $Option->getAttribute('value');
       // end else
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $Form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $CurrentElementID = $Form->addFormElementBeforeMarker(
                                          'fields',
                                          'form:text',
                                          array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                                                              );

         // configure further form element attributes
         $CurrentElement = &$Form->getFormElementByObjectID($CurrentElementID);
         $CurrentElement->setAttribute('style','width: 200px;');

         // add a line break
         $Form->addFormContentBeforeMarker('fields','<br />');

       // end for
      }

      // display form
      $Form->transformOnPlace();

    // end function
   }

 // end class
}
</php:highlight>
<br />
<a name="4-3-Notes"></a><h4>4.3. Notes</h4>
A APF form element does need information about the name of itself already at creation time. If the
element doesn't know it's own name, presetting and validation cannot be enabled. In order to use
presetting and validation in combination with dynamic form elements, the <em>addFormElement()</em>,
<em>addFormElementBeforeMarker()</em> and <em>addFormElementBeforeMarker()</em> functions possess a
third parameter. This parameter expects an associative list of tag attributes, that are applied to
the form object on creation time. Creating dynamic form elements, it is thus recommended to at least
apply the name of the tag to the third argument:
<pre class="tagexample">
array(
      'name' => 'currentname'
     )
</pre>
Please note, that the tag attributes are also interesting for addressing the form objects after
appending them to the form via the <em>getFormElementByName()</em> or <em>getFormElementByID()</em>
methods.
<br />
<br />
<br />
<a name="5-Usage-of-form-filters"></a><h3>5. Usage of form filters</h3>
Since the 1.9 branch, the form elements support filtering. The form filters are based on the APF
filter from the core namespace. Details on the design and the usage of filters can be read about
in the <a href="./?Page=087-Filter#4-Design-and-function" title="Filter">filter chapter</a>.
<br />
<br />
The form filters are aimed to enhance the generic input filter (see
<a href="./?Page=087-Filter#5-Configuration" title="configuration of filters">configuration of filters</a>)
to only accept dedicated user input within user input fields. A typical application sample is the
filtering of an email field, that only allows characters, that match the regular expression
&quot;<strong>[a-z0-9-_@.]</strong>&quot;.
<br />
<br />
<br />
<a name="5-1-Built-in-filters"></a><h4>5.1. Built-in filters</h4>
To ease working with user input in forms, a set of default filters is included in the release. The
following filter tasks are presented by the filter class <strong>FormFilter</strong> from the
<strong>tools::form::filter</strong> namespace (filter instructions):
<ul>
  <li><strong>string2Lower</strong>: Changes all capital letters to lower letters.</li>
  <li><strong>string2Upper</strong>: Changes all lower letters to capital letters.</li>
  <li><strong>stripTags</strong>: Trips HTML or script tags.</li>
  <li><strong>noSpecialCharacters</strong>: Filters special characters.</li>
  <li><strong>onlyNumbers</strong>: Only supports digits.</li>
  <li><strong>onlyInteger</strong>: Only supports integer values.</li>
  <li><strong>onlyLetters</strong>: Only supports letters.</li>
  <li><strong>onlyHTMLEntities</strong>: Encodes all HTML signs.</li>
</ul>
<br />
<a name="5-2-Usage"></a><h4>5.2. Usage</h4>
The application of filters is similar to validators. If the attribute <strong>filter</strong> is
present, the filter described by the value is applied to the content of the form element. By default,
the built-in filter is used as described in chapter 5.1.
<br />
<br />
The code box below shows you how to apply a form filter:
<pre class="tagexample">
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="phone"
          filter="onlyNumbers"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</pre>
On parse time of the form, the content of the <strong>phone</strong> field is filtered with the
<em>onlyNumbers</em> filter instruction. If you retrieve the content of the text field, you can be
sure, that it contains no not allowed characters. Due to the fact, that filtering is done <u>before</u>
validation, the validator is not able to give positiv response due to wrong user input.
<br />
<br />
<strong>Important:</strong>
<ul>
  <li>
    Please note, that filters are only available for text input fields at the moment!
  </li>
  <li>
    To apply more that one filter, please have a look at chapter
    <a href="#5-4-Filter-chaining" title="5.4. Filter chaining">5.4. Filter chaining</a>.
  </li>
</ul>
<br />
<a name="5-3-Enhancement"></a><h4>5.3. Enhancement</h4>
If the built-in filters do not satisfy your requirements, the <strong>filterclass</strong> attribute
can be used to specify another filter. The definition (=value) must have the following look:
<pre class="tagexample">
filterclass="path::to::my::filter::class|MyFilterClassName"
</pre>
The first part corresponds to the namespace of the filter, the second part ist the name of the
class or the file, respectivly. The <strong>filter</strong> attribute does also contain the filter
instruction.
<br />
<br />
As described in chapter
<a href="./?Page=087-Filter#4-Design-and-function" title="Design and function">design and function of filters</a>,
each filter class must inherit from the <strong>AbstractFilter</strong> definition and must implement
the <strong>filter()</strong> function. The next code box points out, how a filter replacing all
occurrences from &quot;cm^2&quot; to &quot;cm&sup2;&quot; must be implemented:
<php:highlight>
class DefinitionFilter extends AbstractFilter
{

   function filter($instruction,$input){
      return str_replace('cm^2','cm&sup2;',$input);
   }

}
</php:highlight>
As you can take from the example, the filter instruction must not be used within simple application
cases. In this case, you have to ensure, that the <strong>filter</strong> attribute contains a
non-empty (dummy) value.
<br />
<br />
In order to make a filter reusable, it is well to group similar filter instructions into one filter.
The following example demonstrates a filter, that filters body quantities:
<php:highlight>
class MeasureFilter extends AbstractFilter
{

   function filter($instruction,$input){

      switch($instruction){

         case 'weight':
            $output = preg_replace('/[^0-9,.]/i','',$input);
         case 'size':
            $output = preg_replace('/[^0-9]/i','',$input);
         default:
            $output = $input;

      }

      return $output;

   }

}
</php:highlight>
In order to apply the filter, the form must be adapted as follows:
<pre class="tagexample">
&lt;html:form name="test" method="post"&gt;
  Name:
  &lt;form:text
          name="name"
          filter="noSpecialCharacters"
  /&gt;
  &lt;br /&gt;
  Weight:
  &lt;form:text
          name="weight"
          filterclass="my::special::filter|MeasureFilter"
          filter="weight"
  /&gt;
  kg
  &lt;br /&gt;
  Body size:
  &lt;form:area
          name="bodysize"
          filterclass="my::special::filter|MeasureFilter"
          filter="size"
  /&gt;
  cm
  &lt;br /&gt;
&lt;/html:form&gt;
</pre>
<br />
<a name="5-4-Filter-chaining"></a><h4>5.4. Filter chaining</h4>
Filter chaining can be done by an extra filter class. In order to apply more than one filter, the
<strong>MultiplexFormFilter</strong> class (also included in the release) can be used:
<php:highlight>
class MultiplexFormFilter extends FormFilter
{
   function filter($instruction,$input){

      $instructionSet = explode('|',$instruction);
      $output = $input;

      foreach($instructionSet as $filterInstruction){
         $output = $this->{'__'.trim($filterInstruction)}($output);
      }

      return $output;

   }

}
</php:highlight>
In order to apply the a filter chain, the form must be adapted as follows:
<pre class="tagexample">
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="specialfield"
          filterclass="tools::form::filter|MultiplexFormFilter"
          filter="noSpecialCharacters|string2Upper"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</pre>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_011" />