<core:addtaglib namespace="sites::demosite::pres::taglib" prefix="file" class="highlight" />
<core:addtaglib namespace="sites::demosite::pres::taglib" prefix="php" class="highlight" />
<core:addtaglib namespace="sites::demosite::pres::taglib" prefix="doku" class="navigation" />
<doku:navigation />
<br />
<br />
<font style="font-size: 26px; font weight: bold;">Forms</font>
<br />
<br />
<core:importdesign namespace="sites::demosite::pres::templates::voting" template="voting" />
The adventure php framework supports the dynamic generation and abstraction of forms out-of-the-box.
Owing to the generic tag parser forms can be mapped by XML tags in template files and thus are embedded
in the DOM tree of the presentation layer. Thereby it is possible to give "internal intelligence" to
form elements. This implies automatic filling with the help of an URL parameter and the validation
of user inputs. The behaviour of these features can be influenced by configuring the form elements
via tag attributes. It is not necessary to implement functionality of these elements for the current
application.
<br />
<br />
<br />
<a name="1-Contruction-of-forms"></a><h3>1. Construction of forms</h3>
APF forms are simily to the HTML templates discussed under <a href="./?Page=047-Templates" title="templates">templates</a>.
Each form can be seen as a child object of the current DOM node. To get a reference on this object
each document controller feature the <strong>__getForm()</strong> method. The form class has the
following API:
<ul>
  <li>
    <strong>addFormElement()</strong>
    <br />
    Adds a form element at the end of the current form. This method can be used for dynamic form
    creation.
  </li>
  <li>
    <strong>addFormContent()</strong>
    <br />
    Adds content (HTML or text) to the end of the currend form. This method can be used for dynamic
    form creation.
  </li>
  <li>
    <strong>addFormContentBeforeMarker()</strong>
    <br />
    Adds content (HTML or text) before a marker tag to the current form. This method can be used for
    dynamic form creation.
  </li>
  <li>
    <strong>addFormContentAfterMarker()</strong>
    <br />
    Adds content (HTML or text) after a marker tag to the current form. This method can be used for
    dynamic form creation.
  </li>
  <li>
    <strong>addFormElementBeforeMarker()</strong>
    <br />
    Adds a form element before a marker tag to the current form. This method can be used for dynamic
    form creation.
  </li>
  <li>
    <strong>addFormElementAfterMarker()</strong>
    <br />
    Adds a form element after a marker tag to the current form. This method can be used for dynamic
    form creation.
  </li>
  <li>
    <strong>setPlaceHolder()</strong>
    <br />
    Fills a place holder defined within the form. Please refer to
    <a href="./?Page=046-Standard-TagLibs" title="standard taglibs">standard taglibs</a> for more details.
  </li>
  <li>
    <strong>setAction()</strong>
    <br />
    Sets the "action" attribute do define the target to POST or GET against.
  </li>
  <li>
    <strong>getFormElementByName()</strong>
    <br />
    Returns a reference an any form object defined by a name.
  </li>
  <li>
    <strong>getFormElementByID()</strong>
    <br />
    Returns a reference an any form object defined by an id.
  </li>
  <li>
    <strong>getFormElementByObjectID()</strong>
    <br />
    Returns a reference an any form object defined by an internal object id.
  </li>
  <li>
    <strong>transformForm()</strong>
    <br />
    Creates the HTML output of a form and returns it.
  </li>
  <li>
    <strong>transformOnPlace()</strong>
    <br />
    Indicates, that the form will be displayed where it was defined within the template file. Though
    it is not necessary to transform the form object with <em>transformForm()</em> and assign the
    content to a place holder.
  </li>
</ul>
To use the tag it must be announced using the
<pre class="tagexample">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
</pre>
directive before using it. After that a login form may be defined like this:
<pre class="tagexample">
  &lt;html:form name="AdminLogin" method="post" action=""&gt;
    &lt;form:placeholder name="LogInError" /&gt;
    Username: &lt;form:text name="Username" class="input_feld" style="width: 200px; margin-left: 20px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    Password: &lt;form:password name="Password" class="input_feld" style="width: 200px; margin-left: 16px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="AdminLogin" value="Login" class="input_feld" style="margin-left: 227px;"/&gt;
  &lt;/html:form&gt;
</pre>
In detail: the <strong>&lt;html:form /&gt;</strong> XML tag possesses the attribute <strong>name</strong>
to be able to get reference on the form and the attribute <strong>method</strong> to define the
send mode. <strong>action</strong> defines the target to send the form to. This attribute most not be
defined due to the fact, that the taglib behind the form tag adds the <strong>action</strong> automatically
if the attribute is not present in the template file.
<br />
<br />
Within forms many form elements can bedefined: place holders to display hints or legends, text or
password fields or buttons. Please refer to <a href="./?Page=046-Standard-TagLibs" title="standard taglibs">standard taglibs</a>
to find a detailed description of the available tag libs. To use the previously defined form the
following code can be used:
<php:highlight>
  $Form__AdminLogin = &$this->__getForm('AdminLogin');
</php:highlight>
The variable <strong>$Form__AdminLogin</strong> now contains a reference on the form object. Further
the place holder's content of the previously defined form can be filled by
<php:highlight>
  $Form__Placeholder_LogInError = &$Form__AdminLogin->getFormElementByName('LogInError');
  $Form__Placeholder_LogInError->setPlaceHolder('Login failed!');
</php:highlight>
The form object internally stores the current status of the form. To gather the information whether
a form was sent or filled correctly concerning the defined validation methods the subsequent lines of
code help to achieve this:
<php:highlight>
  if($Form__AdminLogin->get('isValid') && $Form__AdminLogin->get('isSent')){

     // Do something that should be done if the form is sent and valid ...

   // end if
  }
</php:highlight>
In order to display a form you have two possibilities: assigning the content to any place holder
defined within the template file of make use of the <em>transformOnPlace()</em> function:
<php:highlight>
   function transformContent(){

      ...

      // Transform and output form by assigning the content to any placeholder ...
      $this->setPlaceHolder('...',$Form__AdminLogin->tranformForm());

      // ... display the form in place
      $Form__AdminLogin->tranformOnPlace();

      ...

    // end function
   }
</php:highlight>
<br />
<a name="2-Validation"></a><h3>2. Validation</h3>
As mentioned above validation of form elements can be configured out-of-the-box. For this purpose the
attributes
<ul>
  <li>validate</li>
  <li>validator</li>
  <li>button</li>
</ul>
must be added to a form element. For details please refer to the XML tag definition under
<a href="./?Page=046-Standard-TagLibs" title="standard taglibs">standard taglibs</a>, Kapitel 2.3. In order to
validate the fields of the above defined form the text field must be adjusted as performed afterwards:
<pre class="tagexample">
  &lt;form:text name="Username" validate="true" button="AdminLogin" /&gt;
</pre>
Please note that for correct validation the name of the button must be present. If the attribute
<strong>button</strong> is not set the taglib implementation raises an error. In order to format a
form element with CSS attributes, the attributes "style" or "class" can be used as desired.
<pre class="tagexample">
  &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
  validate="true" button="AdminLogin" /&gt;
</pre>
If the attribute "validator" is not set the standard validator (<em>validateText</em>) is used instead.
<br />
<br />
<br />
<a name="3-Manipulation-of-form-elements"></a><h3>3. Manipulation of form elements</h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige M&ouml;glichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen h&auml;ufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<a name="3-1-Prefilling-of-forms"></a><h4>3.1. Prefilling of forms</h4>
In order to prefill forms (e.g. in edit dialoges) the methods <strong>getFormElementByID()</strong>,
<strong>getFormElementByID()</strong> or <strong>getFormElementByObjectID()</strong> can be used to
get a reference on the desired form element. Subsequently, the standard methods <strong>get()</strong>
and <strong>getAttribute()</strong> and <strong>set()</strong> and <strong>setAttribute()</strong>
respectivly are avaliable for data manipulation of an form element.
<br />
<br />
The following box defines an example form, that will be filled by the PHP code printed below:
<br />
<pre class="tagexample">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserEdit" method="post"&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</pre>
<php:highlight>
   // get the form object
   $Form__Edit = &$this->__getForm('UserEdit');

   // get the hidden field object and fill the value
   $UserID = &$Form__Edit->getFormElementByName('userid');
   $UserID->setAttribute('value','...');

   // get the FirstName field and fill the value
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   $FirstName->setAttribute('value','...');

   // get the LastName field and fill the value
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   $LastName->setAttribute('value','...');
</php:highlight>
<br />
<a name="3-2-Prefilling-of-select-fields"></a><h4>3.2. Prefilling of select fields</h4>
Dealing with select or multiselect fields is a little bit different to "normal" form elements. But the
framework provides common methods to fill these types of fields as well. The following form contains
two select fields in addition to the four "normal" form elements:
<pre class="tagexample">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserCreate" method="post"&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;form:select name="Salutation" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;br /&gt;
    &lt;form:multiselect name="Group[]" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</pre>
As the tag definition of the <strong>Groups[]</strong> fiels shows, the name of a multiselect field
must contain brackets. If the template developer forgets to put them in, a error message will be
displayed.
<br />
<br />
In order to fill the select fields, the following PHP code can be used:
Der folgende PHP-Code bef&uuml;llt das Formular:
<php:highlight>
   // get the form object
   $Form__Create = &$this->__getForm('UserCreate');

   ...

   // get the Salutation field and add some options
   $Salutation = &$Form__Create->getFormElementByName('Salutation');

   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }


   // get the Groups[] field and add some options
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   ...
</php:highlight>
<br />
<a name="3-3-Readout-of-form-elements"></a><h4>3.3. Readout form element values</h4>
Readout of form elements is similar to the filling of form elements. In both situations, the
<strong>getFormElementByName()</strong> method can be used to obtain a reference on any form element.
Please note, that select and multiselect fields are here also treated a little bit different. The
next few lines describe, how to gather values of form elements:
<php:highlight>
   // get the form object
   $Form__Edit = &$this->__getForm('UserEdit');

   // get the value of the hidden field
   $UserID = &$Form__Edit->getFormElementByName('userid');
   echo $UserID->getAttribute('value');

   // read the content of the FirstName field
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   echo $FirstName->getAttribute('value');

   // read the content of the LastName field
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   echo $LastName->getAttribute('value');
</php:highlight>
To read the content of select or multiselect fields the <strong>getSelectedOption()</strong> and
<strong>getSelectedOptions()</strong> function can be used:
<php:highlight>
   // get the form object
   $Form__Create = &$this->__getForm('UserCreate');

   // prefill the Salutation field
   $Salutation = &$Form__Create->getFormElementByName('Salutation');
   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }

   // get the selected option of the Salutation field and print it to screen
   $Option = &$Salutation->getSelectedOption();
   echo $Option->getAttribute('value').', '.$Option->get('Content');


   // prefill the Group field
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   // get the selected options of the Groups[] field and print them to screen
   $SelectedGroups = &$Group->getSelectedOptions();
   for($i = 0; $i < count($SelectedGroups); $i++){
      echo $SelectedGroups[$i]->getAttribute('value').', '.$SelectedGroups[$i]->get('Content');
    // end for
   }
</php:highlight>
<br />
<br />
<a name="4-Dynamic-Forms"></a><h3>4. Dynamic Forms</h3>
In some cases it is necessary to generate forms dynamically. For this reason, the form taglib
(<em>html_taglib_form</em>) features the methods
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
and as of release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
The first two functions can be used to add content (i.e. plain text or html) or form elements at the
end of the form. The latter ones are intended to add content or form at certain positions. For this
reason, the <strong>&lt;form:marker /&gt;</strong> tag was introduced. The tag itself does not generate
any output, but can be used for positioning purposes along with the "<em>addForm*[Before|After]Marker()</em>"
methods.
<br />
<br />
The following chapters describe, how a dynamic form can be generated displaying form coordinate fields
(triangle, square, ...). Depending on the type, the corresponding fields are displayed. If the type
is set to "square", four fields are displayed ...
<br />
<br />
<img src="/frontend/media/dynamic_forms_02.png" alt="APF - dynamische Form generation; selection of the 'square' type" />
<br />
<br />
... in case of "triangle" three fields are presented:
<br />
<br />
<img src="/frontend/media/dynamic_forms_01.png" alt="APF - dynamische Form generation; selection of the 'triangle' type" />
<br />
<br />
<br />
<a name="4-1-Form-definition"></a><h4>4.1. Form definition</h4>
As already mentioned, the dynamic definition can be done in two flavours. While using
<em>addFormElement()</em> and/or <em>addFormContent()</em>, no marker is needed. Instead, the
following example uses marker, because the form already contains structural elements (e.g. table).
<br />
<br />
The following code box shows the form definition needed to display the form denoted above. To keep
things simple, no CSS was added. Taking a closer look at the definition, you can see, that the form
consists of a static select field, that defines the types available and a marker tag for positioning.
Further, a document controller is specified, to add the desired form elements in front of the marker:
<pre class="tagexample">
&lt;@controller namespace="..." file="..." class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</pre>
<br />
<a name="4-2-Controller"></a><h4>4.2. Controller</h4>
The document controller is responsible for generating the form field, that depends on the type of
the geometrical shape. For this reason, the constructor contains a definition of the form fields
that should be displayed for a concrete type. Afterwards, the typ is read from the select field and
the form is enhanced with additional content and fields. The following code box presents the
implementation of the document controller needed for this functionality:
<php:highlight>
class select_controller extends baseController
{

   // specify form element container
   var $__FormElements = array();


   function select_controller(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

    // end function
   }


   function transformContent(){

      // get form reference
      $Form = &$this->__getForm('type');

      // get current decision
      $Select = &$Form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
       // end if
      }
      else{
         $CurrentType = $Option->getAttribute('value');
       // end else
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $Form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $CurrentElementID = $Form->addFormElementBeforeMarker(
                                          'fields',
                                          'form:text',
                                          array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                                                              );

         // configure further form element attributes
         $CurrentElement = &$Form->getFormElementByObjectID($CurrentElementID);
         $CurrentElement->setAttribute('style','width: 200px;');

         // add a line break
         $Form->addFormContentBeforeMarker('fields','<br />');

       // end for
      }

      // display form
      $Form->transformOnPlace();

    // end function
   }

 // end class
}
</php:highlight>
<br />
<a name="4-3-Notes"></a><h4>4.3. Notes</h4>
A APF form element does need information about the name of itself already at creation time. If the
element doesn't know it's own name, presetting and validation cannot be enabled. In order to use
presetting and validation in combination with dynamic form elements, the <em>addFormElement()</em>,
<em>addFormElementBeforeMarker()</em> and <em>addFormElementBeforeMarker()</em> functions possess a
third parameter. This parameter expects an associative list of tag attributes, that are applied to
the form object on creation time. Creating dynamic form elements, it is thus recommended to at least
apply the name of the tag to the third argument:
<pre class="tagexample">
array(
      'name' => 'currentname'
     )
</pre>
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="manual_formulare_en" />