<doku:title tags="form,taglib,validatoren,validator,filter,auto,ausfuellen,presetting,1.11" title="Forms (as of release 1.11)" urlname="Forms">
   Das APF bietet auf Basis von Taglibs eine komplette Abstraktion von Formularen und
   Formular-Elementen. Diese beherrschen out-of-the-box Presetting (Auto-Ausf&uuml;llen), Validierung
   und Filterung. Im Document-Controller steht ein Formular als eigenst&auml;ndiges Objekt mit diversen
   Funktionen zur Verf&uuml;gung.
</doku:title>
<a name="1-Introduction"></a><h3>1. Introduction</h3>
Due to the fact, that the
<a href="./?Seite=098-Pagecontroller" title="Page controller">page controller</a> of the APF
provides a generic frame to handle taglibs, we were able to implement a form abstraction built on
taglibs (e.g. text fields).
<br />
<br />
The release of the adventure php framework contains a set of taglibs, that fully describe HTML
forms and that contain features such as filtering, validation and presetting at the same time out of
the box. With the taglibs reworked with release 1.11, form fields can be applied various filters and
validators and custom form elements can be integrated with the delivered ones.
<br />
<br />
The subsequent chapters describe the general design and the handling of APF forms as well as the
tags shipped with the release with their meaning and functionality. Reading this documentation
and implementing applications, it is recommended to have the
<a href="./?Page=002-API-documentation" title="API documentation">API documentation</a> opened.
There, you can see, which functionality is included in the various taglibs - e.g. the
<strong>html_taglib_form</strong>.
<br />
<br />
<br />
<a name="2-Construction"></a><h3>2. Construction of forms</h3>
As noted in the introduction, APF forms are represented by taglibs. The
<strong>&lt;html:form /&gt;</strong> tag forms the base taglib, that encapsulates all other form
tags and presents an APF form <u>as a single</u> object to the document controller. It contains
further tag instances as it's child oblects that represent dedicated elements like text fields or
buttons or functional tags such as place holders, listeners or tags, that add custom form controls.
<br />
<br />
Forms - as you know from other APF GUI elements - are defines within template files. A simple form
with a search field and a button looks like this:
<code:highlight>
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="Search"&gt;
   &lt;form:text name="searchterm" /&gt; &lt;form:button name="search" value="GO" /&gt;
&lt;/html:form&gt;
</code:highlight>
In order to display the form a document controller must be defined for the corresponding template.
This is necessary, because a form - in contrast to other tags - is always coupled with functionality
to handle the data passed to the form. This may be reading the search term or executing the search
or saving user data.
<br />
<br />
Displaying a form is not rocket science with the APF and can be done with the following controller
code:
<php:highlight>
class search_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('Search');
      $form->transfromOnPlace();
   }
}
</php:highlight>
The subsequent sections present the form controls contained within the APF release and give you
a brief introduction to the usage of these elements.
<br />
<br />
<br />
<a name="3-Shipped-tags"></a><h3>3. Shipped tags</h3>
The APF contains an extended set of form control abstraction tags, that can be configured for
different purposes. In case this is not enough, custom form taglibs can be introduced as desired.
This is described in detail under
<a href="./?Page=114-Form-usage" title="Usage of forms">usage of forms</a>.
<br />
<br />
Since the APF's page controller is built up on a generic tag parser, form tags can be added
generic attributes such as:
<ul>
   <li><strong>id="..."</strong></li>
   <li><strong>class="..."</strong></li>
   <li><strong>style="..."</strong></li>
</ul>
These are presented in the generated source code and can thus be used for formatting purposes. For
this reason, the following chapters do not mention these attributes, but only describe the
attributes, that are necessary for the configuration of the tag.
<br />
<br />
<div class="hint">
   Attributes, that are surrounded with &quot;[&quot; and &quot;]&quot; (brackets) are optional.
   All other attributes must be present, otherwise the corresponding taglib may throw an error.
</div>
<br />
The form tag itself takes three functional atributes, that are used for definition and configuration:
<code:highlight>
&lt;html:form name="" [method=""] [action=""]&gt;
  ...
&lt;/html:form&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the form. This attribute is used to address the form within
    a document controller.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>method</strong>: Method that is used to send the form data. By default, 
    <strong>post</strong> is used.
    (<strong>Allowed characters</strong>: <code>[get|post]</code>)
  </li>
  <li>
    <strong>action</strong>: The url, that is called on button click by the browser.
  </li>
</ul>
<br />
<a name="3-1-Button"></a><h4>3.1. Button</h4>
This taglib represents a submit button. APF form elements are validated and filtered on button click
event. Hence, it is necessary to specify a button or image button within the form, due buttons
create the <em>click event</em>.
<code:highlight>
&lt;form:button name="" value="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the button. The name is used to access the button. This is
    necessary for validators and filters.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of the button. The browser uses this value to label the button.
  </li>
</ul>
<br />
<a name="3-2-Image-button"></a><h4>3.2. Image button</h4>
The image button tag creates an image button, that uses an image as the label. The functionality
is equal to the &quot;normal&quot; button.
<code:highlight>
&lt;form:imagebutton name="" src="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the button. The name is used to access the button. This is
    necessary for validators and filters.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>src</strong>: Image source.
  </li>
</ul>
<br />
<a name="3-3-Reset"></a><h4>3.3. Reset button</h4>
As of the release 1.10, the form taglibs contain a reset button wrapper. It represents a HTML reset
button and can be addressed and configured as &quot;normal&quot; buttons within a document
controller.
<br />
<br />
<div class="hint">
   A reset button does not fire the click event, thus validation and filtering is not possible!
</div>
<code:highlight>
&lt;form:reset value="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>value</strong>: The value (label) of the reset button.
  </li>
</ul>
<br />
<a name="3-4-Hidden"></a><h4>3.4. Hidden field</h4>
<code:highlight>
&lt;form:hidden name="" value="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: The name of the hidden field. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: The value of the hidden field.
  </li>
</ul>
<br />
<a name="3-5-Text"></a><h4>3.5. Text field</h4>
<code:highlight>
&lt;form:text name="" [value=""] /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the text fields. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of te text field.
  </li>
</ul>
<br />
<a name="3-6-Text-area"></a><h4>3.6. Text area</h4>
You can use the APF text area wrapper taglib in two flavours: without explicit content as a
self-closing tag and with content as explicitly closing tag.
<code:highlight>
&lt;form:area name="" /&gt;
&lt;form:area name=""&gt;...&lt;/form:area&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the text area. This attribute can be used to access the
    control. (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
<br />
<a name="3-7-Password"></a><h4>3.7. Password field</h4>
<code:highlight>
&lt;form:password name="" [value=""]/&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the password field. This attribute can be used to access the
    control. (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of the password field.
  </li>
</ul>
<br />
<a name="3-8-File-upload-field"></a><h4>3.8. File upload field</h4>
<code:highlight>
&lt;form:file name="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the file upload field. This attribute can be used to access the
    control. (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
<br />
<a name="3-9-Checkbox"></a><h4>3.9. Checkbox</h4>
The checkbox implementation is not only a simple wrapper for the HTML checkbox, but includes the
functionality to automatically check or uncheck the box. With this taglib, the problem with
re-checking boxes on re-submit is solved.
<code:highlight>
&lt;form:checkbox name="" value="" [checked="checked"] /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the checkbox. This attribute can be used to access the
    control. (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of the checkbox.
  </li>
  <li>
    <strong>checked</strong>: Defines, whether the checkbox should be preselected.
  </li>
</ul>
<br />
<a name="3-10-Radio-button"></a><h4>3.10. Radio button</h4>
The radio button implementation is not only a simple wrapper for the HTML radio buttons, but
includes the functionality to automatically check or uncheck the button. With this taglib, the
problem with re-checking buttons on re-submit is solved.
<code:highlight>
&lt;form:radio name="" value="" [checked="checked"]/&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the radio button. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of the radio button - or precisely - the name of the current option.
  </li>
  <li>
    <strong>checked</strong>: Defines, whether the button should be preselected.
  </li>
</ul>
<br />
<a name="3-11-Select"></a><h4>3.11. Select field</h4>
A select field can be defined in two different ways. Possibility one is a field, that is filled
dynamically within a document controller and does not contain static options. Possibility two is a
select field, that defines static options that may be preselected.
<code:highlight>
&lt;form:select name="" /&gt;
&lt;form:select name=""&gt;
  &lt;select:option value="" [selected="selected"]&gt;...&lt;/select:option&gt;
&lt;/form:select&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the select field. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of the option.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>selected</strong>: In case an option should be preselected, the <em>selected</em>
    attribute must contain the name of the attribute as it's value.
  </li>
</ul>
<br />
<a name="3-12-Multi-select"></a><h4>3.12. Multi select field</h4>
As the simple select field, the multi select field allows you to specify two different types: with
and without static options.
<code:highlight>
&lt;form:multiselect name="" /&gt;
&lt;form:multiselect name=""&gt;
  &lt;select:option value="" [selected="selected"]&gt;&lt;/select:option&gt;
&lt;/form:multiselect&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the multi select field. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Value of the option.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>selected</strong>: In case an option should be preselected, the <em>selected</em>
    attribute must contain the name of the attribute as it's value.
  </li>
</ul>
<br />
<div class="hint">
   The name of the form field must not contain &quot;[]&quot; at the end. Otherwise errors occure
   when addressing the element!
</div>
<br />
<br />
<a name="3-13-Place-holder"></a><h4>3.13. Place holder</h4>
A place holder can be used to insert dynamic content into the form.
<code:highlight>
&lt;form:placeholder name="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the place holder. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
Filling a place holder, the <strong>html_taglib_form</strong>'s method
<strong>setPlaceHolder()</strong> can be uses:
<php:highlight>
$form = &$this->__getForm('MyForm');
$form->setPlaceHolder('NameOfThePlaceHolder','...Value...');
</php:highlight>
<br />
<a name="3-14-Date-control"></a><h4>3.14. Date control</h4>
To ease date select field generation, the APF contains a date form control that can be configured
to fit your needs.
<code:highlight>
&lt;form:date name="" [yearrange=""] [offsetnames=""]/&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the date control. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>yearrange</strong>: The range of years, that should be presented to the user.
    Example: <code>1990-2007</code>.
    (<strong>Allowed characters</strong>: <code>[0-9-]</code>)
  </li>
  <li>
    <strong>offsetnames</strong>: Explicitly specifies the name of the date control's components
    (=name of the single fields). Example: <code>day;month;year</code>.
    (<strong>Allowed characters</strong>: <code>[A-Za-z;]</code>)
  </li>
</ul>
<br />
<a name="3-15-Marker"></a><h4>3.15. Marker</h4>
As described in chapter 
<a href="" title="Dynamic forms">dynamic forms</a>,
the <strong>&lt;form:marker /&gt;</strong> tag can be used to position dynamic form elements. The
tag itself creates no output.
<code:highlight>
&lt;form:marker name="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>name</strong>: Name of the markers. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
</ul>
<br />
<a name="3-16-Addtaglib"></a><h4>3.16. Addtaglib</h4>
The <strong>&lt;form:addtaglib /&gt;</strong> tag is the pendant to the
<strong>&lt;core:addtaglib /&gt;</strong> tag. It offers the possibbility to add custom form tags.
<code:highlight>
&lt;form:addtaglib namespace="" prefix="" class="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Namespace path seperated with "::".
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_-:]</code>)
  </li>
  <li>
    <strong>prefix</strong>: XML prefix
    (<strong>Allowed characters</strong>: <code>[a-z]</code>)
  </li>
  <li>
    <strong>class</strong>: XML class
    (<strong>Allowed characters</strong>: <code>[a-z]</code>)
  </li>
</ul>
<div class="hint">
   Please note, that the taglibs added with this tag implement the <strong>form_control</strong>
   class to ensure, that the correct status is reported to the form by isSent() and isValid().
</div>
<br />
<a name="3-17-Getstring"></a><h4>3.17. Getstring</h4>
The <strong>&lt;form:getstring /&gt;</strong> tag offers the possibility to display language
dependent values from a language dependent config file within forms. Details on the configuration
can be read about in the chapter, that describes the
<a href="./?Page=046-Standard-taglibs#2-2-Getstring" title="html:getstring">&lt;html:getstring /&gt;</a>
tag.
<code:highlight>
&lt;form:getstring namespace="" config="" entry="" /&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Namespace of the configuration file.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_-:]</code>)
  </li>
  <li>
    <strong>config</strong>: Name of the configuration file.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>entry</strong>: Name of the configuration key to display the value of.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_.]</code>)
  </li>
</ul>
<br />
<a name="3-18-Listener"></a><h4>3.18. Listener</h4>
The listener tag is part of the new validation concept. The tag &quot;listens&quot; on the event, the
validator fires and shows it's content, in case the addressed form element could not be validated
successfully. Within the body of the tag, several subtags and textual content can be defined, that
can be used to format the output. Details on the validation concept can be read about in chapter 4.
<code:highlight>
&lt;form:listener [name=""] control="..."&gt;
  ...
  [&lt;listener:getstring namespace="" config="" key="" /&gt;]
  [&lt;listener:placeholder name="" /&gt;]
  ...
&lt;/form:listener&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>control</strong>: Name of the form element, that the validator tag listens to.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
  <li>
    <strong>name</strong>: Name of the listener. This attribute can be used to access the
    control.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
</ul>
The place holder tag <strong>&lt;listener:placeholder /&gt;</strong> acts like the
<a href="./?Page=046-Standard-taglibs#2-1-Placeholder" title="html:placeholder tag">&lt;html:placeholder /&gt;</a>,
the <strong>&lt;listener:getstring /&gt;</strong> tag like the
<a href="./?Page=046-Standard-taglibs#2-2-Getstring" title="html:getstring tag">&lt;html:getstring /&gt;</a>
tag. In order to fill the the place holder, the following document controller code can be used:
<br />
<br />
<u>Template:</u>
<code:highlight>
&lt;html:form name="name_form" method="post"&gt;
   &lt;form:listener name="name-listener" control="name"&gt;
      Please fill in the &lt;listener:placeholder name="field-name" /&gt; field!
   &lt;/form:listener&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="name"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</code:highlight>
<u>Controller:</u>
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('name-form');
      $listener = &$form->getFormElementByName('name-listener');
      $listener->setPlaceHolder('field-name','name');
   }
}
</php:highlight>
<br />
<a name="3-19-Error"></a><h4>3.19. Display of form errors</h4>
The tag described within chapter 3.18 can be used to automatically display field relevant errors.
The <nobr><strong>&lt;form:error /&gt;</strong></nobr> tag is used to display errors for the matter
of the whole form. If one of the fields could not be validated successfully, the content of the tag
is displayed - if present in the form definition.
<code:highlight>
&lt;form:error [name=""]&gt;
  ...
  [&lt;error:getstring namespace="" config="" key="" /&gt;]
  [&lt;error:placeholder name="" /&gt;]
  ...
&lt;/form:error&gt;
</code:highlight>
The place holder tag <strong>&lt;error:placeholder /&gt;</strong> acts like the
<a href="./?Page=046-Standard-taglibs#2-1-Placeholder" title="html:placeholder tag">&lt;html:placeholder /&gt;</a>,
the <strong>&lt;error:getstring /&gt;</strong> tag like the
<a href="./?Page=046-Standard-taglibs#2-2-Getstring" title="html:getstring tag">&lt;html:getstring /&gt;</a>
tag. Filling the place holder can be done as described in the last chapter.
<br />
<br />
<br />
<a name="4-Validation"></a><h3>4. Validation</h3>
In the previous versions of the APF the validation was linked directly with a form element and
the validation was executed within the
<a href="./?Page=098-Pagecontroller#2-1-Activity-diagram" title="Taglib lifecycle of the page controller">lifecycle of the taglibs</a>.
This has the disadvantage, that one element can be defined with only one validator. This leads to
redundant code, because each field must have it's own validator defined. Furthermore, it was not
possible to implement own validators.
<br />
<br />
From version 1.11 these circumstances were considered and the form taglibs were moved to a new
variation of the validation. From this version validators are applied by an own tag, that follows
the <a href="http://en.wikipedia.org/wiki/Observer_pattern" title="Observer pattern" target="_blank">observer pattern</a>.
The tag itself then binds a validator to the desired form control. Thus it is possible to attach
several validators onto one field, to write own validators and to validate several fields with one
observer definition at the same time.
<br />
<br />
The definition of a validator now is as follows:
<code:highlight>
&lt;form:addvalidator
   namespace=""
   class=""
   button=""
   control=""
/&gt;
</code:highlight>
<!--
   Hier weiter übersetzen!
-->
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Namespace der Validator-Implementierung.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>class</strong>: Name der Validator-Implementierung (Name = Klassen-Name!)
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>button</strong>: Name des Buttons, der die Validierung ausl&ouml;sen soll. Die Validierung
    ist immer an das Event <em>isSent</em> eines Buttons oder Image-Buttons gebunden.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>control</strong>: Name des Formular-Controls auf das die Validierung Anwendung finden
    soll. Sollen mehrere Controls mit der im Tag definierten Validierung belegt werden, so enth&auml;lt
    das Attribut alle mit Pipe getrennte Feld-Namen (z.B. <em>sender|recipient|subject</em>).
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_|]</code>)
  </li>
</ul>
<div class="hint">
   F&uuml;r mitgelieferte Validatoren muss das Attribut <strong>namespace</strong> nicht definiert
   werden. Hier verwendet die Taglib automatisch <strong>tools::form::validator</strong> als Wert.
   Unter diesem Namespace finden sich alle enthaltenen Validatoren, die im Kapitel 4.1. aufgef&uuml;hrt
   sind.
</div>
<br />
<br />
<a name="4-1-Verfuegbare-Validatoren"></a><h4>4.1. Verf&uuml;gbare Validatoren</h4>
Wie auch in den Releases < 1.11 werden eine Reihe von Validatoren mitgeliefert. Diese decken
&uuml;blicherweise den Gro&szlig;teil der Anforderungen ab. Sollten diese nicht gen&uuml;gen, k&ouml;nnen eigene
Validatoren implementiert werden. Dies ist im n&auml;chsten Kapitel beschrieben.
<br />
<br />
Aktuell sind folgende Validatoren im Release verf&uuml;gbar:
<br />
<br />
<br />
<a name="4-1-1-TextLengthValidator"></a><h5>4.1.1. TextLengthValidator</h5>
Der <strong>TextLengthValidator</strong> &uuml;berpr&uuml;ft ein Text-Formular-Feld (Text-Feld,
Passwort-Feld, Text-Area), ob der enthaltene Text eine Mindestl&auml;nge aufweist. Standardm&auml;&szlig;ig
wird von einer L&auml;nge von 3 Zeichen ausgegangen, die vom Benutzer eingegeben werden m&uuml;ssen,
ehe das Feld als g&uuml;ltig markiert wird. Sofern eine andere Text-L&auml;nge erw&uuml;nscht ist,
muss dem referenzierten Text-Feld das Attribut <strong>minlength</strong> mitgegeben werden:
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="firstname" /&gt;
   &lt;form:text name="lastname" minlength="5" /&gt;
   &lt;form:password name="pass" /&gt;
   &lt;form:area name="comment" minlength="20" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      button="send"
      control="firstname|lastname|pass|comment"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
Im abgebildeten Code-Block wird das Formular-Control <strong>firstname</strong> auf einen Text
mit einer Zeichenl&auml;nge &gt;=3 validiert, im Feld <strong>lastname</strong> m&uuml;ssen mindestens 5
Zeichen enthalten sein.
<br />
<br />
<br />
<a name="4-1-2-NumberValidator"></a><h5>4.1.2. NumberValidator</h5>
Der <strong>NumberValidator</strong> pr&uuml;ft, ob ein Text-Feld eine g&uuml;ltige Nummer enth&auml;lt. Hierzu
wird die PHP-Funktion <em>is_numeric()</em> genutzt.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="number" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="NumberValidator"
      button="send"
      control="number"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-3-EMailValidator"></a><h5>4.1.3. EMailValidator</h5>
Der <strong>EMailValidator</strong> pr&uuml;ft, ob im referenzierten ein Form-Control eine g&uuml;ltige
E-Mail-Addresse steht. Hierzu wird der Inhalt des Text-Feldes gegen einen regul&auml;ren Ausdruck
gepr&uuml;ft.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="EMailValidator"
      button="send"
      control="email"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-4-PhoneAndFaxValidator"></a><h5>4.1.4. PhoneAndFaxValidator</h5>
Der <strong>PhoneAndFaxValidator</strong> pr&uuml;ft, ob ein Formular-Feld eine g&uuml;ltige Telefon-
oder Fax-Nummer enth&auml;lt. Hierzu wird der Inhalt des Text-Feldes gegen einen regul&auml;ren Ausdruck
gepr&uuml;ft.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="phone" /&gt;
   &lt;form:text name="fax" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="PhoneAndFaxValidator"
      button="send"
      control="phone|fax"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-5-FieldCompareValidator"></a><h5>4.1.5. FieldCompareValidator</h5>
Mit dem <strong>FieldCompareValidator</strong> ist es m&ouml;glich, den Inhalt zweiter Felder mit
einander zu vergleichen. Stimmen sie nicht &uuml;berein, werden die beiden Felder auf <em>invalid</em>
gesetzt.
<br />
<br />
Da ein Validator immer auf ein konkretes Control gesetzt wird, muss das Haupt-Feld definieren,
welches Formular-Element als Referenz-Feld genutzt wird. Hierzu definiert dieses das Attribut
<strong>ref</strong>, das den Namen des Referenz-Feldes enth&auml;lt.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:password name="pass" ref="pass2" /&gt;
   &lt;form:password name="pass2" /&gt;
   &lt;form:addvalidator
      class="FieldCompareValidator"
      control="pass"
      button="login"
   /&gt;
   &lt;form:button name="login" value="login" /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-6-FolderValidator"></a><h5>4.1.6. FolderValidator</h5>
Der <strong>FolderValidator</strong> geh&ouml;rt ebenso zur Klasse der Text-Feld-Validatoren. Er pr&uuml;ft,
ob ein Text-Feld einen korrekten Ordner-Pfad enth&auml;lt.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="rootfolder" /&gt;
   &lt;form:text name="fax" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="FolderValidator"
      button="send"
      control="rootfolder"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-7-SimpleBirthdayValidator"></a><h5>4.1.7. SimpleBirthdayValidator</h5>
Der <strong>SimpleBirthdayValidator</strong> pr&uuml;ft ein Text-Feld auf ein korrektes Datum der Form
<strong>dd.MM.YYYY</strong>.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="birthday" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleBirthdayValidator"
      button="send"
      control="birthday"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-8-DefaultSelectFieldValidator"></a><h5>4.1.8. DefaultSelectFieldValidator</h5>
Der <strong>DefaultSelectFieldValidator</strong> pr&uuml;ft ein Select-Feld, ob der ausgew&auml;hlte Inhalt
nicht leer ist. Dieser kann nur bei statisch definierten Select-Feldern genutzt werden. F&uuml;r
dynamische Formulare ist der <strong>SimpleSelectControlValidator</strong> besser geeignet.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:select name="color"&gt;
      &lt;select:option value=""&gt;&lt;/select:option&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:select&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="DefaultSelectFieldValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-9-SimpleSelectControlValidator"></a><h5>4.1.9. SimpleSelectControlValidator</h5>
Der <strong>SimpleSelectControlValidator</strong> ist f&uuml;r die Pr&uuml;fung von statischen und
dynanischen Select-Formular-Feldern geeignet. Er pr&uuml;ft ein Select-Feld, ob der ausgew&auml;hlte Inhalt
nicht leer ist.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:select name="color"&gt;
      &lt;select:option value=""&gt;&lt;/select:option&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:select&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleSelectControlValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-10-MultiSelectFieldValidator"></a><h5>4.1.10. MultiSelectFieldValidator</h5>
Der <strong>MultiSelectFieldValidator</strong> ist das Pendant zum
<strong>SimpleSelectControlValidator</strong>. Er pr&uuml;ft Multi-Select-Felder auf eine nicht leere
Auswahl.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:multiselect name="colors"&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:multiselect&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="MultiSelectFieldValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-11-SimpleRadioControlValidator"></a><h5>4.1.11. SimpleRadioControlValidator</h5>
Mit dem <strong>SimpleRadioControlValidator</strong> kann ein Radio-Button, bzw. eine ganze Gruppe
validiert werden. Anforderung des Validators ist, das eine Option der Gruppe ausgew&auml;hlt ist. Der
Validator ist sowohl f&uuml;r dynamische als auch f&uuml;r statische Formular-Definitionen geeignet.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:radio id="red" name="color" /&gt; Red color
   &lt;form:radio id="green" name="color" /&gt; Green color
   &lt;form:radio id="blue" name="color" /&gt; Blue color
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleRadioControlValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-1-11-SimpleDateControlValidator"></a><h5>4.1.11. SimpleDateControlValidator</h5>
Der <strong>SimpleDateControlValidator</strong> validiert ein Date-Control (siehe Kapitel 3.14.).
Er erwartet, dass das dort ausgew&auml;hlte Datum gr&ouml;&szlig;er als das heutige ist.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:date name="birthday" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleDateControlValidator"
      button="send"
      control="birthday"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-2-Aufbau-von-Validatoren"></a><h4>4.2. Aufbau von Validatoren</h4>
Validatoren sind Klassen, die von <strong>AbstractFormValidator</strong> erben. Diese definiert das
Interface aller Formular-Validatoren. Das ist notwendig, damit diese als Observer an alle
Formular-Elemente geheftet werden k&ouml;nnen.
<br />
<br />
Das Interface eines Validators hat folgende gestalt:
<php:highlight>
abstract class AbstractFormValidator extends coreObject {

   protected $__Control;
   protected $__Button;

   public function AbstractFormValidator(form_control &$control,form_control &$button){
      $this->__Control = &$control;
      $this->__Button = &$button;
   }

   public abstract function validate($input);

   public abstract function notify();

   public function isActive(){
      return $this->__Button->isSent();
   }

}
</php:highlight>
&Uuml;ber den Konstruktor werden das zu validierende Form-Control und der Button, der als Trigger
fungiert injiziert. Die Methode <strong>validate()</strong> wird vom Formular-Element mit dem zu
validierenden Inhalt versorgt und muss den Validierungs-Code enthalten. Als R&uuml;ckgabe wird
<em>true</em> im Erfolgsfall und <em>false</em> im Fehlerfall erwartet.
<br />
<br />
Die Methode <strong>notify()</strong> wird aufgerufen, wenn ein Formular-Element nicht erfolgreich
validiert werden konnte. Dieses kann dazu dienen, die Formular-Elemente mit weiteren
CSS-Formatierungen zu versehen, Platzhalter zu f&uuml;llen oder &Auml;nderungen am DOM-Baum vorzunehmen.
Die &uuml;bliche Vorgehensweise ist, das Feld entsprechen zu markieren und die registrierten Listener
zu benachrichtigen.
<br />
<br />
Die Klassen-Variablen <strong>$__Control</strong> und <strong>$__Button</strong> enthalten jeweils
die Instanz des zu validieren Formular-Elements und den Button, der als Trigger verwendet wird.
<br />
<br />
Voraussetzung f&uuml;r die Funktion von Validatoren ist, dass ein Formular-Element die Validierung
unterst&uuml;tzt. Hierzu muss in jedem Formular-Control die Methode <strong>addValidator()</strong>
implementiert sein. Diese in der Klasse <strong>form_control</strong> definierte Methode hat
folgende Signatur:
<php:highlight>
public function addValidator(AbstractFormValidator &$validator){
   if($validator->isActive()){
      if(!$validator->validate($this->getAttribute('value'))){
         $validator->notify();
      }
   }
}
</php:highlight>
Wie im Code-Snippet zu sehen ist, nimmt die Methode eine Instanz eines Validators entgegen, f&uuml;hrt
diesen - falls als aktiv gekennzeichnet - aus und involviert die <strong>notify()</strong>-Methode
bei nicht erfolgreicher Validierung.
<br />
<br />
Wie ebenfalls zu erkennen ist, wird dem Validator <em>by default</em> das Tag-Attribut
<strong>value</strong> &uuml;bergeben, was nur f&uuml;r Text-Felder g&uuml;ltig ist. Aus diesem Grund
&uuml;berschreiben Nicht-Text-Felder diese Methode und &uuml;bergeben dem Validator den relevanten
Inhalt.
<br />
<br />
<br />
<a name="4-3-Implementierung-von-Validatoren"></a><h4>4.3. Implementierung von Validatoren</h4>
Wie bereits im letzten Kapitel angesprochen, muss ein Validator von der Klasse
<strong>AbstractFormValidator</strong> erben. Das APF enth&auml;lt daneben noch einige weitere
Basis-Klassen, die f&uuml;r die Implementierung von Validatoren verwendet werden k&ouml;nnen. Diese sind:
<ul>
   <li><strong>TextFieldValidator:</strong> Basis f&uuml;r alle Text-Feld Validatoren</li>
   <li><strong>SelectFieldValidator:</strong> Basis f&uuml;r alle Select-Feld Validatoren</li>
</ul>
Diese sehen bereits vor, welche &Auml;nderungen am Formular-Element im Fehlerfall vorgenommen werden
und welche Listener zu benachrichtigen sind.
<br />
<br />
F&uuml;r die Implementierung eines eigenen Validators muss folgendes beachtet werden:
<ul>
   <li>Der Validator muss von von der Klasse <strong>AbstractFormValidator</strong> erben.</li>
   <li>
      Mit Hilfe der Methode <strong>markAsInvalid()</strong> kann ein Formular-Element als
      invalide gekennzeichnet werden.
   </li>
   <li>
      Mit Hilfe der Methode <strong>notifyValidationListeners()</strong> k&ouml;nnen die Listener eines
      Elements benachrichtigt werden.
   </li>
   <li>
      &Uuml;ber den Button (Methode: <strong>isSent()</strong>)kann der Entwickler abfragen, ob das
      Formular mit Klick auf diesen abgesendet wurde.
   </li>
</ul>
<br />
<a name="5-Filter"></a><h3>5. Filter</h3>
In den bisherigen Versionen des APF wurde die Filterung von Formular-Element-Werten ebenfalls direkt
mit einem Formular-Element verkn&uuml;pft und im
<a href="./?Seite=098-Pagecontroller#2-1-Ablaufdiagramm" title="Taglib-Lifecycle des Page-Controllers">Lifecycle einer Taglib</a>
ausgef&uuml;hrt. Hieraus ergeben sich &auml;hnliche Nachteile wie es bei der Validierung der Fall ist.
Deshalb wurde auch die Filterung in der Version 1.11 nach dem Konzept der Validierung angepasst.
Ab Version 1.11 k&ouml;nnen Filter gleicherma&szlig;en als Observer auf ein Formular-Element angewendet
werden.
<br />
<br />
<div class="hint">
   Die Filterung von Formular-Felder wird <strong>vor</strong> der Validierung ausgef&uuml;hrt um zu
   verhindern, dass Eingaben, die durch einen Filter entfernt werden, eine positive Validierung
   erzeugen. Dies ist insbesondere beim <strong>TextLengthValidator</strong> relevant.
</div>
<br />
Die Definition der Filterung eines Formular-Feldes gestaltet sich dabei wie folgt:
<code:highlight>
&lt;form:addfilter
   namespace=""
   class=""
   button=""
   control=""
/&gt;
</code:highlight>
<strong>Description of the attributes:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Namespace der Filter-Implementierung.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>class</strong>: Name der Filter-Implementierung (Name = Klassen-Name!)
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>button</strong>: Name des Buttons, der die Filterung ausl&ouml;sen soll. Die Filterung
    ist immer an das Event <em>isSent</em> eines Buttons oder Image-Buttons gebunden.
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>control</strong>: Name des Formular-Controls auf das die Filterung Anwendung finden
    soll. Sollen mehrere Controls mit der im Tag definierten Filterung belegt werden, so enth&auml;lt
    das Attribut alle mit Pipe getrennte Feld-Namen (z.B. <em>sender|recipient|subject</em>).
    (<strong>Allowed characters</strong>: <code>[A-Za-z0-9-_|]</code>)
  </li>
</ul>
<div class="hint">
   F&uuml;r mitgelieferte Filter muss das Attribut <strong>namespace</strong> nicht definiert
   werden. Hier verwendet die Taglib automatisch <strong>tools::form::filter</strong> als Wert.
   Unter diesem Namespace finden sich alle enthaltenen Filter, die im Kapitel 1.1. aufgef&uuml;hrt
   sind.
</div>
<br />
<br />
<a name="5-1-Verfuegbare-Filter"></a><h4>5.1. Verf&uuml;gbare Filter</h4>
Wie auch in den Releases < 1.11 werden eine Reihe von Filter mitgeliefert. Diese decken
&uuml;blicherweise den Gro&szlig;teil der Anforderungen ab. Sollten diese nicht gen&uuml;gen, k&ouml;nnen
eigene Filter implementiert werden. Dies ist im n&auml;chsten Kapitel beschrieben.
<br />
<br />
Aktuell sind folgende Filter im Release verf&uuml;gbar:
<br />
<br />
<br />
<a name="5-1-1-EMailFilter"></a><h5>5.1.1. EMailFilter</h5>
Der <strong>EMailFilter</strong> entfernt alle Zeichen, die f&uuml;r eine E-Mail-Adresse nicht relevant
sind.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="EMailFilter"
      button="send"
      control="email"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-2-NoSpecialCharactersFilter"></a><h5>5.1.2. NoSpecialCharactersFilter</h5>
Der <strong>NoSpecialCharactersFilter</strong> filtert alle Zeichen, die nicht dem regul&auml;ren
Ausdruck <strong>[^0-9A-Za-z-_\.& ]</strong> gen&uuml;gen.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="simplechars" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="NoSpecialCharactersFilter"
      button="send"
      control="simplechars"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-3-OnlyHTMLEntitiesFilter"></a><h5>5.1.3. OnlyHTMLEntitiesFilter</h5>
Mit dem <strong>OnlyHTMLEntitiesFilter</strong> kann erreicht werden, dass Sonderzeichen in ihre
HTML Entity Entsprechungen umgewandelt werden. Hierbei muss jedoch beachtet werden, dass bei
mehrmaligem Abschicken, Mehrfach-Codierungen m&ouml;glich sind.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="htmlentitiestext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyHTMLEntitiesFilter"
      button="send"
      control="htmlentitiestext"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-4-OnlyIntegersFilter"></a><h5>5.1.4. OnlyIntegersFilter</h5>
Der <strong>OnlyIntegersFilter</strong> l&auml;sst nur Ziffern zu und filtert alle anderen Zeichen.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="zipcode" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyIntegersFilter"
      button="send"
      control="zipcode"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-5-OnlyLettersFilter"></a><h5>5.1.5. OnlyLettersFilter</h5>
Mit dem <strong>OnlyLettersFilter</strong> werden nur Standard-Zeichen des Alphabets zugelassen.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="productcode" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyLettersFilter"
      button="send"
      control="productcode"
   /&gt;
&lt;/html:form&gt;
</code:highlight>

<br />
<a name="5-1-6-OnlyNumbersFilter"></a><h5>5.1.6. OnlyNumbersFilter</h5>
Der <strong>OnlyNumbersFilter</strong> l&auml;sst nur Ziffern und Interpunktionen zu, die f&uuml;r die
Trennung von 1000er Bl&ouml;cken und Nachkommastellen notwendig sind.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:text name="productprice" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyNumbersFilter"
      button="send"
      control="productprice"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-7-SpecialCharacterFilter"></a><h5>5.1.7. SpecialCharacterFilter</h5>
Mit dem <strong>SpecialCharacterFilter</strong> werden nur Zeichen zugelassen, die im normalen
Satzbau notwendig sind.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:area name="simpletext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="SpecialCharacterFilter"
      button="send"
      control="simpletext"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-8-String2LowerFilter"></a><h5>5.1.8. String2LowerFilter</h5>
Der <strong>String2LowerFilter</strong> wandelt alle Buchstaben in Klein-Buchstaben um.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:area name="lowertext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="String2LowerFilter"
      button="send"
      control="lowertext"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-9-String2UpperFilter"></a><h5>5.1.9. String2UpperFilter</h5>
Der <strong>String2UpperFilter</strong> wandelt alle Buchstaben in Gro&szlig;-Buchstaben um.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:area name="uppertext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="String2LowerFilter"
      button="send"
      control="uppertext"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-1-10-StripTagsFilter"></a><h5>5.1.10. StripTagsFilter</h5>
Mit dem <strong>StripTagsFilter</strong> werden alle HTML- und PHP-Code-Fragmente aus dem Text
entfernt. Dieser eignet sich gut f&uuml;r Felder, in denen viel Freitext eingegeben werden kann.
<code:highlight>
&lt;html:form name="..."&gt;
   &lt;form:area name="notagstext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="StripTagsFilter"
      button="send"
      control="notagstext"
   /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-2-Aufbau-von-Filtern"></a><h4>5.2. Aufbau von Filtern</h4>
Formular-Filter sind eine Spezialisierung der APF-Filter-API, die im Kapitel
<a href="./?Seite=087-Filter#4-Aufbau-und-Funktion" title="Aufbau und Funktion von Filtern">Aufbau und Funktion von Filtern</a>
n&auml;her beschrieben ist. Als Interface steht die abstrakte Klasse <strong>AbstractFormFilter</strong>
zur Verf&uuml;gung, die alle konkreten Formular-Filter implementieren m&uuml;ssen.
<br />
<br />
&Auml;hnlich den im Kapitel 4.2 beschrieben Formular-Validatoren, m&uuml;ssen Formular-Validatoren einige
Formular-spezifische Methoden implementieren. Die Klasse <strong>AbstractFormFilter</strong> hat
folgenden Aufbau:
<php:highlight>
abstract class AbstractFormFilter extends AbstractFilter {

   protected $__Control;
   protected $__Button;

   public function AbstractFormFilter(form_control &$control,form_control &$button){
      $this->__Control = &$control;
      $this->__Button = &$button;
   }

   public function isActive(){
      return $this->__Button->isSent();
   }

}
</php:highlight>
&Uuml;ber den Konstruktor werden das zu filternde Form-Control und der Button, der als Trigger
fungiert injiziert. Die Methode <strong>filter()</strong> wird vom Formular-Element mit dem zu
filternden Inhalt versorgt und muss den Filter-Code enthalten. Als R&uuml;ckgabe wird der gefilterte
Wert erwartet.
<br />
<br />
Die Methode <strong>isActive()</strong> dienen dazu, dem Filter zu fragen, ob er ausgef&uuml;hrt werden
darf.
<br />
<br />
Die Klassen-Variablen <strong>$__Control</strong> und <strong>$__Button</strong> enthalten jeweils
die Instanz des zu validieren Formular-Elements und den Button, der als Trigger verwendet wird.
<br />
<br />
Voraussetzung f&uuml;r die Funktion von Filtern ist, dass ein Formular-Element dies unterst&uuml;tzt.
Hierzu muss in jedem Formular-Control die Methode <strong>addFilter()</strong>
implementiert sein. Diese in der Klasse <strong>form_control</strong> definierte Methode hat
folgende Signatur:
<php:highlight>
public function addFilter(AbstractFormFilter &$filter){
   if($filter->isActive()){
      $value = $this->getAttribute('value');
      $filteredValue = $filter->filter($value);
      $this->setAttribute('value',$filteredValue);
   }
}
</php:highlight>
Wie im Code-Snippet zu sehen ist, nimmt die Methode eine Instanz eines Filters entgegen, f&uuml;hrt
diesen - falls als aktiv gekennzeichnet - aus.
<br />
<br />
Wie ebenfalls zu erkennen ist, wird dem Filter <em>by default</em> das Tag-Attribut
<strong>value</strong> &uuml;bergeben, was nur f&uuml;r Text-Felder g&uuml;ltig ist. Aus diesem Grund
&uuml;berschreiben Nicht-Text-Felder diese Methode und &uuml;bergeben dem Filter den relevanten
Inhalt.
<br />
<br />
<div class="hint">
   Filter finden &uuml;blicherweise nur bei Text-Feldern Anwendung. F&uuml;r Felder mit komplexeren
   Datenstrukturen kann es Sinn machen einen Filter zu schreiben, im Fall der Select-Felder ist es
   jedoch f&uuml;r die Sicherheit nicht von Bedeutung. Aus diesem Grund liefert das APF f&uuml;r Select-Felder
   keine Filter mit.
</div>
<br />
<br />
<a name="5-3-Implementierung-von-Filtern"></a><h4>5.3. Implementierung von Filtern</h4>
Wie bereits im letzten Kapitel angesprochen, muss ein Filter von der Klasse
<strong>AbstractFormFilter</strong> erben.
<br />
<br />
F&uuml;r die Implementierung eines eigenen Filters muss folgendes beachtet werden:
<ul>
   <li>Der Filter muss von von der Klasse <strong>AbstractFormFilter</strong> erben.</li>
   <li>
      &Uuml;ber den Button (Methode: <strong>isSent()</strong>) kann der Entwickler abfragen, ob das
      Formular mit Klick auf diesen abgesendet wurde.
   </li>
   <li>
      Die Methode <strong>isActive()</strong> kann &uuml;blicherweise von
      <strong>AbstractFormFilter</strong> &uuml;bernommen werden.
   </li>
</ul>
<div class="hint">
   Auf Grund der Besonderheit, dass mit PHP >=5.2.10, bzw. >=5.3.0 die Signaturen von
   &uuml;berschriebenen abstrakten Methoden Zeichen-identisch sein m&uuml;ssen, muss darauf geachtet werden,
   dass die Funktion <em>public function filter($input)</em> in der Filter-Imp&uuml;lementierung exakt so
   definiert wurde!
</div>
<br />
<br />
<a name="6-Verwendung-von-Formularen"></a><h3>6. Verwendung von Formularen</h3>
Die Verwendung von Formularen und die Verarbeitung mit Hilfe von Document Controllern ist im Kapitel
<a href="./?Page=114-Form-usage" title="Usage of forms">usage of forms</a>
n&auml;her bescchrieben. Diese Seite soll lediglich als Referenz f&uuml;r die vorhandenen Taglibs
und die Implementierung von Validatoren und Filtern dienen. Weiter wird auf die Erstellung von
dynamischen Formularen eingegangen.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_113" />