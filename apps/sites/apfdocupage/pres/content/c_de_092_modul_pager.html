<doku:title tags="dokumentation,module,captcha,gaestebuch,pager,kommentar,social bookmarking,usermanagement" title="Module - Pager" urlname="Module-Pager">
  Der Pager ist eine Komponente, die zur Ausgabe-Steuerung von Datenbank-Eintr&auml;gen verwendet
  werden kann. Diese findet bereits in den Modulen Kommentar-Funktion und G&auml;stebuch Anwendung.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
Der Pager ist eine Komponente, die zur Ausgabe-Steuerung von Datenbank-Eintr&auml;gen verwendet werden
kann. Diese findet bereits in den Modulen <em>Kommentar-Funktion</em> und <em>G&auml;stebuch</em>
Anwendung. Auf dieser Seite wird der Aufbau des Moduls und die Verwendung n&auml;her erl&auml;utert.
<br />
<br />
<br />
<a name="1-Aufbau"></a><h3>1. Aufbau</h3>
Der Pager besteht im wesentlichen aus einer Business-Komponente (<strong>PagerManager</strong>), der
Ausgabe-Komponente f&uuml;r die Pager-HTML-Darstellung (DocumentController
<strong>pager_v1_controller</strong> oder <strong>pager_2_v1_controller</strong>) und einer
Daten-Schicht, die die f&uuml;r den Betrieb des Managers notwendigen Informationen aus der Datenbank
liest. Um einen Pager verwenden zu k&ouml;nnen muss dieser zun&auml;chst initialisiert und mit den
richtigen Parametern versorgt werden. Diese Arbeit wird durch die <strong>PagerManagerFabric</strong>
erledigt.
<br />
<br />
<br />
<a name="2-Konfiguration"></a><h3>2. Konfiguration</h3>
Um den PagerManager zum Laden der f&uuml;r eine Seite relevanten Eintr&auml;ge nutzen zu k&ouml;nnen,
muss dieser zun&auml;chst konfiguriert werden. Dazu sind im Wesentlichen eine Konfigurationsdatei und
zwei Statementment-Dateien notwenig. Die Konfigurationsdatei umfasst folgende Parameter:
<code:highlight>
[&lt;Abschnittsname&gt;]
Pager.DatabaseConnection = "&lt;ConnectionKey&gt;"

Pager.EntriesPerPage = "&lt;Anzahl&gt;"

Pager.ParameterStartName = "&lt;URL-Parameter&gt;"
Pager.ParameterCountName = "&lt;URL-Parameter&gt;"

Pager.StatementNamespace = "&lt;Statement-Namespace&gt;"
Pager.CountStatement = "&lt;Load-Entries-Count-Statement&gt;"
Pager.CountStatement.Params = "&lt;Statement-Parameter&gt;"
Pager.EntriesStatement = "&lt;Statement-Parameter&gt;"
Pager.EntriesStatement.Params = "&lt;Load-Entry-Statement&gt;"

Pager.DesignNamespace = "&lt;Ausgabe-Template-Namespace&gt;"
Pager.DesignTemplate = "&lt;Ausgabe-Template-Name&gt;"

Pager.CacheInSession = "true|false"
</code:highlight>
In den beiden Statements werden jeweils definierte Statement-Parameter erwartet, damit der Pager
arbeiten kann. Innerhalb des <em>Load-Entries-Count-Statements</em> k&ouml;nnen beliebiger Parameter
eingesetzt werden um das Ergebnis einzuschr&auml;nken. Diese m&uuml;ssen aber entweder in der
Konfiguration unter <strong>Pager.CountStatement.Params</strong> oder beim Laden von Eintr&auml;gen
&uuml;bergeben werden. Das Ergebnis wird im Offset <strong>EntriesCount</strong> erwartet (Aliasing
erforderlich!). Das Statement sollte daher wie folgt aufgebaut sein
<code:highlight>
  SELECT COUNT(Spalte) AS EntriesCount ...
</code:highlight>
Im <em>Load-Entry-Statement</em> muss immer eine LIMIT-Klausel der Form
<code:highlight>
  LIMIT [Start],[EntriesCount]
</code:highlight>
aufgef&uuml;hrt sein. Weiterhin erwartet der Pager auch hier das Ergebnis (ID des Datensatzes) in
einem Offset <strong>DB_ID</strong>. Das bedeutet, dass auch in diesem Fall mit einem Alias gearbeitet
werden muss:
<code:highlight>
  SELECT &lt;Spalte&gt; AS DB_ID ...
</code:highlight>
gearbeitet werden. Weitere Parameter k&ouml;nnen entweder in der Konfiguration unter
<strong>Pager.EntriesStatement.Params</strong> oder beim Laden von Eintr&auml;gen an den Pager
&uuml;bergeben werden.
<br />
<br />
Die Parameter k&ouml;nnen in der Form
<code:highlight>
param1:value1|param2:value2|...
</code:highlight>
definiert werden.
<br />
<br />
<strong>Hinweise:</strong>
<ul>
  <li>
    Beim Initialisieren der Konfigurationsparameter wird versucht, die Parameter mit Werten aus der
    URL zu f&uuml;llen. Dies bietet die M&ouml;glichkeit, die Parameter dynamisch per URL
    zus&auml;tzlich zu manipulieren. Ist die nicht gew&uuml;nscht, so muss daf&uuml;r Sorge getragen
    werden, dass die Parameter nicht in der URL auftauchen. In den Statements k&ouml;nnen diese dann
    wie die &uuml;brigen Platzhalter eingebaut werden.
    <br />
    <br />
  </li>
  <li>
    Mit der Option <strong>Pager.CacheInSession</strong> wird definiert, ob die Anzahl der Eintr&auml;ge
    eines Objektes in der Datenbank und die IDs der jeweiligen Seite in einer Session gecached werden
    sollen. Ist die Option mit <em>true</em> belegt, wird dies in der Datenschicht des Pagers
    zwischengespeichert und beh&auml;lt so lange G&uuml;ltigkeit, wie die Session besteht.
  </li>
</ul>
<br />
<a name="3-Anwendungsbeispiel"></a><h3>4.3. Anwendungsbeispiel</h3>
Ein ausf&uuml;hrliches Anwendungsbeispiele findet sich im Kapitel
<a href="./?Seite=032-Kommentarfunktion#4-3-Datenschicht" title="Kommentar-Funktion - 4.3. Datenschicht">Datenschicht</a>
des Kommentar-Funktion-Tutorials. Dabei wird die
<a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API</a> des PagerManagers wie
folgt verwendet:
<br />
<br />
<h4>3.1. Laden der relevanten IDs:</h4>
<php:highlight>
// PagerManager &uuml;ber die Fabric erzeugen
$pMF = &$this->__getServiceObject('modules::pager::biz','PagerManagerFabric');
$pM = &$pMF->getPagerManager('{CONFIG_SECTION}');

// IDs laden
$IDs = $pM->loadEntries(array('AddParams' => 'Value'));

// Daten-Schicht-Komponente erzeugen und Objekt per ID laden
$M = &$this->__getServiceObject('namespace::to::data::component','DataMapper');

$list = array();
for($i = 0; $i < count($IDs); $i++){
   $list[] = $M->loadDomainObjectByID($IDs[$i]);
 // end for
}
</php:highlight>
<br />
<h4>3.2. Direktes Laden der Business-Objekte:</h4>
<php:highlight>
// PagerManager &uuml;ber die Fabric erzeugen
$pMF = &$this->__getServiceObject('modules::pager::biz','PagerManagerFabric');
$pM = &$pMF->getPagerManager('{CONFIG_SECTION}');

// Daten mit Hilfe einer Datenschicht-Komponente direkt laden
$M = &$this->__getServiceObject('namespace::to::data::component','DataMapper');
$list = $pM->loadEntriesByAppDataComponent($M,'loadDomainObjectByID',array('AddParams' => 'Value'));
</php:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_092" />