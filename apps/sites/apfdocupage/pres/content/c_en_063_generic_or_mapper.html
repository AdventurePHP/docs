<doku:title tags="object,relational,mapping,or,mapper,generic,relations,objects,object tree,object structures,configuration,usage" title="Generic OR mapper" urlname="Generic-OR-mapper">
  The genericormapper module provides a generic data mapper, that is fully integrated into the APF.
  It enables the developer to dynamically handle objects and their reations, that are defined within
  configuration files.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<a name="1-Introduction"></a><h3>1. Introduction</h3>
Designing object oriented applications, you typically claim, that the complete design can be created
on OO style - without break of media. In order to achieve this goal, each developer was yet faced
with the problem of data storage in relation databases. If there is no tool, a <em>DataMapper</em>
has to be implemented newly for each application. This does not only result in higher costs and lack
of time, but is also not compatible with the <strong>DRY</strong> (<em>don't repeat yourself</em>)
paradigma. You still are forced to produce redundant code.
<br />
<br />
The APF module <strong>genericormapper</strong> now provides an abstraction layer, that is intended
to do most of the work a data mapper has to do. The functionality thereby can
<ul>
  <li>manage objects,</li>
  <li>manage relations between objects (compositions and assoziations) and</li>
  <li>features CRUD functionality for objects and object structures (aka. trees).</li>
</ul>
For this tasks, the API features a couple of methods, that support loading, manipulation and deletion
of objects within the database. The generic domain object (<strong>GenericDomainObject</strong>)
returned by the API functions can on the one hand be used directly within your applications or your
application features a simple data layer, that mapps the data mapper domain objects into your
application's domain objects and vice versa.
<br />
<br />
The following chapters show how the OR mapper has to be configured and how you can use it. The
module <strong>usermanagement</strong> shipped with the APF release is completely based on the
GenericORMapper and thus can be used as an extended implementation example. Details on the module
can be seen on the
<a href="./?Page=095-Modul-usermanagement" title="Usermanagement">usermanagement page</a>.
<br />
<br />
<br />
<a name="2-Configuration"></a><h3>2. Configuration of the OR mapper</h3>
<br />
<a name="2-1-Basics"></a><h4>2.1. Basics</h4>
To be able to user the OR mapper, two configuration files must be present:
<ul>
  <li>{ENVIRONMENT}_{NAMEAFFIX}_objects.ini</li>
  <li>{ENVIRONMENT}_{NAMEAFFIX}_relations.ini</li>
</ul>
The first file defines the objects and attributes, the second one is intended to define the relations
between the objects from the first file. Due to the fact, that the <strong>GenericORRelationMapper</strong>
uses the <a href="./?Page=031-Class-reference-table-connectionManager" title="Class reference table - connectionManager">connectionManager</a>
for database access, a database connection configuration must be created if not done yet.
<br />
<br />
The <strong>{ENVIRONMENT}</strong> part of the configuration file names is taken from the registry
directive <strong>Environment</strong> from the <strong>apf::core</strong> namespace. The
<strong>{NAMEAFFIX}</strong> can be defined freely by the developer. This part of the name is inteded
to provide the possibility of different mapper configurations for one context and one environment.
This enables you to create applications, that are able to use multiple data sources.
<br />
<br />
<br />
<a name="2-2-Configuration-examples"></a><h4>2.2. Configuration examples</h4>
Imagine, that a developer wants to create a guestbook. The source code files are located in the
<strong>modules::myguestbook</strong> namespace and the guestbook's data layer should us the OR mapper.
Further, the registry value <strong>Environment</strong> is not touched (so it is still the default
value) and the current application context is <strong>sites::mysite</strong>. Moreover, he decides,
that the name affix should be identical to <strong>guestbook</strong>. In this case, the object
configuration file must be named
<pre class="tagexample">
DEFAULT_guestbook_objects.ini
</pre>
and the relation configuration file
<pre class="tagexample">
DEFAULT_guestbook_relations.ini
</pre>
These must reside within the folder
<pre class="tagexample">
/apps/config/modules/myguestbook/sites/mysite
</pre>
Further details on configuration, namespaces and contexts can be taken from the
<a href="./?Page=033-Configuration#2-Naming-conventions" title="Configuration">configuration section</a>.
<br />
<br />
<br />
<a name="2-3-Object-and-relation-definition"></a><h4>2.3. Object and relation definition</h4>
The way of object and relation definition is described in the next two chapters:
<br />
<br />
<a name="2-3-1-Object-definition"></a><h5>2.3.1. Object definition</h5>
The <strong>GenericORRelationMapper</strong> provides a generic domain object (<strong>GenericDomainObject</strong>)
that represents a persistence object. The type of the concrete object is classified by the domain
object's <strong>ObjectName</strong> property.
<br />
<br />
The object definition thus contains the name of the object (=name of the section) and the attributes
(=properties of the <strong>GenericDomainObject</strong> class). The following codebox shows a
typical object configuration:
<pre class="tagexample">
[Application]
DisplayName = "VARCHAR(100)"

[User]
DisplayName = "VARCHAR(100)"
FirstName = "VARCHAR(100)"
LastName = "VARCHAR(100)"
EMail = "VARCHAR(100)"
Username = "VARCHAR(100)"
Password = "VARCHAR(100)"

[Group]
DisplayName = "VARCHAR(100)"

[Role]
DisplayName = "VARCHAR(100)"
</pre>
The values of the attributes represent the database data types of the object's properties. The
mapper knows the following values and translates them into the right create table statements:
<ul>
  <li>VARCHAR(<strong>{LENGTH}</strong>)</li>
  <li>TEXT</li>
  <li>DATE</li>
</ul>
The <strong>{LENGTH}</strong> place holder must be replaced by any number. All other values are
directly used for the data type of a property. These must be valid data type definitions. Otherwise,
the <em>CREATE TABLE</em> statements will fail. The values presented above should be suitable for
most application cases.
<br />
<br />
The attributes of a domain object can then be addressed as follows:
<php:highlight testing="true">
...
$User = new GenericDomainObject('User');
$User->setProperty('FirstName','Christian');
$User->setProperty('LastName','Achatz');
...
echo 'Surename: '.$User->getProperty('FirstName');
echo 'Name: '.$User->getProperty('LastName');
...
</php:highlight>
<br />
<a name="2-3-2-Relation-definition"></a><h5>2.3.2. Relation definition</h5>
The file <strong>*_relations.ini</strong> defines the relations between the objects defined in the
previous chapter. The mapper knows two types of relations: compositions and associations. Due to the
fact, that compositions are strong relations, objects, that compose other objects, cannot be deleted
due to data consistency. This case is checked by the mapper and it throws an error, if a object
is tried to be deleted, that must not.
<br />
<br />
<strong>Note:</strong>
The persistancy theory contains the rule, that each object should be composed exactly one time. This
is because an object cannot have more than one strong binding to another object in real life, too.
Futhermore, a composition relation defines the object's right to exist. Hence, be aware that your
objects are composed concerning this rule. For example, a guestbook entry cannot exist without the
guestbook object. Instead, a user can exist without the guestbook. This means, that the relation
between a guestbook and an entry must be a composition, the relation of the entry to the user must
be an association.
<br />
<br />
The following codebox shows a typical relation configuration:
<pre class="tagexample">
[Application2Group]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Group"

[Group2User]
Type = "ASSOCIATION"
SourceObject = "Group"
TargetObject = "User"

[Role2User]
Type = "ASSOCIATION"
SourceObject = "Role"
TargetObject = "User"

[Application2User]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "User"

[Application2Role]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Role"
</pre>
Der Sektionsname (z.B. <strong>Group2User</strong>) sollte sprechend gew&auml;lt werden, da dieser
sowohl zum Laden von zu einem Objekt in Beziehung stehenden Objekten als auch f&uuml;r die
Inbeziehungssetzung beim Speichern von Objekten Verwendung findet. Der Typ beinhaltet die Qualit&auml;t
der Beziehung, die Parameter <strong>SourceObject</strong> und <strong>TargetObject</strong> sind
eine Referenz auf die Sektion der Objektdefinition.
<br />
<br />
<strong>Hinweise:</strong>
<ul>
  <li>
    Die Anzahl der Beziehungsdefinitionen ist nicht limitiert, die Definitionen sollten jedoch den
    Anforderungen der Applikation gerecht werden. Hierbei gilt die Daumenregel, dass bei mehrmaliger
    und gleichbedeutender Verwendung eines Attributs eines Objekts dieses in ein eigenes Objekt
    ausgelagert und das jeweilige Objekt in Beziehung (Assoziation) zu diesem gesetz werden soll.
    Typisches Beispiel ist die Sprache eines Objekts.
  </li>
  <li>
    Wurde mit Hilfe der Methode <strong>addRelatedObject()</strong> ein Objektbaum aufgebaut, so
    k&ouml;nnen die in Beziehung stehenden Objekte mit der Methode <strong>getRelatedObjects()</strong>
    aus dem <strong>GenericDomainObject</strong> ausgelesen und ggf. weiterverarbeitet oder manipuliert
    werden.
  </li>
</ul>
<br />
<a name="3-Datenbank-Setup"></a><h3>3. Setup der Datenbank</h3>
Nachdem die Konfigurationsdateien fertiggestellt sind, muss die Datenbank f&uuml;r die Verwendung
vorkonfiguriert werden. Dies kann manuell oder automatisiert vorgenommen passieren. Die manuelle
Variante kann unter
<a href="./?Seite=064-Generischer-OR-Mapper-Manuelles-Setup-der-Datenbank" title="Generischer OR-Mapper - Manuelles Setup der Datenbank">Manuelles Setup der Datenbank</a>
nachgelesen werden.
<br />
<br />
Das folgende Skript zeigt, wie das Datenbank-Setup mit Hilfe des <strong>GenericORMapperSetup</strong>-Tools
das Layout der Tabellen automatisiert erstellt werden kann. Eine Vorlage f&uuml;r dieses Skript
befindet sich zudem im Ordner <em>/apps/modules/genericormapper/data/tools</em> des jeweiligen
<em>adventure-codepack-*</em> Releases und tr&auml;gt den Namen <em>setup.php</em>. Dieses muss
gem&auml;&szlig; den Bemerkungen unterhalb der Codebox f&uuml;r den entstprechenden Anwendungsfall
angepasst werden. Hier das Setup-Skript im &Uuml;berblick:
<php:highlight>
   // PageController einbinden
   require('../../apps/core/pagecontroller/pagecontroller.php');

   // Ggf. Werte der Registry anpassen
   $Reg = &Singleton::getInstance('Registry');
   $Reg->register('apf::core','Environment',{ENVIRONMENT});

   // SetupMapper einbinden
   import('modules::genericormapper::data::tools','GenericORMapperSetup');

   // SetupMapper instanziieren
   $SetupMapper = new GenericORMapperSetup();

   // Context der Applikation bekannt geben (wichtig f&uuml;r die Konfigurationsdateien!)
   $SetupMapper->set('Context',{CONTEXT});

   // Ggf. MySQL Storage-Engine anpassen (Standard is MyISAM)
   $SetupMapper->set('StorageEngine','...');

   // Datenbanklayout erstellen
   $SetupMapper->setupDatabase({CONFIG_NAMESPACE},{CONFIG_NAME_AFFIX},{CONNECTION_NAME});

   // Datenbanklayout lediglich anzeigen
   $SetupMapper->setupDatabase({CONFIG_NAMESPACE},{CONFIG_NAME_AFFIX});
</php:highlight>
Die eingesetzten Platzhalter haben folgende Bedeutung:
<ul>
  <li>
    <strong>{ENVIRONMENT}</strong>: Umgebungsvariable der Applikation. Diese wird bei der Adressierung
    von Konfigurationsdateien verwendet und muss auf den Wert gesetzt werden, der auch in der
    Zielanwendung verwendet wird. Siehe hierzu Kapitel
    <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a>.
    <br />
    <br />
  </li>
  <li>
    <strong>{CONTEXT}</strong>: Context der Applikation. Dieser wird zur Addressierung der
    Konfigurationsdateien verwendet und muss auf den Wert gesetzt werden, der auch in der
    Zielanwendung verwendet wird. Siehe hierzu Kapitel
    <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a>.
    <br />
    <br />
  </li>
  <li>
    <strong>{CONFIG_NAMESPACE}</strong>: Namespace, unter dem die Konfigurationsdateien f&uuml;r den
    OR-Mapper liegen (siehe Kapitel 2.2).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONFIG_NAME_AFFIX}</strong>: Namenszusatz der Konfigurationsdateien (siehe Kapitel 2.1).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONNECTION_NAME}</strong>: Name der Datenbankverbindung, die f&uuml;r das Setup genutzt
    werden soll.
    <br />
    <br />
  </li>
</ul>
Weiterhin ist wichtig, dass die zu initialisierende Datenbank bereits existiert und der in der
Verbindungskonfiguration aufgef&uuml;hrte Benutzer <em>CREATE TABLE</em>-Rechte f&uuml;r diese
besitzt. Wird nach der Ausf&uuml;hrung des Codes kein Fehler angezeigt, wurde das Setup erfolgreich
abgeschlossen. Das Ergebnis kann dann beispielsweise mit phpMyAdmin oder dem MySQLAdmin
&uuml;berpr&uuml;ft werden.
<br />
<br />
Die Ausgabe des obigen Scripts sollte bei erfolgreicher Ausf&uuml;hrung folgendes anzeigen:
<pre class="tagexample">
CREATE TABLE IF NOT EXISTS `ent_application` (
  `ApplicationID` TINYINT(5) NOT NULL auto_increment,
  `DisplayName` VARCHAR(100) character set utf8 NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY (`ApplicationID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `ent_user` (
  `UserID` TINYINT(5) NOT NULL auto_increment,
  `DisplayName` VARCHAR(100) character set utf8 NOT NULL default '',
  `FirstName` VARCHAR(100) character set utf8 NOT NULL default '',
  `LastName` VARCHAR(100) character set utf8 NOT NULL default '',
  `EMail` VARCHAR(100) character set utf8 NOT NULL default '',
  `Username` VARCHAR(100) character set utf8 NOT NULL default '',
  `Password` VARCHAR(100) character set utf8 NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

...

CREATE TABLE IF NOT EXISTS `cmp_application2user` (
  `CMPID` TINYINT(5) NOT NULL auto_increment,
  `ApplicationID` TINYINT(5) NOT NULL default '0',
  `UserID` TINYINT(5) NOT NULL default '0',
  PRIMARY KEY  (`CMPID`),
  KEY `JOININDEX` (`ApplicationID`,`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `cmp_application2role` (
  `CMPID` TINYINT(5) NOT NULL auto_increment,
  `ApplicationID` TINYINT(5) NOT NULL default '0',
  `RoleID` TINYINT(5) NOT NULL default '0',
  PRIMARY KEY  (`CMPID`),
  KEY `JOININDEX` (`ApplicationID`,`RoleID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
</pre>
In phpMyAdmin sollte ungef&auml;hr folgende Ansicht erscheinen:
<br />
<br />
<center><img src="http://media.adventure-php-framework.org/content/ormapper_phpmyadmin.png" border="0" style="width: 560px;"/></center>
<br />
Damit ist die Konfiguration des Mappers abgeschlossen und dieser kann in der Anwendung verwendet
werden. &Auml;nderungen am Datenmodell k&ouml;nnen (noch) nicht automatisiert abgeglichen werden.
Hierzu m&uuml;ssen die Tabellen manuell angepasst werden. Da das Tabellendesign einigen wenigen
Grundregeln folgt, ist dieses jedoch einfach zu bewerkstelligen. Hilfestellungen k&ouml;nnen dem
Kapitel
<a href="./?Seite=064-Generischer-OR-Mapper-Manuelles-Setup-der-Datenbank" title="Generischer OR-Mapper - Manuelles Setup der Datenbank">Manuelles Setup der Datenbank</a>
entnommen werden.
<br />
<br />
<br />
<a name="4-Verwendung"></a><h3>4. Verwendung des OR-Mappers</h3>
Der OR-Mapper, oder genauer die Komponente <strong>GenericORRelationMapper</strong>, bietet eine Reihe
von API-Methoden an, die zur Manipulation von Daten und Beziehungen eingesetzt werden k&ouml;nnen.
Hier ein &Uuml;berblick &uuml;ber die Methoden, deren Parameter und Bedeutung:
<ul>
  <li>
    <strong>loadObjectListByCriterion()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines Kriterien-Objekts.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByCriterion()</strong>:
    L&auml;d ein Objekt an Hand eines Kriterien-Objekts.
    <br />
    <br />
  </li>
  <li>
     <strong>loadRelatedObjects()</strong>:
     L&auml;d eine Liste von Objekten, die mit diesem &uuml;ber eine definierte Beziehung
     verkn&uuml;pft sind.
     <br />
     <br />
  </li>
  <li>
     <strong>loadNotRelatedObjects()</strong>:
     L&auml;d eine Liste von Objekten, die mit diesem &uuml;ber nicht &uuml;ber eine definierte
     Beziehung verkn&uuml;pft sind.
     <br />
     <br />
  </li>
  <li>
     <strong>loadRelationMultiplicity()</strong>:
     L&auml;d die Anzahl der zu einem Objekt verk&uuml;pften Objekte unter Angabe der Beziehungskennung.
     <br />
     <br />
  </li>
  <li>
     <strong>saveObject()</strong>:
     Speichert ein Objekt oder einen Objektbaum, der aus in Beziehung stehenden Domain-Objekten
     besteht.
     <br />
     <br />
  </li>
  <li>
     <strong>deleteObject()</strong>:
     L&ouml;scht ein Objekt. Dabei werden bestehende Assoziationen und Kompositionen aufgel&ouml;st.
     <br />
     <br />
  </li>
  <li>
    <strong>createAssociation()</strong>:
    Erzeugt eine Assoziation zwischen zwei Objekten.
    <br />
    <br />
  </li>
  <li>
    <strong>deleteAssociation()</strong>:
    L&ouml;scht die Assoziation zwischen zwei Objekten.
    <br />
    <br />
  </li>
  <li>
    <strong>isAssociated()</strong>:
    Pr&uuml;ft, ob eine Assiziation zwischen zwei Objekten besteht.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectListByStatement()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectListByTextStatement()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines &uuml;bergebenen SQL-Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectListByIDs()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines &uuml;bergebenen Arrays.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByStatement()</strong>:
    L&auml;d ein Objekt an Hand eines Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByTextStatement()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines &uuml;bergebenen SQL-Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByID()</strong>:
    L&auml;d ein Objekt an Hand einer &uuml;bergebenen ID.
    <br />
    <br />
  </li>
</ul>
Die <strong>*Statement*</strong>-Methoden werden aus Performance-Gr&uuml;nden angeboten (siehe
Kapitel
<a href="./?Seite=065-Generischer-OR-Mapper-Performance-Hacks" title="Generischer OR-Mapper - Performance-Hacks">Performance-Hacks</a>).
Datails zu Argumenten und R&uuml;ckgabewerten k&ouml;nnen der
<a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation der Module</a>
entnommen werden, im Folgenden finden die wichtigsten Methoden jedoch Verwendung.
<br />
<br />
<br />
<a name="4-1-Erzeugen-einer-Instanz"></a><h4>4.1. Erzeugen einer Instanz</h4>
Die Instanz eines OR-Mappers muss &uuml;ber die zugeh&ouml;rige Factory (<strong>GenericORMapperFactory</strong>)
erzeugt werden. Dies ist zum einen deshalb notwendig, um den konkreten OR-Mapper vor der Verwendung
zu initialisieren und zum anderen, damit mehrere OR-Mapper innerhalb einer Applikation verwendet
werden k&ouml;nnen. Letzteres ist in einfachen Anwendungen sicher nicht notwenig, in komplexeren
Konstrukten ist dies jedoch eine notwendige Anforderung.
<br />
<br />
Die folgende Codebox zeigt einen typischen Aufruf eines OR-Mappers:
<php:highlight>
// Inkludieren der Factory
import('modules::genericormapper::data','GenericORMapperFactory');

// Factory erstellen
$ORMFactory = $this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper von der Factory beziehen
$ORM = &$ORMFactory->getGenericORMapper(
                                        {CONFIG_NAMESPACE},
                                        {CONFIG_NAME_AFFIX},
                                        {CONNECTION_NAME},
                                        {SERVICE_OBJECT_TYPE}
                                       );
</php:highlight>
Die Platzhalter haben dabei folgende Bedeutung:
<ul>
  <li>
    <strong>{CONFIG_NAMESPACE}</strong>: Namespace, unter dem die Konfigurationsdateien f&uuml;r den
    OR-Mapper liegen (siehe Kapitel 2.2).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONFIG_NAME_AFFIX}</strong>: Namenszusatz der Konfigurationsdateien (siehe Kapitel 2.1).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONNECTION_NAME}</strong>: Name der Datenbankverbindung, die f&uuml;r das Setup genutzt
    werden soll.
    <br />
    <br />
  </li>
  <li>
    <strong>{SERVICE_OBJECT_TYPE}</strong>: Art der Instanziierung des Mappers. G&uuml;ltige Werte
    sind "SINGLETON" und "SESSIONSINGLETON", Standard ist "SINGLETON".
    <br />
    <br />
  </li>
</ul>
Wichtig ist dabei weiterhin, dass die Factory mit der Methode <strong>__getServiceObject()</strong>
erzeugt wird, da es sonst zu unerw&uuml;nschten Seiteneffekten hinsichtlich Konfiguration der Mapper
kommen kann.
<br />
<br />
<br />
<a name="4-2-Laden-von-Daten"></a><h4>4.2. Laden von Daten</h4>
Um die Beschreibung der Features plastischer gestalten zu k&ouml;nnen, soll folgendes UML als Basis
f&uuml;r Beispiele dienen. Das Diagramm enth&auml;lt die Definition der Business-Objekte des
<a href="./?Seite=039-Mitgelieferte-Module" title="Mitgelieferte Module">usermanagement</a>-Moduls.
Die im Kapitel 4.2. verwendeten Code-Beispiele sind dabei dem genannten Modul entnommen.
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/usermanagement_domain_model.png" border="0" style="width: 560px;"/>
<br />
<br />
<a name="4-2-1-Laden-von-Objekten"></a><h5>4.2.1. Laden von Objekten</h5>
F&uuml;r das Laden von Objekten stehen die Methoden
<ul>
  <li><strong>loadObjectByCriterion()</strong></li>
  <li><strong>loadObjectByTextStatement()</strong></li>
  <li><strong>loadObjectByStatement()</strong></li>
  <li><strong>loadObjectByID()</strong></li>
</ul>
zur Verf&uuml;gung. M&ouml;chte der Entwickler auf einer Seite die Details eines Benutzers (siehe
UML-Diagramm) darstellen, so k&ouml;nnen die aufgef&uuml;hrten Methoden wie in der anschlie&szlig;end
dargestellten Codebox beschreiben eingesetzt werden:
<php:highlight>
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer laden (1)
$Crit = new GenericCriterionObject();
$Crit->addPropertyIndicator('UserID',1);
$User = $ORM->loadObjectByCriterion('User',$Crit);

// Benutzer laden (2)
$select = 'SELECT * FROM ent_user WHERE UserID = \'1\';';
$User = $ORM->loadObjectByTextStatement('User',$select);

// Benutzer laden (3)
$User = $ORM->loadObjectByStatement('User','modules::usermanagement','load_user_by_id');

// Benutzer laden (4)
$User = $ORM->loadObjectByID('User',1);
</php:highlight>
Der Inhalt der Statement-Datei <strong>load_user_by_id</strong> ist dabei
<pre class="tagexample">
SELECT * FROM ent_user WHERE UserID = '1';
</pre>
Details zur Ausf&uuml;hrung von Statement-Dateien k&ouml;nnen dem Kapitel
<a href="./?Seite=018-KlassenReferenz-MySQLHandler" title="KlassenReferenz-MySQLHandler">KlassenReferenz-MySQLHandler</a>
entnommen werden.
<br />
<br />
<br />
<a name="4-2-2-Laden-von-Listen"></a><h5>4.2.2. Laden von Objekt-Listen</h5>
F&uuml;r das Laden von Objekt-Listen stehen die Methoden
<ul>
  <li><strong>loadObjectListByCriterion()</strong></li>
  <li><strong>loadObjectListByTextStatement()</strong></li>
  <li><strong>loadObjectListByStatement()</strong></li>
  <li><strong>loadObjectListByIDs()</strong></li>
</ul>
zur Verf&uuml;gung. M&ouml;chte der Entwickler auf einer Seite eine Liste von Benutzern (siehe
UML-Diagramm) darstellen, so k&ouml;nnen die aufgef&uuml;hrten Methoden wie in der anschlie&szlig;end
dargestellten Codebox beschreiben eingesetzt werden:
<php:highlight>
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer-Liste laden (1)
$Crit = new GenericCriterionObject();
$Crit->addPropertyIndicator('DisplayName','a%');
$UserList = $ORM->loadObjectListByCriterion('User',$Crit);

// Benutzer-Liste laden (2)
$select = 'SELECT * FROM ent_user WHERE DisplayName LIKE \'a%\';';
$UserList = $ORM->loadObjectListByTextStatement('User',$select);

// Benutzer-Liste laden (3)
$UserList = $ORM->loadObjectListByStatement('User','modules::usermanagement','load_user_list');

// Benutzer-Liste laden (4)
$UserList = $ORM->loadObjectListByIDs('User',array(1,2,3,4,5,6));
</php:highlight>
Der Inhalt der Statement-Datei <strong>load_user_list</strong> ist dabei
<pre class="tagexample">
SELECT * FROM ent_user WHERE DisplayName LIKE 'a%';
</pre>
<br />
<a name="4-2-3-Nachladen-von-Beziehungsobjekten"></a><h5>4.2.3. Nachladen von Beziehungsobjektlisten</h5>
Besteht die Notwendigkeit, bei der Auflistung der Benutzer, deren zugeordnete Gruppen mit
aufzuf&uuml;hren, k&ouml;nnen die Gruppen an Hand der Beziehung nachgeladen werden. F&uuml;r das
Nachladen von zu einem Objekt in Beziehung stehenden Objekten kann die Methode
<ul>
  <li><strong>loadRelatedObjects()</strong></li>
</ul>
eingesetzt werden. Das folgende Beispiel zeigt, wie die einem Benutzer zugeordneten Gruppen
geladen werden k&ouml;nnen:
<php:highlight>
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer-Liste laden
$Crit = new GenericCriterionObject();
$Crit->addOrderIndicator('DisplayName','ASC');
$UserList = $ORM->loadObjectListByCriterion('User',$Crit);

// Ausgeben der Liste inkl. Gruppen des Benutzers
for($i = 0; $ < count($UserList); $i++){

   // Name des Benutzers ausgeben
   echo '<br />'.$UserList[$i]->getProperty('DisplayName');

   // Gruppen nachladen
   $GroupList = $ORM->loadRelatedObjects($UserList[$i],'Group2User');

   // Gruppen ausgeben
   echo ' ,Gruppen: ';
   for($j = 0; $j < count($GroupList); $j++){
      echo $GroupList[$j]->getProperty('DisplayName').' ';
    // end for
   }

   // Neue Zeile ausgeben
   echo '<br />';

 // end for
}
</php:highlight>
Zur Vereinfachung des Nachladens besitzt auch das Objekt <strong>GenericDomainObject</strong> die
Methode <strong>loadRelatedObjects()</strong>. Damit ist es m&ouml;glich in der Pr&auml;sentationsschicht,
und &uuml;berall dort, wo keine Instanz des Mappers zur Verf&uuml;gung steht, in Beziehung stehende
Objekte nachzuladen. Im obigen Beispiel k&ouml;nnen die einem Benutzer zugeordneten Gruppen damit auch
per
<php:highlight>
$GroupList = $UserList[$i]->loadRelatedObjects('Group2User');
</php:highlight>
geladen werden.
<br />
<br />
<strong>Hinweis:</strong> Die Menge der nachgeladenen Daten kann auch hier mit einem
<strong>GenericCriterionObject</strong> eingeschr&auml;nkt werden. Die im Beispiel genannte
Gruppen-Liste kann wie folgt limitiert werden:
<php:highlight>
// Definieren der Limitierungsindikatoren
$Crit = new GenericCriterionObject();
$Crit->addOrderIndicator('DisplayName','ASC');
$Crit->addPropertyIndicator('DisplayName','A%');
$Crit->addCountIndicator(10);

// Laden der Liste ueber das Dom&auml;nen-Objekt selbst
$GroupList = $UserList[$i]->loadRelatedObjects('Group2User',$Crit);

// Laden der Liste direkt ueber den OR-Mapper
$GroupList = $ORM->loadRelatedObjects($UserList[$i],'Group2User',$Crit);
</php:highlight>
<br />
<a name="4-2-4-Nachladen-von-Nichtbeziehungsobjekten"></a><h5>4.2.4. Nachladen von "Nichtbeziehungsobjekten"</h5>
Oft besteht die Notwendigkeit, Objekte zu selektieren, die zu einem bestimmten Objekt (noch) nicht
in Beziehung stehen, f&uuml;r die jedoch eine Beziehung definiert ist. Ein konkreter Anwendungsfall
bezogen auf das oben gezeigte UML-Diagramm ist die Selektion aller Gruppen, zu denen ein Benutzer
noch keine Assoziation hat um diesen zur Gruppe hinzuf&uuml;gen zu k&ouml;nnen. Zu diesem Zweck
kann die Methode
<ul>
  <li><strong>loadNotRelatedObjects()</strong></li>
</ul>
eingesetzt werden. Das folgende Beispiel zeigt, wie alle Gruppen selektiert werden k&ouml;nnen, zu
denen der genannte Benutzer noch keine Beziehung besitzt:
<php:highlight>
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer selektieren
$Crit = new GenericCriterionObject();
$Crit->addpropertyIndicator('DisplayName','Mustermann, Max');
$User = $ORM->loadObjectByCriterion('User',$Crit);

// Selektieren der nicht assoziierten Gruppen
$GroupList = $ORM->loadNotRelatedObjects($User,'Group2User');

// Ausgeben der Liste der noch nicht assoziierten Gruppen
for($i = 0; $ < count($GroupList); $i++){
   echo '<br />'.$GroupList[$i]->getProperty('DisplayName');
 // end for
}
</php:highlight>
<strong>Hinweis:</strong> Auch hier kann die Menge der nachgeladenen Objekte mit Hilfe des
<strong>GenericCriterionObject</strong> eingeschr&auml;nkt werden. H&auml;ufiger Anwendungsfall ist
hier die Einschr&auml;nkung &uuml;ber weitere Beziehungen der gew&uuml;nschten Objekte zu anderen.
Im folgenden Beispiel sollen nur diejenigen Gruppen selektiert werden, zu denen der gew&uuml;hlte
Benutzer noch keine Beziehung besitzt, die jedoch unterhalb eines definierten
<em>Application</em>-Objekts komponiert sind:
<php:highlight>
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer selektieren
$Crit = new GenericCriterionObject();
$Crit->addpropertyIndicator('DisplayName','Mustermann, Max');
$User = $ORM->loadObjectByCriterion('User',$Crit);

// Additived Beziehungskriterium definieren
$Crit = new GenericCriterionObject();
$App = new GenericDomainObject('Application');
$App->setProperty('ApplicationID',1);
$Crit->addRelationIndicator('Application2Group',$App);

// Selektieren der nicht assoziierten Gruppen
$GroupList = $ORM->loadNotRelatedObjects($User,'Group2User',$Crit);

// Ausgeben der Liste der noch nicht assoziierten Gruppen
for($i = 0; $ < count($GroupList); $i++){
   echo '<br />'.$GroupList[$i]->getProperty('DisplayName');
 // end for
}
</php:highlight>
<br />
<a name="4-2-5-Laden-der-Beziehungsmultiplizitaet"></a><h4>4.2.5 Laden der Beziehungsmultiplizit&auml;t</h4>
Um herauszufinden, wie viele Objekte in Beziehung zu einem anderen gesetzt wurden, steht dem
Entwickler die Methode
<ul>
  <li><strong>loadRelationMultiplicity()</strong></li>
</ul>
zur Verf&uuml;gung. Diese gibt die erfragte Anzahl an Hand eines Objekts und eines
Beziehungsschl&uuml;ssels zur&uuml;ck. Soll die Anzahl der Benutzer einer Gruppe abgefragt werden,
so kann dies mit folgendem Code bewerkstelligt werden:
<php:highlight>
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Gruppe selektieren
$Group = $ORM->loadObjectByID('Group',1);

// Selektieren und Ausgeben der Anzahl der Benutzer einer Gruppe
echo $ORM->loadRelationMultiplicity($Group,'Group2User');
</php:highlight>
<br />
<a name="4-3-Speichern-von-Objekten"></a><h4>4.3. Speichern von Objekten</h4>
F&uuml;r das Speichern von Objekten steht die Methode
<ul>
  <li><strong>saveObject()</strong></li>
</ul>
zur Verf&uuml;gung. Um einen Benutzer in der Datenbank zu speichern ist folgender Code notwendig:
<php:highlight>
   // Fabric instanziieren
   $ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

   // Mapper mit Basis-Konfiguration laden
   $ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

   // Benutzer befuellen
   $User = new GenericDomainObject('User');
   $User->setProperty('FirstName','Christian');
   $User->setProperty('LastName','Achatz');

   // Benutzer speichern
   $ORM->saveObject($User);
</php:highlight>
<br />
<a name="4-4-Speichern-von-Objektbaeumen"></a><h4>4.4. Speichern von Objekt-B&auml;umen</h4>
Wie bereits in der Einleitung angemerkt, kann der OR-Mapper nicht nur einzelne Objekte, sondern auch
Objektb&auml;ume speichern. Dieses Feature kann in der Datenschicht der Applikation insbesondere dazu
genutzt werden, um f&uuml;r die Applikation notwendige Beziehungen aufzubauen.
<br />
<br />
<strong>Aufgabenstellung:</strong> Beim Erstellen eines Benutzers, soll dieser unterhalb einer Applikation
komponiert werden. Diese Komposition kann sp&auml;ter dazu genutzt werden um das Usermanagement
mandantenf&auml;hig zu gestalten.
<br />
<br />
<strong>Umsetzung:</strong> Um eine Beziehung zwischen einem <em>Application</em>- und einem
<em>User</em>-Objekt herzustellen und diese Beziehung auch zu speichern, kann die Methode
<strong>addRelatedObject()</strong> der Klasse <strong>GenericDomainObject</strong> verwendet werden.
Die folgende Codebox zeigt die Implementierung:
<php:highlight>
   // Fabric instanziieren
   $ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

   // Mapper mit Basis-Konfiguration laden
   $ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

   // Applikation laden
   $App = $ORM->loadObjectByID('Application',1);

   // Benutzer befuellen
   $User = new GenericDomainObject('User');
   $User->setProperty('FirstName','Christian');
   $User->setProperty('LastName','Achatz');

   // Beziehung herstellen
   $App->addRelatedObject('Application2User',$User);

   // Objektbaum speichern
   $ORM->saveObject($App);
</php:highlight>
M&ouml;chte der Entwickler im gleichen Zug dem Benutzer noch eine Gruppe und eine Rolle zuordnen,
muss der oben gezeigte Quellcode zwischen dem Bef&uuml;llen des Benutzer-Objekts und der Herstellung
der Beziehung zum Application-Objekt entsprechend erweitert werden:
<php:highlight>
   ...

   // Applikation laden
   $App = $ORM->loadObjectByID('Application',1);

   // Benutzer befuellen
   $User = new GenericDomainObject('User');
   $User->setProperty('FirstName','Christian');
   $User->setProperty('LastName','Achatz');

   // Gruppe laden
   $Group = $ORM->loadObjectByID('Group',1);

   // Rolle laden
   $Role = $ORM->loadObjectByID('Role',1);

   // Gruppe und Rolle zuweisen
   $User->addRelatedObject('Group2User',$Group);
   $User->addRelatedObject('Role2User',$Role);

   // Beziehung herstellen
   $App->addRelatedObject('Application2User',$User);

   // Objektbaum speichern
   $ORM->saveObject($App);
</php:highlight>
<br />
<a name="5-GenericCriterionObject"></a><h3>5. &Uuml;bersicht zum <em>GenericCriterionObject</em></h3>
Das vorliegende Kapitel m&ouml;chte einen zusammenfassenden &Uuml;berblick &uuml;ber die Nutzung des
<strong>GenericCriterionObject</strong> geben. Wie in den vorherigen Kapiteln angedeutet, kann das
Kriterium-Objekt dazu genutzt werden, Abfragen ohne Schreiben von SQL-Statements f&uuml;r den
Anwendungsfall zu konfigurieren. Das Objekt kann bei den <strong>load*ByCriterion()</strong>-Methoden
und beim Nachladen von in Beziehung stehenden Objekten und Objektlisten genutzt werden.
<br />
<br />
Die folgende Code-Box zeigt einen &Uuml;berblick &uuml;ber die Einsatzm&ouml;glichkeiten des
<strong>GenericCriterionObject</strong>s am Beispiel einer Benutzer-Liste, deren Benutzer zu einer
Applikation geh&ouml;ren und eine definierte Gruppe zugeordnet haben:
<php:highlight>
class usermanagementManager extends coreObject
{

   ...

   function getUserList(){

      // Fabric instanziieren
      $ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

      // Mapper mit Basis-Konfiguration laden
      $ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

      // Erzeugen des Kriterien-Objekts
      $Crit = new GenericCriterionObject();

      // Hinzufuegen einer Beziehung zum Objekt "Application" (Komposition)
      $Application = new GenericDomainObject('Application');
      $Application->setProperty('ApplicationID',1);
      $Crit->addRelationIndicator('Application2User',$Application);

      // Hinzufuegen einer Beziehung zum Objekt "Group" (Assoziation)
      $Group = new GenericDomainObject('Group');
      $Group->setProperty('GroupID',1);
      $Crit->addRelationIndicator('Group2User',$Group);

      // Hinzufuegen einer Begrenzung der Anzahl mit definiertem Startpunkt
      $Crit->addCountIndicator(0,3);

      // Hinzufuegen einer Begrenzung der Anzahl
      $Crit->addCountIndicator(2);

      // Hinzufuegen einer Bedingung auf Ebene der Eigenschaften des zu ladenden Objekts
      $Crit->addPropertyIndicator('LastName','Achatz');

      // Hinzufuegen einer Sortierreihenfolge
      $Crit->addOrderIndicator('FirstName','ASC');
      $Crit->addOrderIndicator('LastName','DESC');

      // Definition der zu ladenden Attribute eines Objekts
      $Crit->addLoadedProperty('FirstName');
      $Crit->addLoadedProperty('LastName');

      // Laden einer Objektliste mit Hilfe des Kriterium-Objekts
      return $ORM->loadObjectListByCriterion('User',$Crit);

      // Laden eines Objekts mit Hilfe des Kriterium-Objekts
      return $ORM->loadObjectByCriterion('User',$Crit);

    // end function
   }

   ...

 // end class
}
</php:highlight>
<strong>Hinweise zum Quelltext:</strong>
<ul>
  <li>
    <strong>Beziehungen</strong>:
    <br />
    Das Hinzuf&uuml;gen von Beziehungen zum Kriterien-Objekt beschreiben, dass das zu ladende Objekt
    oder jedes Objekt der zu ladenden Liste in Beziehung zum Objekt des Kriteriums stehen muss. Wird
    wie im Beispiel eine Beziehung zum Objekt <em>Application</em> (Komposition) und zum Objekt
    <em>Group</em> (Assoziation) aufgebaut, ist das Ergebnis eine Liste von Objekten innerhalb einer
    Applikation, die in einer bestimmten Gruppe sind.
    <br />
    M&ouml;chte der Entwickler alle Benutzer selektieren, die in einer Applikation enthalten sind,
    einer definierten Gruppe angeh&ouml;ren und eine bestimmte Rolle zugewiesen haben, m&uuml;ssen
    drei Beziehungen gem&auml;&szlig; der Beziehungskonfiguration zum Kriterium hinzugef&uuml;gt
    werden.
    <br />
    <br />
  </li>
  <li>
     <strong>Sortierreihenfolge</strong>:
     <br />
     Die Reihenfolge der Aufrufe entscheidet die Sortierung. Soll die Sortierung in einer anderen
     Reihenfolge vorgenommen werden, m&uuml;ssen die Sortierkriterien in der entsprechend anderen
     Abfolge hinzugef&uuml;gt werden. Der Wert <strong>ASC</strong> steht f&uuml;r aufsteigende
     Sortierung, <strong>DESC</strong> f&uuml;r absteigende.
     <br />
     <br />
  </li>
</ul>
<a name="6-Erweiterung-Mapping-und-Relation-Table"></a><h3>6. Erweiterung des Mapping- und Relation-Table</h3>
Wenn der <em>GenericORRelationMapper</em> &uuml;ber mehrere Anwendungen und mehrere Anwendungsf&auml;lle
hinweg eingesetzt wird, ergibt sich die Schwierigkeit, dass unterschiedliche Applikationen unterschiedliche
Bereiche der vom OR-Mapper verwalteten Datenbank nutzen. Hierzu kann entweder f&uuml;r den entsprechenden
Anwendungsfall jeweils eine passende Konfiguration angelegt werden oder der Entwickler definiert
eine f&uuml;r alle verwendbare Basis-Konfiguration (z.B. alle Objekte des Moduls <em>usermanagement</em>)
und nutzt die Methoden
<ul>
  <li><strong>addMappingConfiguration()</strong></li>
  <li><strong>addRelationConfiguration()</strong></li>
</ul>
um die allgemeing&uuml;ltige Konfiguration f&uuml;r den aktuellen Anwendungsfall zu erweitern. Mit
den genannten Funktionen k&ouml;nnen beliebige weitere Objektdefinitions- und Beziehungs-Konfigurationen
hinzugeladen werden. Das folgende Beispiel zeigt, wie die aufgef&uuml;hrten Methoden genutzt werden
k&ouml;nnen um den Wirkungsbereich des Mappers zu erweitern:
<php:highlight>
// Fabric instanziieren
$oRMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$oRM = &$oRMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Zusaetzliche Objekt-Definitionen hinzuladen
$oRM->addMappingConfiguration('modules::usermanagement','umgt_2');

// Zusaetzliche Beziehungs-Definitionen hinzuladen
$oRM->addRelationConfiguration('modules::usermanagement','umgt_2');
</php:highlight>
Die Syntax der Objektdefinitions- und Beziehungs-Konfigurationen ist dabei identisch zu den
Standard-Konfiguration, wie sie im Kapitel
<a href="#2-3-Objekt-und-Beziehungsdefinition" title="2.3. Objekt- und-Beziehungsdefinition">2.3. Objekt- und-Beziehungsdefinition</a>
diskutiert wurden. Die zus&auml;tzliche Objekt-Definition beinhaltete dabei die folgenden Objekte:
<pre class="tagexample">
[Project]
DisplayName = "VARCHAR(100)"
Description = "TEXT"

[News]
DisplayName = "VARCHAR(100)"
Title = "VARCHAR(100)"
Content = "TEXT"
</pre>
und die neu hinzugekommenen Beziehungen waren
<pre class="tagexample">
[Application2Project]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Project"

[Project2News]
Type = "COMPOSITION"
SourceObject = "Project"
TargetObject = "News"
</pre>
<br />
<a name="7-Notes"></a><h3>7. Notes</h3>
Hints on performance relevant issues can be found in the
<a href="./?Page=065-Generic-OR-mapper-performance-hacks" title="Performance hacks">performance hacks</a>
chapter, the manual database setup is discussed in the
<a href="./?Page=064-Generic-OR-mapper-manual-database-setup" title="Manual database setup">manual database setup</a>
section. The source files of the
<a href="./?Page=095-Modul-usermanagement" title="Usermanagement module">usermanagement module</a>
can be used as an extended example.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_063" />