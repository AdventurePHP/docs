<doku:title tags="forumlare,form,aufbau,validierung,manipulation,befuellung,auslesen,dynamische formulare,controller" title="Verwendung von Formularen (ab Version 1.11)" urlname="Verwendung-von-Formularen">
  Diese Dokumentationsseite beschreibt den Aufbau und die Verwendung von Formularen so wie die
  M&ouml;glichkeiten, die sich aus dem APF-Formular-Modell ergeben. Dazu z&auml;hlen die Validierung 
  und das Vorausf&uuml;llen, sowie die M&ouml;glichkeit, Formular-Elemente (=Objekte) im Controller
  zu manipulieren, zu bef&uuml;llen oder diese auszulesen. Weiterhin wird die dynamische
  Formular-Erstellung beschrieben.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
Das Adventure PHP Framework beinhaltet eine sehr umfangreiche Formular-Unterst&uuml;tzung die auf dem
Taglibs-Konzept basiert. Die Grundlagen und vorhandenen Taglibs sind im Abschnitt
<a href="./?Seite=113-Formulare" title="Formulare">Formulare</a> beschrieben. Dieses Kapitel
besch&auml;ftigt sich nun mit der Verwendung von Formularen, der dynamischen Formular-Generierung
und der Erweiterung der Formular-Taglibs.
<br />
<br />
<br />
<a name="1-Formulare-und-Controller"></a><h3>1. Formulare &amp; Controller</h3>
Formulare sind - genau wie Template-Fragmente - Elemente, die im DOM-Baum existieren, jedoch bei der
Transformation nicht automatisch ausgegeben werden. Hierzu bedarf es eines Document-Controller. Der
Grund daf&uuml;r ist simple: nahezu jedes Formular ist an Aktionen gekn&uuml;pft, die mit dem Absenden
des Formulars ausgef&uuml;hrt werden sollen (z.B. Speichern der Daten).
<br />
<br />
Um ein Formular mit Hilfe eines Document-Controller auszugeben, ist folgender Code notwendig:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('Search');
      $form->transfromOnPlace();
   }
}
</php:highlight>
In der Variable <strong>$form</strong> steht dabei eine Instanz der Klasse
<strong>html_taglib_form</strong> zur Verf&uuml;gung, die ein APF-Formular mit all seinen Elementen und
Funktionen kapselt. Mit Hilfe dieser Referenz auf das Formular-Objekt im DOM-Baum kann das Formular
ausgegeben, manipuliert, bef&uuml;llt und angepasst werden. Details dazu k&ouml;nnen den folgenden Kapiteln
entnommen werden.
<br />
<br />
<br />
<a name="2-API-der-Formular-Taglibs"></a><h3>2. API der Formular-Taglibs</h3>
Im vorangegangenen Abschnitt wurde beschrieben, wie ein Formular in einem Document-Controller
referenziert werden kann. In diesem Kapitel besch&auml;ftigen wir uns nun mit der API der
Formular-Taglibs, die Aufschluss dar&uuml;ber gibt, welche M&ouml;glichkeiten die Formular-Integration des
APF bietet.
<br />
<br />
<div class="hint">
   F&uuml;r die Entwicklung ist es stets ratsam, die
   <a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
   der eingesetzten Version parallel zur Entwicklungsumgebung ge&ouml;ffnet zu haben. Dies erleichtert
   die Arbeit, da jede Taglib ihre eigene API mitbringt, die in der API-DOkumentation genau
   beschrieben ist.
</div>
<br />
Grundlage f&uuml;r alle Formular-Elemente ist die Klasse <strong>form_control</strong>. Diese
implementiert Basis-Funktionalit&auml;ten f&uuml;r alle konkreten Formular-Elemente und definiert die
Struktur eines Formular-Elements. Da die Formular-Elemente als Taglibs ausgef&uuml;hrt sind, unterliegen
sie dem
<a href="./?Seite=098-Pagecontroller#2-1-Ablaufdiagramm" title="Lifecycle des Page-Controllers">Lifecycle des Page-Controllers</a>.
Das bedeutet, dass sie dar&uuml;ber hinaus alle Methoden einer &quot;normalen&quot; Taglib
implementieren m&uuml;ssen.
<br />
<br />
<div class="hint">
   Im Gegensatz zu den Formular-Taglibs <strong>bis Version 1.10</strong>, kennen die
   Formular-Elemente <strong>ab Version 1.11</strong> ihren Validit&auml;ts-Status selbst. Damit kann
   jedes Element nach seinem Status gefragt werden. F&uuml;r das Formular selbst bedeutet das, dass die
   Methode <strong>isValid()</strong> den Status von jedem Element abfragt und daraus einen
   kumulierten Wert erzeugt.
</div>
<br />
Die Klasse <strong>form_control</strong> implementierten folgende Methoden:
<ul>
   <li>
      <strong>isValid():</strong> Die Funktion erm&ouml;glicht es, den Validit&auml;ts-Status der
      Formular-Elements abzufragen. Intern oder auch von aussen.
   </li>
   <li>
      <strong>markAsInvalid():</strong> Markiert ein Element als invalid.
   </li>
   <li>
      <strong>markAsSent():</strong> Markiert ein Element als abgesendet (relevant f&uuml;r Formulare
      und Buttons).
   </li>
   <li>
      <strong>isSent():</strong> Pr&uuml;ft, ob ein Formular abgesendet wurde.
   </li>
   <li>
      <strong>isChecked():</strong> Gibt zur&uuml;ck, ob eine Checkbox angehakt wurde oder nicht.
   </li>
   <li>
      <strong>check():</strong> Hakt eine Checkbox an.
   </li>
   <li>
      <strong>uncheck():</strong> Deaktiviert eine Checkbox.
   </li>
   <li>
      <strong>addFilter():</strong> F&uuml;gt einen Filter zu einem Element hinzu.
   </li>
   <li>
      <strong>addValidator():</strong> F&uuml;gt einen Validator zu einem Element hinzu.
   </li>
   <li>
      <strong>addAttribute():</strong> Kann genutzt werden, um zu einem Attribut eines Tags weiteren
      Inhalt hinzuzuf&uuml;gen. Dies wird beim Benachrichtigen eines Formular-Elements innerhalb der
      Validierung genutzt.
   </li>
   <li>
      <strong>notifyValidationListeners():</strong> Benachrichtigt alle Listener eines
      Formular-Elements, dass dieses invalid ist.
   </li>
   <li>
      <strong>__presetValue():</strong> Die Methode stellt Presetting von Formular-Elementen f&uuml;r
      einfache Text-Felder zur Verf&uuml;gung. Diese kann bei der Erweiterung von Formular-Elementen
      entweder mit einer eigenen Logik &uuml;berschrieben oder direkt genutzt werden.
   </li>
   <li>
      <strong>setPlaceHolder():</strong> Die Methode implementiert eine generische Funktion zum
      setzen eines Platzhalters in einem Formular-Element. Wichtig hierbei ist, dass das Kind-Tag
      <strong>*:placeholder</strong> hei&szlig;t.
   </li>
</ul>
Mit Hilfe dieser Funktionen wird der Entwickler darin untrst&uuml;tzt, eigene Formular-Elemente zu
erstellen. Mehr dazu in Kapitel 7.
<br />
<br />
<br />
<a name="3-Validierung"></a><h3>3. Validierung</h3>
Die Validierung von Formular-Elementen wird &uuml;ber die Taglib <strong>form:addvalidator</strong>
und die Implementierung der Validatoren auf das Klick-Event eines Buttons ausgef&uuml;hrt. Zeitlich
gesehen erfolgt die Validierung bei der Ausf&uuml;hrung der <strong>onAfterAppend()</strong>-Methode.
Das ist nach der Analyse-Phase (hier wird die Methode <strong>onParseTime()</strong> jeder Taglib
ausgef&uuml;hrt) und damit steht der DOM-Baum der Formular-Elemente vollst&auml;ndig zur Verf&uuml;gung.
<br />
<br />
In der <strong>onAfterAppend()</strong>-Methode des <strong>form:addvalidator</strong>-Tags wird
dann der Validator erzeugt, mit den notwendigen Informationen (Button und Formular-Control)
ausgestattet und dem Element &uuml;bergeben. Das Element f&uuml;hrt den Validator dann bei aktivem Status
aus und pr&uuml;ft das Ergebnis. Im Negativfall wird die <strong>notify()</strong>-Methode des
Validators aufgerufen.
<br />
<br />
<br />
<a name="3-1-Abfragen-des-Validierungs-Status"></a><h4>3.1. Abfragen des Validierungs-Status</h4>
Da die einzelnen Formular-Elemente ab der neuen Implementierung selbst kennen, muss die Methode
<em>isValid()</em> des Formulars den Status jedes einzelnen Elements erfragen. In einem
Document-Controller kann der Zustand eines Formulars damit wie folgt abgefragt werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      if($form->isSent()){
         echo 'Form was send');
      }
      if($form->isValid()){
         echo 'Form is valid';
      }
   }
}
</php:highlight>
Ebenso ist es m&ouml;glich, den Status eines definierten Elements zu erfragen:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      $searchField = &$form->getFormElementByName('searchterm');
      if($searchField->isValid()){
         echo 'Search field is valid';
      }
   }
}
</php:highlight>
Um den Klick-Status eines Buttons abzufragen, kann folgender Code genutzt werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      $button = &$form->getFormElementByID('button');
      if($button->isSent()){
         echo 'Search button was clicked';
      }
   }
}
</php:highlight>
<div class="hint">
   Weitere Methoden der Formular-Elemente finden sich in der
   <a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
   der Klassen <strong>html_taglib_form</strong>, <strong>form_control</strong> und den Taglibs
   der jeweiligen Formular-Elemente (z.B. <strong>form_taglib_text</strong>).
</div>
<br />
<br />
<a name="3-2-Ausgabe-von-Validator-Fehlermeldungen"></a><h4>3.2. Ausgabe von Validator-Fehlermeldungen</h4>
Bei der Validierung von Formularen werden monierte Felder &uuml;blicherweise farblich markiert und der
Benutzer mit einem Hinweistext benachrichtigt. F&uuml;r diese Aufgaben k&ouml;nnen die Tags
<strong>&lt;form:error /&gt;</strong> (globale Formular-Fehlermeldungen) und
<strong>&lt;form:listener /&gt;</strong> verwendet werden. Alternativ dazu ist ein Platzhalter-Tag
verf&uuml;gbar, das im Controller mit einem entsprechenden Wert belegt werden kann.
<br />
<br />
<br />
<a name="3-2-1-Form-Error"></a><h5>3.2.1. Form-Error</h5>
Der <strong>&lt;form:error /&gt;</strong> gibt immer dann seinen Inhalt aus, wenn das Formular nicht
valide ist. Dazu fragt er das Formular bei der Transformation nach seinem Status:
<br />
<br />
<u>Template:</u>
<code:highlight>
&lt;html:form name="product-form"&gt;
   &lt;form:error&gt;Please fill in the mandatory fields!&lt;/form:error&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</code:highlight>
<u>Controller:</u>
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $form->transformOnPlace();
   }
}
</php:highlight>
Innerhalb des <strong>&lt;form:error /&gt;</strong>-Tags k&ouml;nnen gem&auml;&szlig;
<a href="./?Seite=113-Formulare#3-19-Error" title="Anzeige von Formular-Fehlern">Anzeige von Formular-Fehlern</a>
noch weitere Tags zur Definition der Inhalte verwendet werden.
<br />
<br />
<br />
<a name="3-2-2-Listener"></a><h5>3.2.2. Listener</h5>
Der <strong>&lt;form:listener /&gt;</strong>-Tag dient dazu Feld-speziefische Fehler anzuzeigen. Wie
in der Einleitung zum Kapitel 3 angesprochen, wird bei fehlgeschlagener Validierung die Methode
<strong>notify()</strong> aufgerufen. Diese benachrichtigt alle Listener, die sich auf das
entsprechende Control registriert haben und diese geben dann bei der Transformation den definierten
Inhalt aus.
<br />
<br />
Im folgenden Beispiel wird bei fehgeschlagener Validierung jeweils eine Feld-spezifische Meldung
angezeigt:
<br />
<br />
<u>Template:</u>
<code:highlight>
&lt;html:form name="product-form"&gt;
   &lt;form:listener control="code"&gt;Please fill in a five letter product code!&lt;/form:listener&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:listener control="title"&gt;Please fill in a title with at least 20 characters!&lt;/form:listener&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:listener control="description"&gt;Please provide a verbose product description!&lt;/form:listener&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</code:highlight>
<u>Controller:</u>
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $form->transformOnPlace();
   }
}
</php:highlight>
Innerhalb des <strong>&lt;form:listener /&gt;</strong>-Tags k&ouml;nnen gem&auml;&szlig;
<a href="./?Seite=113-Formulare#3-18-Listener" title="Listener">Listener</a> noch weitere Tags zur
Definition der Inhalte verwendet werden.
<br />
<br />
<br />
<a name="4-Auslesen-von-Formularen"></a><h3>4. Auslesen von Formularen</h3>
Eine h&auml;ufige Aufgabe beim Handling von Formularen stellt das Auslesen von Werte dar. Hierzu
k&ouml;nnen im Document-Controller folgende Methoden genutzt werden:
<ul>
   <li>
      <strong>getFormElementByID():</strong> Liefert ein Formular-Element an Hand seiner ID
      (Attribut: <em>id</em>).
   </li>
   <li>
      <strong>getFormElementByName():</strong> Liefert ein Formular-Element an Hand seines Namens
      (Attribut: <em>name</em>).
   </li>
   <li>
      <strong>getFormElementsByTagName():</strong> Liefert eine Liste von Formular-Elementen an
      Hand des Tag-Namens (z.B. <em>form:text</em>).
   </li>
   <li>
      <strong>getFormElementsByObjectID():</strong> Liefert ein Formular-Element an Hand seiner
      internen ObjektID. Diese Vorgehensweise kann bei der Generierung von dynamischen Formularen
      angewendet werden.
   </li>
</ul>
<br />
<a name="4-1-Auswahl-per-Name"></a><h4>4.1. Auswahl per Name</h4>
Sollen die im Formular des Kapitels 3.2.2. beschriebenen Felder zum Abspeichern des Formulars
ausgelesen werden, kann dies mit Hilfe des folgenden Controller-Codes erreicht werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');

      if($form->isSent() && $form->isValid()){

         $code = &$form->getFormElementByName('code');
         echo 'product code: '.$code->getAttribute('value');

         $title = &$form->getFormElementByName('title');
         echo 'product title: '.$title->getAttribute('value');

         $description = &$form->getFormElementByName('description');
         echo 'product desc: '.$description->getContent();
      }
      
   }
}
</php:highlight>
<div class="hint">
   Bei Textareas wird der Inhalt nicht im Attribut <strong>value</strong> gespeichert, sondern
   im Inhalt des Tags. Dies entspriche exakt der Vorgehensweise der Tag-Definition in HTML.
</div>
<br />
Da das Formular nichts anderes darstellt als einen DOM-Baum von Formular-Elementen, kann ein
Platzhalter in einem Error-Tag &uuml;ber zwei Stufen adressiert werden. Zu erst wird die Instanz des
Error-Tags bezogen und von dort der Platzhalter. Als Beispiel nutzen wir folgendes Formular:
<code:highlight>
&lt;html:form name="product-form"&gt;
   &lt;form:error name="error"&gt;
      &lt;error:placeholder name="ph1" /&gt;
   &lt;/form:error&gt;
   ...
&lt;/html:form&gt;
</code:highlight>
Um nun den Platzhalter innerhalb des <strong>&lt;form:error /&gt;</strong>-Tags zu f&uuml;llen, kann
folgender Controller-Code genutzt werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $error = &$form->getFormElementByName('error');

      // simple way:
      $error->setPlaceHolder('ph1','My placeholder value');

      // alternative way:
      $placeHolder = $error->getFormElementByName('ph1');
      $placeHolder->set('Content','My placeholder value');
   }
}
</php:highlight>
<div class="hint">
   Um ein Formular-Element per ID auszuw&auml;hlen, kann die gleiche Vorgehensweise wie bei der Auswahl
   nach Name verwendet werden.
</div>
<br />
<br />
<a name="4-2-Auswahl-per-Tag"></a><h4>4.2. Auswahl per Tag</h4>
In manchen F&auml;llen kann es n&uuml;tzlich sein, die gew&uuml;nschten Formular-Elemente per Tag-Namen zu
selektieren. Hierzu steht die Methode <strong>getFormElementsByTagName()</strong> zur Verf&uuml;gung.
Diese liefert eine Liste mit Referenzen auf Formular-Elemente des &uuml;bergebenen Tag-Namens.
<br />
<br />
Im Zusammenspiel mit dem
<a href="./?Seite=063-Generischer-OR-Mapper#4-3-Speichern-von-Objekten" title="GenericORMapper - Speichern von Objekten">GenericORMapper</a>
kann die Methode genutzt werden um Formular-Felder auszulesen und direkt in ein
<strong>GenericDomainObject</strong> zu speichern. Hierzu kann folgender Code genutzt werden:
<php:highlight>
class edit_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('...');
      $textFields = &$form->getFormElementsByTagName('form:text');
      $user = new GenericDomainObject('User');
      $count = count($textFields);
      for($i = 0; $i < $count; $i++){
         $user->setProperty(
            $textFields[$i]->getAttribute('name'),
            $textFields[$i]->getAttribute('value')
         );
      }
   }
}
</php:highlight>
Bei der Anwendung ist zu beachten, dass die Methode jeweils nur diejenigen Elemente zur&uuml;ckliefert,
die ausgehend vom verwendeten Element, als direkte Kind-Knoten vorhanden sind.
<br />
<br />
<br />
<a name="5-Manipulation-von-Formularen"></a><h3>5. Manipulation von Formularen</h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige M&ouml;glichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen h&auml;ufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<a name="5-1-Vorbefuellung"></a><h4>5.1. Vorbef&uuml;llung von Formularen</h4>
Zur Vorbef&uuml;llung von Formularen (z.B. in einem Bearbeiten-Dialog) k&ouml;nnen Methoden
<ul>
   <li><strong>getFormElementByName()</strong>,</li>
   <li><strong>getFormElementByTagName()</strong>,</li>
   <li><strong>getFormElementByID()</strong> oder</li>
   <li><strong>getFormElementByObjectID()</strong></li>
</ul>
eingesetzt werden um eine Referenz auf ein Formular-Element zu beziehen. Anschlie&szlig;end stehen
die Standard-Methoden
<ul>
   <li><strong>get()</strong> und</li>
   <li><strong>getAttribute()</strong></li>
</ul>
bzw.
<ul>
   <li><strong>set()</strong> und </li>
   <li><strong>setAttribute()</strong></li>
</ul>
zur Verf&uuml;gung.
<br />
<br />
Die folgenden Codebox definiert ein Beispiel-Formular, das im anschlie&szlig;end abgedruckten
PHP-Code bef&uuml;llt wird:
<br />
<br />
<u>Template:</u>
<code:highlight>
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="UserEdit" method="post"&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</code:highlight>
<u>Controller:</u>
<php:highlight>
$form = &$this->__getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
$userID->setAttribute('value','...');

$firstName = &$form->getFormElementByName('FirstName');
$fFirstName->setAttribute('value','...');

$lastName = &$form->getFormElementByName('LastName');
$lastName->setAttribute('value','...');
</php:highlight>
<br />
<a name="5-2-Befuellen-von-Select-Feldern"></a><h4>5.2. Bef&uuml;llen von Select-Feldern</h4>
Die Behandlung Select- und Multiselect-Feldern unterscheidet sich ein wenig von einfachen
Formular-Elementen. Das Framework stellt jedoch auch hier Methoden zur Verf&uuml;gung, mit denen das
Bef&uuml;llen von Feldern vereinfacht wird. Im nachfolgend aufgef&uuml;hrten Code wird ein Formular
vorausgef&uuml;llt, das zus&auml;tzlich zu den Standard-Text-Felder auch Auswahlfelder beinhaltet:
<code:highlight>
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="UserCreate" method="post"&gt;
   &lt;strong&gt;Salutation&lt;/strong&gt;:
   &lt;form:select name="Salutation" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;strong&gt;Salutation&lt;/strong&gt;:
   &lt;br /&gt;
   &lt;form:multiselect name="Group" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</code:highlight>
Der folgende PHP-Code bef&uuml;llt das Formular:
<php:highlight>
$form = &$this->__getForm('UserCreate');
$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['Value'],$salutations[$i]['DisplayName']);
}
$goups = array(...);
$group = &$form->getFormElementByName('Groups');
for($i = 0; $i < count($groups); $i++){
   $Group->addOption($groups[$i]['Value'],$groups[$i]['DisplayName']);
}
</php:highlight>
<div class="hint">
   Sollen beim Bef&uuml;llen eines Multiselect-Feldes bestimmte Optionen bereits vorausgew&auml;hlt
   sein, so kann die Methode <strong>setOption2Selected()</strong> verwendet werden.
</div>
<br />
Der folgende Code zeigt, wie ein Multiselect-Feld zun&auml;chst mit Berechtigungen gef&uuml;llt und
anschlie&szlig;end gem&auml;&szlig; den Applikationsinformationen vorselektiert wird. Das Beispiel
ist aus dem im Release mitgelieferten
<a href="./?Seite=095-Module-Usermanagement" title="Usermanagement-Modul">Usermanagement-Modul</a>
entnommen.
<php:highlight>
$form = &$this->__getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</php:highlight>
<br />
<a name="5-3-Auslesen-von-Formular-Elementen"></a><h4>5.3. Auslesen von Formular-Elementen</h4>
Das Auslesen von Formular-Elementen gestaltet sich &auml;hnlich wie das Bef&uuml;llen. Eine
Besonderheit stellen auch hier die Einfach- und Mehrfachselektionsfelder dar. Das folgende Code-Beispiel
zeigt, wie die Werte des unter 3.1 dargestellten Formulars im DocumentController ausgelesen werden
k&ouml;nnen:
<php:highlight>
$form = &$this->__getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
echo $userID->getAttribute('value');

$firstName = &$form->getFormElementByName('FirstName');
echo $firstName->getAttribute('value');

$lastName = &$form->getFormElementByName('LastName');
echo $lastName->getAttribute('value');
</php:highlight>
Um die selektierten Optionen eines Einfach- oder Mehrfachselektionsfeldes auszulesen, stehen die
Methoden <strong>getSelectedOption()</strong> und <strong>getSelectedOptions()</strong> zur
Verf&uuml;gung. Die folgende Codebox zeigt den Anwendungsfall:
<php:highlight>
$form = &$this->__getForm('UserCreate');

$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['Value'],$salutations[$i]['DisplayName']);
}

$option = &$salutation->getSelectedOption();
echo $option->getAttribute('value').', '.$option->get('Content');

$groups = array(...);
$group = &$form->getFormElementByName('Groups[]');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['Value'],$groups[$i]['DisplayName']);
}

$selectedGroups = &$group->getSelectedOptions();
for($i = 0; $i < count($selectedGroups); $i++){
   echo $selectedGroups[$i]->getAttribute('value').', '.$selectedGroups[$i]->get('Content');
}
</php:highlight>
<br />
<a name="6-Dynamische-Formulare"></a><h3>6. Dynamische Formulare</h3>
In einigen Anwendungsf&auml;llen ist es notwenig, Formulare dynamisch nach Anforderung zu erstellen.
Hierzu besitzt die Implementierung der Formular-TagLib (<em>html_taglib_form</em>) die Methoden
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
und seit dem Release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
an. Die ersten beiden Funktionen lassen sich dazu nutzen, Inhalte oder konkrete Formular-Elemente
an das Ende des Formulars anzuh&auml;ngen. Die zu letzt genannten Methoden sind dazu gedacht, Inhalte
oder Formular-Elemente an konkreten Stellen zu platzieren. Zur Positionierung steht das
<strong>&lt;form:marker /&gt;</strong>-Tag zur Verf&uuml;gung. Das Tag selbst generiert keine Ausgabe,
sondern dient lediglich als Positionierungshilfe.
<br />
<br />
Die folgenden Kapitel sollen zeigen, wie ein dynamisches Formular zur Eingabe von Form-Koordinaten
(Dreieck, Quadrat, ...) realisiert werden kann. Je nach Auswahl des Typs sollen die jeweils notwenigen
Felder angezeigt werden. Bei Auswahl des Typs "square" werden vier Felder angezeigt ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs square" />
<br />
<br />
... und bei Auswahl von "triangle" drei:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs triangle" />
<br />
<br />
<br />
<a name="6-1-Formular-Definition"></a><h4>6.1. Formular-Definition</h4>
Bei der Definition des Formulars sollte bereits bedacht werden, welche Art der Formular-Generierung
angestrebt wird. Kommen die Methoden <em>addFormElement()</em> und/oder <em>addFormContent()</em>
zum Einsatz, ist keinen Marker erforderlich. In diesem Beispiel wird jedoch ein Marker eingesetzt, da
das Formular bereits Inhalte besitzt, die nach den dynamisch erzeugten Elementen angezeigt werden
sollen.
<br />
<br />
Die folgende Code-Box zeigt das notwenige Formular mit einem Auswahlfeld. Bei der Implementierung
wurde auf CSS-Formatierung verzichtet um die wesentlichen Elemente besser hervorheben zu k&ouml;nnen.
Das Formular besteht dabei aus einem statisch definierten Auswahlfeld, das den Typ der geometrischen
Form vorgibt und aus einem Marker-Tag, der als Positionierungshilfe f&uuml;r die dynamisch erzeugten
Felder dient. Weiterhin wird ein DocumentController definiert, der die gew&uuml;nschten Felder
dynamisch an der Stelle des Markers hinzuf&uuml;gt:
<code:highlight>
&lt;@controller namespace="..." file="..." class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="6-2-Controller"></a><h4>6.2. Controller</h4>
Der DocumentController &uuml;bernimmt im beschriebenen Beispiel die Generierung der abh&auml;ngigen
Formularfelder, die je nach Auswahl angezeigt werden sollen. Hierzu wird im Controller zun&auml;chst
definiert, welche Formular-Felder f&uuml;r welchen Typ angezeigt werden. Anschlie&szlig;end wird
das Typ-Feld ausgewertet und das Formular mit Inhalten und Text-Feldern gem&auml;&szlig; Typ
erg&auml;nzt. Die folgende Code-Box zeigt die Implementierung des DocumentControllers:
<php:highlight>
class select_controller extends baseController {

   // specify form element container
   var $__FormElements = array();

   function select_controller(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

   }

   function transformContent(){

      // get form reference
      $form = &$this->__getForm('type');

      // get current decision
      $Select = &$form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
      }
      else{
         $CurrentType = $Option->getAttribute('value');
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $currentElementID = $form->addFormElementBeforeMarker(
                                'fields',
                                'form:text',
                                array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                             );

         // configure further form element attributes
         $currentElement = &$form->getFormElementByObjectID($currentElementID);
         $currentElement->setAttribute('style','width: 200px;');

         // add a line break
         $form->addFormContentBeforeMarker('fields','<br />');

      }

      // display form
      $form->transformOnPlace();

   }

}
</php:highlight>
<br />
<a name="6-3-Dynamische-Filter-und-Validatoren"></a><h4>6.3. Dynamische Filter und Validatoren</h4>
Mit dem <strong>Release 1.10</strong> wurde das Konzept der Filter und Validatoren &uuml;berarbeitet.
Dies wirkt sich auch auf die Definition von dynamischen Formular-Elementen mit Filtern und
Validatoren aus.
<br />
<br />
Wie im Kapitel
<a href="./?Seite=113-Formulare#4-2-Aufbau-von-Validatoren" title="Aufbau von Validatoren">Aufbau von Validatoren</a>
und
<a href="./?Seite=113-Formulare#5-2-Aufbau-von-Filtern" title="Aufbau von Filtern">Aufbau von Filtern</a>
besprochen wurde, werden Validatoren und Filter als <strong>Observer</strong> an Formular-Elemente
geheftet. Bei dynamischen Formularen kann durch &quot;Simulation&quot; der
<strong>&lt;form:addvalidator /&gt;</strong>- und <strong>&lt;form:addfilter /&gt;</strong>-Tags
ebenso verfahren werden. F&uuml;r die konkrete Anwendung bedeutet das, dass nach der Definition eines
dynamischen Formular-Feldes der gew&uuml;nschte Validator oder Filter &uuml;ber die Methoden
<strong>addValidator()</strong> bzw. <strong>addFilter()</strong> angeheftet werden kann. Dies
gestaltet sich in Code ausgedr&uuml;ckt im Kontext des in den letzten Kapiteln besprochenen
Beispiels wie folgt:
<php:highlight>
// gather button instance of the form
$button = &$form->getFormElementByName('submit');

// create dynamic form elements
for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

   // add label
   $form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

   // add text field (name attribute is present to enable validation and presetting!)
   $currentElementID = $form->addFormElementBeforeMarker(
                           'fields',
                           'form:text',
                           array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                       );

   // configure further form element attributes
   $currentElement = &$form->getFormElementByObjectID($currentElementID);
   $currentElement->setAttribute('style','width: 200px;');

   // add filter to the current element
   $filter = new NoSpecialCharactersFilter($currentElement,$button);
   $currentElement->addFilter($filter);

   // add validator to the current element
   $validator = new TextLengthValidator($currentElement,$button);
   $currentElement->addValidator($validator);

   // add a line break
   $form->addFormContentBeforeMarker('fields','<br />');

}
</php:highlight>
<div class="hint">
   Bei der Definition von dynamischen Validatoren und Filtern muss die Reihenfolge beachtet werden.
   Damit keine unerw&uuml;nschten Validierungs-Ergebnisse auftreten, m&uuml;ssen Filter stets 
   <u>vor</u> Validatoren ausgef&uuml;hrt werden.
</div>
<br />
<br />
<a name="6-4-Weitere-Hinweise"></a><h4>6.4. Weitere Hinweise</h4>
Ein APF-Formular-Element ben&ouml;tigt bereits bei der Erstellung des Objekts die Information &uuml;ber
den Namen des Feldes. Ist dieser nicht bekannt, kann es nicht vorausgef&uuml;llt oder validiert werden.
Um die Presetting und Validierung von Formular-Elementen nutzen zu k&ouml;nnen besitzen die Methoden
<em>addFormElement()</em>, <em>addFormElementBeforeMarker()</em> und <em>addFormElementBeforeMarker()</em>
einen optionalen, dritten Parameter. Dieser erwartet eine assoziative Liste von Tag-Attributen, die
dem Formular-Tag bei der Erstellung mitgegeben werden. Es daher sinnvoll, der Methode mindestens
den Namen des Feldes in der Form
<code:highlight>
array(
      'name' => 'current_name'
     )
</code:highlight>
als drittes Argument mitzugeben. Dies kann unter Umst&auml;nden auch f&uuml;r die sp&auml;tere
Adressierung der Objekte &uuml;ber die Methoden <em>getFormElementByName()</em> und
<em>getFormElementByID()</em> von Interesse sein.
<br />
<br />
<br />
<a name="7-Erweiterung-von-Formular-Elementen"></a><h3>7. Erweiterung von Formular-Elementen</h3>
Das APF-Konzept des Page-Controllers erlaubt es, eigene Taglibs zu schreiben um wiederverwendbare
Elemente zu schaffen. Dies setzt sich auch bei den Formularen fort. Eigene Formular-Elemente
k&ouml;nnen bequem mit dem <strong>&lt;form:addtaglib /&gt;</strong>-Tag, dessen Funktion identisch
zum <strong>&lt;core:addtaglib /&gt;</strong> ist, in ein bestehendes Formular eingebunden werden.
<br />
<br />
Die Besonderheit der Formular-Taglibs bzw. Formular-Elemente ist, dass diese die abstrakte Klasse
<strong>form_control</strong> implementieren. Sie gen&uuml;gen damit einem erweiterten Tag-Interface,
das vom <strong>&lt;html:form /&gt;</strong>-Tag behandelt werden kann. Die Erweiterung des
Funktions-Umfangs besteht insbesondere in der Validierung und Filterung.
<br />
<br />
Die folgenden drei Kapitel beschreiben die Erstellung von eigenen Formular-Elementen, Validatoren
und Filter und geben Beispiele f&uuml;r die Implementierung.
<br />
<br />
<br />
<a name="7-1-Formular-Felder"></a><h4>7.1. Formular-Felder</h4>
Wie bereits angedeutet, ist eine Formular-Element im APF durch die abstrakten Basis-Klasse
<strong>form_control</strong> definiert. Um ein neues Formular-Element zu implementieren, muss diese
nun um die gew&uuml;nschten Funktionen erweitert werden.
<br />
<br />
Als Beispiel soll im Folgenden ein Formular-Element besprochen werden, das zum Schutz eines
Formulars ein verstecktes Text-Feld erzeugt und das im darauffolgenden Kapitel mit einem speziellen
Validator belegt werden kann. Ist das Feld gef&uuml;llt, ist davon auszugehen, dass es sich um eine
automatisierte Anfrage handelt. Ist das Feld nicht gef&uuml;llt, wird das Formular als valide
betrachtet, sofern alle anderen Felder ebenfalls valide sind. In diversen Blog-Eintr&auml;gen werden
diese Art von Felder auch als
<a href="http://nedbatchelder.com/text/stopbots.html" title="Stopping spambots with hashes and honeypots" target="_blank">honeypot fields</a>
bezeichnet.
<br />
<br />
Beginnen wir zun&auml;chst mit dem Rumpf des Elements. Wie zuvor beschrieben soll ein Text-Feld
ausgeben werden, das via CSS versteckt wird. Um diese Funktion zu gew&auml;hrleisten, muss das neue
Formular-Element bei der Transformation die entsprechende HTML-Ausgabe zur&uuml;ckliefern:
<php:highlight>
class form_taglib_honeypot extends form_control {
   public function transform(){
      $htmlCode  = (string)'&lt;input ';
      $htmlCode .= $this->__getAttributesAsString($this->__Attributes);
      $htmlCode .= 'type="text" ';
      $htmlCode .= 'style="margin: 0px; padding: 0px; display: none; height: 0px; width: 0px;"';
      $htmlCode .= ' /&gt;';
      return $htmlCode;
   }
}
</php:highlight>
Da die R&uuml;ckgabe des Validit&auml;ts-Status, die M&ouml;glichkeit Validatoren und Filter
anzuheften und Presetting der eingegebenen Werte beim Absenden bereits in der Klasse
<strong>form_control</strong> enthalten ist, stellt die oben gezeigte Klasse bereits den
vollst&auml;ndig Funktionsumfang dar.
<br />
<br />
Um das neue Element in einem Formular verwenden zu k&ouml;nnen, muss dieses mit Hilfe des
<strong>&lt;form:addtaglib /&gt;</strong>-Tags im Formular bekannt gemacht werden:
<code:highlight>
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="CheckedForm"&gt;
   ...
   &lt;form:addtaglib namespace="..." prefix="form" class="honeypot" /&gt;
   &lt;form:honeypot name="check" /&gt;
   ...
&lt;/html:form&gt;
</code:highlight>
Die eigentliche Funktionalit&auml;t des <strong>honepot field</strong> steckt in der Validierung.
Diese wird im n&auml;chsten Kapitel besprochen.
<br />
<br />
<br />
<a name="7-2-Validatoren"></a><h4>7.2. Validatoren</h4>
Validatoren werden ab dem Release <strong>1.11</strong> von Formular-Elementen getrennt
definiert und diesen als Observer mitgegeben. Um diesen Mechanismus zu unterst&uuml;tzen, muss das
Formular-Element jedoch darauf vorbereitet sein. Im Fall des im vorangegangenen Kapitels
beschriebenen Honeypot-Feldes ist die Validierungs-Funktionalit&auml;t bereits durch die
Basis-Klasse <strong>form_control</strong> definiert. Bei der Validierung wird dem Validator der
Inhalt des Attributs <strong>value</strong> &uuml;bergeben und dieser kann entsprechend darauf
reagieren.
<br />
<br />
Der zu erstellende <strong>HoneypotValidator</strong> ist im Wesentlichen ein Text-Feld-Validator,
daher kann die im APF-Release enthaltene Klasse <strong>TextFieldValidator</strong> als Basis
f&uuml;r die Implementierung verwendet werden. Diese leitet von
<strong>AbstractFormValidator</strong> ab, der Basis-Klasse f&uuml;r alle Formular-Validatoren.
<br />
<br />
Jeder Validator implementiert die Methode <strong>validate()</strong>, die den zu validierenden
Inhalt entgegen nimmt. In unserem Fall erh&auml;lt die Funktion den Inhalt des Honeypot-Feldes.
Dieses muss im Positiv-Fall leer sein, sofern dort Zeichen enthalten ist, muss das Feld als invalid
gekennzeichnet werden. Hierzu kann folgender Code verwendet werden:
<php:highlight>
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }
   ...
}
</php:highlight>
Da die Klasse <strong>TextFieldValidator</strong> bereits die Benachrichtigung eines &quot;echten&quot;
Text-Feldes &uuml;bernimmt wird das Feld im Fehlerfall mit einem roten Rahmen versehen. Dies ist im
aktuellen Anwendungsfall nicht erforderlich und muss daher unterdr&uuml;ckt werden. Hierzu
&uuml;berschreiben wir die Methode <strong>notify()</strong> der Klasse
<strong>TextFieldValidator</strong>, die aufgerufen wird, sofern ein Feld nicht erfolgreich
validiert werden konnte:
<php:highlight>
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }

   public function notify(){
      $this->__Control->markAsInvalid();
      $this->__Control->notifyValidationListeners();
   }
}
</php:highlight>
Die Methode enth&auml;lt im Gegensatz zur Implementierung in der Klasse
<strong>TextFieldValidator</strong> die Zeile
<php:highlight>
$this->__Control->addAttribute('style','; border: 2px solid red;');
</php:highlight>
nicht. Damit haben wir das Markieren des fehlerhaften Formular-Feldes durch einen roten Rahmen
ausgeschaltet.
<br />
<br />
Die Anwendung des Validators gestaltet sich dann im Zusammenhang mit dem Honeypot-Textfeld wie folgt:
<code:highlight>
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="CheckedForm"&gt;
   &lt;form:addtaglib namespace="..." prefix="form" class="honeypot" /&gt;
   &lt;form:honeypot name="check" /&gt;
   &lt;form:addvalidator
      namespace="..."
      class="HoneypotValidator"
      control="check"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</code:highlight>
Der Validator kann durch die eigentst&auml;ndige Definition auch auf andere Text-Felder angewendet
werden, die Text-Validierung unterst&uuml;tzen. Hierzu z&auml;hlen alle im Release mitgelieferten
Text- und Text-Area-Taglibs.
<br />
<br />
<br />
<a name="7-3-Filter"></a><h4>7.3. Filter</h4>
F&uuml;r das Honeypot-Feld wird kein Validator ben&ouml;tigt. Aus diesem Grund soll in diesem
Kapitel ein Filter implementiert werden, mit dem deutsche Umlaute durch die Laut-Entsprechungen
(z.B. &auml; -> ae) ersetzt werden.
<br />
<br />
Der <strong>GermanUmlautsFilter</strong> implementiert dabei die Klasse
<strong>AbstractFormFilter</strong> - die wie der <strong>AbstractFormValidator</strong> bei den
Validatoren - das Interface eines Formular-Filters beschreibt.
<br />
<br />
Jeder Filter implementiert dabei gem&auml;&szlig; der
<a href="./?Seite=087-Filter#4-Aufbau-und-Funktion" title="Aufbau und Funktion von Filtern">Filter-API</a>
die Methode <strong>filter()</strong>. Diese nimmt den zu filternden Inhalt entgegen, f&uuml;hrt
die gew&uuml;nschte Funktion aus und gibt den gefilterten Inhalt wieder zur&uuml;ck.
<br />
<br />
Das Grundger&uuml;st des Filters kann damit durch folgenden Code beschrieben werden:
<php:highlight>
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return $input;
   }
}
</php:highlight>
Die Funktionalit&auml;t des Filters besteht aus einem einfachen Aufruf der Funktion
<strong>str_replace()</strong>:
<php:highlight>
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return str_replace(
         array('&auml;','&ouml;','&uuml;','&Auml;','&Ouml;','&Uuml;','&szlig;'),
         array('ae','oe','ue','Ae','Oe','Ue','ss'),
         $input
      );
   }
}
</php:highlight>
Die Anwendung des Filters gestaltet sich dann im Zusammenhang mit einem Text-Feld oder einer
Text-Area wie folgt:
<code:highlight>
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="UmlautsForm"&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:area name="comment" /&gt;
   &lt;form:addfilter
      namespace="..."
      class="GermanUmlautsFilter"
      control="name|comment"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_114" />