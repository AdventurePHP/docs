<doku:title tags="forumlare,forums,aufbau,validierung,manipulation,befuellung,auslesen,dynamische formulare,controller" title="Verwendung von Formularen (ab Version 1.11)" urlname="Verwendung-von-Formularen">
  Diese Dokumentationsseite beschreibt den Aufbau und die Verwendung von Formularen so wie die
  M&ouml;glichkeiten, die sich aus dem APF-Form-Modell ergeben. Dazu z&auml;hlen die Validierung und
  das Vorausf&uuml;llen sowie die M&ouml;glichkeit, Formular-Elemente (=Objekte) im Controller zu
  Manipulieren, zu bef&uuml;llen oder diese auszulesen. In einem weiteren Kapitel wird beschrieben,
  wie dynamische Formulare erstellt werden k&ouml;nnen.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
Das Adventure PHP Framework beinhaltet eine sehr umfangreiche Formular-Unterst&uuml;tzung die auf dem
Taglibs-Konzept basiert. Die Grundlagen und vorhandenen Taglibs sind im Abschnitt
<a href="./?Seite=113-Formulare" title="Formulare">Formulare</a> beschrieben. Dieses Kapitel
besch&auml;ftigt sich nun mit der Verwendung von Formularen, der dynamischen Formular-Generierung
und der Erweiterung der Formular-Taglibs.
<br />
<br />
<br />
<a name="1-Formulare-und-Controller"></a><h3>1. Formulare &amp; Controller</h3>
Formulare sind - genau wie Template-Fragmente - Elemente, die im DOM-Baum existieren, jedoch bei der
Transformation nicht automatisch ausgegeben werden. Hierzu bedarf es eines Document-Controller. Der
Grund daf&uuml;r ist simple: nahezu jedes Formular ist an Aktionen geknüpft, die mit dem Absenden
des Formulars ausgeführt werden sollen (z.B. Speichern der Daten).
<br />
<br />
Um ein Formular mit Hilfe eines Document-Controller auszugeben, ist folgender Code notwendig:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('Search');
      $form->transfromOnPlace();
   }
}
</php:highlight>
In der Variable <strong>$form</strong> steht dabei eine Instanz der Klasse
<strong>html_taglib_form</strong> zur Verfügung, die ein APF-Formular mit all seinen Elementen und
Funktionen kapselt. Mit Hilfe dieser Referenz auf das Formular-Objekt im DOM-Baum kann das Formular
ausgegeben, manipuliert, befüllt und angepasst werden. Details dazu können den folgenden Kapiteln
entnommen werden.
<br />
<br />
<br />
<a name="2-API-der-Formular-Taglibs"></a><h3>2. API der Formular-Taglibs</h3>
Im vorangegangenen Abschnitt wurde beschrieben, wie ein Formular in einem Document-Controller
referenziert werden kann. In diesem Kapitel beschäftigen wir uns nun mit der API der
Formular-Taglibs, die Aufschluss darüber gibt, welche Möglichkeiten die Formular-Integration des
APF bietet.
<br />
<br />
<div class="hint">
   Für die Entwicklung ist es stets ratsam, die
   <a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
   der eingesetzten Version parallel zur Entwicklungsumgebung geöffnet zu haben. Dies erleichtert
   die Arbeit, da jede Taglib ihre eigene API mitbringt, die in der API-DOkumentation genau
   beschrieben ist.
</div>
<br />
Grundlage für alle Formular-Elemente ist die Klasse <strong>form_control</strong>. Diese
implementiert Basis-Funktionalitäten für alle konkreten Formular-Elemente und definiert die
Struktur eines Formular-Elements. Da die Formular-Elemente als Taglibs ausgeführt sind, unterliegen
sie dem
<a href="./?Seite=098-Pagecontroller#2-1-Ablaufdiagramm" title="Lifecycle des Page-Controllers">Lifecycle des Page-Controllers</a>.
Das bedeutet, dass sie darüber hinaus alle Methoden einer &quot;normalen&quot; Taglib
implementieren müssen.
<br />
<br />
<div class="hint">
   Im Gegensatz zu den Formular-Taglibs <strong>bis Version 1.10</strong>, kennen die
   Formular-Elemente <strong>ab Version 1.11</strong> ihren Validitäts-Status selbst. Damit kann
   jedes Element nach seinem Status gefragt werden. Für das Formular selbst bedeutet das, dass die
   Methode <strong>isValid()</strong> den Status von jedem Element abfragt und daraus einen
   kumulierten Wert erzeugt.
</div>
<br />
Die Klasse <strong>form_control</strong> implementierten folgende Methoden:
<ul>
   <li>
      <strong>isValid():</strong> Die Funktion ermöglicht es, den Validitäts-Status der
      Formular-Elements abzufragen. Intern oder auch von aussen.
   </li>
   <li>
      <strong>markAsInvalid():</strong> Markiert ein Element als invalid.
   </li>
   <li>
      <strong>markAsSent():</strong> Markiert ein Element als abgesendet (relevant für Formulare
      und Buttons).
   </li>
   <li>
      <strong>isSent():</strong> Prüft, ob ein Formular abgesendet wurde!
   </li>
   <li>
      <strong>isChecked():</strong> Gibt zurück, ob eine Checkbox angehakt wurde oder nicht.
   </li>
   <li>
      <strong>check():</strong> Hakt eine Checkbox an.
   </li>
   <li>
      <strong>uncheck():</strong> Deaktiviert eine Checkbox.
   </li>
   <li>
      <strong>addFilter():</strong> Fügt einen Filter zu einem Element hinzu.
   </li>
   <li>
      <strong>addValidator():</strong> Fügt einen Validator zu einem Element hinzu.
   </li>
   <li>
      <strong>addAttribute():</strong> Kann genutzt werden, um zu einem Attribut eines Tags weiteren
      Inhalt hinzuzufügen. Dies wird beim Benachrichtigen eines Formular-Elements innerhalb der 
      Validierung genutz.
   </li>
   <li>
      <strong>notifyValidationListeners():</strong> Benachrichtigt alle Listener eines
      Formular-Elements, dass dieses invalid ist.
   </li>
   <li>
      <strong>__presetValue():</strong> Die Methode stellt Presetting von Formular-Elementen für
      einfache Text-Felder zur Verfügung. Diese kann bei der Erweiterung von Formular-Elementen
      entweder mit einer eigenen Logik überschrieben oder direkt genutzt werden.
   </li>
   <li>
      <strong>setPlaceHolder():</strong> Die Methode implementiert eine generische Funktion zum
      setzen eines Platzhalters in einem Formular-Element. Wichtig hierbei ist, dass das Kind-Tag
      <strong>*:placeholder</strong> hei&szlig;t.
   </li>
</ul>
Mit Hilfe dieser Funktionen wird der Entwickler darin untrstützt, eigene Formular-Elemente zu
erstellen. Mehr dazu in Kapitel 7.
<br />
<br />
<br />
<a name="3-Validierung"></a><h3>3. Validierung</h3>
Die Validierung von Formular-Elementen wird über die Taglib <strong>form:addvalidator</strong>
und die Implementierung der Validatoren auf das Klick-Event eines Buttons ausgeführt. Zeitlich
gesehen erfolgt die Validierung bei der Ausführung der <strong>onAfterAppend()</strong>-Methode.
Das ist nach der Analyse-Phase (hier wird die Methode <strong>onParseTime()</strong> jeder Taglib
ausgeführt) und damit steht der DOM-Baum der Formular-Elemente vollständig zur Verfügung.
<br />
<br />
In der <strong>onAfterAppend()</strong>-Methode des <strong>form:addvalidator</strong>-Tags wird
dann der Validator erzeugt, mit den notwendigen Informationen (Button und Formular-Control)
ausgestattet und dem Element übergeben. Das Element führt den Validator dann bei aktivem Status
aus und prüft das Ergebnis. Im Negativfall wird die <strong>notify()</strong>-Methode des
Validators aufgerufen.
<br />
<br />
<br />
<a name="3-1-Abfragen-des-Validierungs-Status"></a><h4>3.1. Abfragen des Validierungs-Status</h4>
Damit ist sichergestellt, dass zum Zeitpunkt der Transformation der Status des Formulars - der sich
aus den Einzel-Status der Elemente zusammen setzt - bekannt ist. Damit kann nun in einem
Document-Controller wie folgt der Zustand eines Formulars abgefragt werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      if($form->isSent()){
         echo 'Form was send');
      }
      if($form->isValid()){
         echo 'Form is valid';
      }
   }
}
</php:highlight>
Ebenso ist es möglich, den Status eines definierten Elements zu erfragen:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      $searchField = &$form->getFormElementByName('searchterm');
      if($searchField->isValid()){
         echo 'Search field is valid';
      }
   }
}
</php:highlight>
Um den Klick-Status eines Buttons abzufragen, kann folgender Code genutzt werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      $button = &$form->getFormElementByID('button');
      if($button->isSent()){
         echo 'Search button was clicked';
      }
   }
}
</php:highlight>
<div class="hint">
   Weitere Methoden der Formular-Elemente finden sich in der
   <a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
   der Klassen <strong>html_taglib_form</strong>, <strong>form_control</strong> und den Taglibs
   der jeweiligen Formular-Elemente (z.B. <strong>form_taglib_text</strong>).
</div>
<br />
<br />
<a name="3-2-Ausgabe-von-Validator-Fehlermeldungen"></a><h4>3.2. Ausgabe von Validator-Fehlermeldungen</h4>
Bei der Validierung von Formularen werden monierte Felder üblicherweise farblich markiert und der
Benutzer mit einem Hinweistext benachrichtigt. Für diese Aufgaben können die Tags
<strong>&lt;form:error /&gt;</strong> (globale Formular-Fehlermeldungen) und
<strong>&lt;form:listener /&gt;</strong> verwendet werden. Alternativ dazu ist ein Platzhalter-Tag
verfügbar, das im Controller mit einem entsprechenden Wert belegt werden kann.
<br />
<br />
<br />
<a name="3-2-1-Form-Error"></a><h5>3.2.1. Form-Error</h5>
Der <strong>&lt;form:error /&gt;</strong> gibt immer dann seinen Inhalt aus, wenn das Formular nicht
valide ist. Dazu fragt er das Formular bei der Transformation nach seinem Status:
<br />
<br />
<u>Template:</u>
<code:highlight>
&lt;html:form name="product-form"&gt;
   &lt;form:error&gt;Please fill in the mandatory fields!&lt;/form:error&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</code:highlight>
<u>Controller</u>
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $form->transformOnPlace();
   }
}
</php:highlight>
Innerhalb des <strong>&lt;form:error /&gt;</strong>-Tags können gemäß
<a href="./?Seite=113-Formulare#3-19-Error" title="Anzeige von Formular-Fehlern">Anzeige von Formular-Fehlern</a>
noch weitere Tags zur Definition der Inhalte verwendet werden.
<br />
<br />
<br />
<a name="3-2-2-Listener"></a><h5>3.2.2. Listener</h5>
Der <strong>&lt;form:listener /&gt;</strong>-Tag dient dazu Feld-speziefische Fehler anzuzeigen. Wie
in der Einleitung zum Kapitel 3 angesprochen, wird bei fehlgeschlagener Validierung die Methode
<strong>notify()</strong> aufgerufen. Diese benachrichtigt alle Listener, die sich auf das
entsprechende Control registriert haben und diese geben dann bei der Transformation den definierten
Inhalt aus.
<br />
<br />
Im folgenden Beispiel wird bei fehgeschlagener Validierung jeweils eine Feld-spezifische Meldung
angezeigt:
<br />
<br />
<u>Template:</u>
<code:highlight>
&lt;html:form name="product-form"&gt;
   &lt;form:listener control="code"&gt;Please fill in a five letter product code!&lt;/form:listener&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:listener control="title"&gt;Please fill in a title with at least 20 characters!&lt;/form:listener&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:listener control="description"&gt;Please provide a verbose product description!&lt;/form:listener&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</code:highlight>
<u>Controller</u>
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $form->transformOnPlace();
   }
}
</php:highlight>
Innerhalb des <strong>&lt;form:listener /&gt;</strong>-Tags können gemäß
<a href="./?Seite=113-Formulare#3-18-Listener" title="Listener">Listener</a> noch weitere Tags zur
Definition der Inhalte verwendet werden.
<br />
<br />
<br />
<a name="4-Auslesen-von-Formularen"></a><h3>4. Auslesen von Formularen</h3>
Eine häufige Aufgabe beim Handling von Formularen stellt das Auslesen von Werte dar. Hierzu
können im Document-Controller folgende Methoden genutzt werden:
<ul>
   <li>
      <strong>getFormElementByID():</strong> Liefert ein Formular-Element an Hand seiner ID
      (Attribut: <em>id</em>).
   </li>
   <li>
      <strong>getFormElementByName():</strong> Liefert ein Formular-Element an Hand seines Namens
      (Attribut: <em>name</em>).
   </li>
   <li>
      <strong>getFormElementsByTagName():</strong> Liefert eine Liste von Formular-Elementen an
      Hand des Tag-Namens (z.B. <em>form:text</em>).
   </li>
   <li>
      <strong>getFormElementsByObjectID():</strong> Liefert ein Formular-Element an Hand seiner
      internen ObjektID. Diese Vorgehensweise kann bei der Generierung von dynamischen Formularen
      angewendet werden.
   </li>
</ul>
<br />
<a name="4-1-Auswahl-per-Name"></a><h4>4.1. Auswahl per Name</h4>
Sollen die im Formular des Kapitels 3.2.2. beschriebenen Felder zum Abspeichern des Formulars
ausgelesen werden, kann dies mit Hilfe des folgenden Controller-Codes erreicht werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');

      if($form->isSent() && $form->isValid()){

         $code = &$form->getFormElementByName('code');
         echo 'product code: '.$code->getAttribute('value');

         $title = &$form->getFormElementByName('title');
         echo 'product title: '.$title->getAttribute('value');

         $description = &$form->getFormElementByName('description');
         echo 'product desc: '.$description->getContent();
      }
      
   }
}
</php:highlight>
<div class="hint">
   Bei Textareas wird der Inhalt nicht im Attribut <strong>value</strong> gespeichert, sondern
   im Inhalt des Tags. Dies entspriche exakt der Vorgehensweise der Tag-Definition in HTML.
</div>
<br />
Da das Formular nichts anderes darstellt als einen DOM-Baum von Formular-Elementen, kann ein
Platzhalter in einem Error-Tag über zwei Stufen adressiert werden. Zu erst wird die Instanz des
Error-Tags bezogen und von dort der Platzhalter. Als Beispiel nutzen wir folgendes Formular:
<code:highlight>
&lt;html:form name="product-form"&gt;
   &lt;form:error name="error"&gt;
      &lt;error:placeholder name="ph1" /&gt;
   &lt;/form:error&gt;
   ...
&lt;/html:form&gt;
</code:highlight>
Um nun den Platzhalter innerhalb des <strong>&lt;form:error /&gt;</strong>-Tags zu füllen, kann
folgender Controller-Code genutzt werden:
<php:highlight>
class form_controller extends baseController {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $error = &$form->getFormElementByName('error');

      // simple way:
      $error->setPlaceHolder('ph1','My placeholder value');

      // alternative way:
      $placeHolder = $error->getFormElementByName('ph1');
      $placeHolder->setContent('My placeholder value');
   }
}
</php:highlight>
<div class="hint">
   Um ein Formular-Element per ID auszuwählen, kann die gleiche Vorgehensweise wie bei der Auswahl
   nach Name verwendet werden.
</div>
<br />
<br />
<a name="4-2-Auswahl-per-Tag"></a><h4>4.2. Auswahl per Tag</h4>
In manchen Fällen kann es nützlich sein, die gewünschten Formular-Elemente per Tag-Namen zu
selektieren.


<br />
<br />
<br />
<a name=""></a><h3>5. Manipulation von Formularen</h3>

<br />
<br />
<br />
<a name=""></a><h3>6. Dynamische Formulare</h3>

<br />
<br />
<br />
<a name=""></a><h3>7. Erweiterung von Formular-Elementen</h3>



<br />
<br />
<br />

<br />
<br />
<br />
<a name="1-Aufbau-von-Formularen"></a><h3>1. Aufbau von Formularen</h3>
Formulare werden im Framework wie Templates behandelt und sind Kinder eines Baum-Knotens. Mit der
Methode <strong>__getForm()</strong> kann innerhalb eines Document-Controllers auf ein Formular
zugegriffen werden. Das Formular unterst&uuml;tzt folgende wichtige Funktionen:
<ul>
  <li>
    <strong>addFormElement()</strong>
    <br />
    F&uuml;gt ein Formular-Element zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContent()</strong>
    <br />
    F&uuml;gt (HTML-/Text-)Inhalt zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContentBeforeMarker()</strong>
    <br />
    F&uuml;gt (HTML-/Text-)Inhalt vor einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContentAfterMarker()</strong>
    <br />
    F&uuml;gt (HTML-/Text-)Inhalt nach einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormElementBeforeMarker()</strong>
    <br />
    F&uuml;gt ein Formular-Element vor einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormElementAfterMarker()</strong>
    <br />
    F&uuml;gt ein Formular-Element nach einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>setPlaceHolder()</strong>
    <br />
    F&uuml;llt einen angegebenen Platzhalter mit einem Wert.
  </li>
  <li>
    <strong>setAction()</strong>
    <br />
    Setzt das "action"-Attribut des Formulars.
  </li>
  <li>
    <strong>getFormElementByName()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zur&uuml;ck.
  </li>
  <li>
    <strong>getFormElementByID()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zur&uuml;ck.
  </li>
  <li>
    <strong>getFormElementByObjectID()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zur&uuml;ck.
  </li>
  <li>
    <strong>getFormElementsByTagName()</strong>
    <br />
    Gibt eine Liste von Formular-Element-Referenzen zur&uuml;ck, die dem &uuml;bergebenen Tag-Namen
    (z.B. <em>form:text</em>) entsprechen.
  </li>
  <li>
    <strong>transformForm()</strong>
    <br />
    Erzeugt die HTML-Ausgabe eines Formular-Objekts und gibt diese zur&uuml;ck.
  </li>
  <li>
    <strong>transformOnPlace()</strong>
    <br />
    Definiert, dass das Formular an der Stelle, an der es im Template-File definiert wurde ausgegeben
    wird. Damit ist es nicht mehr n&ouml;tigt, das Formular per <em>transformForm()</em> zu transformieren
    und in einen Platzhalter einzusetzen.
  </li>
</ul>
Um ein Formular in einer Template-Datei zu definieren muss zuerst per
<code:highlight>
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
</code:highlight>
<strong>vor</strong> der Verwendung hinzugef&uuml;gt werden. Anschlie&szlig;end kann beispielsweise
ein Formular einer Login-Maske definiert werden:
<code:highlight>
  &lt;html:form name="AdminLogin" method="post" action=""&gt;
    &lt;form:placeholder name="LogInError" /&gt;
    Benutzer: &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    Passwort: &lt;form:password name="Password" class="eingabe_feld" style="width: 200px; margin-left: 16px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="AdminLogin" value="Login" class="eingabe_feld" style="margin-left: 227px;"/&gt;
  &lt;/html:form&gt;
</code:highlight>
In Prosa: das Formular definiert die Attribute <strong>name</strong>, damit im Controller sp&auml;ter
auf dieses zugegriffen werden kann, <strong>method</strong> um die Methode des Abschickens zu
definieren und <strong>action</strong> um die Ziel-URL zu definieren. Letzteres muss in der Template-
Datei nicht zwingend gesetzt werden, da die TagLib dieses selbst mit der aktuellen URL setzt oder
f&uuml;llt, falls es nicht vorhanden ist.
<br />
<br />
Innerhalb des Formulars werden viel Formular-Elemente definiert: ein Platzhalter, f&uuml;r die Aufnahme
von Hinweistexten, ein Text- und ein Passwort-Feld und ein Button. Diese sind jeweils mit den unter
<a href="./?Seite=046-Standard-TagLibs" title="Standard-TagLibs">Standard-TagLibs</a> beschriebenen Attributen
ausgestattet. Im Document-Controller kann nun per
<php:highlight>
$Form__AdminLogin = &$this->__getForm('AdminLogin');
</php:highlight>
eine Referenz auf das Formular geholt werden. Anschlie&szlig;end kann per
<php:highlight>
$Form__AdminLogin->setPlaceHolder('...','Login failed!');
</php:highlight>
der Inhalt des Platzhalters manipuliert oder mit
<php:highlight>
  if($Form__AdminLogin->get('isValid') && $Form__AdminLogin->get('isSent')){

     // Aktion ausführen, die bei abgeschicktem und
     // valide ausgefülltem Formular passieren soll...

   // end if
  }
</php:highlight>
abgefragt werden, ob das Formular abgeschickt wurden und die Eingaben valide sind.
<br />
<br />
Um das Formular auszugeben gibt es zwei M&ouml;glichkeiten: Ausgabe &uuml;ber einen im Template-File
definierten Platzhalter oder Verwendung von <em>transformOnPlace()</em>:
<php:highlight>
   function transformContent(){

      ...

      // Formular transformieren und in einen Platzhalter einsetzen ...
      $this->setPlaceHolder('...',$Form__AdminLogin->transformForm());

      // ... oder das Formular an der Definitionsstelle ausgeben
      $Form__AdminLogin->tranformOnPlace();

      ...

    // end function
   }
</php:highlight>
<br />
<a name="2-Validierung"></a><h3>2. Validierung</h3>
Wie bereits erw&auml;hnt ist die Validierung von Formular-Feldern bereits out-of-the-box m&ouml;glich.
Hierzu muss ein Formular-Feld lediglich um die Attribute
<ul>
  <li>validate</li>
  <li>validator</li>
  <li>button</li>
</ul>
wie unter <a href="./?Seite=046-Standard-TagLibs" title="Standard-TagLibs">Standard-TagLibs</a>, Kapitel 2.3.,
beschrieben, erweitert werden. F&uuml;r die Validierung des oben genannten Login-Formulars muss das
Textfeld wie folgt definiert werden:
<code:highlight>
  &lt;form:text name="Username" validate="true" button="AdminLogin" /&gt;
</code:highlight>
Wichtig ist die Angabe des Button-Namens, da das Formular erst nach dem Abschicken validiert werden
soll. Ist das Button-Attribut nicht gesetzt, wird von der TagLib ein Fehler ausgegeben. Zur
Ausgabe-Formatierung kann dieser Tag um weitere Attribute wie "class" und style" erweitert werden.
<code:highlight>
  &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
  validate="true" button="AdminLogin" /&gt;
</code:highlight>
Ist das Attribut "validator" nicht gesetzt, so wird der Standard-Validator verwendet, der pr&uuml;ft,
ob das Feld exakt oder mehr als 3 Zeichen enth&auml;lt.
<br />
<br />
<div class="hint">
Soll zus&auml;tzlich zu einer roten Umrandung der Felder noch eine Meldung angezeigt werden, so kann
im Bereich des Eingabe-Feldes noch ein zus&auml;tzliches
<a href="./?Seite=046-Standard-TagLibs#2-4-18-Generischer-Validator" title="form:genericval-Tag">&lt;form:genericval /&gt;</a>-Tag
platziert werden. Dieses gibt bei nicht erfolgreicher Validierung des angegebenen Feldes eine Text
aus.
</div>
<br />
<br />
<a name="3-Manipulation-von-Formularelementen"></a><h3>3. Manipulation von Formularwerten</h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige M&ouml;glichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen h&auml;ufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<a name="3-1-Vorbefuellung"></a><h4>3.1. Vorbef&uuml;llung von Formularen</h4>
Zur Vorbef&uuml;llung von Formularen (z.B. in einem Bearbeiten-Dialog) k&ouml;nnen Methoden
<strong>getFormElementByID()</strong>, <strong>getFormElementByID()</strong> oder
<strong>getFormElementByObjectID()</strong> eingesetzt werden um eine Referenz auf ein Formular-Element
zu beziehen. Anschlie&szlig;end stehen die Standard-Methoden <strong>get()</strong> und
<strong>getAttribute()</strong>, bzw. <strong>set()</strong> und <strong>setAttribute()</strong> zur
Verf&uuml;gung.
<br />
<br />
Die folgenden Codebox definiert ein Beispiel-Formular, das im anschlie&szlig;end
abgedruckten PHP-Code bef&uuml;llt wird:
<br />
<code:highlight>
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserEdit" method="post"&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</code:highlight>
<php:highlight>
   // Referenz auf das Form-Objekt beziehen
   $Form__Edit = &$this->__getForm('UserEdit');

   // Referenz auf das Hidden-Feld beziehen und Wert befuellen
   $UserID = &$Form__Edit->getFormElementByName('userid');
   $UserID->setAttribute('value','...');

   // Referenz auf das FirstName-Feld beziehen und Wert befuellen
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   $FirstName->setAttribute('value','...');

   // Referenz auf das LastName-Feld beziehen und Wert befuellen
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   $LastName->setAttribute('value','...');
</php:highlight>
<br />
<a name="3-2-Befuellen-von-Select-Feldern"></a><h4>3.2. Bef&uuml;llen von Select-Feldern</h4>
Die Behandlung Select- und Multiselect-Feldern unterscheidet sich ein wenig von einfachen
Formular-Elementen. Das Framework stellt jedoch auch hier Methoden zur Verf&uuml;gung, mit denen das
Bef&uuml;llen von Feldern vereinfacht wird. Im nachfolgend aufgef&uuml;hrten Code wird ein Formular
vorausgef&uuml;llt, das zus&auml;tzlich zu den Standard-Text-Felder auch Auswahlfelder beinhaltet:
<code:highlight>
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserCreate" method="post"&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;form:select name="Salutation" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;br /&gt;
    &lt;form:multiselect name="Group[]" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</code:highlight>
Wie in der Definition des Multiselect-Feldes <strong>Groups[]</strong> zu sehen ist, m&uuml;ssen bei
einem Multiselect-Feld die Namen eckigen Klammern versehen werden. Vergisst der Template-Entwickler
dies, wird eine entsprechende Fehlermeldung ausgegeben.
<br />
<br />
Der folgende PHP-Code bef&uuml;llt das Formular:
<php:highlight>
   // Referenz auf das Form-Objekt beziehen
   $Form__Create = &$this->__getForm('UserCreate');

   ...

   // Referenz auf das Salutation-Feld beziehen und Wert befuellen
   $Salutation = &$Form__Create->getFormElementByName('Salutation');

   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }


   // Referenz auf das Groups[]-Feld beziehen und Werte befuellen
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   ...
</php:highlight>
<strong>Hinweis:</strong> Sollen beim Bef&uuml;llen eines Multiselect-Feldes bestimmte Optionen
bereits vorausgew&auml;hlt sein, so kann die Methode <strong>setOption2Selected()</strong> verwendet
werden. Der folgende Code zeigt, wie ein Multiselect-Feld zun&auml;chst mit Berechtigungen gef&uuml;llt
und anschlie&szlig;end gem&auml;&szlig; den Applikationsinformationen vorselektiert wird. Das Beispiel
ist aus dem im Release mitgelieferten
<a href="./?Seite=095-Module-Usermanagement" title="Usermanagement-Modul">Usermanagement-Modul</a>
entnommen.
<php:highlight>
// reference the form
$form = &$this->__getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</php:highlight>
<br />
<a name="3-3-Auslesen-von-Formular-Elementen"></a><h4>3.3. Auslesen von Formular-Elementen</h4>
Das Auslesen von Formular-Elementen gestaltet sich &auml;hnlich wie das Bef&uuml;llen. Eine
Besonderheit stellen auch hier die Einfach- und Mehrfachselektionsfelder dar. Das folgende Code-Beispiel
zeigt, wie die Werte des unter 3.1 dargestellten Formulars im DocumentController ausgelesen werden
k&ouml;nnen:
<php:highlight>
   // Referenz auf das Form-Objekt beziehen
   $Form__Edit = &$this->__getForm('UserEdit');

   // Hidden-Feld auslesen
   $UserID = &$Form__Edit->getFormElementByName('userid');
   echo $UserID->getAttribute('value');

   // FirstName-Feld auslesen
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   echo $FirstName->getAttribute('value');

   // LastName-Feld auslesen
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   echo $LastName->getAttribute('value');
</php:highlight>
Um die selektierten Optionen eines Einfach- oder Mehrfachselektionsfeldes auszulesen, stehen die
Methoden <strong>getSelectedOption()</strong> und <strong>getSelectedOptions()</strong> zur
Verf&uuml;gung. Die folgende Codebox zeigt den Anwendungsfall:
<php:highlight>
   // Referenz auf das Form-Objekt beziehen
   $Form__Create = &$this->__getForm('UserCreate');

   // Feld Salutation fuellen
   $Salutation = &$Form__Create->getFormElementByName('Salutation');
   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }

   // Salutation auslesen
   $Option = &$Salutation->getSelectedOption();
   echo $Option->getAttribute('value').', '.$Option->get('Content');


   // Feld Group fuellen
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   // Gruppen auslesen
   $SelectedGroups = &$Group->getSelectedOptions();
   for($i = 0; $i < count($SelectedGroups); $i++){
      echo $SelectedGroups[$i]->getAttribute('value').', '.$SelectedGroups[$i]->get('Content');
    // end for
   }
</php:highlight>
<br />
<a name="4-Dynamische-Formulare"></a><h3>4. Dynamische Formulare</h3>
In einigen Anwendungsf&auml;llen ist es notwenig, Formulare dynamisch nach Anforderung zu erstellen.
Hierzu besitzt die Implementierung der Formular-TagLib (<em>html_taglib_form</em>) die Methoden
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
und seit dem Release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
an. Die ersten beiden Funktionen lassen sich dazu nutzen, Inhalte oder konkrete Formular-Elemente
an das Ende des Formulars anzuh&auml;ngen. Die zu letzt genannten Methoden sind dazu gedacht, Inhalte
oder Formular-Elemente an konkreten Stellen zu platzieren. Zur Positionierung steht das
<strong>&lt;form:marker /&gt;</strong>-Tag zur Verf&uuml;gung. Das Tag selbst generiert keine Ausgabe,
sondern dient lediglich als Positionierungshilfe.
<br />
<br />
Die folgenden Kapitel sollen zeigen, wie ein dynamisches Formular zur Eingabe von Form-Koordinaten
(Dreieck, Quadrat, ...) realisiert werden kann. Je nach Auswahl des Typs sollen die jeweils notwenigen
Felder angezeigt werden. Bei Auswahl des Typs "square" werden vier Felder angezeigt ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs square" />
<br />
<br />
... und bei Auswahl von "triangle" drei:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs triangle" />
<br />
<br />
<br />
<a name="4-1-Formular-Definition"></a><h4>4.1. Formular-Definition</h4>
Bei der Definition des Formulars sollte bereits bedacht werden, welche Art der Formular-Generierung
angestrebt wird. Kommen die Methoden <em>addFormElement()</em> und/oder <em>addFormContent()</em>
zum Einsatz, ist keinen Marker erforderlich. In diesem Beispiel wird jedoch ein Marker eingesetzt, da
das Formular bereits Inhalte besitzt, die nach den dynamisch erzeugten Elementen angezeigt werden
sollen.
<br />
<br />
Die folgende Code-Box zeigt das notwenige Formular mit einem Auswahlfeld. Bei der Implementierung
wurde auf CSS-Formatierung verzichtet um die wesentlichen Elemente besser hervorheben zu k&ouml;nnen.
Das Formular besteht dabei aus einem statisch definierten Auswahlfeld, das den Typ der geometrischen
Form vorgibt und aus einem Marker-Tag, der als Positionierungshilfe f&uuml;r die dynamisch erzeugten
Felder dient. Weiterhin wird ein DocumentController definiert, der die gew&uuml;nschten Felder
dynamisch an der Stelle des Markers hinzuf&uuml;gt:
<code:highlight>
&lt;@controller namespace="..." file="..." class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="4-2-Controller"></a><h4>4.2. Controller</h4>
Der DocumentController &uuml;bernimmt im beschriebenen Beispiel die Generierung der abh&auml;ngigen
Formularfelder, die je nach Auswahl angezeigt werden sollen. Hierzu wird im Controller zun&auml;chst
definiert, welche Formular-Felder f&uuml;r welchen Typ angezeigt werden. Anschlie&szlig;end wird
das Typ-Feld ausgewertet und das Formular mit Inhalten und Text-Feldern gem&auml;&szlig; Typ
erg&auml;nzt. Die folgende Code-Box zeigt die Implementierung des DocumentControllers:
<php:highlight>
class select_controller extends baseController
{

   // specify form element container
   var $__FormElements = array();


   function select_controller(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

    // end function
   }


   function transformContent(){

      // get form reference
      $Form = &$this->__getForm('type');

      // get current decision
      $Select = &$Form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
       // end if
      }
      else{
         $CurrentType = $Option->getAttribute('value');
       // end else
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $Form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $CurrentElementID = $Form->addFormElementBeforeMarker(
                                          'fields',
                                          'form:text',
                                          array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                                                              );

         // configure further form element attributes
         $CurrentElement = &$Form->getFormElementByObjectID($CurrentElementID);
         $CurrentElement->setAttribute('style','width: 200px;');

         // add a line break
         $Form->addFormContentBeforeMarker('fields','<br />');

       // end for
      }

      // display form
      $Form->transformOnPlace();

    // end function
   }

 // end class
}
</php:highlight>
<br />
<a name="4-3-Wichtige-Hinweise"></a><h4>4.3. Wichtige Hinweise</h4>
Ein APF-Formular-Element ben&ouml;tigt bereits bei der Erstellung des Objekts die Information &uuml;ber
den Namen des Feldes. Ist dieser nicht bekannt, kann es nicht vorausgef&uuml;llt oder validiert werden.
Um die Presetting und Validierung von Formular-Elementen nutzen zu k&ouml;nnen besitzen die Methoden
<em>addFormElement()</em>, <em>addFormElementBeforeMarker()</em> und <em>addFormElementBeforeMarker()</em>
einen optionalen, dritten Parameter. Dieser erwartet eine assoziative Liste von Tag-Attributen, die
dem Formular-Tag bei der Erstellung mitgegeben werden. Es daher sinnvoll, der Methode mindestens
den Namen des Feldes in der Form
<code:highlight>
array(
      'name' => 'current_name'
     )
</code:highlight>
als drittes Argument mitzugeben. Dies kann unter Umst&auml;nden auch f&uuml;r die sp&auml;tere
Adressierung der Objekte &uuml;ber die Methoden <em>getFormElementByName()</em> und
<em>getFormElementByID()</em> von Interesse sein.
<br />
<br />
<br />
<a name="5-Formular-Filter"></a><h3>5. Verwendung von Formular-Filtern</h3>
Seit dem 1.9er Zweig unterst&uuml;tzen die Formular-Elemente Filter. Als Basis f&uuml;r die Filterung
dienen die APF-Filter aus dem core-Namespace. Details zu den Filtern k&ouml;nnen dem Kapitel
<a href="./?Seite=087-Filter#4-Aufbau-und-Funktion" title="Filter">Filter</a> entnommen werden.
<br />
<br />
Die Formular-Filter dienen dazu, die allgemeinen Eingabe-Filter (siehe
<a href="./?Seite=087-Filter#5-Konfiguration" title="Konfiguration von Filtern">Konfiguration von Filtern</a>)
zu erweitern um in definierten Eingabefeldern nur gew&uuml;nschte Werte zu akzeptieren. Typisches
Anwendungsbeispiel ist die Filterung eines E-Mail-Eingabefeldes, das nur Zeichen, die dem regul&auml;ren
Ausdruck &quot;<strong>[a-z0-9-_@.]</strong>&quot; gen&uuml;gen, enthalten darf.
<br />
<br />
<br />
<a name="5-1-Mitgelieferte-Filter"></a><h4>5.1. Mitgelieferte Filter</h4>
Um die Arbeit mit Formular-Filtern zu erleichtern, wird bereits ein Satz an Filterm&ouml;glichkeiten
mitgeliefert. Die folgenden Filter-Aufgaben k&ouml;nnen von der Klasse <strong>FormFilter</strong>
aus dem Namespace <strong>tools::form::filter</strong> erledigt werden (Filter-Instructions):
<ul>
  <li><strong>string2Lower</strong>: Wandelt alle Gro&szlig;buchstaben in Kleinbuchstaben um.</li>
  <li><strong>string2Upper</strong>: Wandelt alle Kleinbuchstaben in Gro&szlig;buchstaben um.</li>
  <li><strong>stripTags</strong>: Verwirft Code-Tags</li>
  <li><strong>noSpecialCharacters</strong>: L&auml;sst keine Sonderzeichen zu.</li>
  <li><strong>onlyNumbers</strong>: L&auml;sst nur Zahlen zu.</li>
  <li><strong>onlyInteger</strong>: L&auml;sst nur Integer-Werte zu.</li>
  <li><strong>onlyLetters</strong>: L&auml;sst nur Buchstaben zu.</li>
  <li><strong>onlyHTMLEntities</strong>: Codiert alle HTML-Steuer-Zeichen.</li>
</ul>
<br />
<a name="5-2-Anwendung"></a><h4>5.2. Anwendung</h4>
Die Anwendung der Filter gestaltet sich &auml;hnlich den Validatoren. Ist das Attribut
<strong>filter</strong> vorhanden, wird eine Filterung nach der im Wert des Attributs angegebenen
Filterinstruktion ausgef&uuml;hrt. Hierzu wird der Standard-Filter, wie im Kapitel 5.1. beschrieben,
verwendet.
<br />
<br />
Die folgende Code-Box zeigt die Anwendung von Filtern:
<code:highlight>
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="phone"
          filter="onlyNumbers"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</code:highlight>
Beim Aufbau des Formulars wird der Inhalt des Feldes <strong>phone</strong> mit der Instruktion
<em>onlyNumbers</em> gefiltert. Beim Auslesen des Feldes kann der Entwickler nun sicher gehen, dass
sich keine unerlaubten Inhalte im Formularfeld befinden. Da die Filterung <u>vor</u> der Validierung
stattfindet, kann es nicht f&auml;lschlicherweise zu einer korrekten Validierung kommen.
<br />
<br />
<strong>Wichtig:</strong>
<ul>
  <li>
    Bitte beachten Sie, dass die Filter bisher nur auf Text-Eingabefelder angewendet werden
    k&ouml;nnen!
  </li>
  <li>
    Die Verkettung von Filtern wird in Kapitel
    <a href="#5-4-Verkettung-von-Filtern" title="5.4. Verkettung von Filtern">5.4. Verkettung von Filtern</a>
    besprochen.
  </li>
</ul>
<br />
<a name="5-3-Erweiterung"></a><h4>5.3. Erweiterung</h4>
Gen&uuml;gen die mitgelieferten Filter nicht, kann mit Hilfe des Attributes <strong>filterclass</strong>
eine andere Filter-Klasse f&uuml;r das Feld spezifiziert werden. Die Definition muss dabei in der
Form
<code:highlight>
filterclass="path::to::my::filter::class|MyFilterClassName"
</code:highlight>
vorgenommen werden. Der erste Teil entspricht dem Namespace des Filters, der zweite dem Klasse- bzw.
Datei-Namens des Filters. Das Attribut <strong>filter</strong> beinhaltet auch bei Angabe einer
eigenen Filter-Klasse die Filter-Instruktion.
<br />
<br />
Wie im Kapitel
<a href="./?Seite=087-Filter#4-Aufbau-und-Funktion" title="Aufbau und Funktion von Filtern">Aufbau und Funktion von Filtern</a>
beschrieben, muss eine Filter-Klasse immer (direkt oder indirekt) von <strong>AbstractFilter</strong>
erben und die Methode <strong>filter()</strong> implementieren. Die folgende Code-Box zeigt einen
Filter, der alle Vorkommen von &quot;cm^2&quot; durch &quot;cm&sup2;&quot; ersetzt:
<php:highlight>
class DefinitionFilter extends AbstractFormFilter {

   function filter($input){
      return str_replace('cm^2','cm&sup2;',$input);
   }

}
</php:highlight>
<div class="hint">
   Im Fall von "normalen" Filtern (Ein- und Ausgabe-Filter) muss die Klasse <strong>AbstractFilter</strong>
   erweitert werden. F&uuml;r die Formular-Filter wurde nochmals eine weitere Basis-Klasse geschaffen,
   die sich um die Handhabung der Filter-Anweisungen k&uuml;mmert, die im Formular-Feld-Attribut
   <strong>filter</strong> mitgegeben wird. Dieser Wert wird in die interne Variable
   <em>$this->__Instruction</em> injiziert und steht beim Ausf&uuml;hren der Methode <em>filter()</em>
   zur Verf&uuml;gung.
</div>
<br />
Wie dem Beispiel zu entnehmen ist, kann in einfachen Anwendungsf&auml;llen, die Verwendung der
Filter-Instruktion zur Ablaufsteuerung entfallen. Dabei muss jedoch sichergestellt werden, dass das
Attribut <strong>filter</strong> einen nichtleeren (Dummy-)Werte enth&auml;lt.
<br />
<br />
Um einen Filter wiederverwendbar zu gestalten, ist es jedoch ratsam, gleichartige Filter-Funktionen
zusammenzufassen. Das folgende Beispiel zeigt einen Filter, der K&ouml;rperma&szlig;e filtert:
<php:highlight>
class MeasureFilter extends AbstractFormFilter {

   function filter($input){

      switch($this->__Instruction){

         case 'weight':
            $output = preg_replace('/[^0-9,.]/i','',$input);
         case 'size':
            $output = preg_replace('/[^0-9]/i','',$input);
         default:
            $output = $input;

      }

      return $output;

   }

}
</php:highlight>
Die Anwendung des Filters gestaltet sich wie folgt:
<code:highlight>
&lt;html:form name="test" method="post"&gt;
  Name:
  &lt;form:text
          name="name"
          filter="noSpecialCharacters"
  /&gt;
  &lt;br /&gt;
  Weight:
  &lt;form:text
          name="weight"
          filterclass="my::special::filter|MeasureFilter"
          filter="weight"
  /&gt;
  kg
  &lt;br /&gt;
  Body size:
  &lt;form:area
          name="bodysize"
          filterclass="my::special::filter|MeasureFilter"
          filter="size"
  /&gt;
  cm
  &lt;br /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<a name="5-4-Verkettung-von-Filtern"></a><h4>5.4. Verkettung von Filtern</h4>
Die Verkettung von Filtern kann &uuml;ber einen eigenen Filter abgebildet werden. Folgende Klasse,
die auch im Release enthalten ist, kann zur Bildung von Filterketten verwendet werden:
<php:highlight>
class MultiplexFormFilter extends FormFilter
{
   function filter($input){

      $instructionSet = explode('|',$this->__Instruction);
      $output = $input;

      foreach($instructionSet as $filterInstruction){
         $output = $this->{'__'.trim($filterInstruction)}($output);
      }

      return $output;

   }

}
</php:highlight>
Die Verwendung gestaltet sich wie folgt:
<code:highlight>
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="specialfield"
          filterclass="tools::form::filter|MultiplexFormFilter"
          filter="noSpecialCharacters|string2Upper"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</code:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_114" />