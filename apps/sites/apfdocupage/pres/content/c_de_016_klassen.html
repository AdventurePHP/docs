<doku:title tags="wichtige klassen,dom modell,benchmark,controller" title="Klassen" urlname="Klassen">
  Die vorliegende Seite zeigt eine &Uuml;bersicht &uuml;ber die wichtigsten Klassen im Framework.
  Weiterhin wird die APF-eigene DOM-Struktur der Pr&auml;sentationsschicht erl&auml;utert, die eine
  maximale Integration von Anwendungen und Modulen und eine generische Strukturierung der GUI
  erm&ouml;glicht.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
Das vorliegende Kapitel erl&auml;utert wichtige Klassen des Frameworks und definiert die Bedeutungen
dieser. Es wird auf das interne Design des Frameworks eingegangen und das dort definierte DOM besprochen.
Die Klassen-Definitionen k&ouml;nnen unter <a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
in den CHM-Dateien oder den HTML-ZIP-Dokumentationen eingesehen werden.
<br />
<br />
<br />
<a name="1-Basis-Klassen"></a><h3>1. Basis-Klassen des Frameworks</h3>
Zu den wichtigen Klassen z&auml;hlen grunds&auml;tzlich alle Klassen im Ordner "core" und dessen
Unterordnern. Diese wurden im Ordner "core" strukturiert, da der Autor davon ausgeht, dass diese
zum Betrieb einer Applikation - basierend auf diesem Framework - "zwingend notwendig" sind. Im Folgenden
wird nun auf die wichtigsten und am h&auml;ufigsten verwendete Klassen und deren Stellung eingegangen.
<br />
<br />
<br />
<a name="1-1-coreObject"></a><h4>1.1. coreObject</h4>
Die Klasse <em>coreObject</em> bildet die zentrale Klasse, von der (nahezu) alle Klassen erben. Diese
definiert gemeinsam genutzte Attribute und Methoden, bzw. gibt f&uuml;r bestimmte Implementierungen ein
Interface vor. Von <em>coreObject</em> erben nicht nur Klassen der Pr&auml;sentations-Schicht, sondern
auch Klassen der Business- und Datenschicht. Das hat den Vorteil, dass viele Teile der Applikationen
vereinheitlicht werden k&ouml;nnen. Die privaten Attribute definieren Grundeigenschaften eines Objekts
und erm&ouml;glichen Objektb&auml;ume per Vater-Kind-Beziehungen aufzubauen. Mit den &ouml;ffentlichen
Methoden k&ouml;nnen die Attribute und Eigenschaften manipuliert werden. Die privaten Methoden sind
Service-Methoden, die in den Implementierungen von <em>coreObject</em> Verwendung finden. Diese werden
beispielsweise unter <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a> n&auml;her
betrachtet.
<br />
<br />
<br />
<a name="1-2-Document"></a><h4>1.2. Document</h4>
Das <em>Document</em> ist eine von <em>coreObject</em> erbende Klasse und spielt eine &auml;hnlich
zentrale Rolle - jedoch ausschlie&szlig;lich in der Pr&auml;sentations-Schicht. Das <em>Document</em>
implementiert eine Reihe von Parser-Methoden, die aus einem gegebenen XML-Code einen DOM-Objektbaum
generieren oder aus diesem mit Hilfe der transform()-Methoden wieder HTML-Code generieren. Jede XML-
TagLib erbt von <em>Document</em> und nutzt die Attribute und Methoden dieser Klasse. Das UML-Diagramm
dazu kann der <a href="Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a> entnommen
werden. Mit der Klasse <em>Document</em> kommt der Entwickler beim
<a href="./?Seite=047-Templates" title="Templates">Template-Bauen</a> zun&auml;chst nicht in Ber&uuml;hrung,
die Definition der Klasse wird jedoch beim Erstellen von eigenen
<a href="./?Seite=TagLibsErstellen" title="TagLibs erstellen">TagLibs</a> interessant, da alle
verwendete Baum-Knoten nochmals von <em>Document</em> ableiten m&uuml;ssen und sich dabei weiter
spezialisieren.
<br />
<br />
<br />
<a name="1-3-Page"></a><h4>1.3. Page</h4>
Die Klasse <em>Page</em> kapselt eine komplette Webseite mit ihrer internen Baum-Struktur. Sie findet
in der Index-Datei Verwendung und implementiert eine Reihe von Methoden f&uuml;r das URL-Rewriting.
<br />
<br />
<br />
<a name="1-4-baseController"></a><h4>1.4. baseController</h4>
Die Klasse <em>baseController</em> ist das zentrale Interface f&uuml;r alle DocumentController gem&auml;&szlig;
MVC-Ansatz. Sie gibt vor, welche Methoden des DocumentControllers implementiert werden m&uuml;ssen
und welche Attribute eines <em>Document</em>s innerhalb des Controllers verf&uuml;gbar sind.
N&auml;heres zu Controllern kann <a href="./?Seite=006-Controller" title="Controller">hier</a> nachgelesen
werden. Um in Dokumenten dynamische Inhalte einzuf&uuml;gen muss in der abgeleiteten Controller-Klasse
die Methode "transformContent()" implementiert werden. Diese wird beim Transformieren eines Baum-
Knotes des Objektbaums ausgef&uuml;hrt und anschlie&szlig;end in den Inhalt des Knotens implantiert.
So ist es beispielweise m&ouml;glich statt "<code>Hallo Welt!</code>" einen Text in der jeweiligen
Browser-Sprache auszugeben.
<br />
<br />
<br />
<a name="1-5-Singleton"></a><h4>1.5. Singleton</h4>
Eine sehr h&auml;ufig eingesetzte Komponente ist die Singleton-Implementierung. Die im Framework
enthaltene Implementierung ist eine <strong>Abstract Singleton</strong>-Klasse. Mit dieser ist es
m&ouml;glich beliebige Klassen als Singleton-Objekte in der Anwendung einzusetzen. Vorraussetzung ist,
dass der Konstruktor keine Pflicht-Parameter erwartet. Aus Design- und Performance-Gr&uuml;nden
werden nahezu alle Services "singleton" verwendet. Das bedeutet, dass der "Service" w&auml;hrend eines
Requests genau <strong>einmal</strong> existiert. Dieses Muster wird vor Allem in den Service-Methoden
<em>__getServiceObject()</em> und <em>__getAndInitServiceObject()</em> verwendet. Eine h&auml;ufig
auftretender Anwendungs-Fall von Singleton ist der Einsatz des Benchmarkers.
<br />
<br />
<br />
<a name="1-6-BenchmarkTimer"></a><h4>1.6. BenchmarkTimer</h4>
Eine weitere wichtige Komponente stellt der <em>BenchmarkTimer</em> dar. Mit dieser ist es m&ouml;glich
die Ausf&uuml;hrungszeiten der unterschiedlichen Software-Teile zu erfassen und daraus Reports zu
generieren. So k&ouml;nnen Performance-Schwachpunkte ausgemacht und Ausf&uuml;hrungszeiten gemessen
werden. Details zum <em>BenchmarkTimer</em> k&ouml;nnen <a href="./?Seite=004-Benchmark" title="Benchmark">hier</a>
nachgelesen werden.
<br />
<br />
<br />
<a name="2-DOM-Model-der-GUI"></a><h3>2. DOM-Objektmodell der Pr&auml;sentations-Schicht</h3>
Mit dem enthaltenen PageController besitzt das Framework einen GUI-Controller, der die komplette
GUI einer Seite in einem eigenen internen DOM-Objektbaum abstrahiert. Jeder Knoten wird dabei von
einem Objekt, das von <em>Document</em> erbt, repr&auml;sentiert. So ist gem&auml;&szlig; Composite-
Pattern sichergestellt, dass der Objektbaum mit jedem beliebigen Element an jeder beliebigen Stelle
erweitert werden kann. Ein Baum-Element wird dabei gem&auml;&szlig; MVC-Pattern von einem Model, einem
View und einem Controller repr&auml;sentiert. Das Model - hier spricht man von "Model" im Sinne von
Applikationsinterna wie Abl&auml;ufen und Statusinformationen, nicht von "Model" im Sinne eines
Dom&auml;nen-Objektes - steckt h&auml;ufig im Controller oder einer Business-Komponente, der View
wird in der vorliegenden Implementierung durch eine Template-Datei repr&auml;sentiert und der
Controller ein DocumentController, der von der Klasse <em>baseController</em>
erbt.
<br />
<br />
Der PageController besitzt die zentrale Parser-Methode <strong>__extractTagLibTags()</strong>, die beim
Erzeugen eines Baum-Knoten die in der Template-Datei vorhandenen Tags ausliest und aus den bekannten
XML-Tags wiederum Kinder des aktuellen Knotens erstellt. Die Funktionalit&auml;t eines Knotens wird
dabei von einer TagLib repr&auml;sentiert. Das ist eine Klasse, die von <em>Document</em> abgeleitet
ist. Die Liste der "bekannten" TagLibs kann durch Hinzuf&uuml;gen weiterer TagLibs in einer Template-
Datei ohne Eingriff in den PageController erweitert werden. Dazu gibt es bereits einen Satz von
Standard-TagLibs, die unter <a href="./?Seite=Standard-TagLibs" title="Standard TagLibs">Standard TagLibs</a>
dokumentiert sind.
<br />
<br />
Analysiert man die Templates und Controller der aktuellen Dokumentations-Webseite, ergibt sich nach
dem Parsen der Templates folgende interne DOM-Objekt-Struktur:
<br />
<br />
<a href="http://media.adventure-php-framework.org/content/DOM_Tree.png" target="_blank" title="Klicken um zu vergr&ouml;&szlig;ern!">
  <img src="http://media.adventure-php-framework.org/content/DOM_Tree.png" border="0" alt="DOM-Objektbaum Adventure PHP Framework" style="width: 560px;" />
</a>
<br />
<br />
Die DOM-Definition des Frameworks geht davon aus, dass die Struktur einer Seite in einem Objekt der
Klasse <em>Page</em> gekapselt wird. Aus diesem Grund bildet das Objekt der Klasse <em>Page</em> den
Root-Knoten. Innerhalb dieses Root-Knotens wird immer ein initialer <em>Document</em>-Knoten mit dem
in der Methode <em>loadDesign()</em> angegebenen Template erzeugt. Die Tags dieses Templates werden
beim Laden auf bekannte TagLibs untersucht und diese werden dann als Kind-Objekte in den Baum
eingeh&auml;ngt.
<br />
<br />
&Uuml;blicherweise werden <strong>&lt;core:importdesign /&gt;</strong>-Tags dazu genutzt, um die in
den Attributen benannten Templates als Kind-Knoten der aktuellen Baum-Struktur einzusetzen. Auf diese
Weise ist es m&ouml;glich, beliebig tiefe Baum-Struktur zu erzeugen und zu verwalten. Dies bietet sich
vor Allem bei gro&szlig;en Webseiten mit vielen Views an. Details zum
<strong>&lt;core:importdesign /&gt;</strong>-Tag k&ouml;nnen der
<a href="./?Seite=046-Standard-TagLibs#1-2-Importdesign" title="Standard-TagLibs">Standard-TagLibs-Seite</a>
entnommen werden.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_016" />