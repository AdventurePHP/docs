<doku:title tags="php,frameworks,test,cakephp,codeigniter,zend framework,adventure php framework,bewertung" title="PHP-Frameworks im Test (5)" urlname="PHP-Frameworks-im-Test-5">
  Der Artikel PHP-Frameworks im Test vergleicht unterschiedliche Frameworks. Basis der Bewertung ist
  ein Anforderungskatalog, der darauf Wert legt, dass der Entwickler einen m&ouml;glichst
  vollst&auml;ndigen Werkzeugkasten an die Hand bekommt um effektiv Webseiten und Web-Applikationen
  entwickeln zu k&ouml;nnen.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<a name="3-3-Zend-Framework"></a><h4>3.3. Zend Framework</h4>
<br />
<a name="3-3-1-Allgemeines"></a><h5>3.3.1. Allgemeines</h5>
<br />
<a name="Roadmap-des-Projekts"></a><h6>Roadmap des Projekts</h6>
Das Zend Framework stellt unter <doku:link>http://framework.zend.com/whyzf/future/</doku:link> seine
Roadmap f&uuml;r die zuk&uuml;nftigen Releases vor. Ein konkreter Release-Plan fehlt jedoch genauso
wie ein Zeitplan f&uuml;r das erscheinen der aufgezeigten Features.
<br />
<br />
<br />
<a name="Aktualitaet-der-Version"></a><h6>Aktualit&auml;t der Version</h6>
Die Seite <doku:link>http://framework.zend.com/download</doku:link> gibt eine &Uuml;bersicht &uuml;ber
die letzten 6 Releases, die jeweils im Abstand zwischen 10 und 30 Tagen erfolgten. Das aktuelle
Release, mit dem auch beim Verfassen dieses Artikels zur&uuml;ckgegriffen wurde ist 1.0.1 vom
30.07.2007.
<br />
<br />
<br />
<a name="Release-Packages-in-verschiedenen-Formaten"></a><h6>Release-Packages in verschiedenen Formaten</h6>
Das Release-Package ist in den Varianten ZIP und TGZ verf&uuml;gbar. Die Dokumentation wurde seit dem
Release 1.0.0 RC2 aus dem Release-Package ausgegliedert. Die aktuelle Version der Dokumentation kann
unter <doku:link>http://framework.zend.com/manual</doku:link> eingesehen werden.
<br />
<br />
<br />
<a name="CVS-SVN-Repositories"></a><h6>CVS/SVN-Repositories</h6>
Unter <doku:link>http://framework.zend.com/download/subversion/</doku:link> ist beschrieben, wie der
Entwickler eine Kopie des SVN-Repositories, bzw. "nighly builds" beziehen kann. Damit ist
gew&auml;hrleistet, dass Bugfixes schnell verf&uuml;gbar sind.
<br />
<br />
<br />
<a name="Bug-Tracking-Ticketing"></a><h6>Bug-Tracking / Ticketing</h6>
Der Bug-Tracker <doku:link>http://framework.zend.com/issues/secure/Dashboard.jspa</doku:link> war
w&auml;hrend der Zeit der Evaluierung nicht durchg&auml;ngig verf&uuml;gbar und der Aufruf wurde oft
mit einem Fehler 502 quittiert. Der Autor geht davon aus, dass das Zend Framework &uuml;ber einen
funktionierenden Bug-Tracker verf&uuml;gt, da Jira &uuml;ber &auml;hnliche Features wie das Software-
Paket Trac verf&uuml;gt.
<br />
<br />
<br />
<a name="Version-fuer-PHP-4"></a><h6>Version f&uuml;r PHP 4</h6>
Eine Version f&uuml;r PHP 4 ist nicht erh&auml;ltlich.
<br />
<br />
<br />
<a name="Version-fuer-PHP-5"></a><h6>Version f&uuml;r PHP 5</h6>
Die installierte Version ist zu PHP 5 (im Test: Version 5.2.1) kompatibel. Um das Zend Framework betreiben
zu k&ouml;nnen wird eine PHP Version > 5.1.2 vorausgesetzt.
<br />
<br />
<br />
<a name="3-3-2-Installation"></a><h5>3.3.2. Installation</h5>
<br />
<a name="Extract-Go"></a><h6>Extract & Go</h6>
Die Installation des Frameworks gestaltet sich erwartungsgem&auml;&szlig; einfach. Nach dem Extrahieren
des Paketes kann der Anwender mit der Implementierung seiner ersten Anwendung beginnen. Auch bei
diesem Framework wurde ein lokaler VHOST angelegt um z.B. URL-Rewriting sauber testen zu k&ouml;nnen.
Es f&auml;llt jedoch sofort auf, dass das Zend Framework keine Beispiel-Applikation oder eine Startseite
mit wichtigen Hinweisen im Release mitbringt.
<br />
<br />
<a name="Konfiguration"></a><h6>Konfiguration</h6>
Der Einsteiger st&ouml;&szlig;t nach einer Weile des Suchens auf ein Einsteiger-Tutorial, das zeigt,
wie eine Anwendungsstruktur und eine "Hallo-Welt"-Applikation erstellt werden kann. Hinsichtlich
Konfiguration beschreibt <doku:link>http://framework.zend.com/manual/en/zend.controller.html#zend.controller.quickstart.introduction</doku:link>
dass die Zend Framework Bibliotheken via PHP <em>include_path</em> erreichbar sein m&uuml;ssen.
Dieser muss entweder global oder in der Bootstrap-Datei der Applikation gesetzt sein. F&uuml;r den
Test entschied sich der Autor f&uuml;r die zweite Alternative.<br />
Weiterhin muss die Bootstrap-Datei (<em>/myapp/html/index.php</em>) die ben&ouml;tigten Bibliotheken
laden, im Fall der beschriebenen Beispiel-Applikation ist das der Zend Framework FrontController.
Dieser kann nach dem Setzen des include_path's per
<php:highlight>
  require_once 'Zend/Controller/Front.php';
</php:highlight>
eingebunden werden.
<br />
<br />
<br />
<a name="3-3-3-Erste-Schritte"></a><h5>3.3.3. Erste Schritte</h5>
<br />
<a name="Demo-Software"></a><h6>Demo-Software</h6>
Weder das Release-Package noch das Wiki beinhalten eine einfache Demo-Software, mit dem der Anwender
einen ersten Einblick in die Funktionsweise und die Anwendung des Frameworks bekommen kann.
<br />
<br />
<br />
<a name="Einfuehrung-Quickstart"></a><h6>Einf&uuml;hrung / Quickstart</h6>
Da kein ausgewiesenes Einsteiger-Tutorial auf der Seite framework.zend.com verf&uuml;gbar ist, versuchte
der Autor &uuml;ber das Wiki ein f&uuml;r Einsteiger relevantes Tutorial zu finden. Nach einer Recherche
konnte <doku:link>http://akrabat.com/zend-framework-tutorial/</doku:link> ausgemacht werden. Das dort
verf&uuml;gbare Einsteiger-Tutorial, das auch in Deutsch erh&auml;ltlich ist, beschreibt das Erstellen
einer einfachen CD-Verwaltung in f&uuml;r Einsteiger nachvollziehbaren Schritten.
<br />
<br />
<br />
<a name="3-3-4-Erstellung-einer-Webseite"></a><h5>3.3.4. Erstellung einer Webseite</h5>
<br />
<a name="Template-Bau-Layoutgestaltung"></a><h6>Template-Bau / Layoutgestaltung</h6>
Das unter 3.3.3 genannte Tutorial gibt erste Einblicke in die Art und Weise des Template-Baus, die
nun zur Erstellung der Demo-Seite verwendet werden k&ouml;nnen. Dazu wird unter einem neuen Ordner
(<em>/myapp</em>) eine Strukur f&uuml;r die Applikation gem&auml;&szlig;
<doku:link>http://framework.zend.com/manual/en/zend.controller.html#zend.controller.quickstart.introduction</doku:link>
angelegt. Auch das Zend Framework verfolgt die Philosophie, dass die URL gem&auml;&szlig; dem Pattern
<code:highlight>
  http://www.example.com[/{Module}]/{Controller}/{Action}[/{Param1}/../{ParamN}]
</code:highlight>
aufgebaut ist. Der Einfachheit wegen wird die Demo-Seite ohne die Verwendung der Modul-Logik aufgebaut.
Zun&auml;chst muss unter <em>/myapp/html</em> eine <strong>index.php</strong> mit folgendem Inhalt
angelegt werden:
<php:highlight>
   // Set include_path
   set_include_path(get_include_path().';'.'***/zendtest.de/library');

   // Run FrontController
   require_once 'Zend/Controller/Front.php';
   $fC = Zend_Controller_Front::getInstance();
   $fC->throwExceptions(true);
   $fC->setControllerDirectory('../application/controllers');
   $fC->dispatch();
</php:highlight>
Die Aktivierung des Parameters <strong>throwExceptions</strong> des Frontcontrollers ist dabei von
gro&szlig;er Bedeutung f&uuml;r Anf&auml;nger, da der FrontController sonst nur Meldungen der Form
<code:highlight>
  Fatal error: Uncaught exception 'Zend_Controller_Dispatcher_Exception' with message
  'Invalid controller specified ...
</code:highlight>
wirft und keinen Hinweis auf den eigentlichen Fehler ausgibt.
<br />
<br />
Auf Grund des gew&uuml;nschten URL-Designs wird nun unter <em>/myapp/application/controllers</em> die
Datei <em>SeiteController.php</em> mit der Klasse <strong>SeiteController</strong> angelegt. Der darin
enthaltene Action-Controller erbt von der Klasse <em>Zend_Controller_Action</em>. Das Grundger&uuml;st
sieht wie folgt aus:
<php:highlight>
   class SeiteController extends Zend_Controller_Action
   {

      // Abfangen von falschen / nicht vorhandenen Actions
      function __call($method, $args){

         // indexAction
         if($method == 'indexAction'){
            return $this->render('startseite');
          // end if
         }

         // return error page
         return $this->render('error');

       // end function
      }

    // end class
   }
</php:highlight>
Die Methode <em>__call()</em> wird verwendet um Standard- und Fehler-F&auml;lle abzufangen. Im hier
aufgezeigten Fall wird die Fehlerseite angezeigt, falls es keine anzeigbare Seite gibt. Die View-
Templates wurden im Ordner <em>/myapp/application/views/scripts/seite</em> angelegt und mit der Endung
<strong>.phtml</strong> versehen. Um nicht bei jeder Seite den Quellcode des Headers, des Men&uuml;s,
des News-Bereichs, des Top-Men&uuml;s und des Footers kopieren zu m&uuml;ssen wurden diese Teile in
den Ordner <em>/myapp/application/views/scripts/seite/design</em> ausgelagert. Dort existieren nun
f&uuml;nf Dateien:
<ul>
  <li>
    <strong>header.phtml</strong>: Beinhaltet den Teil vor dem Content-Bereich. Inkludiert
    News, Top-Men&uuml; und Men&uuml;.
  </li>
  <li><strong>news.phtml</strong>: Newsbereich der Seite</li>
  <li><strong>topmenu.phtml</strong>: Horizontales Men&uuml; im oberen rechten Bereich</li>
  <li><strong>menu.html</strong>: Haupt-Men&uuml; in linken mittleren Bereich</li>
  <li><strong>footer.phtml</strong>: HTML-Fragmente der Fu&szlig;zeile der Seite</li>
</ul>
Wird nun die URL
<code:highlight>
  http://zendtest.de/Seite/Benchmark
</code:highlight>
aufgerufen, so l&auml;dt der FrontController die ActionKlasse <em>SeiteController</em> und f&uuml;hrt
die Methode <em>benchmarkAction()</em> aus. Diese ist im Moment noch nicht implementiert und die Fehler-
Seite wird angezeigt. Legt der Benutzer nun die Datei <strong>benchmark.phtml</strong> im Ordner
<em>/myapp/application/views/scripts/seite</em> an und erweitert den Controller um die Methode
<php:highlight>
   function benchmarkAction(){
   }
</php:highlight>
so wird die Benchmark-Seite angezeigt. Die Template-Datei f&uuml;r die Benchmark-Seite ist dabei wie
folgt aufgebaut:
<html:highlight>
<?php
   $view = new Zend_View();
   $view->setScriptPath('../application/views/scripts/seite/design');

   // Header ausgeben
   echo $view->render('header.phtml');
?>
<font style="font-size: 26px; font-weight: bold;">Benchmark</font>
<br />
<br />

[..]

<?php
   // Footer ausgeben
   echo $view->render('footer.phtml');
?>
</html:highlight>
<br />
<br />
<a name="Handling-von-Controllern"></a><h6>Handling von Controllern</h6>
Unter <strong>Template-Bau / Layoutgestaltung</strong> wurde bereits angerissen, wie Controller
im Zend Framework aufgebaut sind und wie sich diese verhalten. Auch wurde bereits vorweg genommen,
wie die Namensgebung der Controller festgelegt ist. Um das im Test gew&uuml;nschte URL-Format
abbilden zu k&auml;nnen und um zu erreichen, dass beim Aufruf der URL
<html:highlight>
  http://zendtest.de/
</html:highlight>
keine Fehlermeldung, sondern die gew&uuml;nschte Seite angezeigt wird, muss das Standard-Routing
angepasst werden. Hilfestellung dazu bietet das Manual auf der Seite
<doku:link>http://framework.zend.com/manual/de/zend.controller.router.html#zend.controller.router.default-routes</doku:link>.
Etwas unter geht hier jedoch die Tatsache, dass die Variable <strong>$router</strong> eine Referenz
auf die Instanz des Rewrite-Routers sein muss. Die <em>index.php</em> muss dann um die Zeilen
<php:highlight>
   $router = $fC->getRouter();

   $default_route = new Zend_Controller_Router_Route(
                                                     '',
                                                     array(
                                                           'controller' => 'Seite',
                                                           'action'     => 'index'
                                                           )
                                                    );

   $seite_route_default = new Zend_Controller_Router_Route(
                                                           'Seite',
                                                           array(
                                                                 'controller' => 'Seite',
                                                                 'action'     => 'index'
                                                                 )
                                                          );

   $seite_route_dynamic = new Zend_Controller_Router_Route(
                                                           'Seite/:Action/*',
                                                           array(
                                                                 'controller' => 'Seite'
                                                                 )
                                                          );


   $router->removeDefaultRoutes();
   $router->addRoute('default',$default_route);
   $router->addRoute('SeiteDefault',$seite_route_default);
   $router->addRoute('SeiteDynamic',$seite_route_dynamic);
</php:highlight>
zwischen
<php:highlight>
   require_once 'Zend/Controller/Front.php';
   $fC = Zend_Controller_Front::getInstance();
   $fC->throwExceptions(true);
</php:highlight>
und
<php:highlight>
   $fC->setControllerDirectory('../application/controllers');
   $fC->dispatch();
</php:highlight>
erweitert werden. Weitere Routing-Eintr&auml;ge k&ouml;nnen analog dazu eingetragen werden. Hier sind
die Hinweise auf der zuvor referenzierten Manual-Seite zu beachten. Das gew&auml;hlte Routing
impliziert jedoch weitere &Auml;nderungen im Controller. Es war dem Autor nicht m&ouml;glich sowohl
das Default-Routing als auch das dynamische Routing so zu konfigurieren, dass der Controller in der
oben aufgezeigten Form sowohl f&uuml;r
<html:highlight>
  http://zendtest.de/
</html:highlight>
als auch f&uuml;r
<html:highlight>
  http://zendtest.de/Seite
</html:highlight>
oder
<html:highlight>
  http://zendtest.de/Seite/Literatur
</html:highlight>
die richtigen Views rendert und ausliefert. Der Router unterst&uuml;tzt zwar ein Remapping von URLs,
jedoch kein Remapping von Wildcard-Parametern in die URL-Parameter selbst, so dass der Dispatcher
weiterhin erkennt, dass der zweite Parameter die Action ist. Das Manual (englisch) spricht zwar von
<code:highlight>
Route definition can contain one more special character a wildcard represented by '*' symbol. It is
used to gather parameters similarly to the default Module route (var => value pairs defined in the
URI). The following route moreorless mimics the Module route behavior:

  $route = new Zend_Controller_Router_Route(
                                            ':module/:controller/:action/*',
                                            array('module' => 'default')
                                           );
  $router->addRoute('default', $route);
</code:highlight>
, das bewirkt jedoch nur ein Mappen der URL-Pfad-Abschnitte in Request-Variablen, die im
<em>Request</em>-Objekt ausgelesen werden k&ouml;nnen. Der zweite - bzw. im Beispiel des Manuals
dritte - URL-Parameter wird jedoch nicht automatisch dem Dispatcher als Action-Kenner &uuml;bergeben.
<br />
<br />
Daher wurde die <strong>__call()</strong>-Methode wie folgt umgestellt, so dass diese zun&auml;chst
versucht eine Methode f&uuml;r das Rendering aufzurufen, sollte diese nicht vorhanden sein, versucht
den View zu rendern und ansonsten eine Fehler-Seite anzeigt. In PHP-Code gestaltet sich das wie folgt:
<php:highlight>
   public function __call($method,$args){

      // Request-Objekt holen
      $Request = $this->getRequest();

      // Action-Parameter holen (muss in Route definiert sein
      $ActionParam = strtolower($Request->getParam('Action'));

      // Request-Methode zusammenbauen
      $RequestedMethod = $ActionParam.'Action';

      // Pr&uuml;fen, ob Methode existiert und diese dann ausf&uuml;hren
      if(method_exists($this,$RequestedMethod)){
         return $this->$RequestedMethod();
       // end if
      }
      else{
         // Falls lediglich der View existiert, diesen ohne Hilfe einer Action-Methode rendern
         if(file_exists('../application/views/scripts/seite/'.$ActionParam.'.phtml')){
            return $this->render($ActionParam);
          // end if
         }
       // end else
      }


      // F&uuml;r alle &uuml;brigen F&auml;lle Fehler-Seite zeigen
      return $this->render('error');

    // end function
   }
</php:highlight>
Etwas ungenerisch ist hierbei die Pr&uuml;fung gew&auml;hlt, ob das View-Script existiert. Es wurde
jedoch nicht weiter nach einer L&ouml;sung gesucht, da sich die &Auml;nderungen auf Grund des
URL-Routings bereits als zeitintensiv erwiesen haben.
<br />
<br />
<br />
<a name="Erweiterbarkeit-der-GUI-Komponenten"></a><h6>Erweiterbarkeit der GUI-Komponenten</h6>
Wie auch in den bisherigen Tests befinden sich im Quellcode der Datei <em>benchmark.phtml</em>
neben "normalen" HTML-Tags auch XML-Tags, zwischen den PHP-Codes eingeschlossen sind, die formatiert
auf der Seite dargestellt werden sollen. Dies sind
<code:highlight>
  &lt;php:highlight&gt;
  &lt;/php:highlight&gt;
</code:highlight>
f&uuml;r das Highlighting und
<code:highlight>
  &lt;doku:navigation /&gt;
</code:highlight>
f&uuml;r die Darstellung des dynamischen Men&uuml;s. Dies beiden Aufgaben k&ouml;nnen durch Action-Helper
realisiert werden, die dem FrontController bzw. Dispatcher in der <em>index.php</em> bekannt gemacht
werden. Auf der Seite <doku:link>http://framework.zend.com/manual/de/zend.controller.actionhelpers.html#zend.controller.actionhelper.broker</doku:link>
wird diese M&ouml;glichkeit entsprechend beschrieben wird. Der Action-Helper muss dabei immer von
<strong>Zend_Controller_Action_Helper_Abstract</strong> erben und kann die unter
<doku:link>http://framework.zend.com/manual/de/zend.controller.actionhelpers.html#zend.controller.actionhelper.writingyourown</doku:link>
beschriebenen Methoden implementieren. Im Fall des Formatierens von XML-Tags kommt hier die Funktion
<strong>postDispatch()</strong> in Frage, da zu diesem Zeitpunkt alle Views gerendert sind und der
HTML-Quelltext im Response-Objekt vollst&auml;ndig vorliegt. Nachteil der L&ouml;sung ist jedoch, dass
nicht nur der betroffene ein Teil des Quelltextes (Content-View) durchsucht werden muss, sondern der
komplette Quelltext, was u.U. zu unerw&uuml;nschten Ergebnissen oder zu schlechter Performance f&uuml;hren
kann. Eine andere L&ouml;sung konnte jedoch auch unter
<doku:link>http://www.zfforum.de/showthread.php?t=685</doku:link> nicht erarbeitet werden.
<br />
<br />
Die beiden Helper wurden unter <em>/myapp/applications/views/helpers</em> angelegt und mit
<strong>Highlight.php</strong> und <strong>DokuNavi.php</strong> benannt. Die Quelltexte der zwei
Helper gestaltet sich wie folgt:
<br />
<br />
<strong>Highlight.php:</strong>
<php:highlight>
   require_once 'Zend/Controller/Action/Helper/Abstract.php';

   class Helper_Highligh extends Zend_Controller_Action_Helper_Abstract
   {

      function postDispatch(){

         // Response-Objekt holen
         $Response = $this->getResponse();

         // Inhalt vom Response-Objekt holen
         $Body = $Response->getBody();

         // PHP-Highlight erzeugen
         $Body = $this->highlight($Body);

         // Body in das Response-Objekt zur&uuml;ckschreiben
         $Response->setBody($Body);

       // end function
      }


      function highlight($content){

         // Quelltext parsen
         return preg_replace_callback(
                                      '=\<php\:highlight\>(.*?)\<\/php\:highlight\>=si',
                                      array('Helper_Highligh','highlight_it'),
                                      $content
                                     );

       // end function
      }

      function highlight_it($content){

         $HighlightedContent = highlight_string(trim('<?php'.ltrim(rtrim($content[1]),"\x0A..\x0D").' ?>'),true);

         // PHP-Anfangstag ersetzen
         $HighlightedContent = str_replace('<font color="#007700">&lt;?</font>',
                                           '',
                                           $HighlightedContent);
         $HighlightedContent = str_replace('<font color="#0000BB">&lt;?php&nbsp;',
                                           '<font color="#0000BB">',
                                           $HighlightedContent);
         $HighlightedContent = str_replace('<font color="#0000BB">php',
                                           '<font color="#0000BB">',
                                           $HighlightedContent);
         $HighlightedContent = str_replace('<font color="#0000BB">&nbsp;</font>',
                                           '',
                                           $HighlightedContent);

         // PHP-Endtag ersetzen
         $HighlightedContent = str_replace('<font color="#0000BB">?&gt;</font>','',$HighlightedContent);

         // Code im DIV zur&uuml;ckgeben
         return '<div class="phpcode">'.$HighlightedContent.'</div>';

       // end function
      }

    // end class
   }
</php:highlight>
<br />
<strong>DokuNavi.php:</strong> (<em>gek&uuml;rzt</em>)
<php:highlight>
   require_once 'Zend/Controller/Action/Helper/Abstract.php';

   class Helper_DokuNavi extends Zend_Controller_Action_Helper_Abstract
   {

      private $__DokuSites = array();


      function postDispatch(){

         //
         // Navigation erzeugen
         //

         // Array f&uuml;llen
         $this->__fillSitesArray();


         // Aktuelle Seite deklarieren
         $Request = $this->getRequest();


         // Action-Parameter holen (muss in Route definiert sein
         $ActionParam = $Request->getParam('Action');
         if($ActionParam == null){
            $Page = 'Startseite';
          // end if
         }
         else{
            $Page = $ActionParam;
          // end else
         }


         // Vorherige Seite deklarieren
         $PreviousPage = $this->__getNeighborPageName($Page);


         // N&auml;chste Seite deklarieren
         $NextPage = $this->__getNeighborPageName($Page,'next');


         // R&uuml;ckgabe-Puffer deklarieren
         $Buffer = (string)'';


         [..]


         //
         // Ergebnis in Response implantieren
         //

         // Response-Objekt holen
         $Response = $this->getResponse();


         // Inhalt vom Response-Objekt holen
         $Body = $Response->getBody();


         // Ausgabe in Response-HTML-Quelltext einsetzen
         $Body = str_replace('<doku:navigation />',$Buffer,$Body);


         // Body in das Response-Objekt zur&uuml;ckschreiben
         $Response->setBody($Body);

       // end function
      }


      function __fillSitesArray(){
         [..]
      }

      function __getNeighborPageName($CurrentPage,$Type = 'previous'){
         [..]
      }

    // end class
   }
</php:highlight>
Um den Navi-Helper dem Dispatcher bzw. FrontController bekannt zu machen, muss die <em>index.php</em>
wie folgt ge&auml;ndert werden:
<php:highlight>
   require_once '../application/views/helpers/Highlight.php';
   require_once '../application/views/helpers/DokuNavi.php';
   Zend_Controller_Action_HelperBroker::addPath('../application/views/helpers','Helper');
   $Helper_Highlight = new Helper_Highligh();
   $Helper_DokuNavi = new Helper_DokuNavi();
   Zend_Controller_Action_HelperBroker::addHelper($Helper_Highlight);
   Zend_Controller_Action_HelperBroker::addHelper($Helper_DokuNavi);
</php:highlight>
<br />
<br />
<a name="Komplexe-Layouts"></a><h6>Komplexe Layouts</h6>
Die Erstellung einfacher Layouts f&uuml;r eine Webseite konnte sehr einfach beschritten werden. Das
Gestalten von komplexen Layouts scheitert auch hier an der "Ein Controller - eine Action"-Logik im
Bereich der Umsetzung des MVC-Pattern und am URL-Design. So ist es weder m&ouml;glich einem
eingebundenen View einen Controller zuzuweisen, der dem View dynamisch Inhalte liefert, noch ist
vorgesehen, dass mehrere Front- bzw. ActionController-Actions in der URL deklariert werden k&ouml;nnen.
Hierzu wurde eine ausf&uuml;hrliche Diskussion unter <doku:link>http://www.zfforum.de/showthread.php?t=359</doku:link>
mit dem Ergebnis gef&uuml;hrt, dass das Framework bisher keine M&ouml;glichkeit vorsieht, ein Layout
mit mehreren und vor Allem unabh&auml;ngigen Actions f&uuml;r unterschiedliche GUI-Teile zu erstellen.
<br />
<br />
<br />
<a name="FormularDesign"></a><h6>FormularDesign</h6>
Wie auf der Seite <doku:link>http://framework.zend.com/manual/de/zend.view.helpers.html#zend.view.helpers.initial</doku:link>
beschrieben ist, kann der Entwickler zur Erstellung von Formularen auf eine Vielzahl von Helper-
Methoden zur&uuml;ckgreifen. Um das hier zu erstellende Formular mit dem Zend Framework nachempfinden
zu k&ouml;nnen, wird zun&auml;chst eine View-Script-Datei mit dem Namen <strong>kontakt.phtml</strong>
angelegt und eine weitere (<em>danke.phtml</em>) f&uuml;r die Anzeige der Erfolgsmeldung. Die Datei
<em>kontakt.phtml</em> beinhaltet neben den &uuml;blichen Bereichen f&uuml;r das Anzeigen von
Header- und Footer-Komponenten den folgenden Quelltext:
<html:highlight>
  <font style="font-size: 26px; font-weight: bold;">Kontakt-Formular</font>
  <br />
  <br />
  Wenn Sie mit mir in Kontakt treten m&ouml;chten, dann benutzen Sie einfach dieses Formular. Geben Sie Ihre
  Nachricht ein und schon kann es los gehen. Ich werden mich dann umgehend mit Ihnen in Verbindung
  setzten. <strong>Bitte f&uuml;llen Sie das Formular vollst&auml;ndig aus!</strong>.
  <br />
  <br />
  <form action="<?php echo $this->url(); ?>" method="post">
    <span style="width: 47px; border: 0px solid black; margin-right: 69px;">Person:</span>
    <?php echo $this->formSelect('Person',
                                 $this->Person,
                                 array(
                                       'class' => 'eingabe_feld',
                                       'style' => $this->PersonStyle
                                      ),
                                 array(
                                       '' => '',
                                       '1' => 'Max Mustermann',
                                       '2' => 'Bianka Mustermann'
                                      )
                                );
    ?>
    <?php echo $this->PersonError; ?>
    <br />
    <br />
    <span style="width: 56x; border: 0px solid black; margin-right: 64px;">Ihr Name:</span>
    <?php echo $this->formText('Name',
                               $this->Name,
                               array(
                                     'class' => 'eingabe_feld',
                                     'style' => 'width: 280px;'.$this->NameStyle
                                    )
                              );
    ?>
    <?php echo $this->NameError; ?>
    <br />
    <br />
    <span style="width: 108px; border: 0px solid black; margin-right: 10px;">Ihre eMail-Adresse:</span>
    <?php echo $this->formText('EMail',
                               $this->EMail,
                               array(
                                     'class' => 'eingabe_feld',
                                     'style' => 'width: 280px;'.$this->EMailStyle
                                    )
                              );
    ?>
    <?php echo $this->EMailError; ?>
    <br />
    <br />
    <span style="width: 57px; border: 0px solid black; margin-right: 61px;">Ihr Betreff:</span>
    <?php echo $this->formText('Subject',
                               $this->Subject,
                               array(
                                     'class' => 'eingabe_feld',
                                     'style' => 'width: 280px;'.$this->SubjectStyle
                                    )
                              );
    ?>
    <?php echo $this->SubjectError; ?>
    <br />
    <br />
    Ihre Nachricht:
    <br />
    <?php echo $this->formTextarea('Comment',
                                   $this->Comment,
                                   array(
                                         'class' => 'eingabe_feld',
                                         'style' => 'height: 200px;
                                                     width: 400px;
                                                     overflow: auto;
                                                     '.$this->CommentStyle

                                        )
                                  );
    ?>
    <?php echo $this->CommentError; ?>
    <br />
   <br />
   <?php echo $this->formSubmit('Absenden','Absenden',array('class' => 'eingabe_feld')); ?>
  </form>
</html:highlight>
Im Controller wird f&uuml;r das Formular-Handling eine neue Methode mit dem Namen
<strong>kontaktAction</strong> angelegt, die das &Uuml;berpr&uuml;fen der Formular-Eingaben und
das reagieren auf Fehleingaben erledigt. Dabei wird von der M&ouml;glichkeit Gebrauch gemacht, dass
dem View beliebige Variablen zur Verwendung durch Setzen der Attribute des aktuellen View-Objekts
zugewiesen werden k&ouml;nnen. Der Quelltext der Methode ist folgender:
<php:highlight>
   function kontaktAction(){

      // View-Variablen setzen
      $this->view->Person = (string)'';
      $this->view->Name = (string)'';
      $this->view->EMail = (string)'';
      $this->view->Subject = (string)'';
      $this->view->Comment = (string)'';


      // Variablen zur Ausgabe-Steuerung setzen
      $this->view->PersonStyle = (string)'';
      $this->view->NameStyle = (string)'';
      $this->view->EMailStyle = (string)'';
      $this->view->SubjectStyle = (string)'';
      $this->view->CommentStyle = (string)'';


      // Variablen f&uuml;r Fehlermeldungen setzen
      $this->view->PersonError = (string)'';
      $this->view->NameError = (string)'';
      $this->view->EMailError = (string)'';
      $this->view->SubjectError = (string)'';
      $this->view->CommentError = (string)'';


      // Pr&uuml;fen, ob Formular abgeschickt wurde
      if(isset($_POST['Absenden']) && $_POST['Absenden'] == 'Absenden'){

         // Validatoren erstellen
         $Val_StrLen = new Zend_Validate_StringLength(3);
         $Val_EMail = new Zend_Validate_EmailAddress();

         // Werte des Formulars presetten
         $this->view->Person = $_POST['Person'];
         $this->view->Name = $_POST['Name'];
         $this->view->EMail = $_POST['EMail'];
         $this->view->Subject = $_POST['Subject'];
         $this->view->Comment = $_POST['Comment'];

         // Post-Daten pr&uuml;fen
         $FormValid = true;

         if(empty($_POST['Person'])){
            $this->view->PersonStyle = ' background-color: red; border: 2px solid red;';
            $this->view->PersonError = 'Bitte w&auml;hlen Sie eine Kontakt-Person aus!';
            $FormValid = false;
          // end if
         }
         if(!$Val_StrLen->isValid($_POST['Name'])){
            $this->view->NameStyle = ' border: 2px solid red;';
            $this->view->NameError = 'Bitte geben Sie einen Namen ein!';
            $FormValid = false;
          // end if
         }
         if(!$Val_EMail->isValid($_POST['EMail'])){
            $this->view->EMailStyle = ' border: 2px solid red;';
            $this->view->EMailError = 'Bitte geben Sie eine korrekte E-Mail-Adresse ein!';
            $FormValid = false;
          // end if
         }
         if(!$Val_StrLen->isValid($_POST['Subject'])){
            $this->view->SubjectStyle = ' border: 2px solid red;';
            $this->view->SubjectError = 'Bitte geben Sie ein Betreff ein!';
            $FormValid = false;
          // end if
         }
         if(!$Val_StrLen->isValid($_POST['Comment'])){
            $this->view->CommentStyle = ' border: 2px solid red;';
            $this->view->CommentError = 'Bitte geben Sie einen Kommentar ein!';
            $FormValid = false;
          // end if
         }


         // Formular absenden, fals Valide ausgef&uuml;llt
         if($FormValid == true){
            header('Location: /Seite/Danke');
          // end if
         }

       // end if
      }

      // Formular anzeigen
      $this->render('kontakt');

    // end function
   }
</php:highlight>
Das Zend Framework bringt - wie unschwer zu erkennen ist - einen Satz von Validatoren mit, die einfach
zur Validierung der Benutzereingaben verwendet werden k&ouml;nnen. Das Presetting von Benutzer-Eingaben
in Formular-Komponenten muss der Entwickler, genauso wie Markierung von nicht korrekt ausgef&uuml;llten
Feldern oder Fehlermeldungs-Ausgaben - trotz Form-Helper - zu Fu&szlig; implementieren. Verglichen mit
z.B. CakePHP wird das Formular-Handling nur rudiment&auml;r unterst&uuml;tzt und der Template-Bauer
spart sich durch den Einsatz der View-Helper nur wenig Arbeit. Das Presetting von Select-Feldern wird
jedoch im Gegensatz zu den View-Helpern von CodeIgniter durch &Uuml;bergabe des POST-Wertes
unterst&uuml;tzt.
<br />
<br />
<br />
<br />
<a name="3-3-5-URL-Handling"></a><h5>3.3.5. URL-Handling</h5>
<br />
<a name="Unterstuetzung-von-URL-Rewriting"></a><h6>Unterst&uuml;tzung von URL-Rewriting</h6>
Das Ausliefern der Applikation &uuml;ber Rewriting-URLs wird vom Zend-Framework standardm&auml;&szlig;ig
unterst&uuml;tzt. Damit alle Anfragen auf die Bootstrapping-Datei weitergeleitet werden muss die
RewriteRule
<code:highlight>
  RewriteEngine on
  RewriteRule !\.(js|ico|gif|jpg|png|css)$ index.php
</code:highlight>
f&uuml;r den VHOST aktiviert werden. &Uuml;ber die Unterst&uuml;tzung von URLs ohne Rewriting wurde
im Manual kein Eintrag gefunden.
<br />
<br />
<br />
<a name="Generik-des-URL-Layouts"></a><h6>Generik des URL-Layouts</h6>
Wie bei den bisherigen Test-Kandidaten wird das URL-Layout der Form
<code:highlight>
 http://www.example.com[/{Module}]/{Controller}/{Action}[/{Param1}/.../{ParamN}]
</code:highlight>
fest vorgeschrieben und kann lediglich durch Routing-Eintr&auml;ge manipuliert, jedoch nicht in seiner
Bedeutung ge&auml;ndert werden.
<br />
<br />
<br />
<a name="URL-Manipulations-Tools-Linkgenerierung"></a><h6>URL-Manipulations-Tools / Linkgenerierung</h6>
Zur Unterst&uuml;tzung der URL-Generierung liefert das Zend Framework die Komponente <strong>Zend_Uri</strong>
mit. Diese unterst&uuml;tzt aktuell HTTP- und HTTPS-Schemata und kann beispielsweise mit
<php:highlight>
   require_once 'Zend/Uri.php';
   $uri = Zend_Uri::factory(
         'http://www.zend.com:8180/Module/Controller/Action/Value1/Value2/Value3?param4=val4&param5=val5'
   );
   $uri->setPath('/Seite/Danke');
   $uri->setPort('');
   $uri->setHost('www.test.de');
   $uri->setQuery('param4=show&param5=false');
   echo $uri->getUri();
</php:highlight>
die URL
<code:highlight>
  http://www.zend.com:8180/Module/Controller/Action/Value1/Value2/Value3?param4=val4&amp;param5=val5
</code:highlight>
zu
<code:highlight>
  http://www.test.de/Seite/Danke?param4=show&amp;param5=false
</code:highlight>
ver&auml;ndern. Auff&auml;llig ist jedoch, dass Ampersands in URLs nicht codiert werden, was auf
Ausgabe-Seite zum Effekt f&uuml;hren kann dass statt der oben aufgef&uuml;hrten URL
<code:highlight>
  http://www.test.de/Seite/Danke?param4=show&para;m5=false
</code:highlight>
oder jede m&ouml;gliche andere Kombination von HTML-Entitys ausgegeben werden.
<br />
<br />
<br />
<br />
<a name="3-3-6-Design-des-Frameworks"></a><h5>3.3.6. Design des Frameworks</h5>
<br />
<a name="Umfang-der-mitgelieferten-Komponenten"></a><h6>Umfang der mitgelieferten Komponenten</h6>
Das Zend Framework besticht in der aktuellen Version durch eine F&uuml;lle von Komponenten f&uuml;r
die verschiedensten Anwendungsf&auml;lle. Es werden im Paket Klassen f&uuml;r Benutzer-Authentifizierung,
Rechte-Verwaltung (Zend_ACL), Webservices, Google-Data Client, Mail-Versand, PDF-Generierung,
Mehrsprachigkeit, XMLRPC und viele mehr mitgeliefert. Einen &Uuml;berblick und Detail-Informationen
k&ouml;nnen unter <doku:link>http://framework.zend.com/manual/de/</doku:link> eingesehen werden. Die
Evaluation jeder dieser Komponenten wurde nicht in der Evaluierung einbezogen. Der Umfang wird jedoch
als sehr positiv in die Bewertung eingebracht. Besonders aufgefallen ist, dass sich die Entwickler
des Zend Frameworks der Einheiten-Thematik eine eigene Komponente gewidmet haben und die Lucene-Suche
bereits out-of-the-box unterst&uuml;tzt wird. Ebenso positiv ist das konsequente Exception-Handling
f&uuml;r die jeweiligen Module.
<br />
<br />
Negativ zu bewerten ist, dass das Zend Framework keine eigene Benchmark-M&ouml;glichkeit mitbringt um
den Quellcode profilen zu k&ouml;nnen.
<br />
<br />
<br />
<a name="Einsatz-von-Design-Pattern"></a><h6>Einsatz von Design-Pattern</h6>
Design-Pattern spielen beim Zend Framework eine herausragende Rolle. Im Mittelpunkt stehen wie bei den
&uuml;brigen bisherigen Probanden auch das MVC- und FrontController-Paradigma als zentrale
Pr&auml;sentations- und Business-Schicht-Pattern. Um die Struktur und den Aufbau genauer analysieren
zu k&ouml;nnen wurde auch hier eine Komplett-API-Dokumentation in Doxygen und Dot erzeugt. Trotz des
hinsichtlich PHP 5 m&ouml;glichen sauberen Interface-Designs und der Verwendung von abstrakten
Basis-Klassen ist auch beim Zend Framework im Gegensatz zu CakePHP und dem Adventure-PHP-Framework
kein einheitliches Klassen-Design auszumachen, sondern jedes Package besitzt eine oder mehrere eigene
Definitionen einer abstrakten Basis-Klasse oder eines Interfaces.<br />
Auff&auml;llig ist, dass sehr viele Klassen entweder statisch verwendet werden (<em>Zend_Controller_Action_HelperBroker</em>)
oder das Singleton-Pattern in jeder Klasse neu implementieren (<em>Zend_Controller_Front</em>). Ein
abstrakter Ansatz (evtl. "abstract singleton" oder "generic fabric pattern") wird nicht verfolgt, was
den Anwender darauf beschr&auml;nkt, nur diejenigen Klassen singleton instanziieren oder verwenden zu
k&ouml;nnen, die das Feature auch unterst&uuml;tzen.
<br />
<br />
<br />
<a name="Struktur-des-Quellcodes-Design-der-Klassen"></a><h6>Struktur des Quellcodes / Design der Klassen</h6>
Der Aufbau des Packages wurde nach dem Zend Namensgebungsprinzip stringent aufgebaut und der Anwender
findet sich in den Komponenten sehr schnell zurecht. Die Klassen und deren Methoden sind auf einem
sehr hohen Abstraktionslevel abgefasst, was designtechnisch als sehr positiv zu bewerten ist, Einsteigern
das Analysieren des Quellcodes jedoch etwas erschwert. Nichtsdestoweniger wird durchg&auml;ngig
Gebrauch von der Parameter-Typ-Deklaration in den Funktionsdefinitionen gemacht, was das Debugging
erleichtert, da nur erlaubte Daten- und Objekt-Typen akzeptiert werden.
<br />
<br />
<br />
<a name="Einsetzbarkeit-fuer-mehrere-Applikationen"></a><h6>Einsetzbarkeit f&uuml;r mehrere Applikationen</h6>
Um Anwendungen und Module in unterschiedlichen Umgebungen verwenden zu k&ouml;nnen bietet das Zend
Framework die Komponenten
<ul>
  <li>Zend_Registry</li>
  <li>Zend_Config</li>
  <li>Zend_Locale.</li>
</ul>
Mit diesen kann der Entwickler sehr einfach Sprach- und Umgebungs-abh&auml;ngige Konfigurationen erzeugen
und in den Anwendungen verwenden. Im Klassen-Design fehlt die Sprach- und Umgebungs-Abh&auml;ngigkeit
jedoch noch, so dass es nicht m&ouml;glich ist in einem Controller an Hand der Sprache des Controllers
selbst eine Konfiguration zu laden, sondern man muss auf Mittel wie Registry zur&uuml;ckgreifen, was
zun&auml;chst nicht negativ auff&auml;llt, aber etwas aufw&auml;ndiger ist.
<br />
<br />
<br />
<a name="Erweiterbarkeit"></a><h6>Erweiterbarkeit</h6>
Engagierte Entwickler k&ouml;nnen das Zend Framework einfach erweitern. M&ouml;glichkeiten werden
bereits im Manual aufgezeigt und es wird auf Situationen verwiesen, zu denen dieses auch notwendig ist.
Dies sollte dem Anwender auch nicht schwer fallen, denn zu den jeweiligen Klassen existiert
&uuml;blicherweise eine Interface-Definition der zu erweiternden Klasse. Durch die Masse der im Zend
Framework integrierten Klassen und Module besteht jedoch auch hier die Gefahr, dass dieses zu einer
monolithischen Klassensammlung wie PEAR mutieren k&ouml;nnte und das Kern-Design verloren geht. Wie
bei den bisherigen Testkandidaten auch, muss der Entwickler bei der Erstellung komplexer GUI-Strukturen
auf Drittprodukte ausweichen, was vom Autor als problematisch hinsichtlich des urspr&uuml;nglichen
Designs des Frameworks betrachtet wird.
<br />
<br />
<br />
<a name="Scaffolding"></a><h6>Scaffolding</h6>
Ein Rapid Development Feature im Sinne von CakePHP und CodeIgniter ist im Zend Framework nicht
vorgesehen. Es sind zwar &auml;hnliche Strukturen vorhanden (Zend_Db_Adapter, Row- / Table-Data-Gateway),
jedoch gibt es keinen Scaffolding-Mode, bei dem mit wenigen Handgriffen eine komplette GUI-Anwendung
erzeugt werden kann. Aus Sicht des Autors ist dieses jedoch auch nicht Teil der Strategie bzw. des
Designs des Frameworks, muss aber in der Bewertung als fehlend kenntlich gemacht werden.
<br />
<br />
<br />
<a name="3-3-7-Dokumentation"></a><h5>3.3.7. Dokumentation</h5>
<br />
<a name="Dokumentation-des-Quellcodes"></a><h6>Dokumentation des Quellcodes</h6>
Der Quellcode des Frameworks ist sehr gut dokumentiert wodurch der Blick in den Quellcode eine einfache
Analyse - nat&uuml;rlich im Rahmen der F&auml;higkeiten des Programmierers betrachtet - zul&auml;sst.
<br />
<br />
<br />
<a name="API-Dokumentation"></a><h6>API-Dokumentation</h6>
Unter <doku:link>http://framework.zend.com/apidoc/core/</doku:link> findet der interessierte
Entwickler eine API-Dokumentation, die mit PHPDocumentor aus dem Quelltext generiert wurde.
<br />
<br />
<br />
<a name="Einfuehrungen,-Tutorials-und-Anwendungs-Beispiele"></a><h6>Einf&uuml;hrungen, Tutorials und Anwendungs-Beispiele</h6>
Die Seite <doku:link>http://framework.zend.com/</doku:link> dient dem Entwickler als zentrale Ressource
f&uuml;r Dokumentationen. Das Manual selbst ist im deutschen an vielen Stellen schlecht &uuml;bersetzt,
oder es fehlen &Uuml;bersetzungen. Die Beispiele sind oft unvollst&auml;ndig und "verschweigen" die
Bedeutung einiger Variablen (wie oben aufgezeigt <em>$router</em>). Viele der Code-Snippets zeigen
zudem nur die Verwendung einer Komponente als Prototyp, unterst&uuml;tzen jedoch nicht den konkreten
Anwendungsfall.<br />
Ein weiteres Manko ist die Verf&uuml;gbarkeit des Wikis (<em><doku:link>http://framework.zend.com/wiki/display/ZFDEV/Home</doku:link></em>).
Dieses ist aus M&uuml;nchen nur in ca. 50% der F&auml;lle verf&uuml;gbar und wird &uuml;blicherweise
mit einem "Bad Proxy Request" quittiert. Im Wiki sind nach Meinung der Redaktion keine f&uuml;r
Anf&auml;nger geeigneten Tutorials enthalten - die Beitr&auml;ge helfen lediglich bereits mit dem
Thema vertrauten Personen.
<br />
<br />
<br />
<a name="ChangeLogs-Migrations-Hinweise-f&uuml;r-API-Aenderungen"></a><h6>ChangeLogs / Migrations-Hinweise f&uuml;r API-&Auml;nderungen</h6>
Die detaillierten ChangeLogs und &Auml;nderungshinweise zu den Versionen sind im Manual eingearbeitet
und werden auch auf <doku:link>http://framework.zend.com/changelog</doku:link> nochmal gesondert f&uuml;r
die bereits ver&ouml;ffentlichten dargestellt.
<br />
<br />
<br />
<br />
<a name="3-3-8-Support"></a><h5>3.3.8. Support</h5>
F&uuml;r den Support des Frameworks werden dem Besucher unter <doku:link>http://framework.zend.com/support</doku:link>
mehrere kostenlose und kostenpflichtige Services offeriert. Unter die kostenlosen Services fallen
das Wiki, verschiedene Mailing-Listen, Chats, Blogs und der Bugtracker. Im deutschsprachigen Raum wird
das "ZF Forum" (<em><doku:link>http://www.zfforums.de/</doku:link></em>), das oben bereits zitiert
wurde, angeboten. Dar&uuml;ber hinaus bietet Zend das englischsprachige Pendant unter
<doku:link>http://www.zfforums.com/</doku:link>, bzw. die Developer Zone
(<em><doku:link>http://devzone.zend.com/public/view</doku:link></em>). Alles in Allem ist der Umfang
der von Zend angebotenen Support-M&ouml;glichkeiten sehr gro&szlig; und sehr vielseitig.
<br />
<br />
<br />
<br />
<a name="3-3-9-Benchmark"></a><h5>3.3.9. Benchmark</h5>
Das Benchmark-Ergebnis wurde mit der im Adventure-PHP-Framework integrierten Benchmark-Komponente
<strong>BenchmarkTimer</strong> gemessen. Hierzu wurde ein
<php:highlight>
   $T = &Singleton::getInstance('BenchmarkTimer');
   $T->start('ZFPage');
</php:highlight>
am Anfang der <em>index.php</em> und ein
<php:highlight>
   $T->stop('ZFPage');
   echo $T->createReport();
</php:highlight>
am Ende eingef&uuml;gt. Es wurde eine Durchschnitts-Wert von <strong>0.2498 s</strong> gemessen. In
der Rendering-Zeit ist die komplette Ausf&uuml;hrungszeit f&uuml;r das Generieren der Views und der
Formatierung der Quelltexte eingeschlossen.
<br />
<br />
<br />
&raquo; Weiter auf <a href="./?Seite=054-PHP-Frameworks-im-Test-6" title="PHP-Frameworks im Test (6)">Seite 6</a> (Bewertung Adventure-PHP-Framework).
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_053" />