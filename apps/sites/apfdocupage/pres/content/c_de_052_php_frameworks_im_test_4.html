<doku:title tags="php,frameworks,test,cakephp,codeigniter,zend framework,adventure php framework,bewertung" title="PHP-Frameworks im Test (4)" urlname="PHP-Frameworks-im-Test-4">
  Der Artikel PHP-Frameworks im Test vergleicht unterschiedliche Frameworks. Basis der Bewertung ist
  ein Anforderungskatalog, der darauf Wert legt, dass der Entwickler einen m&ouml;glichst
  vollst&auml;ndigen Werkzeugkasten an die Hand bekommt um effektiv Webseiten und Web-Applikationen
  entwickeln zu k&ouml;nnen.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<h3>3.2. CodeIgniter</h3>
<br />
<h4>3.2.1. Allgemeines</h4>
<br />
<h5>Roadmap des Projekts</h5>
Auf der Seite <doku:link>http://codeigniter.com/</doku:link> und den angeschlossenene Seiten findet
sich leider keine Roadmap, die &uuml;ber den weiteren Verlauf der Entwicklungen Aufschluss geben
k&ouml;nnte. Einzig das Bug-Tracking-System oder das Forum lassen vermuten, welche Features im
n&auml;chsten Release eingef&uuml;hrt werden.
<br />
<br />
<br />
<h5>Aktualit&auml;t der Version</h5>
Die unter <doku:link>http://codeigniter.com/download.php</doku:link> (Download startet sofort)
verf&uuml;gbare Version stammt vom 12.07.2007. Das Release-Datum und die Aktivit&auml;ten im
Bug-Tracking-System stellen sicher, dass der Code aktuell ist und das Projekt regelm&auml;&szlig;ig
gepflegt wird.
<br />
<br />
<br />
<h5>Release-Packages in verschiedenen Formaten</h5>
Das Release von CodeIgniter ist nur in einer ZIP-Version verf&uuml;gbar. Somit ist nicht sichergestellt,
dass die Pakete auch auf Nicht-Windows-Betriebssystemen einfach verwendet werden k&ouml;nnen.
<br />
<br />
<br />
<h5>CVS/SVN-Repositories</h5>
F&uuml;r CodeIgniter ist kein &ouml;ffentliches CVS- oder SVN-Repository zug&auml;nglich, &uuml;ber
das z.B. "nightly builds" bezogen werden k&ouml;nnen.
<br />
<br />
<br />
<h5>Bug-Tracking / Ticketing</h5>
Unter <doku:link>http://codeigniter.com/bug_tracker/</doku:link> k&ouml;nnen Bugs berichtet werden.
Zudem existiert mit <doku:link>http://codeigniter.com/forums/viewforum/51/</doku:link> ein Bug-Report-
Forum, das sowohl zum Reporting als auch zur Diskussion mit den Entwicklern genutzt wird.
<br />
<br />
<br />
<h5>Version f&uuml;r PHP 4</h5>
Die installierte Version ist zu PHP 4 (im Test: Version 4.4.6) kompatibel.
<br />
<br />
<br />
<h5>Version f&uuml;r PHP 5</h5>
Die installierte Version ist zu PHP 5 (im Test: Version 5.2.1) kompatibel.
<br />
<br />
<br />
<h4>3.2.2. Installation</h4>
<br />
<h5>Extract & Go</h5>
Auch bei CodeIgniter ist keine aufw&auml;ndige Vorbereitung notwendig. Nach dem Entpacken des Paketes
in den Document-Root des zu Test-Zwecken erstellten VHOSTs ist die Demo-Applikation verf&uuml;gbar.
Positiv auff&auml;llig ist der grafisch &uuml;bersichtlich und inhaltlich gut strukturierte
User-Guide, der dem Benutzer den Einstieg erleichtert.
<br />
<br />
<h5>Konfiguration</h5>
Die notwendigen Konfigurationsarbeiten sind im User-Guide auf der Seite
<doku:link>http://codeigniter.com/user_guide/installation/index.html</doku:link> beschrieben.
Haupts&auml;chlich geht es dabei um das Setup des absoluten Pfads, in dem CodeIgniter ausgef&uuml;hrt
wird und die Datenbank Zugangsdaten. Um das URL-Layout von CodeIgniter nutzen zu k&ouml;nnen, sind
manuelle Anpassungen notwendig. Hierzu wurde eine Apache RewriteRule erstellt, die alle Anfragen der
Form
<pre class="tagexample">
  http://codeigniter.de/{Controlle}/{Action}[/{Param}]/../{ParamN}]
</pre>
an die zentrale Datei <em>index.php</em> weiterleitet. Die erstellte <em>.htaccess</em>-Datei hat
folgenden Inhalt:
<pre class="tagexample">
  RewriteEngine On
  RewriteRule !(index.php|css|jpe?g|png|gif)$ /index.php?%{REQUEST_URI} [NC,L]
</pre>
(<em>Quelle: <doku:link>http://codeigniter.com/user_guide/general/urls.html</doku:link></em>)
<br />
<br />
<br />
<h4>3.2.3. Erste Schritte</h4>
<br />
<h5>Demo-Software</h5>
Das PHP-Framework CodeIgniter bringt, &auml;hnlich wie CakePHP, eine Demo-Seite sowie einen
Offline-User-Guide mit. Die Einstiegsseite gibt dem Anwender Informationen dar&uuml;ber, wo in das
System eingegriffen werden muss um &Auml;nderungen an der angezeigten Seite durchzuf&uuml;hren, bzw.
wo das Manual zu finden ist. Die Seite bringt jedoch keine Demo-Applikation bzw. -Module mit, die
dem Entwickler ein Gef&uuml;hl f&uuml;r die Funktionsweise geben.
<br />
<br />
<h5>Einf&uuml;hrung / Quickstart</h5>
Das Manual enth&auml;lt einige ausf&uuml;hrliche Kapitel, &uuml;ber die ersten Schritte. An dieser
Stelle sie nochmals auf <doku:link>http://codeigniter.com/user_guide/installation/index.html</doku:link>
hingewiesen. Die Seite dient dem CodeIgniter-Anf&auml;nger als Einstiegsseite.<br />
Etwas negativ f&auml;llt auf, dass der Benutzer direkt nach der Installations-Seite  an die Referenz
verwiesen wird ohne etwa eine "Hallo Welt!"-Applikation oder &auml;hnliches zwischen zu lagern.
Eine "Hallo Welt!"-Applikation findet sich in Form eines Video Tutorials unter
<doku:link>http://codeigniter.com/tutorials/watch/intro/</doku:link> allerdings wird im Manual nicht
darauf verwiesen.
<br />
<br />
<br />
<h4>3.2.4. Erstellung einer Webseite</h4>
<br />
<h5>Template-Bau / Layoutgestaltung</h5>
Die Standard-Seite, die mit dem Release mitgeliefert wird beschreibt bereits, welche Dateien bearbeitet
werden m&uuml;ssen um auf die Ausgabe Einfluss nehmen zu k&ouml;nnen. Nagativ f&auml;llt sofort
ins Auge, dass CodeIgniter standardm&auml;&szlig;ig keine Layouts unterst&uuml;tzt, wie dies z.B.
CakePHP tut. Um ein zentrales Seiten-Layout einsetzen zu k&ouml;nnen ist eine Erweiterung der eingesetzten
Klassen notwendig. Eine Anleitung dazu kann unter <doku:link>http://codeigniter.com/wiki/layout_library/</doku:link>
gefunden werden. Nach einer erneuten Recherche konnte eine weitere L&ouml;sung f&uuml;r das Layout-
Thema gefunden werden: YATS, ein erweitertes Template-System f&uuml;r CodeIgniter. Dieses geh&ouml;rt
jedoch ebenso wie der Quick-Hack im Wiki nicht zum Standard-Release. YATS kann unter
<doku:link>http://codeigniter.com/wiki/Yet_Another_Template_System/</doku:link> heruntergeladen
und installiert werden. Postitiv ist zu vermerken, dass das AddOn ein eigenes Support-Forum mitbringt.
YATS ersetzt bei der Installation einige der Standard-Bibliotheken von CodeIgniter, was zur Folge hat,
dass einige der bisher erstellten Applikationen unter Umst&auml;nden nicht mehr korrekt ausgef&uuml;hrt
werden k&ouml;nnen.
<br />
<br />
F&uuml;r die Untersuchung des Frameworks wurde beim Template-Bau die erweiterte Layout-Library des WIKIs
genutzt. Das Erstellen von Templates erfolgt damit einer &auml;hnlichen Vorgehensweise, die bei CakePHP
state-of-the-art ist. View-Templates (<em>Endung: .php</em>) werden als PHP-Skripte eingebunden und
k&ouml;nnen beliebigen PHP-Code enthalten. Zun&auml;chst wurde unter
<strong>/system/application/views/demosite</strong> eine Layout-Datei mit dem Namen
<strong>basic_layout.php</strong> angelegt um das gemeinsame Layout abbilden zu k&ouml;nnen. Diese
enth&auml;lt, ebenso wie beim Test des vorangegangenen Probanden die Bereiche f&uuml;r Men&uuml;,
Top-Men&uuml;, News und Content.
<br />
<br />
Da CodeIgniter auch mit der erweiterten Layout-Library das Handeln von mehr als einem View-Bereich im
Layout-Template nicht unterst&uuml;tzt, wurde die Layout-Library wie folgt erweitert:
<php:highlight>
   class Layout
   {

       var $obj;
       var $layout;

       function Layout($layout)
       {
           $this->obj =& get_instance();
           $this->layout = $layout;
       }

       function view($view, $layoutvar = 'content_for_layout',$data=null, $return=true)
       {
           $data[$layoutvar] = $this->obj->load->view($view,$data,true);

           if($return)
           {
               $output = $this->obj->load->view($this->layout,$data, true);
               return $output;
           }
           else
           {
               $this->obj->load->view($this->layout,$data, false);
           }
       }
   }
</php:highlight>
Damit ist es dem Entwickler m&ouml;glich mehrere Bereiche im zentralen Layout zu definieren und den
Inhalt unterschiedlicher Views dynamisch dort zu platzieren. Im Beispiel konnte damit sowohl ein
<pre class="tagexample">
  &lt;td width="180" height="400" valign="top" class="menu"&gt;
    &lt;?php echo $content_for_menu; ?&gt;
  &lt;/td&gt;
</pre>
als auch ein
<pre class="tagexample">
  &lt;td height="20" class="topmenu"&gt;
    &lt;?php echo $content_for_topmenu; ?&gt;
  &lt;/td>
</pre>
im Template definiert und im zugeh&ouml;rigen Controller gef&uuml;llt werden.
<br />
<br />
<br />
<h5>Handling von Controllern</h5>
Um ein einheitliches URL-Bild erstellen zu k&ouml;nnen muss auch hier das Routing angepasst werden.
Dies erfolgt in der Datei <strong>/system/application/config/routes.php</strong>. Dort werden u.a.
die Default-Route und Benutzer-eigene Routen definiert. F&uuml;r den Test muss lediglich die
Default-Route angepasst und ein Mapping auf den Seite-Controller eingetragen werden:
<php:highlight>
   $route['default_controller'] = 'Seite';
   $route['Seite'] = 'Seite/Startseite';
</php:highlight>
Der bereits angesprochene Action-Controller implementiert die mitgelieferte Controller-Klasse und
steuert die Bef&uuml;llung der einzelnen Views. Der Konstruktor der Klasse wir dazu genutzt um die
o.g. Layout-Library zu laden und die allgemeinen Views (Men&uuml;, Top-Men&uuml;) mit Daten zu
f&uuml;llen.
<php:highlight>
 class Seite extends Controller {

    function Seite(){
       parent::Controller();
       $this->load->library('layout','demosite/basic_layout');
       $this->layout->view('demosite/menu','content_for_menu');
       $this->layout->view('demosite/topmenu','content_for_topmenu');
    }

    function index(){
       $this->Startseite();
    }

    function Startseite(){
       echo $this->layout->view('demosite/content/startseite');
    }

    function Benchmark(){
       echo $this->layout->view('demosite/content/benchmark');
    }

 }
</php:highlight>
Die Methode <strong>index()</strong> wird immer dann vom Dispatcher aufgerufen, wenn keine Methode in
der URL angegeben ist. Wird eine Methode in der URL angegeben, die nicht im Controller existert wird
die etwas unverst&auml;ndliche Meldung angezeigt, dass die aufgerufene Seite nicht auf dem Server
existiert (Fehler 404). Die Ursache konnte erst nach einer Zeit der Nachforschung herausgefunden werden.
Es ist bei CodeIgniter tats&auml;chlich so, dass jede "virtuelle" Methode der URL auch eine konkrete
Implementierung im Controller ben&ouml;tigt. Interessant w&auml;re an dieser Stelle eine Bootstrap-Methode,
die alle Aufrufe, in denen lediglich Inhalte per URL-Parameter geladen werden m&uuml;ssen, abf&auml;ngt.
Auf Grund der URL-Struktur kann dies beispielsweise &uuml;ber den URL-Helper in der Methode
<strong>index()</strong> realisiert werden:
<php:highlight>
   function index(){

      // Action-Parameter holen
      $Action = $this->uri->segment(2);

      if(!method_exists($this,$Action)){

         // Action-Methode ausf&uuml;hren
         $this->{$Action}();

       // end if
      }
      else{

         if(file_exists('system/application/views/demosite/content/'.strtolower($Action).'.php')){

            // View rendern
            $this->_output($this->layout->view('views/demosite/content/'.strtolower($Action));

          // end if
         }
         else{

            // Zur Startseite leiten
            redirect('Seite');

          // end else
         }

       // end else
      }

   // end function
  }
</php:highlight>
Um den Test zu komplettieren, wurden - wie bereits im Code des Controllers zu sehen ist - die Seiten
Startseite, Benchmark und Formulare mit Inhalten gef&uuml;llt.
<br />
<br />
<br />
<h5>Erweiterbarkeit der GUI-Komponenten</h5>
Im Quellcode der Datei <em>benchmark.php</em> befinden sich neben "normalen" HTML-Tags auch XML-Tags,
zwischen den PHP-Codes eingeschlossen sind, der formatiert auf der Seite dargestellt werden sollen.
CakePHP und das Adventure-PHP-Framework bieten dazu generische Tag-Parser bzw. TagLibs, die diese
Ausgaben erzeugen. CodeIgniter verf&uuml;gt zwar ebenso wie CakePHP &uuml;ber Helper-Funktionen, die
allerdings nativ keine XML-Tags parsen k&ouml;nnen. Um dieses Verhalten nachstellen zu k&ouml;nnen
wird die interne Controller-Methode <strong>_output()</strong> f&uuml;r die Aufgabe des XML-Tag-Parsings
modifiziert. Es wurde jedoch davon abgesehen eine generische Implementierung f&uuml;r diese Aufgabe
zu w&auml;hlen, da dies sonst den Rahmen der Evaluierung sprengen w&uuml;rde. Die Bereiche Navigation
innerhalb des Dokumentationsbereich wurde nicht als Tag, sondern als zus&auml;tzlicher View realisiert,
damit die Codierung nicht zu stark vom CodeIgniter-Standard abweicht:
<php:highlight>
	function _output($output){

      // load helper
      $this->load->helper('highlight');

      // Include Tag parsing
      // We could go so far to include a generic tag-parser, that can be configured in any
      // configuration file, but i refrain from doing that. this is just a non generic parser
      echo highlight($output);

    // end function
	}
</php:highlight>
Um die Funktion des Parsens auszulagern wurde ein Helper programmiert, der das Tag-Parsen &uuml;ber
Ersetzung regul&auml;rer Such-Strings realisiert. Die Datei
<strong>/system/application/helpers/highlight_helper.php</strong> hat demnach folgenden Inhalt:
<php:highlight>
   function highlight($content){

      // Quelltext parsen
      return preg_replace_callback('=\<php\:highlight\>(.*?)\<\/php\:highlight\>=si','highlight_it',$content);

    // end function
   }

   function highlight_it($content){

      $HighlightedContent = highlight_string(trim('<?php'.ltrim(rtrim($content[1]),"\x0A..\x0D").' ?>'),true);

      // PHP-Anfangstag ersetzen
      $HighlightedContent = str_replace('<font color="#007700">&lt;?</font>',
                                        '',
                                        $HighlightedContent);
      $HighlightedContent = str_replace('<font color="#0000BB">&lt;?php&nbsp;',
                                        '<font color="#0000BB">',
                                        $HighlightedContent);
      $HighlightedContent = str_replace('<font color="#0000BB">php',
                                        '<font color="#0000BB">',
                                        $HighlightedContent);
      $HighlightedContent = str_replace('<font color="#0000BB">&nbsp;</font>',
                                        '',
                                        $HighlightedContent);

      // PHP-Endtag ersetzen
      $HighlightedContent = str_replace('<font color="#0000BB">?&gt;</font>','',$HighlightedContent);

      // Code im DIV zurückgeben
      return '<div class="phpcode">'.$HighlightedContent.'</div>';

    // end function
   }
</php:highlight>
<br />
<br />
<h5>Komplexe Layouts</h5>
Da bereits die Gestaltung einer einfachen Webseite nicht ohne einige Hindernisse m&ouml;glich ist,
sieht der Autor auch bei diesem Framework Schwierigkeiten beim Aufsetzen von komplexen Layouts und
verschachtelten Funktionen. Auch bei CodeIgniter konnten Men&uuml; und Top-Men&uuml; nur als statische
Views eingebunden werden. Eine Art "Controller f&uuml;r Views", mit dem weiterer dynamischer
HTML-Code generiert werden kann - um beispielsweise ein Men&uuml; aus einem Model-Objekt darzustellen -
ist nicht vorgesehen.
<br />
<br />
Auch hier wurde keine weitere Pr&uuml;fung unternommen, da keine Beschreibungen f&uuml;r eine
offizielle L&ouml;sung unter den CodeIgniter-Seiten gefunden werden konnte. Ans&auml;tze waren unter
<ul>
  <li><doku:link>http://codeigniter.com/wiki/Multiple_Applications_via_Symlinks/</doku:link> (Smarty)</li>
</ul>
zu finden. Diese waren jedoch nicht auf das Problem zugeschnitten und eine Evaluierung von Smarty im
Zusammenspiel mit CodeIgniter ist nicht Teil der Betrachtungen.
<br />
<br />
<br />
<h5>FormularDesign</h5>
Zur Erstellung eines Formulars bietet CodeIgniter den FormHelper (<doku:link>http://codeigniter.com/user_guide/helpers/form_helper.html</doku:link>).
Um die Vergleichbarkeit zu wahren wird auch hier das bereits unter 3.1.4. beschriebene Formular
erstellt. Da das Formular in die bereits bestehende Seite eingebunden werden soll, wird neues
View-Template mit dem Namen <em>kontakt.php</em> unter <em>/system/application/views/demosite/content</em>
angelegt. Dieses hat den folgenden Inhalt:
<pre class="tagexample">
&lt;font style="font-size: 26px; font weight: bold;"&gt;Kontakt-Formular&lt;/font&gt;
&lt;br /&gt;
&lt;br /&gt;
Wenn Sie mit mir in Kontakt treten möchten, dann benutzen Sie einfach dieses Formular. Geben Sie Ihre
Nachricht ein und schon kann es los gehen. Ich werden mich dann umgehend mit Ihnen in Verbindung
setzten. &lt;strong&gt;Bitte füllen Sie das Formular vollständig aus!&lt;/strong&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;?php echo $this-&gt;validation-&gt;error_string; ?&gt;
&lt;?php echo form_open('/Seite/Kontakt'); ?&gt;
 &lt;span style="width: 47px; border: 0px solid black; margin-right: 69px;"&gt;Person:&lt;/span&gt;
 &lt;?php
  echo form_dropdown('person',
                     array(
                              '' =&gt; '',
                              '1' =&gt; 'Max Mustermann',
                              '2' =&gt; 'Bianka Mustermann'
                              ),
                     null,
                     'class="eingabe_feld"'
                    );
 ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;span style="width: 56x; border: 0px solid black; margin-right: 64px;"&gt;Ihr Name:&lt;/span&gt;
 &lt;?php
    echo form_input(array(
                          'name' =&gt; 'name',
                          'value' =&gt; $this-&gt;validation-&gt;name,
                          'class' =&gt; 'eingabe_feld',
                          'style' =&gt; 'width: 280px;'.$ContactNameStyle
                         )
                    );
 ?&gt;
 &lt;?php echo $ContactNameErrorMessage; ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;span style="width: 108px; border: 0px solid black; margin-right: 10px;"&gt;Ihre eMail-Adresse:&lt;/span&gt;
 &lt;?php
    echo form_input(array(
                          'name' =&gt; 'email',
                          'value' =&gt; $this-&gt;validation-&gt;email,
                          'class' =&gt; 'eingabe_feld',
                          'style' =&gt; 'width: 280px;'.$ContactEMailStyle
                         )
                    );
 ?&gt;
 &lt;?php echo $ContactEMailErrorMessage; ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;span style="width: 57px; border: 0px solid black; margin-right: 61px;"&gt;Ihr Betreff:&lt;/span&gt;
 &lt;?php
    echo form_input(array(
                          'name' =&gt; 'subject',
                          'value' =&gt; $this-&gt;validation-&gt;subject,
                          'class' =&gt; 'eingabe_feld',
                          'style' =&gt; 'width: 280px;'.$ContactSubjectStyle
                         )
                    );
 ?&gt;
 &lt;?php echo $ContactSubjectErrorMessage; ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 Ihre Nachricht:
 &lt;br /&gt;
 &lt;?php
    echo form_textarea(array(
                             'name' =&gt; 'note',
                             'value' =&gt; $this-&gt;validation-&gt;note,
                             'class' =&gt; 'eingabe_feld',
                             'style' =&gt; 'height: 200px; width: 400px; overflow: auto;'.$ContactNoteStyle
                            )
                      );
 ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;?php echo form_submit('Absenden','Absenden','class="eingabe_feld"'); ?&gt;
&lt;?php echo form_close(); ?&gt;
</pre>
Das Template zeigt, dass der Entwickler und Template-Bauer mit dem Form-Helper die M&ouml;glichkeit
hat Formular-Felder per Helper-Funktionen generieren zu lassen. Hier stehen ihm beispielsweise die
Funktionen <strong>form_input()</strong> oder <strong>form_textarea()</strong> zur Verf&uuml;gung.
Auch Formular-Tags k&ouml;nnen automatisch generiert werden.<br />
Im Gegensatz zu CakePHP verf&uuml;gt das Framework CodeIgniter &uuml;ber eine eingebaute Formular-
Validierung mit sehr vielseitigen Einstellungsm&ouml;glichkeiten. Der Quellcode der zugeh&ouml;rigen
Controller-Methode zeigt die Anwendung:
<php:highlight>
	function Kontakt(){

      // Libraries und Helper laden
   	$this->load->helper('form');
   	$this->load->helper('url');
		$this->load->library('validation');

   	// View-Daten vorbereiten
      $data['ContactNameStyle'] = '';
      $data['ContactEMailStyle'] = '';
      $data['ContactSubjectStyle'] = '';
      $data['ContactNoteStyle'] = '';

      // Validierung konfigurieren
		$rules['person'] = 'required|empty';
		$rules['name']	= 'required|min_length[3]';
		$rules['email'] = 'required|valid_email';
		$rules['subject']	= 'required|min_length[3]';
		$rules['note'] = 'required|min_length[5]';
		$this->validation->set_rules($rules);

		// Feldernamen für Validierung bezeichnen
   	$fields['person'] = 'Person';
   	$fields['name'] = 'Name';
   	$fields['email'] = 'E-Mail';
   	$fields['subject'] = 'Betreff';
   	$fields['note'] = 'Notiz';
   	$this->validation->set_fields($fields);

      // Validierung starten
      if($this->validation->run() == FALSE){

         // Falls die Error-Member-Variable gesetzt ist, roten Rahmen zeichnen
         if($this->validation->name_error){
            $data['ContactNameStyle'] = 'border: 2px solid red;';
         }
         if($this->validation->email_error){
            $data['ContactEMailStyle'] = 'border: 2px solid red;';
         }
         if($this->validation->subject_error){
            $data['ContactSubjectStyle'] = 'border: 2px solid red;';
         }
         if($this->validation->note_error){
            $data['ContactNoteStyle'] = 'border: 2px solid red;';
         }

			// View rendern
         $this->_output($this->layout->view('demosite/content/kontakt','content_for_layout',$data));

       // end else
		}
		else{
      	$this->_output($this->layout->view('demosite/content/kontakt_success','content_for_layout',$data));
       // end else
      }

    // end function
	}
</php:highlight>
Im ersten Anweisungsblock werden die Helper und Libraries geladen, die zur Validierung ben&ouml;tigt
werden. Der zweite Block definiert einen Satz von Daten, die an den Formular-View &uuml;bergeben
werden sollen um die Formatierung der Felder bei Bedarf um ein weiteres Style-Attribut zu erg&auml;nzen.
Anschlie&szlig;end wird die Validierung konfiguriert. Wie unter <doku:link>http://codeigniter.com/user_guide/libraries/validation.html</doku:link>
nachzulesen ist, k&ouml;nnen beliebig viele Validierungsmethoden kaskadiert und neue vom Anwender
programmiert werden. Damit die Ausgabe der Fehlermeldungen zum aktuellen Anwendungsfall passt, wird
der Validator-Library im n&auml;chsten Schritt bekannt gemacht, wie die Felder-Namen hei&szlig;en.
Diese Definition ist vor allem deshalb wichtig, damit sp&auml;ter mit
<php:highlight>
   if($this->validation->name_error){
      $data['ContactNameStyle'] = 'border: 2px solid red;';
   }
</php:highlight>
der zus&auml;tzliche CSS-Tag erg&auml;nz werden kann um die Felder mit roten Rahmen zu markieren.
<br />
<br />
Nachteilig an der aufgezeigten Vorgehensweise ist, dass CodeIgniter das F&uuml;llen von POST-Werten
nicht selbst&auml;ndig bei Verwendung der Form-Helper-Funktionen erledigt, sondern dies zu Fu&szlig;
&uuml;ber die Validate-Library programmiert werden muss. Auch problematisch sieht der Autor, dass
das Presetting von POST-Werten in Select-Feldern nur dann funktioniert, wenn das Select-Feld manuell
angelegt wird. Bei Verwendung der Helper-Funktion <strong>form_dropdown()</strong> gibt es keine
generische M&ouml;glichkeit dies zu realisieren. Dar&uuml;ber hinaus ist die Validierung von
Formular-Feldern zwar unterst&uuml;tzt, jedoch recht umst&auml;ndlich in der Anwendung.
<br />
<br />
Fazit: Das Formular-Handling ist im Bereich der Validierung dem von CakePHP &uuml;berlegen, jedoch fehlen
in CodeIgniter wiederum einige Features, die in CakePHP Standard sind (Presetting). Vergleicht man nur
diese beiden Frameworks, so w&auml;re eine Mischung w&uuml;nschenswert.
<br />
<br />
<br />
<br />
<h4>3.2.5. URL-Handling</h4>
<br />
<h5>Unterst&uuml;tzung von URL-Rewriting</h5>
URL-Rewriting wird von CodeIgniter nativ unterst&uuml;tzt. Hierzu m&uuml;ssen zwar entsprechende
RewriteRules angelegt werden und diese leiten die Anfragen alle an die zentrale Bootstrap-Datei
<em>index.php</em> zur Verarbeitung weiter. Ein Betrieb ohne URL-Rewriting ist aber ebenso m&ouml;glich.
Dazu m&uuml;ssen einige Konfigurationseinstellungen in der <em>config.php</em>, die unter
<doku:link>http://codeigniter.com/user_guide/general/urls.html</doku:link> beschrieben sind,
ge&auml;ndert werden.
<br />
<br />
<h5>Generik des URL-Layouts</h5>
Das URL-Layout hat zur Zeit der Auslieferung das Format
<pre class="tagexample">
 http://www.example.com/{Controller}/{Action}[/{Param1}/.../{ParamN}]
</pre>
&Uuml;ber die Routing-Eintr&auml;ge k&ouml;nnen unterschiedliche URL-Teile als Kenner f&uuml;r
bestimmte Aktionen verwendet werden. Das Aufbrechenen des URL-Layouts hinsichtlich der Ausf&uuml;hrung
mehrerer Controller zur Laufzeit ist jedoch nicht m&ouml;glich. Die &Uuml;bergabe von beliebig vielen
und beliebig gearteten GET-Parametern ist nur im Non-Rewrite-URL-Moduls m&ouml;glich und auch nur dann,
wenn das globale Zur&uuml;cksetzen des <strong>$_GET</strong>-Arrays im Code verhindert wird.
<br />
<br />
<br />
<h5>URL-Manipulations-Tools / Linkgenerierung</h5>
Zur Generierung von URLs steht der URL-Helper zur Verf&uuml;gung. Dieser besitzt die unter
<doku:link>http://codeigniter.com/user_guide/helpers/url_helper.html</doku:link> beschriebenen
Funktionen. Es ist sowohl m&ouml;glich eine URL mit <strong>site_url()</strong> oder <strong>base_url()</strong>
zu generieren, als auch mit <strong>anchor()</strong> einen Anker-Link zu erstellen. Dar&uuml;ber
hinaus bietet die URL-Library(<em><doku:link>http://codeigniter.com/user_guide/libraries/uri.html</doku:link></em>)
diverse Manipulations-M&ouml;glichkeiten einer URL. Herausgegriffen sei an dieser Stelle die Methoden
<strong>uri_to_assoc</strong> und <strong>assoc_to_uri()</strong>, die zur Manipulation einer URL
an Hand eines Array m&ouml;glich macht. Dies k&ouml;nnte in etwa so aussehen:
<php:highlight>
  $this->load->library('uri');

  $ParamArray = array(
                      'MyParam1' => 'value1',
                      'MyParam2' => 'value2'
                      );
  $URLParams = $this->uri->uri_to_assoc(10);
  $URLParams = array_merge($ParamArray,$URL);

  $URL = $this->uri->assoc_to_uri($URLParams);
</php:highlight>
<br />
<br />
<h4>3.2.6. Design des Frameworks</h4>
<br />
<h5>Umfang der mitgelieferten Komponenten</h5>
CodeIgniter liefert einen gro&szlig;en Umfang an Bibliotheken mit dem Release aus. Hierzu geh&ouml;ren
alle Komponenten rund um die MVC-Implementierung und deren Helper, sowie Klassen, die als Basis
f&uuml;r GUI-Module dienen wie die Kalender- oder die File-Upload-Klasse. Einzusehen sind die
Dokumentationen im User-Guide / Sektion "Class Reference" unter <doku:link>http://codeigniter.com/user_guide</doku:link>.
Die Seite <doku:link>http://codeigniter.com/projects/</doku:link> und das Wiki
(<doku:link>http://codeigniter.com/wiki/</doku:link>) sind eine gute Ressource f&uuml;r fertige
Applikationen und Artikel mit Code-Beispielen rund um CodeIgniter. Ein netter Ansatz ist der
Quick-Reference-Table, der alle Methoden im &Uuml;berblick zeigt. So hat der Entwickler eine weitere
M&ouml;glichkeit, sich schnell einen &Uuml;berblick &uuml;ber die Komponenten und deren
M&ouml;glichkeiten zu verschaffen. Die Quick-Reference kann auf
<doku:link>http://codeigniter.com/user_guide/general/quick_reference.html</doku:link> im Manual
nachgeschlagen werden.<br />
Ein weiterer positiver Punkt ist, dass CodeIgniter eine direkte Unterst&uuml;tzung von Unit-Tests
mitbringt. Die Komponente <em>CI_Unit_test</em> kann dazu verwendet werden automatisierte Unit-Tests
von CodeIgniter-Applikationen ablaufen zu lassen.
<br />
<br />
<br />
<h5>Einsatz von Design-Pattern</h5>
Um w&auml;hrend der Evaluierung ein besseres Verst&auml;ndnis des Designs des Frameworks zu bekommen
wurde mit Hilfe von Doxygen und Dot eine API-Dokumentation generiert. Auff&auml;llig ist, dass kein
einheitliches Klassen-Modell existiert. Gegen&uuml;ber CakePHP und dem Adventure-PHP-Framework
basiert nicht jede Klasse auf einer gemeinsamen Basis-Klasse, sondern jede Klasse jedes Unter-Namespaces
hat ihre eigene Basis-Klasse. Das Singleton-Pattern wird zudem f&uuml;r einige Klassen jeweils neu
implementiert. Ein abstrakter Ansatz wird nicht verfolgt, was dazu f&uuml;hrt, dass der Anwender
darauf beschr&auml;nkt ist, nur diejenigen Klassen singleton instanziieren zu k&ouml;nnen, die das
Feature auch unterst&uuml;tzen. Positiv zu bewerten ist jedoch hier, dass ein generischer
Benchmarker im Lieferumfang enthalten ist, mit dem beliebige Code-Stellen gemessen werden k&ouml;nnen.
Das Handling des Benchmarkers ist jedoch hinsichtlich der <strong>mark()</strong>-Methode etwas
gew&ouml;hnungsbed&uuml;rftig. Die Ausgabe hingegen ist sehr &uuml;bersichtlich und erleichtert
die Performance-Optimierung.
<br />
<br />
<br />
<h5>Struktur des Quellcodes / Design der Klassen</h5>
Der Aufbau des Packages ist sehr &uuml;bersichtlich gestaltet. Die Benennung der Klassen kann jedoch
bei der Komponente "Controller" nicht ganz nachvollzogen werden, da es sich offensichtlich um eine
Core-Komponente handelt, die jedoch nicht mit "CI_" gepr&auml;fixt ist. Die Klassen an sich sind gut
dokumentiert, die Klassen-Variablen wurden in die Dokumentation leider nicht einbezogen.
<br />
<br />
<br />
<h5>Einsetzbarkeit f&uuml;r mehrere Applikationen</h5>
CodeIgniter bringt f&uuml;r die generische Implementierung von Applikationen und Modulen mehrere
Komponenten mit: <em>CI_Language</em> und <em>CI_Config</em>. Diese beiden Bibliotheken, und insbesondere
<strong>CI_Config</strong> bringen jedoch keine weitere Abstraktionsebene mit, die unterscheidet,
in welchem Umfeld und in welche Applikation ein Modul eingesetzt ist.
<br />
<br />
<br />
<h5>Erweiterbarkeit</h5>
Der modulare Design-Ansatz erm&ouml;glicht es dem engagierten Entwickler die Funktionalit&auml;ten
des Frameworks beliebig zu erweitern. Durch das nicht durchg&auml;ngige Klassen-Modell sind Erweiterungen
jedoch nicht durch ein Interface definiert und es besteht die Gefahr, dass CodeIgniter durch zu viele
Erweiterungen zu einer monolithischen Klassensammlung wie PEAR mutieren k&ouml;nnte. Auch im GUI-Bereich
von CodeIgniter sto&szlig;en die Entwickler schnell an die Grenzen und m&uuml;ssen auf Erweiterungen
oder den Einsatz von Drittprodukten ausweichen.
<br />
<br />
<br />
<h5>Scaffolding</h5>
Genau wie CakePHP bringt CodeIgniter ein Rapid Development Feature mit, das wie CakePHP Benutzern
hilft, Applikationen schnell zu entwickeln. CodeIgniter wei&szlig;t im Manual jedoch extra darauf hin,
dass Scaffolding-Applikationen nicht im Live-Betrieb eingesetzt werden sollten, was die Intension des
Rapid Development ein St&uuml;ck weit relativiert. Das hier betrachtete Beispiel ist ein auf
einem auf CodeIgniter aufsetzenden "Framework" basiertes Beispiel. Rapyd besitzt eine eigene Webseite,
die die gew&uuml&auml;hlten Beispiele n&auml;her erl&auml;utert. Auf
<doku:link>http://www.rapyd.com/samples.php/rapyd/samples</doku:link> kann dieses bei Bedarf noch einmal
nachvollzogen werden. Die CodeIgniter-Seite selbst geizt mit Anwendungsbeispielen des Scaffolding-Features.
Wirklich ausf&uuml;hrliche Beispiele finden sich nur auf externen Seiten.
<br />
<br />
<br />
<h4>3.2.7. Dokumentation</h4>
<br />
<h5>Dokumentation des Quellcodes</h5>
Wie bereits erw&auml;hnt ist der Quellcode gut dokumentiert, bei den Klassen-Variablen findet sich
jedoch wenig bis keine Dokumentation zur Bedeutung und Verwendung derselben. Durch die &uuml;bersichtliche
Strukturierung des Paketes findet sich der Anwender aber schnell im Quellcode zurecht, sollte der
Blick in das Manual nicht ausreichen.
<br />
<br />
<br />
<h5>API-Dokumentation</h5>
F&uuml;r CodeIgniter ist weder online noch offline eine API-Dokumentation verf&uuml;gbar. Zu
Evaluationszwecken wurde diese manuell mit Doxygen generiert, ersetzt jedoch nicht die Notwendigkeit,
dass diese vom Entwicklungsteam zur Verf&uuml;gung gestellt wird.
<br />
<br />
<br />
<h5>Einf&uuml;hrungen, Tutorials und Anwendungs-Beispiele</h5>
Die Seiten <doku:link>http://codeigniter.com/user_guide/</doku:link> und
<doku:link>http://codeigniter.com/wiki</doku:link> dienen dem Anwender als Ressourcen f&uuml;r
Einf&uuml;hrungen, Tutorials und Anwendungsbeispiele. Unter <doku:link>http://codeigniter.com/tutorials/</doku:link>
finden sich 2 Video Tutorials, die ebenfalls den Einstieg erleichtern sollen. Ein Link, der auf eine
externe Seite führt, zeigt die Erstellung einer Applikation mit AJAX Features
(<doku:link>http://video.derekallard.com/</doku:link>).<br />
Im Vergleich zu den Hinweisen auf Projekte, die bereits auf CodeIgniter aufgesetzt wurden
(<doku:link>http://codeigniter.com/projects/</doku:link>) wartet das User-Manual mit relativ wenigen
Einf&uuml;hrungsbeispielen auf und versteht sich eher als Referenz. Im Wiki finden sich unter
<doku:link>http://codeigniter.com/wiki/Special:Categories</doku:link> jedoch viele Kategorien, in
denen der Entwickler Anwendungsbeispiele beziehen kann. Abgesehen von der etwas ungl&uuml;cklichen
Strukturierung und den nicht ganz als solche zu verstehende Hinweisen auf das Wiki kann von einer
guten Auswahl an Dokumentationselementen gesprochen werden.
<br />
<br />
<br />
<h5>ChangeLogs / Migrations-Hinweise für API-&Auml;nderungen</h5>
Eine &ouml;ffentlich zug&auml;ngliche Release-Planung scheint kein Feature der CodeIgniter-Webseite
zu sein, denn auch in den News ist keine weitere Planung f&uuml;r das Feature-Set des Frameworks zu
sehen. ChangeLogs zu den einzelnen Releases finden sich dagegen in den Newseintr&auml;gen der
jeweiligen Anlk&uuml;ndigungen der neuen Features. Alte Releases sind jedoch nach einem neuen Release
nicht mehr zug&auml;nglich.
<br />
<br />
<br />
<br />
<h4>3.2.8. Support</h4>
Support erf&auml;hrt der Entwickler im direkt angeschlossenen Forum (<doku:link>http://codeigniter.com/forums/</doku:link>),
per Suche im Wiki, oder in diversen anderen Foren, die sich mit dem Thema PHP-Entwicklung besch&auml;ftigen.
Das eigene Forum ist gut strukturiert und gliedert sich auf in Foren f&uuml;r Feature-Requests und
Support. Bugfixes finden sich zudem auch im WIKI, was schnelle Hilfe verspricht. Eine Newsgroup zu
CodeIgniter findet sich unter <doku:link>http://groups.google.de/group/codeigniter?lnk=gschg</doku:link>,
ein IRC-Channel wurde unter <doku:link>http://codeigniter.com/forums/viewthread/57381/</doku:link>
bekannt gegeben.
<br />
<br />
<br />
<br />
<h4>3.2.9. Benchmark</h4>
Im Benchmark-Test konnte mit den CodeIgniter-eigenen Mitteln eine Rendering-Zeit von durchschnittlich
<strong>0.12434 s</strong> gemessen werden. Die Rendering-Zeit ist hier die komplette
Ausf&uuml;hrungszeit ohne Rendering-Zeit f&uuml;r eine Sub-Navigation. Diese wurde aus genannten
Gr&uuml;nden nicht implementiert.
<br />
<br />
<br />
<img src="./media/content/design/arraw_right.png" alt="PHP-Frameworks im Test (5)"/>
Weiter auf <a href="./?Seite=053-PHP-Frameworks-im-Test-5" title="PHP-Frameworks im Test (5)">Seite 5</a> (Bewertung Zend Framework).
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_052" />