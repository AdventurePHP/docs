<core:addtaglib namespace="sites::apfdocupage::pres::taglib" prefix="file" class="highlight" />
<font style="font-size: 26px; font weight: bold;">Kommentar-Funktion</font>
<br />
<br />
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<br />
<a name="1-Einleitung"></a><h3>1. Einleitung</h3>
Das Tutorial soll zeigen, wie das Kommentar-Modul am Ende der Dokumentations-Seiten aufgebaut ist und
welche Komponenten zur Funktionsweise beitragen. Es soll nochmals verdeutlicht werden, welche Richtlinen
die im Manual genannten Design-Pattern wirklich geben und welche Hintergr&uuml;nde diese haben. Aus
diesem Grund soll das Tutorial wie folgt aufgebaut sein:
<ul>
  <li>Beschreibung des Aufbaus der Applikation,</li>
  <li>Verwendung von Modulen zur Unterst&uuml;tzung und</li>
  <li>Erl&auml;uterung der Programm-Dateien.</li>
</ul>
Dabei werden die unter <a href="./?Seite=013-Grundlagen" title="Grundlagen">Grundlagen</a> bereits vermittelten
Design-Pattern praktisch f&uuml;r diesen Anwendungsfall aufbereitet. Dieses Tutorial sollte deshalb
als Einstiegs-Tutorial vor den beiden Tutorials <a href="./?Seite=034-Kontakt-FormularFormular" title="Kontaktformular">Kontaktformular</a>
und <a href="./?Seite=057-Gaestebuch-Tutorial" title="G&auml;stebuch">G&auml;stebuch</a> zum Studium herangezogen
werden.
<br />
<br />
<br />
<br />
<a name="2-Aufbau"></a><h3>2. Aufbau der Applikation</h3>
Die Kommentar-Funktion besteht aus Sicht eines Anwenders aus zwei Teilen: Ausgabe und Formular. Aus
Sicht eines Entwicklers aus der Ausgabe, dem Formular, einer Datenbank und der zugeh&ouml;rigen Logik,
die das Auslesen der Daten und das F&uuml;llen der Datenbank organisiert. Folgt man der Lehre des
objektorientierten Applikations-Entwurfs, so gibt es dort eine Vielzahl an Entwurfsmuster (Pattern),
die zum Entwurf der Kommentar-Funktion herangezogen werden k&ouml;nnen. Die in diesem Entwurf
eingeschlossenen Muster und deren Auswirkungen seien hier erl&auml;utert:
<br />
<br />
<br />
<a name="2-1-Drei-Schicht-Architektur"></a><h4>2.1. 3-Schicht-Architektur</h4>
Das Pattern der "3-Schicht-Architektur" geht davon aus, dass es von Vorteil ist, ein Programm - hier
ein Teil einer Gesamt-Applikation - in die Schichten <strong>Daten-Schicht</strong>, <strong>Business-Schicht</strong>
und <strong>Pr&auml;sentations-Schicht</strong> zu unterteilen, da so eine gr&ouml;&szlig;ere
Transparenz des Programm-Codes garantiert werden kann. Dies erzeugt im ersten Wurf zwar einen
Mehraufwand, der sich jedoch mit dem Betrieb und der Weiterentwicklung der Software auszahlt. Ein
weiterer Vorteil ist, dass mit Einf&uuml;hrung des Schichten-Modells beliebige Schichten einfach
ausgetauscht werden k&ouml;nnen, ohne dass die Funktion der verbleibenen Schichten ge&auml;ndert
werden muss. F&uuml;r Kommentar-Funktion gilt dann:
<ul>
  <li>
    <strong>Daten-Schicht:</strong>
    <br />
    Liest die Daten aus der Datenbank aus und stellt sie der n&auml;chst h&ouml;heren Schicht, bzw.
    nimmt Daten entgegen und speichert sie in der Datenbank.
  </li>
  <li>
    <strong>Business-Schicht:</strong>
    <br />
    Sie kontrolliert die Funktion der Software, und steuert die Ein- und Ausgabe und den Ablauf der
    Software.
  </li>
  <li>
    <strong>Pr&auml;sentations-Schicht:</strong>
    <br />
    Die Pr&auml;sentations-Schicht k&uuml;mmert sich um die Pr&auml;sentation der Applikation zum
    Kunden. Hierzu z&auml;hlt die Ausgabe einer GUI (im Web-Umfeld HTML) und die damit verbundenen
    Funktionen, jedoch nicht mehr.
  </li>
</ul>
Im objektorientierten Anwendungsdesign hat sich zu diesen Bereichen in der Vergangenheit ein einiger
Sprachgebrauch "eingeb&uuml;rgert", der auch hier verwendet werden soll. So wird bei der Datenschicht-
Komponente von einem <strong>Mapper</strong> gesprochen (siehe 2.2), bei der Business-Schicht von einem
<strong>Manager</strong> und in der Pr&auml;sentations-Schicht je nach Art dieser von
<strong>View-</strong> bzw. hier von <strong>DocumentControllern</strong> gesprochen. F&uuml;r diese
Begriffe existiert in der Regel eine jeweils eigene Klasse. In der Pr&auml;sentations-Schicht kann
dies jedoch je nach Anzahl der Views und Anzeige-Module einer Applikation variieren. Im Fall der
Kommentar-Funktion wird die Software zwei Views mit jeweils einem Template und einem Controller
besitzen. Dieser Verfahrensweise begegnen Sie auch in den folgenden Tutorials.
<br />
<br />
<br />
<a name="2-2-OR-Mapper"></a><h4>2.2. (OR-)Data-Mapper</h4>
Ein <strong>Data-Mapper</strong> ist ein Vermittler zwischen der "Welt" der Datenbank und der "Welt"
der Anwendung. Das bedeutet, dass diese Komponente - wie bereits oben angedeutet - sich mit den
Spezifika der Datenbank besch&auml;ftigt und der Software eine einfache Schnittstelle bietet um auf
dieser Daten zu speichern und anschlie&szlig;end wieder auszulesen. Konkret wird der Mapper - eine
Komponente der Datenschicht - die zur Darstellung ben&ouml;&auml;tigten Daten auslesen und im Format
der Anwendung bereitstellen, bzw. umgekehrt, einen neuen Kommentar speichern. Das Pr&auml;fix
<strong>OR</strong> erh&auml;lt der Mapper in diesem Fall deshalb, weil eine relationale Datenbank
zur Speicherung der Daten verwendet wird (MySQL) und die Anwendung jedoch objektorientiert
entworfen wird. Eine klassische damit verbundene Aufgabe des OR-Mappers ist es ein Ergebnis-Array
in ein Objekt der Anwendung (Domain-Object) zu mappen - zu &uuml;bersetzen. &Uuml;blicherweise
implementiert der Mapper dazu eine Methode <nobr><strong>map{ObjectName}2DomainObject()</strong></nobr>,
wobei <em>{ObjectName}</em> jeweils durch den Namen des Domain-Objekts bzw. der Domain-Objekte (siehe 2.3)
ersetzt wird. Als Parameter tr&auml;gt die Funktion ein Array und der R&uuml;ckgabe-Wert ist immer
vom Typ <em>Object {ObjectName}</em> - das Dom&auml;nen-Objekt. Dar&uuml;ber hinaus besitzt der
Mapper &uuml;blicherweise Methoden zum Lesen von Objekten per ID, bzw. per in der Anwendung ben&ouml;tigten
Schl&uuml;sseln und zum Schreiben dieser.
<br />
<br />
<br />
<a name="2-3-Domain-Object-Pattern"></a><h4>2.3. Domain-Object-Pattern</h4>
Das <strong>Domain-Object-Pattern</strong> besagt vereinfacht ges&uuml;rochen, dass eine Anwendung
immer nur den Teil der in der Datenhaltung vorhandenen Objekte nutzen sollte, die f&uuml;r die Applikation
auch bestimmt ist. In einem gro&szlig;en Datenhaltungs-Konzept werden in der Regel erheblich mehr
Daten abgespeichert, als eine einzelne Anwendung ben&ouml;tigt. Nehmen wir an, in der f&uuml;r die
Kommentar-Funktion genutzen Datenbank werden neben Kommentaren noch Termine, Orte, L&auml;nder und
deren Beziehungen gespeichert, dann ben&ouml;tigt die Kommentar-Funktion nur den (kleinen) Teil der
Kommentare aus diesen Daten-Topf und es w&auml;re &uuml;berfl&uuml;ssig, wenn sich die Anwendung auch
mit den &uuml;brigen Objekten besch&auml;ftigen w&uuml;rde. Aus diesem Grund besch&auml;ftigt sich
jede Dom&auml;ne - hier Kommentar-Funktion - nur mit den Dom&auml;nen-Objekten ihres Interesses.
Die gesammte Applikation "kennt" damit ausschlie&szlig;lich diese Menge von Objekten und kann mit
diesen umgehen. Domain-Objekte sind &uuml;blicherweise Objekte der Business-Schicht und werden auch
in dem daf&uuml;r vorgesehenen Ordner abgelegt. Wichtig ist hier jedoch, dass alle Schichten diese
Objekte "kennen". Die Datenschicht "schneidet" diese aus dem gro&szlig;en Pool an Daten "heraus" um
sp&auml;ter den Extrakt wieder "einpflanzen" zu k&ouml;nnen, die Business-Schicht bildet an Hand der
Objekte ihren internen Ablauf ab und die Pr&auml;sentations-Schicht nutzt diese zur Darstellung der
Benutzer-GUI nutzt.
<br />
<br />
<br />
<a name="2-4-MVC"></a><h4>2.4. MVC</h4>
Das <strong>Model-View-Controller</strong>-Pattern ist ein Entwurfsmuster der Pr&auml;sentations-Schicht
und ist im Sinne der <em>3-Schicht-Architektur</em> lediglich eine "Verfeinerung" des Pr&auml;sentations-
Schicht-Designs. Es beschreibt in Zusammenarbeit mit der <em>3-Schicht-Architektur</em> - wie auch
bereits unter <a href="./?Seite=013-Grundlagen" title="Grundlagen">Grundlagen</a> aufgef&uuml;hrt wurde -
die Trennung zwischen dem dargestellten Inhalt und der Definition der Applikations-Workflows (Model),
der Beschreibung der Darstellung und des Aussehens der Applikation (View) und der eigentlichen
Darstellungs-Logik (Controller). Genau wie das <em>3-Schicht-Architektur</em>-Pattern verspricht sich
der Entwickler auch hier mehr Flexibilit&auml;t bei Erweiterung und Wartung der Applikation.
<br />
<br />
Im Fall der Kommentar-Funktion wird eine gemeinsame Business-Komponente (Model) verwendet, die aus
dem <em>Manager</em> und dem <em>Domain-Objekt</em> besteht. In diesen sind zum einen der Ablauf der
Applikation und zum anderen die Daten zur Ausgabe gespeichert. Zur weiteren Strukturierung der
Pr&auml;sentations-Schicht werden zwei Unterordner angelegt, die sp&auml;ter die Controller- und die
View-Dateien aufnehmen. So kann auf einen Blick bereits beurteilt werden, zu welchem Programmteil
welche Datei geh&ouml;rt.
<br />
<br />
MVC ist jedoch zun&auml;chst ein Pattern, das weitere Tools ben&ouml;tigt um dem Entwickler eine
sinnvolle M&ouml;glichkeit zu bieten Anwendungen zu verfassen ohne mit jeder Anwendung das Rad neu
erfinden zu m&uuml;ssen. Aus diesem Grund wurdem im Adventure-PHP-Framework weitere Pattern zum Design
der Pr&auml;sentations-Schicht und zur Unterst&uuml;tzung des Entwicklers herangezogen.
<br />
<br />
<br />
<a name="2-5-PageController"></a><h4>2.5. PageController</h4>
Der PageController ist in Zusammenarbeit mit dem <em>Composite-Pattern</em> ein generisches Hilfmittel
f&uuml;r den Anwender, MVC-Applikationen zu entwickeln ohne den dazu notwendigen Rahmen bei jeder
Applikation neu erstellen zu m&uuml;ssen. Zudem bietet der PageController einen Mechanismus, wie der
Entwickler Module auf GUI-Ebene in eine bereits bestehende Applikation einklinken kann, die f&uuml;r
die Kommentar-Funktion von Wichtigkeit ist, da diese "einfach per Tag" in eine bereits bestehende
Artikel-Seite eingebunden wird.
<br />
<br />
<br />
<br />
<a name="3-Entwurf-der-Software"></a><h3>3. Entwurf der Software</h3>
Im aktuellen Turorial soll auf einen detaillierten Entwurf der Software via UML verzichtet werden,
denn eine Kommentar-Funktion besitzt keine so hohe Komplexit&auml;t, dass ein schriftliches Design
von N&ouml;ten w&auml;re. Zudem erreicht man mit der unter Kapitel 2 erl&auml;uterten Struktur
bereits ein sehr generisches Anwendungsdesign, das sehr einfach erweitert werden kann.
<br />
<br />
<br />
<br />
<a name="4-Implementierung"></a><h3>4. Implementierung der Software</h3>
F&uuml;r das Vorgehen bei der Implementierung der Software kann der Autor kein allgemeing&uuml;ltiges
Rezept ausstellen. Oft schickt es sich eine Applikation von oben nach unten, oft umgekehrt zu
entwickeln, in manchen F&auml;llen zun&auml;chst den rein lesenden und anschlie&szlig;end erst den
schreibenden Teil zu erstellen. In diesem Fall zieht der Autor letztere vor um schnell ein anzeigbares
Ergebnis zu erhalten.
<br />
<br />
<br />
<a name="4-1-Struktur-des-Moduls"></a><h4>4.1. Struktur des Moduls</h4>
Zun&auml;chst soll die Ordner- bzw. Namespace-Struktur der Software angelegt werden. Da es sich bei
der Kommentar-Funktion gem&auml;&szlig; <a href="./?Seite=013-Grundlagen" title="Grundlagen">Grundlagen</a>
um ein St&uuml;ck Software handelt, das in mehreren Projekten (=Webseiten) eingesetzt werden kann,
handelt es sich um ein <strong>Modul</strong>, das im Ordner <strong>/apps/modules</strong> abgelegt
wird. Dem Modul wird nun der Name <strong>comments</strong> gegeben, was gleichzeitig auch der
Ordner-Name sein muss. F&uuml;r die oben genannten Schichten werden jeweils eigene Ordner (<em>data</em>,
<em>biz</em>, <em>pres</em>) angelegt und im Ordner <strong>pres</strong> nochmals weitere Unterordner
f&uuml;r die Controller (<em>documentcontroller</em>) und die Views (<em>templates</em>). Es ergibt
sich somit eine Ordnerstruktur von
<pre class="tagexample">
/apps
     /config
     /core
     /modules
             /comments
                      /biz
                      /data
                      /pres
                           /documentcontroller
                           /templates
     /sites
     /tools
</pre>
Da die Business-Schicht die Pager-Komponente nutzt m&uuml;ssen sp&auml;ter weitere Strukturen unter
<strong>config</strong> angelegt werden, was aber zu gegebener Zeit erkl&auml;rt wird.
<br />
<br />
<br />
<a name="4-2-Domain-Objekt"></a><h4>4.2. Domain-Objekt</h4>
Als erste Klasse legen wir das von allen Schichten genutzte Domain-Objekt <strong>ArticleComment</strong>
an. Dazu wird die Datei <em>ArticleComment.php</em> im Ordner <strong>/apps/modules/comments/biz</strong>
erstellt un mit folgenden Inhalt gef&uuml;llt:
<br />
<br />
<file:highlight name="ArticleComment.php"/>
<br />
Da die Klasse von <strong>coreObject</strong> erbt m&uuml;ssen keine get()- bzw. set()-Methoden
implementiert werden, da die Klasse <em>coreObject</em> bereits &uuml;ber abstrakte Methoden f&uuml;r
das Lesen und Setzen von privaten Klassen-Variablen besitzt, die sp&auml;ter auch daf&uuml;r genutzt
werden k&ouml;nnen. Um diese jedoch nutzen zu k&ouml;nnen muss die Namens-Konvention eingehalten
werden, die besagt, dass jede private und durch die Methoden get()- bzw. set() manipulierten
Klassen-Variablen mit <strong>$__{Name}</strong> benannt sein m&uuml;ssen, wobei <em>{Name}</em>
durch den jeweils erw&uuml;nschten Namen ersetzt werden muss. Anschlie&szlig;end kann per
<php:highlight>
   $AC = new ArticleComment();
   $AC->set('Name','Max Mustermann');
   echo $AC->get('Name');
</php:highlight>
die Ausgabe
<pre class="tagexample">
  Max Mustermann
</pre>
erzeugt werden.
<br />
<br />
<br />
<a name="4-3-Datenschicht"></a><h4>4.3. Datenschicht</h4>
Die Datenschicht besteht gem&auml;&szlig; den Ausf&uuml;hrungen unter Kapitel 2 als einem
<em>DataMapper</em>, der zun&auml;chst nur eine Lese-Funktion erh&auml;lt. An dieser Stelle muss
vorweggenommen werden, dass innerhalb der Anwednung die Komponente "Pager" zum Einsatz kommt.
Diese l&auml;d an Hand von URL-Parametern IDs der gew&uuml;nschten Datens&auml;tze aus der Datenbank
und erwartet, dass der Data-Mapper lediglich eine Funktion bereitstellt, die an Hand von IDs
Dom&auml;nen-Objekte l&auml;d. Dazu erstellen wir eine Datei mit dem Namen der Klasse - plus Endung -
(<strong>commentMapper.php</strong>) unter <strong>/apps/modules/comments/data</strong>. Diese tr&auml;gt
zun&auml;chst folgenden Inhalt:
<php:highlight>
   import('modules::comments::biz','ArticleComment');
   import('core::database','MySQLHandler');


   class commentMapper extends coreObject
   {

      function commentMapper(){
      }


      function loadArticleCommentByID($ArticleCommentID){

         // SQL-Handler holen
         $SQL = &$this->__getServiceObject('core::database','MySQLHandler');

         // Eintrag selektieren
         $select = 'SELECT ArticleCommentID, Name, EMail, Comment, Date, Time
                    FROM article_comments
                    WHERE ArticleCommentID = \''.$ArticleCommentID.'\';';
         $result = $SQL->executeTextStatement($select);

         // Objekt zurückgeben
         return $this->__mapArticleComment2DomainObject($SQL->fetchData($result));

       // end function
      }


      function __mapArticleComment2DomainObject($ResultSet){

         // Neues Objekt erstellen
         $ArticleComment = new ArticleComment();

         // ArticleCommentID
         if(isset($ResultSet['ArticleCommentID'])){
            $ArticleComment->set('ID',$ResultSet['ArticleCommentID']);
          // end if
         }

         // Name
         if(isset($ResultSet['Name'])){
            $ArticleComment->set('Name',$ResultSet['Name']);
          // end if
         }

         // EMail
         if(isset($ResultSet['EMail'])){
            $ArticleComment->set('EMail',$ResultSet['EMail']);
          // end if
         }

         // Comment
         if(isset($ResultSet['Comment'])){
            $ArticleComment->set('Comment',$ResultSet['Comment']);
          // end if
         }

         // Date
         if(isset($ResultSet['Date'])){
            $ArticleComment->set('Date',$ResultSet['Date']);
          // end if
         }

         // Time
         if(isset($ResultSet['Time'])){
            $ArticleComment->set('Time',$ResultSet['Time']);
          // end if
         }

         // Gefülltes Objekt zurückgeben
         return $ArticleComment;

       // end function
      }

    // end class
   }
</php:highlight>
Der Quellcode hat dabei folgende Bedeutung:
<ul>
  <li>
    Die beiden <em>import()</em>-Befehle binden die ben&ouml;tigten Klassen ein. Hierzu geh&ouml;rt
    das Domain-Objekt <em>ArticleComment</em> und die MySQL-Schnittstellen-Klasse <em>MySQLHandler</em>.
  </li>
  <li>
    Die Methode <em>loadArticleCommentByID()</em> l&auml;d einen Kommentar an Hand einer ID aus der
    Datenbank. Es wird hier auf eine Konfiguration f&uuml;r Feldnamen und Datenbank-Tabelle verzichtet,
    da der <em>commentMapper</em> ohnehin eine konkrete Implementierung eines DataMappers f&uuml;r die
    vorliegende Applikation ist. Die beschleunigt nicht nur das Lade-Verhalten, es ist zudem einfacher
    zu entwickeln. Innerhalb dieser Methode wird vom MySQL-Wrapper gebrauch gemacht, &uuml;ber den eine
    Result gezogen wird. Anschlie&szlig;end wird das Ergebnis abgeholt und der privaten Methode
    <em>__mapArticleComment2DomainObject()</em> &uuml;bergeben und ds Ergebnis an den Aufrufenden
    zur&uuml;ckgegeben.
  </li>
  <li>
     <em>__mapArticleComment2DomainObject()</em> ist die unter Kapitel 2 angesprochene Implementierung
     einer Mapper-Methode, die ein Array in ein Domain-Objekt mappt.
  </li>
</ul>
Um die f&uuml;r dieses Modul notwenige Datenbank-Layout anlegen zu k&ouml;nnen, muss das im Ordner
<strong>/apps/modules/comments/data/scripts</strong> vorhandene SQL-Script <strong>init_comments.sql</strong>
ausgef&uuml;hrt werden. F&uuml;r weitere, von Ihnen erstellte Anwendungen schickt es sich ebenso,
die notwenigen Datenbank-Initialisations-Skripte direkt in einem Ordner der Datenschicht abzulegen
um sp&auml;ter nachvollziehen zu k&ouml;nnen, welche Anwendung, welche Tabellen der Datenbank nutzt.
<br />
<br />
<br />
<a name="4-4-Businessschicht"></a><h4>4.4. Business-Schicht</h4>
Zur Business-Schicht z&auml;hlt eine Manager-Klasse, die den Ablauf der Software regelt. Dazu legen
wir eine Datei mit dem Namen <strong>commentManager.php</strong> im Ordner <strong>/apps/modules/comments/biz</strong>
an. Im Fall der Kommentar-Funktion (lesender Zugriff) muss diese lediglich die Daten aus der Datenschicht beziehen
und diese zur&uuml;ck an die Pr&auml;sentations-Schicht geben. Wie bereits oben angedeutet verwendet
die Kommentar-Funktion den Pager. Aus diesem Grund ist es notwendig weitere Mechanismen vorzusehen und
den Pager entsprechend zu konfigurieren. Das Grundger&uuml;st der Klasse sieht jedoch wie folgt aus:
<php:highlight>
   import('modules::pager::biz','pagerManager');
   import('modules::comments::data','commentMapper');
   import('modules::pager::biz','pagerManager');
   import('tools::link','frontcontrollerLinkHandler');


   class commentManager extends coreObject
   {

      var $__CategoryKey;


      function commentManager(){
      }


      function init($CategoryKey){
         $this->__CategoryKey = $CategoryKey;
       // end function
      }


      function loadEntries(){
      }

    // end class
   }
</php:highlight>
Der Quellcode hat dabei folgende Bedeutung:
<ul>
  <li>
    Die <em>import()</em>-Befehle binden die ben&ouml;tigten Klassen ein. Hierzu geh&ouml;rt das
    Domain-Objekt <em>ArticleComment</em>, die Datenschicht-Komponente <em>commentMapper</em>, der
    <em>PagerManager</em> und der <em>frontcontrollerLinkHandler</em>, der sp&auml;ter zur Generierung
    eines Links f&uuml;r die Weiterleitung w&auml;hrend des Speicher-Vorgangs genutzt wird.
  </li>
  <li>
    Die Klassenvariable <strong>$__CategoryKey</strong> speichert die Katorgorie, dessen Kommentare
    geladen werden sollen.
  </li>
  <li>
    Um die Business-Komponente mit der Methode <strong>getAndInitServiceObject()</strong> verwenden
    zu k&ouml;nnen muss diese eine <strong>init()</strong>-Methode implementieren, die die Klasse
    initialisiert. In diesem Fall soll die Klasse mit der entsprechenden Kommentar-Kategorie best&uuml;ckt
    werden.
  </li>
  <li>
    <strong>loadEntries()</strong> ist der Prototyp der Lade-Methode, die die Eintr&auml;ge an die
    Pr&auml;sentations-Schicht zur&uuml;ckgibt.
  </li>
</ul>
K&uuml;mmern wir uns nun um die zuletzt genannte Funktion. Die Komponente <em>pagerManager</em> hat
gem&auml;&szlig; <a href="Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a> die Methoden
<ul>
  <li><strong>setAnchorName()</strong> (Name des Ankers setzen)</li>
  <li><strong>loadEntries()</strong> (IDs von Eintr&auml;gen laden)</li>
  <li><strong>getPager()</strong> (HTML-Ausgabe des Pagers erzeugen)</li>
  <li><strong>getPagerURLParameters()</strong> (Ausgabe der URL-Parameter der aktuellen Pager-Konfiguration)</li>
</ul>
und eine Referenz auf einen Pager wird mit Hilfe der <strong>pagerManagerFabric</strong> bezogen. Der
Fabric muss dazu der Abschnitt der zu verwendenden Konfiguration und ein Initialisierungs-Parameter
mitgegeben werden. In PHP-Code funktioniert das wie folgt:
<php:highlight>
   // Beziehen einer Singleton-Instanz der Fabric
   $pMF = &$this->__getServiceObject('modules::pager::biz','pagerManagerFabric');

   // Beziehen und initialisieren des PagerManagers
   $pM = &$pMF->getPagerManager('ArticleComments',array('CategoryKey' => $this->__CategoryKey));
</php:highlight>
Damit wird ein PagerManager erzeugt, die Konfiguration aus dem Abschnitt <strong>ArticleComments</strong>
geladen und dieser mit dem Parameter <strong>CategoryKey</strong> und dem Wert aus der lokalen
Klassen-Variable <strong>$__CategoryKey</strong> gespeist. Das zweite Argument der Methode
<strong>getPagerManager()</strong> initialisiert die zus&auml;tzlichen SQL-Statement-Parameter,
die einem ID- oder Count-Statement mitgegeben werden k&ouml;nnen.
<br />
<br />
Die Konfiguration des pagerManager's ist unter dessen Namespace (<em>modules::pager</em>) und dem
aktuellen Context der Applikation abgelegt. Im Fall der Dokumentationsseite ist das <em>sites::demosite</em>.
Daraus ergibt sich der Ordner-Pfad <strong>/apps/config/modules/pager/sites/demosite</strong>. Dort
befindet sich eine Datei mit dem Namen <strong>DEFAULT_pager.ini</strong> mit ungef&auml;hr folgendem
Inhalt:
<pre class="tagexample">
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; ArticleComments                                                                                  ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[ArticleComments]
; Anzahl Einträge pro Seite
Pager.EntriesPerPage = "5"

; Namen der URI-Parameter für Startpunkt und Anzahl/Seite
Pager.ParameterStartName = "PgrStr"
Pager.ParameterCountName = "PgrAnz"

; Namespace und Statements für Selektionen inkl. Konfiguration der Statements
Pager.StatementNamespace = "modules::comments"
Pager.CountStatement = "load_entries_count"
Pager.CountStatement.Params = "CategoryKey:standard"
Pager.EntriesStatement = "load_entry_ids"
Pager.EntriesStatement.Params = "CategoryKey:standard"

; Pager-Ausgabe Design
Pager.DesignNamespace = "modules::pager::pres::templates"
Pager.DesignTemplate = "pager_2"
</pre>
Mit diesem Satz von Parametern kann der Pager vollst&auml;ndig konfiguriert werden. Einge davon
k&ouml;nnen f&uuml;r die mei&szlig;ten Anwendungen ohne &Auml;nderung belassen werden. Was jedoch
von Anwendungsfall zu Anwendungsfall variiert sind die Definition der Statements. Der Pager verlangt -
um seine Arbeit verrichten zu k&ouml;nnen - nach zwei SQL-Statements, die er zum Laden der Anzahl
der in der Datenbank befindlichen Datenst&auml;tze und zum Laden der f&uuml;r eine Seite relevanten
IDs verwendet. Diese Statements werden durch ihren Namespace und durch ihren Namen bestimmt, wobei
der Namespace der Ordner-Pfad - getrennt durch "::" statt "/" - nur demjenigen Pfad entspricht, der
den Context der Applikation nicht enth&auml;lt. Der Context wird dem Pager dadurch &uuml;bergeben,
dass dieser mit der PagerManagerFabric erzeugt wird. Die Statements-Dateien befinden sich im aktuellen
Anwendungsfall in einem Unterordner des Moduls "comments", da die Statements immer unter dem zugeh&ouml;rigen
Modul-Namespace abgelegt werden, nicht unter dem Pager-Namespace. &Uuml;bersetzt man die oben
konfigurierten Ordner-Pfade, m&uuml;ssen die Statement-Dateien unter dem Ordner
<strong>/apps/config/modules/comments/sites/demosite/statements</strong> liegent. Der Ordner
<strong>statements</strong> wird vom Datenbank-Wrapper <strong>MySQLHandler</strong> verlangt. Da
Statements einer Konfiguration gleich kommen werden diese nicht nur unter dem <em>config</em>-Namespace
abgelegt, sondern auch so benannt. Wie unter <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a>
beschrieben, muss dem Dateinamen, der Wert der Umgebungsvariable vorangestellt und eine Endung
angeh&auml;ngt werden. Im Fall der SQL-Statements ist die Endung <strong>.sql</strong>. Die Dateien
m&uuml;ssen deshalb
<ul>
  <li><strong>DEFAULT_load_entries_count.sql</strong></li>
  <li><strong>DEFAULT_load_entry_ids.sql</strong></li>
</ul>
lauten. Der PagerManager erwartet eine weitere Konvention: die Benennung der R&uuml;ckgabe-Variablen
und das Einf&uuml;gen von Parametern. Am Beispiel des Entries-Count-Statement l&auml;sst sich das
einfach zeigen:
<pre class="tagexample">
SELECT COUNT(*) AS EntriesCount
FROM article_comments
WHERE CategoryKey = '[CategoryKey]'
GROUP BY ArticleCommentID;
</pre>
Der PagerManager erwartet intern immer ein Ergebnis in der Variable <strong>EntriesCount</strong>,
weswegen das Ergebnis des Select-Statements auch in diesen Alias geschrieben werden muss. Weitere,
der PagerManagerFaric zuvor &uuml;bergebene Parameter k&ouml;nnen im Statement mit eckigen Klammern
eingeschlossen verwendet werden. F&uuml;r das Load-Statement gelten folgende Regeln:
<pre class="tagexample">
SELECT ArticleCommentID AS DB_ID
FROM article_comments
WHERE CategoryKey = '[CategoryKey]'
ORDER BY Date DESC, Time DESC
LIMIT [Start],[EntriesCount];
</pre>
Auch hier erwartet der PagerManager die Ergebnis-IDs in der Variable <strong>DB_ID</strong> - ein Alias
ist notwenig. Weitere Statement-Parameter k&ouml;nnen einfach wie oben beschrieben verwendet werden.
Eine weitere Besonderheit ist die <em>LIMIT-Anweisung</em>. Diese muss die Parameter
<ul>
  <li><strong>[Start]</strong></li>
  <li><strong>[EntriesCount]</strong></li>
</ul>
enthalten, da diese mit internen Pager-Variablen gef&uuml;llt werden um jeweils nur diejenigen
Eintr&auml;ge auszugeben, die f&uuml;r die aktuelle Seite vorgesehen sind. Die restlichen Konstrukte
der Statements k&ouml;nnen beliebig komplex gew&auml;hlt werden, solange die genannten Struktur-Elemente
eingehalten werden.
<br />
<br />
Kommen wir nun nach der Konfiguration des Pagers zu dessen Verwendung. Die Methode
<strong>loadEntries()</strong> des Managers gestaltet sich damit wie folgt:
<php:highlight>
   function loadEntries(){

      // pagerManager holen
      $pMF = &$this->__getServiceObject('modules::pager::biz','pagerManagerFabric');
      $pM = &$pMF->getPagerManager('ArticleComments',array('CategoryKey' => $this->__CategoryKey));

      // Kommentare laden
      $M = &$this->__getServiceObject('modules::comments::data','commentMapper');
      return $pM->loadEntriesByAppDataComponent($M,'loadArticleCommentByID');

    // end function
   }
</php:highlight>
Im ersten Schritt wird die gew&uuml;nschte Pager-Instanz &uuml;ber die <em>PagerManagerFabric</em>
geholt, im zweiten Schritt wird eine Instanz des DataMappers der Applikation erzeugt. Diese wird dann
in darauf folgenden Schritt als Data-Provider dem PagerManager &uuml;bergeben, damit dieser die
gew&uuml;nschten Dom&auml;nen-Objekte l&auml;d. Eine weitere M&ouml;glichkeit den Pager anzuwenden
ist sich zun&auml;chst die IDs der auf der aktuell anzuzeigenden Seite zu ziehen und dann im Manager
die Objekte per Schleife mit Hilfe des Mappers zu laden. Das sieht in PHP-Code wie folgt aus:
<php:highlight>
   function loadEntries(){

      // pagerManager holen
      $pMF = &$this->__getServiceObject('modules::pager::biz','pagerManagerFabric');
      $pM = &$pMF->getPagerManager('ArticleComments',array('CategoryKey' => $this->__CategoryKey));

      // Ids laden
      $EntryIDs = $pM->loadEntries();

      // Kommentare laden
      $M = &$this->__getServiceObject('modules::comments::data','commentMapper');

      $Entries = array();

      for($i = 0; $i < count($EntryIDs); $i++){
         $Entries[] = $M->loadArticleCommentByID($EntryIDs[$i]);
       // end for
      }

      // Liste zurückgeben
      return $Entries;

    // end function
   }
</php:highlight>
Beide M&ouml;glichkeiten werden angeboten, letztere ist f&uuml;r denjenigen Anwendungsfall gedacht,
bei dem die Business-Komponente noch Einfluss auf die Sortierung oder den Inhalt der Domain-Objects
haben m&ouml;chte oder muss. Innerhalb der Kommentar-Funktion wird die zu erst genannte Variante
eingesetzt in den folgenden Tutorials die zuletzt genannte. Damit w&auml;re der Teil der lesenden
Anwendung f&uuml;r die Business-Schicht abgeschlossen.
<br />
<br />
<br />
<a name="4-5-Praesentationsschicht"></a><h4>4.5. Pr&auml;sentations-Schicht</h4>
Die Ausgabe der Kommentare in einer bl&auml;tterbaren Seite beinhaltet neben der Einbindung des Moduls
lediglich einen View - die Ausgabe-Liste. Widmen wir uns zun&auml;chst der Einbindung, da diese mit
einer Besonderheit ausgestattet werden soll. Wie bereits weiter oben angesprochen, soll es m&ouml;glich
sein, die Kommentar-Funktion in eine bestehende Seite per XML-Tag einbindbar zu machen. Dazu nutzen
wir in diesem Anwendungsfall das <strong>&lt;core:importdesign /&gt;</strong>-Tag. Dieses tr&auml;gt
laut <a href="./?Seite=046-Standard-TagLibs" title="Standard-TagLibs">Standard-TagLibs</a> die XML-Parameter
<strong>namespace</strong> um den Namespace des Templates zu deklarieren, <strong>template</strong>
f&uuml;r die Benennung des Templates und den optionalen Parameter <strong>incparam</strong> um den
URL-Parameter, der die Einbindung steuert zu benennen. Letzterer soll auch hier zum Einsatz kommen,
da der Standard-Parameter "<em>pagepart</em>" unter Umst&auml;nden bereits in Gebrauch sein k&ouml;nnte
und die Ausf&uuml;hrung der Funktion st&ouml;ren k&ouml;nnte. Weiterhin soll der Template-Bauer, der
die Funktion einbaut entscheiden k&ouml;nnen, welche Kommentare angezeigt werden. Dazu f&uuml;hren
wir einen neuen Parameter <strong>categorykey</strong> ein, der beschreiben soll, welche Kategorie
von Kommentaren hier eingetragen werden soll und angezeigt werden kann. Dieser Mechanismus wurde oben
bereits ohne Kommentar vorgesehen, ist aber - mit dem Wissen der hier verfassten Zeilen - notwenig
um eine Unterscheidung der Kommentare vorzusehen. Datenbank-technisch ist sicher auch eine andere
M&ouml;glichkeit der Kategorisierung denkbar, es handelt sich jedoch um eine einfaches Beispiel, bei
dem von einem komplexen Datenbank-Design abgesehen wird.
<br />
<br />
Die Einbindung in ein bestehendes Template kann damit mit einem
<pre class="tagexample">
  &lt;core:importdesign
      namespace="modules::comments::pres::templates"
      template="comment"
      categorykey="****"
  /&gt;
</pre>
erledigt werden. Im dort genannten Template wird nun der Kopf des Moduls durch
<pre class="tagexample">
  &lt;a name="comments" /&gt;&lt;h2&gt;Kommentare&lt;/h2&gt;
</pre>
beschrieben und mit
<pre class="tagexample">
  &lt;core:importdesign
      namespace="modules::comments::pres::templates"
      template="[coview = listing]"
      incparam="coview"
  /&gt;
</pre>
anschlie&szlig;end der gerade angefragte View (Liste oder Formular) an Hand des URL-Parameters
<strong>coview</strong> (coview f&uuml;r CommentView) eingebunden. F&uuml;r die Ausgabe der Liste
soll nun Template <strong>listing</strong> erstellt werden:
<br />
<br />
<file:highlight name="listing.html" />
<br />
Dieses sieht die Definition des zu verwendenden Controllers, einen Einleitungstext, Platz f&uuml;r
die Ausgabe eines Pagers und die Ausgabe der Liste und ein Templates f&uuml;r einen Eintrag und die
Anzeige der Meldung, dass keine Eintr&auml;ge vorhanden sind. Die Beschreibung der verwendeten Tags
kann unter <a href="./?Seite=046-Standard-TagLibs" title="Standard-TagLibs">Standard-TagLibs</a>
nachgelesen werden. Interessanter ist nun die Gestaltung des DocumentControllers f&uuml;r die Ausgabe
der Liste.
<br />
<br />
An dieser Stelle soll jedoch zun&auml;chst ein kleiner Exkurs in die Struktur des GUI-Designs des
Adventure-PHP-Frameworks eingeschoben werden um die Funktion der Tags am Beispiel zu erl&auml;utern.
<br />
Der PageController erzeugt aus jedem Template einen eigenen DOM-Knoten im Objektbaum der Oberfl&auml;che.
Durch Referenzen eines Knotens auf seinen Vater-Knoten k&ouml;nnen ausgehend von einem beliebigen
DOM-Objekt die Eigenschaften des Vater- und/oder Kind-Objekts ausgelesen werden. Diese Eigenschaft
machen wir uns bei der Ausgabe der Liste und sp&auml;ter dem Eintragen eines Kommentars zu Nutze.
Die aktuelle Struktur sieht vor, dass in einem beliebigen Template die Kommentar-Funktion durch ein
parametrisiertes <strong>&lt;core:importdesign /&gt;</strong>-Tag eingebunden wird. Dieses wiederum
bindet ein weiteres Template ein, das f&uuml;r Ausgabe der Liste oder Anzeige des Men&uuml;s
zust&auml;ndig ist. Letztere ben&ouml;tigen jedoch Zugriff auf das im "Haupt-Template" gesetzte
Tag-Attribut um die richtigen Kommentare ausgeben, oder in die richtige Kategorie eintragen zu
k&ouml;nnen. Gem&auml;&szlig; dem DOM-Modell ist das innerhalb eines DocumentControllers, der wiederum
eine Referenz auf das ihm zugewiesene <em>Document</em>-Objekt besitzt, durch den folgenden PHP-Code
m&ouml;glich:
<php:highlight>
   $DocParent = &$this->__Document->getByReference('ParentObject');
   $this->__CategoryKey = $DocParent->getAttribute('categorykey');
</php:highlight>
Um bei fehlenden Attribut keine Fehlermeldung zu bekommen wird der Code noch um
<php:highlight>
   if($CategoryKey == null){
      $this->__CategoryKey = 'standard';
   // end if
   }
   else{
      $this->__CategoryKey = $CategoryKey;
   // end else
   }
</php:highlight>
erg&auml;nzt. Da diese Funktion in beiden DocumentControllern wichtig ist (Erzeugen der Liste, Eintragen
eines Kommentars) wird diese Funktion in einen gemeinsamen Basis-DocumentController verpackt. Dieser
wird mit <strong>commentBaseController</strong> benannt und unter
<strong>/apps/modules/coments/pres/documentcontroller</strong> abgelegt. Der abstrakte Controller wird
zudem f&uuml;r die Einbindung des Domain-Objekts und des Managers verwendet. Alle konkreten Controller
erhalten diese Funktion nun automatisch dadurch, dass diese vom <em>commentBaseController</em> erben.
<br />
<br />
Der konkrete DocumentController <strong>comment_listing_v1_controller</strong> (siehe Template) wird
nun mit den Aufgaben betraut, die gew&uuml;nschten Eintr&auml;ge und den Pager, bzw. ohne Kommentare
eine Meldung auszugeben. In Quellcode gegossen kann das so gel&ouml;st werden:
<br />
<br />
<file:highlight name="comment_listing_v1_controller.php" />
<br />
Besonderheiten der Umsetzung sind das Holen des Kategorie-Schl&uuml;ssels zu Beginn der Methode
<em>transformContent()</em> und die dynamische Generierung des Eintragen-Links, da das Modul selbst
nicht wei&szlig;, in welchem Bereich der Applikation es eingebunden ist. F&uuml;r letztere Aufgabe
wird die Business-Komponente um die R&uuml;ckgabe der URL-Parameter gebeten, die in der Konfiguration
unter 4.3. / Datei <em>DEFAULT_pager.ini </em> definiert worden sind. Die Parameter werden dann aus
kosmetischen Gr&uuml;nden zur&uuml;ckgesetzt, damit der Pager beim Aufruf der Listing-Seite nach dem
Eintragen immer auf die erste Seite springt. Dies k&ouml;nnte auch innerhalb des Managers abgebildet
werden, wurde jedoch in den DocumentController verlagert, da hier ohnehin ein dynamischer Link zum
Formular platziert werden muss. Im Fall der Kommentar-Funktion wird pr&auml;ventiv der
<em>frontcontrollerLinkHandler</em> verwendet, obwohl die Funktion des <em>linkHandler</em>
ausreichend w&auml;re, da nicht mit Sicherheit davon ausgegangen werden kann, dass die aktuell generierte
Seite nicht mit Hilfe von FrontController-Actions generiert wurde. Zur Formatierung der Ausgabe
werden der <strong>bbCodeParser</strong> und der <strong>dateTimeManager</strong> eingesetzt.
<br />
<br />
<br />
<br />
<a name="5-Erweiterung-der-Software"></a><h3>5. Erweiterung der Software</h3>
Die Software, wie sie bis Ende des vierten Kapitels beschrieben wurde, k&ouml;nnte nun alle per
PHPMyAdmin erzeugte Kommentare einer Kategorie auf einer Seite ausgeben, in die das Modul eingebunden
ist. Ein Eintragen ist jedoch nicht m&ouml;glich. Aus diesem Grund soll die Software um das Eintragen
von Kommentaren schrittweise erweitert werden. Dazu gehen wir nun in der umgekehrten Reihenfolge
vor und Beginnen mit der Pr&auml;sentations-Schicht.
<br />
<br />
<br />
<a name="5-1-Praesentationsschicht"></a><h4>5.1. Pr&auml;sentations-Schicht</h4>
Unter 4.4. haben wir bereits die M&ouml;glichkeit vorgesehen einen durch den URL-Parameter
<strong>coview</strong> gesteuerten View einzublenden. Der neu erstellte View f&uuml;r das Formular
soll <strong>form</strong> hei&szlig;en. Wie das Dom&auml;nen-Objekt bereits vorgibt sollen vom
Benutzer die Eingaben
<ul>
  <li>Name</li>
  <li>E-Mail</li>
  <li>Kommentar</li>
</ul>
abgefragt werden. Das Formular gestaltet sich dann in XML-Tags ausgedr&uuml;ckt wie folgt:
<pre class="tagexample">
  &lt;html:form name="AddComment" method="post"&gt;
    &lt;span style="margin-right: 10px;"&gt;Name:&lt;/span&gt;&lt;form:text maxlength="100"
      name="Name" value="" class="eingabe_feld" style="width: 390px;" validate="true"
      button="Speichern" validator="Text" /&gt;
    &lt;br /&gt;
    &lt;span style="margin-right: 10px;"&gt;E-Mail:&lt;/span&gt;&lt;form:text maxlength="100"
      name="EMail" value="" class="eingabe_feld" style="width: 390px;" validate="true"
      button="Speichern" validator="EMail" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    Kommentar:
    &lt;br /&gt;
    &lt;form:area name="Comment" class="eingabe_feld" style="width: 438px; height: 120px; overflow: auto;"
      validate="true" button="Speichern" validator="Text" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Speichern" value="Speichern" class="eingabe_feld" /&gt;
  &lt;/html:form&gt;
</pre>
Mit den Attributen <strong>validate="true"</strong> und <strong>button="Speichern"</strong> wird
die Formular-Validierung f&uuml;r dieses Feld aktiviert und mit <strong>validator="Text"</strong> bzw.
<strong>validator="EMail"</strong> wird die Art und Weise festgelegt, mit der das Feld validiert werden
soll. Mit ein wenig Text versehen hat das Template <em>form</em> damit folgenden Inhalt:
<br />
<br />
<file:highlight name="form.html" />
<br />
Der zugeh&ouml;rige DocumentController (<strong>comment_form_v1_controller</strong>) hat dabei die
Aufgabe das Formular in den daf&uuml;r vorgesehenen Platzhalter einzusetzen und im Fall eines
abgeschickten und validen Formulars den Eintrag mit Hilfe der Business-Komponente zu speichern. Dazu
implementiert dieser eine neue Methode <strong>saveEntry()</strong>, dem ein Domain-Objekt &uuml;bergeben
werden muss. Hier der Controller in der &Uuml;bersicht:
<br />
<br />
<file:highlight name="comment_form_v1_controller.php" />
<br />
<br />
<a name="5-2-Businessschicht"></a><h4>5.2. Business-Schicht</h4>
In diesem Kapitel stellt sich nun die Aufgabe, die zuvor beschriebene Business-Schicht-Methode
<em>saveEntry()</em> mit Leben zu f&uuml;llen. Im Wesentlichen besteht die Aufgabe darin, den neuen
Datensatz zu speichern und den Ausgabe-View anzuzeigen. Wie auch beim Laden der Daten muss dazu die
Datenschicht-Komponente herangezogen werden. Dieser schreiben wir nun - ohne diese bereits
implementiert zu haben - eine Methode <strong>saveArticleComment()</strong> zu, die wir in der
Business-Schicht zur Speicherung des neuen Kommentars nutzen. Die Weiterleitung erledigt eine einfache
Weiterleitung auf den Anzeigen-View. Hier muss nat&uuml;rlich darauf geachtet werden, dass die erzeugte
Seite auch wieder korrekt angezeigt wird.
<php:highlight>
   function saveEntry($ArticleComment){

      // Mapper holen
      $M = &$this->__getServiceObject('modules::comments::data','commentMapper');

      // Artikel speichern
      $ArticleComment->set('CategoryKey',$this->__CategoryKey);
      $M->saveArticleComment($ArticleComment);

      // Auf die Ausgabe weiterleiten
      $Link = frontcontrollerLinkHandler::generateLink($_SERVER['REQUEST_URI'],array('coview' => 'listing'));
      header('Location: '.$Link.'#comments');

    // end function
   }
</php:highlight>
Wie Zeile 6 (<em>$ArticleComment->set('CategoryKey'..</em>) zeigt manipuliert die Business-Schicht
das Domain-Objekt, damit dieses mir der korrekten Kategorie gespeichert wird. Anschlie&szlig;end
wird - wie bereits f&uuml;r die Generierung des Links f&uuml;r das Formular - der
<em>frontcontrollerLinkHandler</em> f&uuml;r die Zusammensetzung der Weiterleitungs-URL verwendet.
<br />
<br />
<br />
<a name="5-3-Datenschicht"></a><h4>5.3. Datenschicht</h4>
Die Datenschicht muss nun noch die Methode <strong>saveArticleComment()</strong> implementieren.
<php:highlight>
   function saveArticleComment($ArticleComment){

      // SQL-Handler holen
      $SQL = &$this->__getServiceObject('core::database','MySQLHandler');

      // Prüfen, ob Artikel bereits existiert
      if($ArticleComment->get('ID') == null){

         $insert = 'INSERT INTO article_comments
                    (Name, EMail, Comment, Date, Time, CategoryKey)
                    VALUES
                    (\''.$ArticleComment->get('Name').'\',
                     \''.$ArticleComment->get('EMail').'\',
                     \''.$ArticleComment->get('Comment').'\',
                     CURDATE(),
                     CURTIME(),
                     \''.$ArticleComment->get('CategoryKey').'\');';
         $SQL->executeTextStatement($insert);

       // end if
      }

    // end function
   }
</php:highlight>
Die Bedeutung der Code-Zeilen l&auml;sst sich leicht erschlie&szlig;en. Zun&auml;chst wird eine
Singleton-Instanz des <em>MySQLHandler</em> &uuml;ber die Methode <em>__getServiceObject()</em>
bezogen und anschlie&szlig;end wird nach Pr&uuml;fung ob es sich um einen neuen Kommentar handelt
wieder in seine flache relationale Strukur zerlegt und per SQL-Statament gespeichert.
<br />
<br />
<br />
<br />
<a name="6-Ausblick"></a><h3>6. Ausblick / Erg&auml;nzung</h3>
An dieser Stelle m&ouml;chte der Autor nochmals darauf hinweisen, dass die Methoden
<strong>__getServiceObject()</strong> und <strong>__getAndInitServiceObject()</strong> immer dann
Anwendung finden m&uuml;ssen, wenn das damit erzeugte Service-Layer Context-abh&auml;ngige Konfigurationen
l&auml;d oder ein Layer instanziiert, die weitere Context-abh&auml;ngige Komponenten verwenden. Im
Datenbank-gest&uuml;tzten Applikations-Design sollten deshalb grunds&auml;tzlich die beiden Methoden
verwendet werden, da in letzter Konsequenz immer der <strong>MySQLHandler</strong> verwendet wird.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="tut_comments" />