<doku:title tags="software,design,pattern,page controller,front controller,uml,er,diagram,mvc,domain object model,mapper,data layer,business" title="Objektorientiertes Design eines G&auml;stebuchs" urlname="Objektorientiertes-Design-eines-Gaestebuchs">
  Der Artikel objektorientiertes Design eines G&auml;stebuchs beleuchtet das Thema aus der
  Perspektive gro&szlig;er Software-Anwendungen und zeigt auf, wie ein Technologie-unabh&auml;ngiges
  Design erstellt werden kann, das sp&auml;ter als Basis f&auml;r die Umsetzung dient. Dabei wird
  auf die ben&ouml;tigten Techniken wie UML und ER-Diagramm sowie auf die Grundlagen des
  Software-Designs eingegangen.
</doku:title>
<core:importdesign namespace="sites::apfdocupage::pres::templates::perspectives::content::voting" template="voting" />
<a name="1-Einleitung"></a><h3>1. Einleitung</h3>
<p>
   &quot;<strong>Ich hab da was programmiert, aber es funktioniert so nicht. Kann mir einer
   helfen?</strong>&quot;. Auf diese, nicht zu selten in PHP-Foren auftauchende, Art der Frage passt
   zu einem sehr hohen Prozentsatz die Antwort: &quot;<strong>Think before you start to write
   code!</strong>&quot;. Die Bedeutung von Softwaredesign wird in der PHP-Community meiner
   Einsch&auml;tzung nach leider immer noch zu wenig beachtet. Die Einstiegsh&uuml;rde ist
   gegen&uuml;ber der JAVA-Entwicklung niedrig und doch scheuen viele Entwickler den Aufwand, Zeit
   f&uuml;r die Analyse der Aufgabenstellung und das Design der Software zu investieren, weil die
   Zeit bereits f&uuml;r die produktive Entwicklung eingesetzt werden kann.
</p>
<p>
   Diese Annahme ist jedoch ein Trugschluss, denn sofort mit der Implementierung zu beginnen bedeutet
   Fehler an der Umsetzungsidee erst w&auml;hrend der Entwicklung zu finden. Das hat mehrfaches Refactoring
   und aufwendige Fehlerbehebung zur Folge. Und: je sp&auml;ter ein Fehler im Software-Lifecycle gefunden
   wird, desto teurer ist er!
</p>
<p>
   Hinzu kommt, dass Anwendungen, die ohne Design - und damit ohne klares Ziel - erstellt wurden, oft
   nicht f&uuml;r zuk&uuml;nftige Weiterentwicklung ausgelegt sind. &Auml;nderungen und Erweiterungen werden teuer.
   Kommen neue Mitarbeiter zum Projekt, haben diese oft kaum eine Chance, sich in bestehende Systeme
   einzuarbeiten, da die Dokumentation fehlt.
</p>
<p>
   In Summe betrachtet, sind die Umsetzungskosten von Projekten mit gutem Softwaredesign daher sogar
   niedriger!
</p>
<br />
<a name="2-Warum-Objektorientierung"></a><h3>2. Warum Objektorientierung?</h3>
<p>
   Hinter objektorientiertem Design (OOD) und objektorientierter Implementierung (OOP) steckt die Idee,
   in Realit&auml;t existierende Problemstellungen in Objekte und deren Beziehungen abzubilden. Die
   Prozess-Logik wird dabei &uuml;ber die Methoden der Objekte definiert.
</p>
<p>
   Durch starke Segmentierung der Elemente und Prozesse einer Software erhofft sich der Entwickler
   &uuml;bersichtliche, leicht implementierbare Funktions-Einheiten. Weiterhin hilft eine gro&szlig;e Sammlung an
   Design-Pattern (siehe
   <a href="http://en.wikipedia.org/wiki/Architectural_pattern_(computer_science)" title="&Uuml;bersicht Design-Pattern" target="_blank">&Uuml;bersicht Design-Pattern</a>),
   die Aufgabenstellungen mit erprobten Standard-L&ouml;sungen zu belegen.
</p>
<p>
   Der Nachteil dieser Vorgehensweise scheint zun&auml;chst der Overhead an Dokumentation und Code zu sein,
   der sich jedoch mit dem Betrieb und der Erweiterung der Applikation als n&uuml;tzlich herausstellt.
   Module sind bei einem guten Design klar strukturiert, Funktionen zentral bereitgestellt und
   Erweiterungen lassen sich mit wenig Aufwand einbringen.
</p>
<br />
<a name="3-Design-Pattern"></a><h3>3. Design Pattern</h3>
<p>
   Ein Design Pattern beschreibt eine L&ouml;sung f&uuml;r ein wiederkehrendes Problem. Dabei wird sowohl auf
   die Aufgabenstellung und Umsetzung, als auch auf die Rahmenbedingungen, in der es eingesetzt werden
   kann, eingegangen. Durch die Verwendung von erprobten Ans&auml;tzen kann unter Architekten und Entwicklern
   eine gemeinsame Sprachregelung etabliert werden. Dies erleichtert nicht nur die Einarbeitung in ein
   neues Aufgabengebiet, sondern erh&ouml;ht auch die Lesbarkeit und die Struktur der Software. Aus diesem
   Grund soll beim Design der G&auml;stebuch-Anwendung nach M&ouml;glichkeit auf anerkannte Design-Pattern
   zur&uuml;ckgegriffen werden.
</p>
<p>
   Bei deren Einsatz ist jedoch zu beachten, dass sich ein gutes Software-Design nicht an der Anzahl
   der eingesetzten Entwurfsmuster, sondern an der Qualit&auml;t der L&ouml;sung, misst. Eine unangemessen hohe
   Anzahl von Pattern scheitert vor allem dann, wenn die Einsatzgebiete und Rahmenbedingungen derselben
   nicht beachtet wurden.
</p>
<p>
   Beim Design einer Software-L&ouml;sung darf der Einsatz von Design Pattern aber auch nicht &uuml;berbewertet
   werden. Nicht f&uuml;r jede Aufgabenstellung ist bereits ein geeignetes Pattern vorhanden. Die Kunst
   eines Software-Designers besteht also darin, verschiedene L&ouml;sungsmodelle so zu kombinieren, dass
   diese einen maximalen Nutzen f&uuml;r das Applikationsdesign bedeuten. Dabei kann es auch notwendig sein,
   verschiedene Pattern in einer Weise zu kombinieren, dass die Nachteile des einen durch die Vorteile
   des anderen aufgewogen werden. Dieses Vorgehen wird auch als &quot;cooperation of design
   patterns&quot; bezeichnet.
</p>
<br />
<a name="4-Grundlagen"></a><h3>4. Grundlagen</h3>
<p>
   Um in den folgenden Abschnitten von gleichen Kenntnissen ausgehen zu k&ouml;nnen, zun&auml;chst ein paar
   Worte zu zentralen Design Pattern und best practices f&uuml;r objektorientiertes Softwaredesign.
</p>
<p>
   Die Kapselung von Funktionalit&auml;t in eigenst&auml;ndige Komponenten ist eine, in der objektorientierten
   Welt, sehr verbreitete Methodik. Dabei geht der Entwickler beim Erstellen des Designs der Software
   davon aus, dass unterschiedliche Schichten der Software (siehe
   <a href="http://de.wikipedia.org/wiki/Schichtenarchitektur" title="Mehrschicht-Architektur" target="_blank">Mehrschicht-Architektur</a>)
   jeweils typische Aufgaben &uuml;bernehmen. Dies erm&ouml;glicht nicht nur eine bessere
   Widerverwendbarkeit der erstellten Services (Komponenten), sondern vereinfacht auch die
   Einbindung von mehreren Entwicklern oder Teams.
</p>
<p>
   Im Enterprise-Bereich hat sich die three tier architecture etabliert. Diese sieht vor, dass
   Anwendungen in eine Pr&auml;sentationsschicht, ein oder mehrere Business-Komponenten und eine
   Daten-Schicht unterteilt sind. Die Pr&auml;sentations-Schicht &uuml;bernimmt die Darstellung. Sie nutzt die
   Business-Schicht zur Beschaffung von Daten und Informationen zu Art und Inhalt der Darstellung.
   Die Business-Schicht repr&auml;sentiert die Anwendungslogik und bildet die Gesch&auml;ftsprozesse ab. Die
   Datenschicht besch&auml;ftigt sich mit der Beschaffung und Speicherung von Daten.
</p>
<p>
   Innerhalb der genannten Schichten existieren weitere Pattern zur Verfeinerung der Vorgehensweisen:
</p>
<p>
   Im Bereich der Datenschicht wird h&auml;ufig das DataMapper-Pattern zitiert. Dieses fungiert als
   Vermittler zwischen der Welt der Datenbank und der Welt der Anwendung. Das bedeutet, dass sich
   diese Komponente mit den Spezifika der Datenbank besch&auml;ftigt und der Software eine einfache
   Schnittstelle bietet um Daten in Form von (Dom&auml;nen-) Objekten zu lesen oder zu speichern.
   Zur weiteren Strukturierung der Business-Schicht k&ouml;nnen das Domain-Object- und
   Front-Controller-Pattern eingesetzt werden:
</p>
<p>
   Das Domain-Model einer Anwendung beschreibt dabei die verarbeiteten Daten und den internen Ablauf.
   In einfachen Anwendungen, wie beispielsweise dem G&auml;stebuch, wird es meist nur genutzt um die
   vorhandenen Datentypen (Benutzer, Eintrag, ...) zu beschreiben.
</p>
<p>
   Der Front-Controller ist vor allem in Web-Applikationen von gro&szlig;er Bedeutung, da er die M&ouml;glichkeit
   bietet, die Business-Schicht-Komponenten vor der Generierung des Benutzer-Interfaces zu
   initialisieren. Daraus leitet sich die M&ouml;glichkeit ab, die Elemente der grafischen Oberfl&auml;che durch
   Model-Parameter direkt zu steuern. Generische Implementierungen des Patterns erm&ouml;glichen zudem,
   allgemeine Aufgaben wie URL-Parameter-Filterung direkt nach der Entgegennahme des Requests zu
   platzieren. So kann beispielsweise die Sicherheit der Applikation bereits an einem zentralen Punkt
   sichergestellt werden.
</p>
<p>
   F&uuml;r die n&auml;here Beschreibung der Pr&auml;sentationsschicht bieten sich das Model-View-Controller (MVC)-
   und das Page-Controller-Pattern an.
</p>
<p>
   Das MVC-Pattern beschreibt die Trennung zwischen dem dargestellten Inhalt und der Definition der
   Applikations-Workflows (Model), der Beschreibung der Darstellung und des Aussehens der Applikation
   (View) und der eigentlichen Darstellungs-Logik (Controller). Auch hier soll die Trennung in weitere
   Schichten f&uuml;r mehr Flexibilit&auml;t bei Erweiterungen und Vereinfachung der Wartung sorgen. Um bei der
   Erstellung einer Applikation noch mehr Flexibilit&auml;t bei der Strukturierung der Views zu haben, sieht
   das hierarchische MVC (HMVC)-Pattern eine Pr&auml;sentations-Schicht aus einem hierarchischen Baum von
   kleinen MVC-Einheiten vor. Dabei wird das Model eines Moduls oder einer Applikation nicht direkt an
   eine solche gebunden, sondern steht mehreren zur Verf&uuml;gung.
</p>
<p>
   Die Funktion des Page-Controller besteht darin, die Anfragen an eine Applikation an einer zentralen
   Stelle entgegen zu nehmen, diesen zu interpretieren und die gew&uuml;nschten Module einer Applikation
   auszuf&uuml;hren. Dabei bietet er insbesondere einen allgemeing&uuml;ltigen Rahmen f&uuml;r nach dem MVC-Pattern
   implementierte Applikationen.
</p>
<p>
   Auch wenn der Page-Controller nur selten in Artikeln mit MVC in Verbindung gebracht wird, ist der
   isolierte Einsatz von MVC nur in sehr einfachen Anwendungsf&auml;llen wertvoll. In gr&ouml;&szlig;eren oder
   komplexeren Projekten f&uuml;hrt die immer wiederkehrende Implementierung der MVC-Mechanismen zu einem
   starken Mehraufwand, was den Einsatz des Patterns nicht mehr rechtfertigen w&uuml;rde.
</p>
<p>
   Neben den genannten Entwurfsmustern existiert noch eine Vielzahl Weiterer. Unter [5] im Info-Kasten
   findet sich Link zu einer &Uuml;bersicht &uuml;ber vorhandene Design-Pattern.
</p>
<br />
<a name="5-Requirements"></a><h3>5. Requirements</h3>
<p>
   F&uuml;r die Analyse der Anforderungen und das Erstellen des Software-Designs, sollten die Anforderungen
   weitestgehend klar sein. Die reine Lehre der agilen Software-Entwicklung geht davon aus, dass auch
   die Anforderungen agil sind, die Erfahrung zeigt jedoch, dass diese zu einem gro&szlig;en Teil stabil
   sein sollten. Aus diesem Grund schickt es sich, offene Fragen im Rahmen eines Design-Reviews
   zusammen mit dem Kunden vor dem Beginn der Implementierung zu kl&auml;ren.
</p>
Die folgende Liste beinhaltet die Anforderungen an das zu erstellende G&auml;stebuch:
<ul>
   <li>Das G&auml;stebuch soll in mehreren Sprachen gleichzeitig einsetzbar sein.</li>
   <li>
      Das Layout soll per CSS frei formatierbar sein (z.B. Ausgabe der Eintr&auml;ge, Formular-Elemente,
      ...).
   </li>
   <li>Das G&auml;stebuch soll als Modul in mehreren Webseiten ohne Code-&Auml;nderungen einsetzbar sein.</li>
   <li>Die festen sprachabh&auml;ngigen Texte sollen in einer Konfigurationsdatei pflegbar sein.</li>
   <li>Das G&auml;stebuch soll schnell auf Benutzer-Eingaben reagieren.</li>
   <li>
      Ein Eintrag besteht aus Titel, Text und Erstellungsdatum. Weiterhin sollen die Attribute Name,
      E-Mail und Webseite vom Besucher abgefragt werden.
   </li>
   <li>
      Die Eintr&auml;ge sollen in einer bl&auml;tterbaren Liste mit dynamischer Anzahl von Eintr&auml;gen pro Seite
      dargestellt werden.
   </li>
   <li>Der Titel und die Beschreibung des G&auml;stebuchs sollen pro Sprache pflegbar sein.</li>
   <li>
      Bereits erstellte Beitr&auml;ge sollen nach einem Login editierbar sein um die Administration
      zu erleichtern.
   </li>
</ul>
Die Formulierung der genannten Punkte l&auml;sst erkennen, dass es sich hierbei lediglich um funktionale
Anforderungen (z.B. Mehrsprachigkeit, Paging) bzw. Umgebungs-Anforderungen (z.B. Performance,
Styling) handelt. Bei komplexen Applikationen ist es ebenso wichtig, auch die nicht-funktionalen
Anforderungen zu definieren. Diese k&ouml;nnen in Form von Screen-Designs, die das statische Aussehen
einer Applikation beschreiben, dokumentiert werden. Erfahrungsgem&auml;&szlig; ergeben sich aus den
Kundengespr&auml;chen oft noch weitere funktionale Anforderungen, die so bisher noch nicht ge&auml;u&szlig;ert
wurden!
<p>
   Die nicht-funktionalen Anforderungen sollen jedoch in diesem Artikel ausgeklammert werden, da das
   G&auml;stebuch ohnehin per CSS frei formatierbar sein soll. Damit steht  jedem Anwender ein probates
   Mittel zur Gestaltung zur Verf&uuml;gung.
</p>
<p>
   Die folgenden Abschnitte widmen sich nun der Analyse der Anforderungen und der Erstellung der
   Design-Dokumentation des G&auml;stebuchs. Zur Problem-Analyse und Dokumentation der erarbeitetet L&ouml;sung
   wird die Beschreibungs- und Modellierungssprache UML eingesetzt.
</p>
<br />
<a name="6-Use-Cases"></a><h3>6. Use Cases</h3>
<p>
   F&uuml;r die genauere Betrachtung von komplexen Software-Systemen bietet sich die Erstellung einer
   Robustness-Analyse an. Die daraus resultierenden Grafiken beinhalten alle Aktoren, Schnittstellen
   und Services und erm&ouml;glichen einem ersten &Uuml;berblick &uuml;ber die zu erstellende L&ouml;sung zu erhalten.
</p>
<p>
   Da die Anforderungen des G&auml;stebuchs jedoch in einem &uuml;berschaubaren Rahmen liegen, kann die Analyse
   mit der Erstellung von Use Cases vorgenommen werden. Use Case-Diagramme bieten daf&uuml;r eine recht
   einfache M&ouml;glichkeit, alle dem Benutzer zur Verf&uuml;gung stehenden Elemente strukturiert zu
   dokumentieren. Die erstellten Grafiken enthalten dabei Aktoren, Anwendungsf&auml;lle und deren
   Beziehungen.
</p>
<p>
   Sofern die Anforderungen des Kunden unstrukturiert vorliegen, k&ouml;nnen Use Cases auch f&uuml;r eine grobe
   Analyse der Anforderungen zusammen mit dem Kunden eingesetzt werden.
</p>
<p>
   Da es sich bei UML um eine formale, grafische Beschreibungssprache handelt, sollten die erstellten
   Diagramme m&ouml;glichst selbsterkl&auml;rend sein. Bei komplexeren Projekten sollte eine textuelle
   Beschreibung jedoch nicht fehlen. &Uuml;blicherweise werden zur Detaillierung Use Case-Templates
   eingesetzt, die einen Use Case mit weiteren Informationen wie Vorbedingung, Standard- und
   Fehler-Verhalten ausstatten. Ein Vorschlag hierf&uuml;r findet sich in der Linkliste am Ende des
   Artikels.
</p>
<p>
   Die folgende Abbildung strukturiert die Anwendungsf&auml;lle, die in den Anforderungen des G&auml;stebuchs
   beschrieben sind:
</p>
<img src="http://media.adventure-php-framework.org/content/uml_use_cases.png" alt=""/>
<p>
   Im Diagramm sind zwei Aktoren abgebildet. Diese beschreiben die beiden in der Applikation
   auftretenden Rollen. Der Besucher (&quot;Visitor&quot;) initiiert das Anzeigen des G&auml;stebuchs und
   agiert als Autor f&uuml;r neue Eintr&auml;ge. Der Administrator (&quot;Editor&quot;) kontrolliert die Inhalte
   und korrigiert diese gegebenenfalls.
</p>
<p>
   Das Verfassen eines Eintrags ist mit dem Anzeigen des Formulars und dessen Speicherung verbunden.
   Um der Anforderung gerecht zu werden, Eintr&auml;ge in einer paginierbaren Liste anzuzeigen, m&uuml;ssen beim
   Betrachten des G&auml;stebuchs sowohl die Seiteninformation als auch die f&uuml;r die Seite relevanten
   Eintr&auml;ge selbst dargestellt werden.
</p>
<p>
   Das Editieren eines Beitrags umfasst mehrere Aktivit&auml;ten, die im Diagramm mit include- und
   dependency-Beziehungen gekennzeichnet sind. Include-Beziehungen werden verwendet, wenn ein Use Case
   einen anderen beinhaltet. Kann ein solcher nur ausgef&uuml;hrt werden, wenn ein anderer erf&uuml;llt ist, wird
   dies durch eine dependency-Beziehung gekennzeichnet.
</p>
<p>
   Nachdem sich der Redakteur authentifiziert hat, kann dieser den gew&uuml;nschten Beitrag ausw&auml;hlen,
   diesen zur Bearbeitung anzeigen lassen und anschlie&szlig;end abspeichern.
</p>
<p>
   Das Erstellen von Use Case Diagrammen scheint zun&auml;chst eine triviale Aufgabe zu sein. Sie ist jedoch
   von nicht geringer Bedeutung, da sich daraus die Views, die dem Nutzer auf GUI-Ebene zur Verf&uuml;gung
   gestellt werden, zumeist direkt ergeben.
</p>
<br />
<a name="7-Daten-Modellierung"></a><h3>7. Daten-Modellierung</h3>
<p>
   Nach der Analyse der Anwendungsf&auml;lle widmen wir uns den im G&auml;stebuch verarbeiteten Daten. Hierf&uuml;r
   ist es von Vorteil, zun&auml;chst die Objekte der Anwendung (=Dom&auml;ne) unabh&auml;ngig von Datenhaltung und
   Darstellung zu betrachten. In einem weiteren Schritt kann dann auf den Ergebnissen des
   Dom&auml;nen-Modells die Modellierung der Datenschicht vorgenommen werden.
</p>
<p>
   Wie bereits in einem der voran gegangenen Abschnitte angesprochen, bedeutet Objektorientierung
   die Abbildung einer reellen Problemstellung in Objekten, deren Funktionen und Beziehungen. Wer
   versucht ist, bereits zum Zeitpunkt der Daten-Analyse Besonderheiten der Darstellung oder
   Speicherung mit in die Modellierung einzubeziehen, l&auml;uft Gefahr, sich von der Realit&auml;t
   zu entfernen.
</p>
F&uuml;r eine korrekte Datenmodellierung sollten folgende Grundregeln und best practices beachtet werden:
<ul>
   <li>Objekte sollten genau mit einer Aufgabe betraut sein.</li>
   <li>
      Sofern ein Attribut eines Objektes mehrfach verwendet wird, sollte dieses als eigenes Objekt
      ausgelagert und mit einer Beziehung referenziert werden.
   </li>
   <li>Die Komposition bezeichnet eine starke Zugeh&ouml;rigkeit (Beispiel: G&auml;stebuch hat Eintr&auml;ge).</li>
   <li>
      Jedes Objekt darf nur einmal komponiert werden, da ein reelles Objekt nur exakt eine starke
      Zugeh&ouml;rigkeit besitzen kann.
   </li>
   <li>
      Die Assoziation bezeichnet eine schwache Zugeh&ouml;rigkeit. Diese wird verwendet, um f&uuml;r eine
      Applikation logisch zusammen geh&ouml;rende Objekte zu verbinden. Assoziationen k&ouml;nnen jederzeit
      aufgel&ouml;st werden, da das betroffene Objekt weiterhin &quot;lebt&quot;.
   </li>
</ul>
In den folgenden Abschnitten wird zwischen dem Daten-Modell der Anwendung (domain object model) und
dem Daten-Modell der Datenschicht (data layer object model) unterschieden.
<br />
<br />
<br />
<a name="8-Domaenen-Modell"></a><h3>8. Dom&auml;nen-Modell</h3>
<p>
   Das domain object model (siehe
   <a href="http://en.wikipedia.org/wiki/Domain_object_model" title="Informationen zum domain object pattern" target="_blank">Informationen zum domain object pattern</a>)
   beschreibt die Objekte, die in einer Anwendung direkt verarbeitet werden. Dabei wird sowohl auf
   die Auspr&auml;gung der Objekte als auch die Beziehungen zu Anderen eingegangen.
</p>
<p>
   Das folgende Diagram zeigt die f&uuml;r ein G&auml;stebuch relevanten Objekte:
</p>
<img src="http://media.adventure-php-framework.org/content/uml_domain_object_model.png" alt="" />
<p>
   Das Guestbook-Objekt repr&auml;sentiert die Instanz eines G&auml;stebuchs. Es beinhaltet den Titel und die
   Beschreibung des G&auml;stebuchs. &Uuml;ber die Assoziation Guestbook2Administrator ist diesem ein Benutzer
   (Typ: User) als administrativer Account zugeordnet. Die Beziehung wird dabei vom Objekt Guestbook
   initiiert, da zur Verwaltung des G&auml;stebuchs ein Administrator vorhanden sein muss.
</p>
<p>
   Das Objekt Entry beschreibt die Daten, die in einem G&auml;stebuch-Eintrag abgespeichert werden. Die
   Attribute des Verfassers werden &uuml;ber die Assoziation Editor2Entry mit dem Eintrag verkn&uuml;pft. Die
   Beziehung wird in diesem Fall vom User initiiert, da die Erstellung des Eintrags von diesem ausgeht
   und nicht umgekehrt.
</p>
<p>
   Weiterhin besitzt das Objekt Entry eine Beziehung vom Typ Komposition zum Objekt Guestbook. Diese
   l&auml;sst erkennen, dass das G&auml;stebuch mehrere Eintr&auml;ge besitzt. Die Qualit&auml;t der Beziehung beschreibt
   zudem, dass ein Entry-Objekt nicht ohne ein Guestbook existieren kann.
</p>
<br />
<a name="9-Mehrsprachigkeit"></a><h3>9. Mehrsprachigkeit</h3>
<p>
   Um der Anforderung nach Mehrsprachigkeit des G&auml;stebuchs gerecht zu werden, ist eine Erweiterung des
   Dom&auml;nen-Modells notwendig, da dieses bisher keine Zuordnung eines G&auml;stebuchs oder Eintrags zu einer
   Sprache &quot;kennt&quot;.
</p>
<p>
   Aus diesem Grund soll nun das Daten-Modell der Anwendung von dem der Datenhaltung getrennt werden.
   Vorteil dieser Verfahrensweise ist, dass die Anwendung nochmals von der Datenhaltung abstrahiert
   wird und &Auml;nderungen zu einem sp&auml;teren Zeitpunkt dadurch erleichtert werden.
</p>
<p>
   Die Erweiterung besteht nun darin, die Attribute der Dom&auml;nen-Objekte durch sprachabh&auml;ngige
   Attribute-Objekte zu ersetzen. Diese sind den &quot;eigentlichen&quot; Guestbook- oder Entry-Objekt
   mit einer Komposition zugewiesen, besitzen jedoch gleichzeitig eine Zuordnung (Assoziation) zu einer
   Sprache. Das zugeh&ouml;rige UML-Diagramm gestaltet sich dann wie folgt:
</p>
<img src="http://media.adventure-php-framework.org/content/uml_data_object_model.png" alt="" />
<p>
   Die Anforderungen beschreiben, dass ein G&auml;stebuch in mehreren Sprachen einsetzbar sein soll. Dies
   ist nur dann m&ouml;glich, wenn es nur eine Instanz gibt, der die sprachabh&auml;ngigen Attribute direkt
   zugeordnet sind. Andernfalls kann die Mehrsprachigkeit nur &uuml;ber eigene G&auml;steb&uuml;cher f&uuml;r jede
   Sprache abgebildet werden.
</p>
<p>
   F&uuml;r Eintr&auml;ge ist es hingegen m&ouml;glich, jeweils ein Entry-Objekt direkt mit den sprachabh&auml;ngigen
   Werten zu f&uuml;llen und zu einer Sprache zuzuordnen. Die Eintr&auml;ge eines G&auml;stebuchs k&ouml;nnen dann durch
   Einschr&auml;nkung &uuml;ber die Beziehung zum G&auml;stebuch und der aktuell gew&auml;hlten Sprache selektiert werden.
   Um die Lesbarkeit zu erh&ouml;hen und die Erweiterbarkeit des Datenmodells zu vereinfachen, wird auch
   diesem Fall auf die Auslagerung der Attribute in eigene Objekte gesetzt. Als Nachteil dieser
   Vorgehensweise ist der erh&ouml;hte Aufwand beim Lesen und Schreiben von Daten zu nennen.
</p>
<p>
   Um die Erweiterung des Dom&auml;nen-Modells um sprachabh&auml;ngige Attribute-Objekte f&uuml;r die Anwendung selbst
   transparent zu gestalten wird das Mapping der sprachabh&auml;ngigen Werte komplett an die Daten-Schicht
   delegiert. Diese f&uuml;llt beim Lesen die Guestbook- und Entry-Objekte mit den f&uuml;r die ausgew&auml;hlte
   Sprache relevanten Daten und &uuml;bersetzt beim Speichern die Dom&auml;nen-Objekte in sprachabh&auml;ngige
   Attribute-Objekte.
</p>
<br />
<a name="10-Datenmodell"></a><h3>10. Datenmodell</h3>
<p>
   In gro&szlig;en Datenhaltungskonzepten werden in der Regel mehr Daten abgespeichert, als eine einzelne
   Anwendung ben&ouml;tigt. Werden in der von der G&auml;stebuch-Applikation benutzen Datenbank neben den
   Eintr&auml;gen noch Termine, Orte, L&auml;nder und deren Beziehungen gespeichert, so ist es Aufgabe der
   Datenschicht der G&auml;stebuch-Anwendung nur diejenigen Daten zur Verf&uuml;gung zu stellen, die auch zur
   Ausf&uuml;hrung ben&ouml;tigt werden.
</p>
<p>
   Im letzten Abschnitt haben wir zudem festgesetzt, dass die L&ouml;sung f&uuml;r das Thema Mehrsprachigkeit
   &uuml;ber ein erweitertes Daten-Modell abgebildet werden soll. Folglich unterscheidet sich auch in diesem
   Fall das Daten- vom Dom&auml;nen-Model.
</p>
<p>
   F&uuml;r die Vermittlung zwischen diesen beiden soll der data mapper verwendet werden. Das Pattern
   beschreibt die Trennung der Datenhaltungs-Logik von der Applikations-Logik. Damit ben&ouml;tigt ein
   Dom&auml;nen-Objekt keine Kenntnisse &uuml;ber die Art der Abbildung auf eine relationale Datenbank. Die
   Trennung von Aufgaben in unterschiedliche Schichten wird dadurch ma&szlig;geblich erleichtert. Abgesehen
   davon l&auml;sst sich der Sinn der Trennung allein darin begr&uuml;nden, dass eine Programmiersprache &uuml;ber
   andere Mechanismen zur Abbildung von Kompositionen und Assoziationen verf&uuml;gt als eine relationale
   Datenbank.
</p>
<p>
   Im Folgenden ist nun das um Mehrsprachigkeit erweitertet Datenmodell auf eine relationale Datenbank
   beschrieben:
</p>
<img src="http://media.adventure-php-framework.org/content/er_data_model.png" alt="" />
<p>
   Dem Tabellen-Design liegen folgende Prinzipien zu Grunde:
</p>
<p>
   Die &quot;einfachen&quot; Attribute eines Objekts werden in einer eigenen Tabelle abgelegt. Dies
   vereinfacht nicht nur die Abfrage der Daten eines Objekts, sondern ist auch aus Sicht der
   Performance g&uuml;nstiger. Nachtr&auml;gliche &Auml;nderungen und Erweiterungen eines Objekts k&ouml;nnen immer
   an zentraler Stelle vorgenommen werden.
</p>
<p>
   Beziehungen - &quot;komplexe&quot; Attribute - werden ebenso in eigenen Tabellen abgebildet. Dies
   erzeugt beim Abfragen von Beziehungsobjekten zun&auml;chst einen gr&ouml;&szlig;eren Umfang der Statements,
   erm&ouml;glicht jedoch die Abbildung von n:m-Beziehungen. Ein weiterer Vorteil ist die Wartung des
   Datenmodells. Wird bei der Weiterentwicklung ein zus&auml;tzliches Objekt mit mehreren Beziehungen
   hinzugef&uuml;gt, kann dieses sehr einfach in die bestehende Struktur eingegliedert werden.
</p>
<p>
   Der hier verwendete Abbildungsansatz von Objekten auf eine relationale Datenbank wird oft auch als
   Teilnormalisierung bezeichnet.
</p>
<br />
<a name="11-Klassenmodell-der-Anwendung"></a><h3>11. Klassenmodell der Anwendung</h3>
<p>
   Ein weiterer Bestandteil des Anwendungs-Designs ist das Klassenmodell. Dieses beschreibt die
   Komponenten einer Software und gibt einen &Uuml;berblick &uuml;ber die Strukturierung innerhalb der einzelnen
   Bereiche. Es umfasst die Klassen und Beziehungen und stellt alle Services der Anwendung nach Au&szlig;en
   dar.
</p>
<p>
   Im Rahmen dieses Artikels kann jedoch kein vollst&auml;ndiges Klassen-Design erbracht werden. Dies ist
   erst bei vollst&auml;ndig bekannter Technologie, deren Tools und Mechanismen komplett m&ouml;glich. Da der
   Artikel trotzdem ein Technologie-unabh&auml;ngiges Design diskutieren m&ouml;chte, zeigt das folgende Diagramm
   eine generische &Uuml;bersicht der relevanten Klassen eines G&auml;stebuchs:
</p>
<img src="http://media.adventure-php-framework.org/content/uml_class_design.png" alt="" />
<p>
   Im Klassendiagramm wird davon ausgegangen, dass innerhalb der Pr&auml;sentationsschicht das MVC-Pattern
   zum Einsatz kommt. Daher wurde f&uuml;r jeden View, der sich aus den essenziellen Use Cases ableitet,
   ein Controller angelegt. Diese nutzen den GuestbookService zum Anzeigen der Daten oder zur
   Speicherung der vom Benutzer eingegebenen Informationen. Um eine &uuml;bersichtliche Abbildung zu
   erhalten, wurden die Klassen des Dom&auml;nen-Modells nicht ber&uuml;cksichtigt. Wie bereits angesprochen,
   z&auml;hlen diese jedoch zur Business-Schicht und sollten bei einer umfassenden Darstellung dort
   angesiedelt sein. Alle abgebildeten Klassen bilden zudem zu diesen eine use-Beziehung aus, da
   Dom&auml;nen-Objekte der kompletten Anwendung bekannt sein m&uuml;ssen.
</p>
<p>
   Der PagingService stellt einen Service f&uuml;r das Anzeigen einer bl&auml;tterbaren Liste dar. F&uuml;r diesen
   wurde wegen der sehr umfangreichen zu implementierenden Funktion eine eigene Klasse eingef&uuml;hrt, die
   unter Umst&auml;nden in anderen Projekten wieder verwendet werden kann. Die Klasse GuestbookMapper
   implementiert das Mapping des mehrsprachenf&auml;higen Datenmodells in das Dom&auml;nen-Modell der Anwendung.
   Dabei greift er zur Anbindung einer Datenbank auf die Klasse DatabaseConnector zur&uuml;ck. Der Grund
   f&uuml;r die Auslagerung ist auch in diesem Fall die M&ouml;glichkeit der Wiederverwendung.
</p>
<br />
<a name="12-Fazit-und-Ausblick"></a><h3>12. Fazit und Ausblick</h3>
<p>
   Die in diesem Artikel beschriebene Software-Architektur bietet eine solide Grundlage f&uuml;r die
   Erstellung eines Technologie-gebundenen Detail-Designs. Der vorliegende Artikel ist daher sowohl
   als Teil der Projekt-Dokumentation als auch zur Absch&auml;tzung des Aufwands und zur Planung der
   Aufgaben geeignet.
</p>
<p>
   Zudem wird widerlegt, dass f&uuml;r die Erstellung einer guten, objektorientierten Software-Architektur
   sehr detaillierte Kenntnisse in UML notwendig sind. Erfahrungsgem&auml;&szlig; gen&uuml;gen Use Case-, Klassen- und
   Ablaufdiagramme bereits f&uuml;r 95% der Design-Beschreibungen. Die in einem UML-Diagramm nicht
   offensichtlich beschreibbaren Anforderungen lassen sich bequem als Erg&auml;nzung zu den Abbildungen
   einf&uuml;gen.
</p>
<p>
   Im n&auml;chsten Artikel dieser Serie wird das hier diskutierte Design um die Technologie-gebundenen
   Aspekte erweitert. In diesem Zusammenhang wird auch auf das bisher ausgesparte Thema Administration
   n&auml;her eingegangen. Um den Software-Lifecycle zu komplettieren, wird in der n&auml;chsten Ausgabe auch
   die Umsetzung des besprochenen Designs beschrieben. Dies umfasst insbesondere die Implementierung
   der Datenschicht und die Strukturierung der Komponenten der Pr&auml;sentations-Schicht mit Hilfe des
   HMVC- und Page-Controller-Pattern.
</p>
<br />
<a name="13-Links-zum-Thema"></a><h3>13. Links zum Thema</h3>
<ul>
   <li><a href="http://de.wikipedia.org/wiki/Robustheitsanalyse" title="Definition und Einsatz der Robustness-Analyse" target="_blank">Definition und Einsatz der Robustness-Analyse</a></li>
   <li><a href="http://de.wikipedia.org/wiki/Use_Case" title="Beschreibung von Use Case Templates" target="_blank">Beschreibung von Use Case Templates</a></li>
   <li><a href="http://de.wikipedia.org/wiki/Anwendungsfall_(UML)" title="Syntax von Use Case Diagrammen" target="_blank">Syntax von Use Case Diagrammen</a></li>
   <li><a href="http://de.wikipedia.org/wiki/UML" title="&Uuml;bersicht &uuml;ber UML" target="_blank">&Uuml;bersicht &uuml;ber UML</a></li>
   <li><a href="http://www.netbeans.org/downloads/index.html" title="Entwicklungsumgebung: NetBeans" target="_blank">Entwicklungsumgebung: NetBeans</a></li>
   <li><a href="http://dev.mysql.com/downloads/workbench/5.1.html" title="Datenbank-Designer: MySQL Workbench" target="_blank">Datenbank-Designer: MySQL Workbench</a></li>
</ul>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_112" />