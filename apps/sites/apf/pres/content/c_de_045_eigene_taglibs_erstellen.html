<doku:title parent="071" tags="tutorial,taglibs,eigene taglibs,erweiterung bestehender taglibs" title="TagLibs erstellen" urlname="TagLibs-erstellen">
  Das vorliegende Tutorial beschreibt, wie eigene TagLibs erstellt werden können. Neben einem
  theoretischen Beispiel finden sich auch praktische Anwendungen auf der Seite.
</doku:title>
<div class="warn">
   Die hier beschriebene Dokumentation gilt für Releases &lt;= 1.15. Die ab Release 1.16 gültige Dokumentation finden
   Sie unter <int:link pageid="147"/>.
</div>

<h3 id="Chapter-1-Einfuehrung"><a href="#Chapter-1-Einfuehrung">1. Einführung</a></h3>
<p>
   Der hier diskutierte Page-Controller baut beim Parsen der Templates einen internen Objektbaum aus den
   Implementierungen der einzelnen TagLib-Klassen auf. Als Basis für alle vorhandenen und weiteren
   Baum-Objekte dient die Klasse <em>Document</em>. Dieses erbt bereits vom zentralen Basis-Objekt
   <em>APFObject</em> und besitzt in ihrer Spezialisierung die zentrale Parser-Methode
   <em>__extractTagLibTags()</em>. Jeder in einem Template notierte XML-TagLib-Tag bildet im DOM-Baum ein
   weiteres Kind des aktuellen Dokuments. Der XML-Tag in einer Template-Datei definiert dabei die Parameter
   des Tags, die TagLib-Klasse die Funktion desselben zum Zeitpunkt des Parsen und bei der Transformation.
</p>

<h3 id="Chapter-2-Aufbau-einer-TagLib"><a href="#Chapter-2-Aufbau-einer-TagLib">2. Aufbau einer TagLib</a></h3>
<p>
   Jeder XML-Tag, der unter <int:link pageid="046" />
   dokumentiert ist, wird - wie oben beschrieben - durch eine TagLib-Klasse repräsentiert. Die
   TagLib-Klasse definiert dabei über die Interface-Methoden das Verhalten des Tags zur Laufzeit der
   Anwendung.
</p>
<p>
   Eine TagLib-Klasse besitzt immer den Namensbestandteil "<strong>_taglib_</strong>" zwischen Präfix
   und Klassenbezeichnung. Möchte der Entwickler in einer Template-Datei das Tag
</p>
<gen:highlight type="apf-xml">
&lt;shop:basket /&gt;
</gen:highlight>
einbauen, so ist die TagLib-Klasse
<gen:highlight type="php">
shop_taglib_basket
</gen:highlight>
<p>
   zu benennen. Dabei wird der grün markierte Teil als <strong>Präfix</strong> und der blau
   markierte Teil als <strong>Klasse</strong> bezeichnet. Die Vergabe von Präfix und Klasse obligt
   dem Entwickler. Es wird jedoch empfohlen, die Tags nach Abhängigkeit und Schachtelung zu bezeichnen.
   Besitzt der <strong>&lt;shop:basket /&gt;</strong>-Tag beispielsweise weitere Sub-Tags, so sollte das
   Präfix dieser mit <strong>basket</strong> betitelt werden. Hier ein Beispiel für die
   sinnvolle Benennung:
</p>
<gen:highlight type="apf-xml">
&lt;shop:basket&gt;
 &lt;basket:title /&gt;
 &lt;basket:products&gt;
   &lt;products:listing /&gt;
   &lt;products:sum /&gt;
 &lt;/basket:products&gt;
&lt;/shop:basket&gt;
</gen:highlight>
<p>
   Da an dieser Stelle gewünscht ist, dass beim Parsen des <strong>&lt;shop:basket /&gt;</strong>-Tags
   weitere Sub-Tags berücksichtigt werden, müssen diese der <strong>shop_taglib_basket</strong>-Klasse
   im Konstruktur durch
</p>
<gen:highlight type="php">
class shop_taglib_basket extends Document {

   public function __construct() {
      $this->__TagLibs[] = new TagLib('namespace::to::taglib','basket','title');
      $this->__TagLibs[] = new TagLib('namespace::to::taglib','basket','products');
   }

   [..]

}
</gen:highlight>
<p>
   bekannt gemacht werden. Selbiges gilt für das Tag <strong>&lt;basket:products /&gt;</strong>
   in der TagLib-Klasse <strong>basket_taglib_products</strong>. Auch hier müssen die TagLibs
   <strong>&lt;products:listing /&gt;</strong> und <strong>&lt;products:sum /&gt;</strong> im Konstruktor
   von <strong>basket_taglib_products</strong> bekannt gemacht werden.
</p>

<h4 id="Chapter-2-1-Klassen-Variablen"><a href="#Chapter-2-1-Klassen-Variablen">2.1. Klassen-Variablen</a></h4>
<p>
   Beim Parsen des XML-/HTML-Codes einer HTML-Datei werden die eingesetzten und dem Parser bekannten Tags
   in Objekte gemappt. Der Inhalt eines Tags, z.B.
</p>
<gen:highlight type="apf-xml">
&lt;php:hightlight&gt;
   $var = 'value';
&lt;/php:hightlight&gt;
</gen:highlight>
<p>
   wird in die Variable <strong>$this->__Content</strong> geschrieben, die Attribute des Tags in die
   Variable <strong>$this->__Attributes</strong>, wobei letzteres vom Typ Array ist. Damit kann
   innerhalb einer TagLib immer auf den Inhalt und die Attribute desselben zugegriffen werden. Tags
   können damit ganz einfach im XML-/HTML-Code für die Verwendung parametrisiert/konfiguriert
   werden. Weiterer Vorteil ist, dass einem so eingesetzten Tag beliebig viele HTML-Attribute wie "style"
   oder "class" zugewiesen werden können. Dies erleichtert vor allem bei UI-Elementen wie Text-Felder
   oder Buttons die Formatierung unabhängig vom PHP-Code.
</p>
<p>
   Die private Variable <strong>$this->__ParentObject</strong> hält eine Referenz auf das
   Vater-Objekt. Mit der Methode <em>getParentObject()</em> und <em>getAttribute()</em> kann auf
   die Eigenschaften der Eltern-Klasse zugegriffen werden. Die Dokumentation
   der Methoden kann unter der <int:link pageid="002" /> des Core-Namespaces für das Objekt
   <em>Document</em> bzw. <em>APFObject</em> nachgelesen werden.
</p>

<h4 id="Chapter-2-2-Klassen-Methoden"><a href="#Chapter-2-2-Klassen-Methoden">2.2. Klassen-Methoden</a></h4>
<p>
   Um einer Tag-Library Funktionen "mitgeben" zu können gibt es mehrere Interface-Methoden, die zu
   unterschiedlichen Zeiten ausgeführt werden und unterschiedliche Bedeutung haben. Grundsätzlich
   ist der Entwickler jedoch frei in der Gestaltung der Klasse selbst und kann diese durch beliebige
   Methoden erweitern. Bindend bzw. vorgegeben sind jedoch folgende Bereiche:
</p>
<ul>
  <li>
    <strong>Klassen-Deklaration:</strong>
    <p>
       Die Klasse muss stets von <em>Document</em> erben, da diese das Interface für die konkrete
       Implementierung vorgibt und die zentrale Parser-Methode zur Verfügung stellt. Der Dateiname
       richtet sich nach der Wahl des Tag-Namens. Wird der Tag "php:highlight" genannt, so bildet der
       erste Teil (Präfix) den ersten Teil des Namens vor dem Mittel-Teil "_taglib_" und der zweite
       Teil (Class) das Suffix. Es ergibt sich somit ein Klassen-Name von <strong>php_taglib_highlight</strong>.
       Wird eine TagLib mit dem "core:addtaglib"-Tag eingebunden sucht der Parser nach einer derart
       benannten Datei. Wichtig ist ausserdem, dass die Dateinamen mit dem der Klasse übereinstimmen
       muss.
    </p>
  </li>
  <li>
    <strong>Konstruktor:</strong>
    <p>
       Im Konstruktor einer TagLib können einfache Initialisierungen von Member-Variablen oder
       ähnliche Aufgaben platziert sein. Beim Erzeugen des Objekts wird dem Konstruktor kein
       Parameter übergeben. Es muss nicht zwingend ein Konstruktor implementiert werden.
    </p>
    <p>
       Ein weiterer Anwendungsfall ist das Hinzufügen weiterer TagLibs, die als Kinder eines Tags
       fungieren (siehe oben). Ein Beispiel hierfür ist zudem die Klasse <em>html_taglib_template</em>
       (siehe <a href="Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>).
    </p>
  </li>
  <li>
    <strong>onParseTime()-Implementierung:</strong>
    <p>
       Die Methode <em>onParseTime()</em> wird auf jede TagLib dann ausgeführt, wenn die Eigenschaften
    </p>
    <ul>
      <li>$this->__Context</li>
      <li>$this->__Attributes</li>
      <li>$this->__Content</li>
      <li>$this->__Language</li>
    </ul>
    <p>
       vom Page-Controller gesetzt wurden. Damit hat die Tag-Library bereits zu diesem Zeitpunkt Zugriff
       auf die Attribute und Inhalte und kann Operationen implementieren. Es ist zu diesem Zeitpunkt
       jedoch noch nicht sichergestellt, dass alle Kinder des aktuellen Dokuments erzeugt und
       eingehängt wurde. Um Zugriff auf diese zu erhalten sollte die Funktion <em>onAfterAppend()</em>
       genutzt werden.
    </p>
    <div class="hint">
      Die Methode eignet sich jedoch um weitere Sub-Tags im Inhalt des aktuellen
      Objekts zu parsen oder etwaig angegebene Document-Controller zu extrahieren. Hier stehen die
      privaten Methoden <em>__extractTagLibTags()</em> und <em>__extractDocument-Controller()</em>
      (siehe <a href="Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>)
      zur Verfügung.
    </div>
    <div class="hint">
       Damit bei der Transformation die Inhalte einer Taglib an der korrekten Stelle ausgegeben werden,
       erzeugt die Methode <em>__extractTagLibTags()</em> Platzhalter-Tags der Form
       <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Dabei entspricht <em>{OBJECT_ID}</em>
       dem Wert der Klassen-Variable <em>$this->__ObjectID</em> und dem Array-Offset, in dem die
       Kind-Tags gespeichert werden (<em>$this->__Children</em>). Dieser Wert kann dann bei der
       Implementierung von eigenen <em>transform()</em>-Methoden für die Ersetzung des Inhalts
       genutzt werden.
    </div>
  </li>
  <li>
    <strong>onAfterAppend()-Implementierung:</strong>
    <p>
       Sind alle Kinder des aktuellen Knotens in den Baum eingehängt, wird auf diese jeweils die
       <em>onAfterAppend()</em>-Methode ausgeführt. Von hier aus kann nun auf alle Objekte des
       Baumes zugegriffen werden. In der Variablen <strong>$this->__ParentObject</strong> ist eine
       Referenz auf das Vater-Objekt und in <strong>$this->__Children</strong> sind die Kinder eines
       Objekts gespeichert. Mit den oben genannten Methoden kann auf die Attribute und Eigenschaften
       zugegriffen werden.
    </p>
  </li>
  <li>
    <strong>transform()-Implementierung</strong>
    <p>
       Die bisher genannten Methoden dienten dem Abbilden des XML-/HTML-Codes in einen Objektbaum. Die
       Funktion <strong>transform()</strong> hingegen ist für die Generierung der HTML-Ausgabe
       zuständig. Hier wird der HTML-Code generiert, der nach der vollständigen Transformation
       des Baumes zur Anzeige gebracht wird. In der Regel kann die Implementierung der Methode von der
       Klasse <em>Document</em> übernommen werden, für spezielle Anwendungen muss diese jedoch
       überladen werden. Um die Attribute eines Objekts in HTML-Code ausgeben zu können gibt es
       eine weitere private Methode: <strong>getAttributesAsString()</strong> (bzw. 
       <strong>__getAttributesAsString()</strong> vor Version 1.14).
    </p>
  </li>
</ul>
<div class="hint">
   Sofern die Methode <em>transform()</em> in eigenen TagLibs überschrieben wird, muss
   sich der Entwickler selbst um die Transformation der Kind-Knoten kümmern. Dies kann im
   einfachsten Fall durch
<gen:highlight type="php">
foreach($this->__Children as $objectId => $DUMMY){
   $this->__Content = str_replace(
         '<'.$objectId.' />',
         $this->__Children[$objectId]->transform(),
         $this->__Content
   );
}
</gen:highlight>
   erreicht werden, wenn in den Methoden <em>onParseTime()</em> oder <em>onAfterAppend()</em> die
   Parser-Funktion <em>__extractTagLibTags()</em> aufgerufen wurde. Weitere Hinweise können dem
   Foren-Beitrag
   <a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a>
   entnommen werden.
</div>

<h3 id="Chapter-3-Anwendungsbeispiele"><a href="#Chapter-3-Anwendungsbeispiele">3. Anwendungsbeispiele</a></h3>
<h4 id="Chapter-3-1-php_taglib_hightlight">3.1. Taglib <em>php_taglib_hightlight</em></h4>
<p>Folgender Code zeigt ein Beispiel für eine einfache TagLib, die im Text zwischen</p>
<gen:highlight type="apf-xml">
  &lt;php:highlight&gt;
    [..]
  &lt;/php:highlight&gt;
</gen:highlight>
<p>
   enthaltenen PHP-Code farbig darstellt. Die Logik wird dabei von der Klasse <strong>php_taglib_hightlight</strong>
   abgebildet. Diese implementiert dazu die Methode <em>transform()</em>, die den in der Variable
   <strong>$this->__Content</strong> enthaltene Text mit Hilfe der PHP-Funktion <em>highlight_string()</em>
   als PHP-Quelltext formatiert wird:
</p>
<gen:highlight type="php">
class phpphp_taglib_highlight extends Document {

   public function transform(){

      // count lines
      $LineCount = substr_count($this-&gt;__Content,"\n") - 1;

      // highlight source code
      // - Remove new lines at the beginning
      // - Remove new lines and blanks at the end
      // - Remove new lines and blanks around the whole text
      $HighlightedContent = highlight_string(trim('&lt;?php '.ltrim(rtrim($this-&gt;__Content),"\x0A..\x0D").' ?&gt;'),true);

      // replace php start tags
      $HighlightedContent = str_replace('&lt;font color="#007700"&gt;&lt;?&lt;/font&gt;','',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;&lt;?php&nbsp;','&lt;font color="#0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;php','&lt;font color="#0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;&nbsp;&lt;/font&gt;','',$HighlightedContent);

      // enhancement to the PHP5 support
      $HighlightedContent = str_replace('&lt;span style="color: #0000BB"&gt;&lt;?php&nbsp;','&lt;span style="color: #0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;span style="color: #0000BB"&gt;&lt;?php','&lt;span style="color: #0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;span style="color: #0000BB"&gt;?&gt;&lt;/span&gt;','',$HighlightedContent);

      // replace php end tags
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;?&gt;&lt;/font&gt;','',$HighlightedContent);

      // return div encloses source code with height limit if necessary
      if($LineCount &gt; 27){
         return '&lt;div class="phpcode" style="height: 400px; overflow: auto;"&gt;'.$HighlightedContent.'&lt;/div&gt;';
      }
      else{
         return '&lt;div class="phpcode"&gt;'.$HighlightedContent.'&lt;/div&gt;';
      }

   }

}
</gen:highlight>

<h4 id="Chapter-3-2-html_taglib_entityencode">3.2. Taglib <em>html_taglib_entityencode</em></h4>
<p>
   Die TagLib <em>html:entityencode</em> dient dazu Text in HTML-Entities zu konvertieren. Ein wichtiges
   Anwendungsgebiet ist die Codierung einer E-Mail-Adresse um diese von Crawlern zu schützen. Um
   diese Funktionalität bereitzustellen wird eine neue TagLib-Klasse definiert, die die Methode
   <strong>encodeCharactersToHTML</strong> der Klasse <strong>StringAssistant</strong> nutzt, um den
   Inhalt des Tags zu konvertieren. Nach dem Einbinden der TagLib kann diese wie folgt verwendet werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
<p>Im Quelltext der ausgelieferten Seite findet sich dann der Text</p>
<gen:highlight type="apf-xml">
&amp;#110;&amp;#111;&amp;#98;&amp;#111;&amp;#100;&amp;#121;&amp;#64;&amp;#101;&amp;#120;&amp;#97;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;
</gen:highlight>
<p>
   wieder. Da die Codierungs-Funktionalität nicht in der TagLib selbst implementiert ist, kann diese
   auch in anderen Bereichen wie einem Gästebuch durch Einbindung der Klasse <strong>StringAssistant</strong>
   verwendet werden. Die nachfolgend angezeigte Quelltext-Box zeigt die TagLib nochmal im Überblick:
</p>
<gen:highlight type="php">
import('tools::string','StringAssistant');

class html_taglib_entityencode extends Document {

   public function transform(){
      return StringAssistant::encodeCharactersToHTML($this->__Content);
   }

}
</gen:highlight>

<h4 id="Chapter-3-3-doc_taglib_createobject">3.3. Taglib <em>doc_taglib_createobject</em></h4>
<p>
   Als weiteres Anwendungs-Beispiel soll die Tag-Library erläutert werden, die für die
   Einbindung des Inhalts der Dokumentations-Seite verantwortlich ist. Die Tag-Library
   <strong>&lt;doc:createobject /&gt;</strong> liest Inhalte aus HTML-Dateien in einem
   speziellen Ordner aus, parst den Inhalt und generiert dadurch eine weitere Verzweigung im Objektbaum.
   Der folgende Kasten zeigt den Quell-Code der TagLib. Um diese nutzen zu können muss diese zuerst
   mit
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::taglib" prefix="doc" class="createobject" /&gt;
</gen:highlight>
<p>
   eingebunden werden. Anschließend (bereits unmittelbar nach dem Einbinden) kann folgendes in der
   HTML-Datei notiert werden:
</p>
<gen:highlight type="apf-xml">
&lt;doc:createobject requestparam="Seite" defaultvalue="Startseite" /&gt;
</gen:highlight>
<p>Betrachtet man den Quellcode der TagLib-Klasse näher wird dort folgende Logik gekapselt:</p>
<gen:highlight type="php">
import('tools::request','RequestHandler');

class doc_taglib_createobject extends Document {

   public function __construct() {
      parent::__construct();
   }

   public function onParseTime() {

      // get the attributes
      $requestParameter = $this->getAttribute('requestparam');
      $defaultValue = $this->getAttribute('defaultvalue');

      // get current request param
      $currentRequestParameter = RequestHandler::getValue($requestParameter, $defaultValue);

      // fill content
      $this->__Content = $this->loadContent($currentRequestParameter);

      // extract tags and document controller
      $this->__extractTagLibTags();
      $this->__extractDocumentController();

   }

   protected function loadContent($pageName) {

      $file = './frontend/content/c_' . $this->__Language . '_' . strtolower($pageName) . '.html';

      if (!file_exists($file)) {
         $file = './frontend/content/c_' . $this->__Language . '_404.html';
      }

      return file_get_contents($file);

   }

}
</gen:highlight>
<ul>
  <li>
    Zu Beginn der Datei wird ein weiteres Tool importiert, das später Verwendung findet.
  </li>
  <li>
    Im Konstruktor wird der Konstruktor der Eltern-Klasse aufgerufen. Dies beinhaltet die Initialisierung
    der standardmäßig eingebundenen TagLibs. Jede TagLib wird in einem Objekt in der
    Variable <strong>$this->__TagLibs</strong> nochmals durch ein eigenes Objekt repräsentiert,
    damit der Parser weiß, auf welche TagLibs er den Inhalt untersuchen muss. Nur bekannt
    gemachte TagLibs können gefunden werden!
  </li>
  <li>
    In der Methode <em>onParseTime()</em> werden die Tag-Attribute eingelesen und der aktuelle
    Request-Parameter mit Hilfe der Klasse <em>RequestHandler</em> ermittelt. Anschließend
    wird mit Hilfe der privaten Funktion <em>loadContent()</em> der Inhalt des Objekts gefüllt.
    Ist der Inhalt eingelesen, wird versucht, mit den Parser-Methoden <em>__extractTagLibTags()</em>
    und <em>__extractDocumentController()</em> enthaltene und bekannte Tags und Document-Controller
    zu extrahieren und als Kinder bzw. Attribut einzuhängen.
  </li>
  <li>
    Innerhalb der Methode <em>loadContent()</em> wird lediglich der Inhalt der mit dem Übergabe-
    Parameter spezifizierten Datei geladen und zurückzugeben. Ist die gewünschte Datei
    nicht vorhanden wird der Inhalt einer Standard-Fehler-Datei zurückgegeben.
  </li>
</ul>
<p>
   Für weiterführende Anwendungs-Beispiele können die TagLibs für das Formular-
   Management herangezogen werden. Diese befinden sich im Ordner <strong>apps/tools/form/taglib/</strong>.
</p>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_045" />