<doku:title parent="100" tags="taglib,taglibs,tag,parser" title="Implementation of tags" urlname="Implementation-of-tags">
   This chapter describes the concepts and the usage of tags/taglibs within the APF.
</doku:title>
<div class="hint">
   Please refer to chapter <int:link pageid="045" /> for the implementation of tags until and including release 1.15.
</div>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   This chapter focuses on APF tags (a.k.a. Taglibs). It describes the concepts and supports development of custom tags.
</p>
<p>
   The <int:link pageid="098"/> is based on the same-name pattern and is one of the central elements of the APF. It
   enables you - as a developer - to inject custom functionality for the creation and transformation of the APF DOM tree.
   Thus, tags are not only a basis for the APF's HMVC concept but can be used to enhance it easily.
</p>
<p>
   Further, tags may be used to re-use functionality encapsulated within a tag within several projects. Since APF
   templates only process tags and no PHP code un-controlled spread of logic is prevented automatically. This means, that
   view logic can only reside within tags and controllers.
</p>

<h4 id="Chapter-1-1-Page-controller"><a href="#Chapter-1-1-Page-controller">1.1. Page controller</a></h4>
<p>
   The <int:link pageid="098"/> is responsible for creating and transforming of the internal template structure. For this
   reason he provides a tag API that parses tags - following a dedicated timing model -, creates documents within the
   DOM tree and finally creates the HTML output. Different formats such as XML can be produced, too. The parser itself
   is no &quot;real&quot; XML parser but resolves explicitly and self closing tags as well as unlimited tag hierarchies.
</p>
<div class="warn">
   Please note the restrictions of the APF parser within the <a href="#Chapter-6-Tag-hierarchies">Tag-Hierarchie</a>
   chapter.
</div>
<p>
   The <int:link pageid="046"/> shipped with the APF provide a series of standard functionality such as inclusion of
   further templates, definition of reusable template fragments and inclusion of custom tags.
</p>

<h4 id="Chapter-1-2-XML-parser"><a href="#Chapter-1-2-XML-parser">1.2. XML parser</a></h4>
<p>
   The <em>XMLParser</em> used by the page controller during creation of the <em>Document</em> instances is intended for
   analyzing tag definitions.
</p>
<div class="warn">
   Due to performance reasonsn, the <em>XMLParser</em> only processes tag attributes that are separated by blanks.
   Further, values must be delimited by double-quotes.
</div>

<h3 id="Chapter-2-Definition-of-a-tag"><a href="#Chapter-2-Definition-of-a-tag">2. Definition of a tag</a></h3>
<p>
   An APF tag is defined by the following parts:
</p>
<ul>
   <li>
      <strong>Prefix</strong>: the <em>prefix</em> is commonly used to group tags (e.g. <em>core</em> for tags that are
      shipped with the APF). This part is similar to XML namespaces.
   </li>
   <li>
      <strong>Name</strong>: the <em>Name</em> can be considered as declaration. This part is similar to XML tag names.
   </li>
   <li>
      <strong>Attributes</strong>: the attributes of a tag can be used for configuration. Attribute vales must not
      contain further tags.
   </li>
   <li>
      <strong>Content</strong>: the content area can contain further tags or simple text. The APF parser resolves tags
      defined there and adds them to the current hierarchy level. Simple text is also available within the tag for
      further usage.
   </li>
</ul>
<p>
   The tag contained in the subsequent code box can be used to print the current date to the template it is contained in:
</p>
<gen:highlight type="apf-xml">
<current:date format="H:i" />
</gen:highlight>
<p>
   Within this declaration, <em>current</em> is the prefix, <em>date</em> is the name, and the attribute <em>format</em>
   contains the output format. This tag does not define any content.
</p>
<p>
   To display an image gallery the following tag definition can be used:
</p>
<gen:highlight type="apf-xml">
<img:gallery>
   <h3>My holiday in 2012</h3>
   <p>
      These pictures are from my holiday in 2012:
   </p>
   <gallery:datasource
      namspace="..."
      class="..."
   />
</img:gallery>
</gen:highlight>
<p>
   In the above example the <em>&lt;img:gallery /&gt;</em> tag contains static HTML - that is used for formatting later
   on - as well as a further tag that defines the data source (z.B. database). Using this tag it must be made known to
   the APF parser.
</p>

<h3 id="Chapter-3-DOM-structure"><a href="#Chapter-3-DOM-structure">3. DOM structure</a></h3>
<p>
   As mentioned in <a href="#Chapter-1-1-Page-controller">chapter 2</a> the <int:link pageid="098"/> creates a DOM tree
   out of the tag structure within the template files. This tree is similar to a browser's DOM tree that creates a memory
   reference out of HTML tags.
</p>
<p>
   The difference between the DOM tree of a browser and the APF implementation is that each node provides logic for
   transformation and displaying that the page controller uses during the transformation phase.
   Details on the timing model of the page controller can be found <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram">here</int:link>.
</p>
<p>
   Each tag - or from a particular point in time it's instance - passes the same life cycle. At the beginning, the
   structure of the tag is analyzed, then it's substance (attributes and content). After that, a DOM node instance is
   created regarding the tag definition and the substance the <em>XMLParser</em> has extracted from the template.
</p>
<div class="hint">
   Please note that the page controller only processes tags that are known within the current node. For this reason,
   custom tags must be published to the current node. You can do so using the <em>&lt;core:addtaglib /&gt;</em> tag or
   adding
<gen:highlight type="php">
$this->__TagLibs[] = new TagLib(...);
</gen:highlight>
   to the constructor of your custom tag. Using the <em>&lt;core:addtaglib /&gt;</em> tag is necessary if you intend to
   add a custom tag within a template file, the PHP code sample can be used within custom tags to publish further
   hierarchies to the APF parser.
</div>
<p>
   Publishing your tag you need to specify <em>prefix</em> and <em>name</em> as well as <em>namespace</em> and
   <em>class name</em> of the tag implementation. Thereby, you can re-use one implementation in different hierarchy
   levels or projects using a different <em>prefix</em> and <em>name</em> declaration. The tag declaration class -
   <em>TagLib</em> - has the following signature (condensed):
</p>
<gen:highlight type="php">
final class TagLib {

   private $namespace;
   private $class;
   private $prefix;
   private $name;

   public function __construct($namespace, $class, $prefix, $name) {
   }

}
</gen:highlight>
<p>
   Details on tag hierarchies can be found in the <a href="#Chapter-6-Tag-hierarchies">tag hierarchies</a> chapter.
</p>

<h3 id="Chapter-4-Class-structure-of-tags"><a href="#Chapter-4-Class-structure-of-tags">4. Class structure of tags</a></h3>
<p>
   The structure of tags is defined by the <em>Document</em> class. This class is the mother of all tag implementations
   of the APF. It defines several methods that are used within the timing model of the page controller for different
   reasons.
</p>
<p>
   Please note the following signature (condensed):
</p>
<gen:highlight type="php">
class Document extends APFObject {

   protected $__ObjectID = null;
   protected $__ParentObject = null;
   protected $__Children = array();
   protected $__Content;
   protected $__TagLibs = array();

   public function __construct() {
   }

   public function onParseTime() {
   }

   public function onAfterAppend() {
   }

   public function transform() {
   }

}
</gen:highlight>
<p>
   The items from the code box have the following meaning:
</p>
<ul>
   <li>
      The field <em>__ObjectID</em> stores the internal unique object id the object receives from the APF parser during
      creation. The value is e.g. used for <int:link pageid="004"/> tags or to refer a DOM element by it's unique
      identifier.
   </li>
   <li>
      <em>__ParentObject</em> refers to the father object within the DOM tree. This reference can be used to navigate
      the DOM tree. The root node does not have a father.
   </li>
   <li>
      The list of <em>__Children</em> contains all child nodes of the current DOM node. This list can be used to navigate
      the DOM tree. In case a DOM node does not have children, the list is empty.
   </li>
   <li>
      The <em>__Content</em> field contains the textual content of the node as well as place holder tags created by the
      page controller during DOM tree creation in order to guarantee correct assembling of the HTML source code.
   </li>
   <li>
      The <em>__Attributes</em> list - inherited from <em>APFObject</em> - contains a list of tag attributes and their
      respective values. In case a tag defines no attributes the list is empty.
   </li>
   <li>
      The <em>__TagLibs</em> list contains all known tags for the current node. As mentioned in the previous chapter,
      the APF parser only processes tags that are known within a particular hierarchy level or within a DOM element
      respectively. Which tags are known and which are not is thus defined by this list.
      <div class="hint">
         The <em>__TagLibs</em> list can be used in custom tag implementations to publish new tags or to remove some or
         all of them. Since manipulation of this list directly influences the parser, please be careful!
      </div>
   </li>
   <li>
      The constructor of the tag class is callen when creating the tag instance. But the parser does not apply arguments.
      It can be used to add known tags to the current hierarchy or to initialize default values.
      <div class="warn">
         On execution time of the constructor neither tag attributes nor content has been initialized within the tag.
         Further, context and language are not available at this time, too.
      </div>
   </li>
   <li>
      After the tag has been parsed, the <em>onParseTime()</em> is called. At this particular point in time, the
      attributes and the content of the tag are available. Moreover, context and language are initialized. This method
      can be used the initialize the tag with the information available or to analyze the content of the tag (e.g. parse
      child tags).
   </li>
   <li>
      After the node has been added to the DOM tree - this means that the father node and the children are initialized -
      the <em>onAfterAppend()</em> is called. Within this method you may execute logic that affects father and child
      nodes.
   </li>
   <li>
      During transformation, the page controller calls the <em>transform()</em> method of your tag. Please place all
      logic needed for creating the appropriate HTML source code within this method. Tags that are intended for
      configuration or initialization often generate no output (e.g. the <em>&lt;core:addtaglib /&gt;</em> tag). However,
      it is up to you how your tag acts.
      <div class="hint">
         In case the <em>transform()</em> method is overwritten by your custom tag, you have to take care of the
         transformation of the child nodes by yourself. This may be done as follows:
<gen:highlight type="php">
foreach($this->__Children as $objectId => $DUMMY){
   $this->__Content = str_replace(
      '<'.$objectId.' />',
      $this->__Children[$objectId]->transform(),
      $this->__Content
   );
}
</gen:highlight>
         You can use the snippet above in case the parser function <em>__extractTagLibTags()</em> has been called within
         <em>onParseTime()</em> or <em>onAfterAppend()</em>. Further notes can be taken from the forum post
         <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a> (German).
      </div>
   </li>
</ul>

<h3 id="Chapter-5-Implementation"><a href="#Chapter-5-Implementation">5. Implementation</a></h3>

<h4 id="Chapter-5-1-Simple-tag"><a href="#Chapter-5-1-Simple-tag">5.1. Simple tag</a></h4>
<p>
   This chapter deals with a simple tag. &quot;Simple&quot; in this case means that the tag does a dedicated job but
   creates no extra hierarchy - precisely he has no children.
</p>
<p>
   As an example we use the tag from <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a> that displays the current
   time. The functionality of the tag is just to return the current time using the applied format at transformation time.
   There is no dependency to other tags within the DOM tree and there is no need for further initialization. The source
   code of the tag might be as follows (namespace: <em>examples::tags::pres</em>):
</p>
<gen:highlight type="php">
class HourDisplayTag extends Document {

   public function transform() {
     return date($this->getAttribute('format'));
   }

}
</gen:highlight>
<p>
   Within a template, the tag can be used as follows:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="examples::tags::pres"
   class="HourDisplayTag"
   prefix="current"
   name="date"
/&gt;
<current:date format="H:i:s" />
</gen:highlight>
<div class="hint">
   The constructor of the <em>Document</em> class defines a standard set of known tags that are not necessary in the
   current implementation. Hence, the constructor may be overwritten by your implementation to optimize memory
   consumption. This can be done because the tag has no need for further children.
</div>

<h4 id="Chapter-5-2-Complex-tag"><a href="#Chapter-5-2-Complex-tag">5.2. Complex tag</a></h4>
<p>
   A &quot;complex&quot; tag is a tag that defines further child nodes - not limited in their hierarchy.
</p>
<p>
   As an example we take the image gallery tag from <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a>. This tag
   defines static content that includes a headline and an introduction text. The content of the gallery itself is
   - represented by the <em>&lt;img:gallery /&gt;</em> tag - is created by the <em>&lt;gallery:datasource /&gt;</em> tag
   using a <em>Content-Providers</em>.
</p>
<div class="hint">
   Please note that the structure of this example has been chosen to depict essential attributes of the APF tag
   implementation. It is not a rule of how your tags and applications must be structured. To realize this particular
   use case, you may also define the content provider within the gallery tag using attributes and use a further formatting
   element to generate the output (e.g. using a mechanism like the <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator</int:link>
   tag).
</div>

<h5 id="Chapter-5-2-1-Basis"><a href="#Chapter-5-2-1-Basis">5.2.1. Basis</a></h5>
<p>
   The basic structure of the tag is as follows:
</p>
<gen:highlight type="php">
import('examples::tags::pres', 'GalleryDataSourceTag');

class GalleryTag extends Document {

   public function __construct() {
      $this->__TagLibs[] = new TagLib(
         'examples::tags::pres',
         'GalleryDataSourceTag',
         'gallery',
         'datasource'
      );
   }

   ...

}
</gen:highlight>
<p>
   Within the constructor the <em>&lt;gallery:datasource /&gt;</em> tag is published to the parser. In order to let the
   APF parser create child nodes, you need to include the implementation via <em>import()</em>.
</p>

<h5 id="Chapter-5-2-2-Configuration-of-the-content-provider"><a href="#Chapter-5-2-2-Configuration-of-the-content-provider">5.2.2. Configuration of the content provider</a></h5>
<p>
   Let us now turn to the configuration of the <em>Content-Providers</em>. To be able to configure the provider freely,
   the <em>&lt;img:gallery /&gt;</em> tag is added a private member plus getter and setter. This enables the
   <em>&lt;gallery:datasource /&gt;</em> tag to apply the instance of the provider:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   private $contentProvider;

   ...

   public function setContentProvider(ImageGalleryContentProvider $provider) {
      $this->contentProvider = $provider;
   }

   ...

}
</gen:highlight>
<p>
   The provider itself is defined by the following interface:
</p>
<gen:highlight type="php">
interface ImageGalleryContentProvider {
   /**
    * @return GalleryImage[]
    */
   public function getImages();
}

class GalleryImage {

   private $title;
   private $description;
   private $imageUrl;

   public function __construct($title, $description, $imageUrl) {
      $this->title = $title;
      $this->description = $description;
      $this->imageUrl = $imageUrl;
   }

   public function getDescription() {
      return $this->description;
   }

   public function getImageUrl() {
      return $this->imageUrl;
   }

   public function getTitle() {
     return $this->title;
   }

}
</gen:highlight>
<p>
   Within our current sample the <em>&lt;gallery:datasource /&gt;</em> tag creates the desired provider and passes it
   to the <em>GalleryTag</em>. This functionality can be implemented within the <em>onAfterAppend()</em> method, because
   at time of execution of this method the father node is initialized:
</p>
<gen:highlight type="php">
class GalleryDataSourceTag extends Document {

   public function __construct() {
   }

   public function onAfterAppend() {
      $provider = &$this->getServiceObject(
         $this->getAttribute('namespace'),
         $this->getAttribute('class')
      );
      /* @var $parent GalleryTag */
      $parent = &$this->getParentObject();
      $parent->setContentProvider($provider);
   }

   public function transform() {
      return '';
   }

}
</gen:highlight>
<p>
   Since the <em>GalleryDataSourceTag</em> is not expecting further child nodes the constructor of the <em>Document</em>
   class has been overwritten with empty content. Within the <em>onAfterAppend()</em> method the desired provider is
   created using the <int:link pageid="107" anchor="Chapter-3-2-1-ServiceManager-Simple-services">ServiceManager</int:link>
   to automatically pass context and language to the instance. After that, the father element of the tag - an instance
   of the <em>GalleryTag</em> class as stated by the IDE type hint - is injected the provider.
</p>
<p>
   The <em>transform()</em> method ensures, that no additional children are transformed and that the tag generates no
   output. This is not necessary here.
</p>

<h5 id="Chapter-5-2-4-Parsing-the-GalleryDataSourceTag"><a href="#Chapter-5-2-4-Parsing-the-GalleryDataSourceTag">5.2.4. Parsing the GalleryDataSourceTag</a></h5>
<p>
   In order to enable the <em>GalleryDataSourceTag</em> to create and inject the gallery content provider the
   <em>GalleryTag</em> has to publish the tag to be caught and executed by the page controller. To create an instance
   of the tag, the page controller brings the <em>__extractTagLibTags()</em> method inherited from the <em>Document</em>
   class.
</p>
<p>
   The point in time when this method is called is subjected to your decision. To ensure proper functionality, please
   keep the
   <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram">Activity diagram of the page controller</int:link>
   in mind to choose the correct point in time. In our use case it is important to create and inject the provider
   <em>before</em> creation of the gallery's content. Hence, there are three possibilities:
</p>
<ul>
   <li>Within the <em>onParseTime()</em> method.</li>
   <li>Within the <em>onAfterAppend()</em> method.</li>
   <li>At the beginning of the <em>transform()</em> method.</li>
</ul>
<p>
   It is recommended to use the <em>onParseTime()</em> method to analyze child node structures to give other nodes the
   chance to be created in correct chronological order, too.
</p>
<p>
   In order to create and execute the <em>GalleryDataSourceTag</em> you might want to use the following code:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   ...

}
</gen:highlight>
<p>
   Everything else is done by the APF parser according to the known tags.
</p>

<h5 id="Chapter-5-2-3-Output-creation"><a href="#Chapter-5-2-3-Output-creation">5.2.3. Output creation</a></h5>
<p>
   The output of the image gallery is created within the <em>transform()</em> function that is called by the page
   controller during transformation of the tree. This method is intended to arrange the images thaat are delivered by
   the provider.
</p>
<p>
   Assuming that all images should be rendered as an unordered list including image and description the
   <em>transform()</em> method looks like this:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
            . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
            . '<p>' . $image->getDescription() . '</p>'
            . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);
   }

}
</gen:highlight>
<p>
   The above implementation displays the images as list elements below the static content contained in the
   <em>&lt;img:gallery /&gt;</em> tag.
</p>
<div class="hint">
   In case static content is not allowed within a custom tag it may be overwritten by <em>setContent()</em>. You can
   overwrite static content with content that has been generated dynamically during a <em>transform()</em> call.
</div>
<div class="hint">
   In order to place the content of your tag correctly during transformation the <em>__extractTagLibTags()</em> method
   generates place holders such as <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Thereby,
   <em>{OBJECT_ID}</em> contains the value of the class member <em>$this->__ObjectID</em> and the array offset the child
   node is stored in (<em>$this->__Children</em>). This value can be used to (re)place the content of the child tag
   within custom <em>transform()</em> implementations.
</div>
<p>
   In case of the <em>&lt;img:gallery /&gt;</em> tag the children should not generate output themselves because this is
   done by the <em>GalleryDataSourceTag::transform()</em> function. Since the APF parser always places place holders to
   be able to position the content during transformation, these place holders must be removed anyway. This can be done
   by the following code:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
         . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
         . '<p>' . $image->getDescription() . '</p>'
         . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);

      foreach ($this->__Children as $objectId => $DUMMY) {
         $this->__Content = str_replace(
            '<' . $objectId . ' />',
            $this->__Children[$objectId]->transform(),
            $this->__Content
         );
      }
   }

}
</gen:highlight>

<h4 id="Chapter-5-3-Document-API"><a href="#Chapter-5-3-Document-API">5.3. Document API</a></h4>
<p>
   Implementing tag logic the APF provides several methods. They include parsing tag structures, accessing the DOM tree
   and manipulating or reading tag information. These are:
</p>
<ul>
   <li>
      <strong>__extractTagLibTags()</strong>:
      Analyzes known child tags and creates the respective DOM tree.
   </li>
   <li>
      <strong>getParentObject()</strong>:
      Returns the instance of the father node within the DOM tree. In case no father is present, <em>null</em> is
      returned.
   </li>
   <li>
      <strong>setParentObject()</strong>:
      Injects the father node of the current item.
   </li>
   <li>
      <strong>getChildren()</strong>:
      Returns the list of all children. In case no child nodes are available an empty list is returned.
   </li>
   <li>
      <strong>getContent()</strong>:
      Returns the content of the DOM element invoked.
   </li>
   <li>
      <strong>setContent()</strong>:
      Writes the content of the DOM element.
   </li>
   <li>
      <strong>getChildNode()</strong>:
      Returns a child node specified by an applied selector.
   </li>
   <li>
      <strong>getChildNodes()</strong>:
      Returns several child nodes specified by an applied selector.
   </li>
   <li>
      <strong>getAttribute()</strong>:
      Returns the value of an attribute.
   </li>
   <li>
      <strong>setAttribute()</strong>:
      Defines the value of an attribute.
   </li>
   <li>
      <strong>getAttributes()</strong>:
      Returns the list of attributes.
   </li>
   <li>
      <strong>getAttributesAsString()</strong>:
      Generates an XML string representation of the given attributes using an optional whitelist.
   </li>
</ul>
<p>
   Further methods of the <em>Document</em> class or the base class of your current tag can be taken from the
   <int:link pageid="002"/>.
</p>

<h3 id="Chapter-6-Tag-hierarchies"><a href="#Chapter-6-Tag-hierarchies">6. Tag hierarchies</a></h3>
<p>
   For performance and consistency reasons the APF parser contains several restrictions compared to a &quot;real&quot;
   XML parser. Thease are:
</p>
<ul>
   <li>Tag attributes must be separated by blanks. Tab signs are not allowed.</li>
   <li>The content of tag attributes must be delimited by double quotes.</li>
   <li>
      Tag hierarchies are only resolved correctly in case a tag - specifies by it's prefix and name - is only known to
      one hierarchy level. This requires registering a tag implementation within different levels to be registered with
      a unique couple of prefix and name.
      <div class="warn">
         In case you intend to use a tag both at the top hierarchy level within a template file and at a deeper level
         the parser will not assign the tags correct. Example:
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="..."
   class="FooBarTag"
   prefix="foo"
   name="tag"
/&gt;
&lt;foo:bar id="..."/&gt;
&lt;html:template name="..."&gt;
   &lt;template:addtaglib
      namespace="..."
      class="FooBarTag"
      prefix="foo"
      name="tag"
   /&gt;
   &lt;foo:bar id="..."/&gt;
&lt;/html:template&gt;
</gen:highlight>
         Doing so, the parser will add the instance of te <em>&lt;foo:bar /&gt;</em> to the top level hierarchy. Within
         the <em>&lt;html:template /&gt;</em> tag no <em>&lt;foo:bar /&gt;</em> instance is assigned. But - due to the
         structure of the parser - the place holder is there and during transformation errors or unexpected behaviour
         will come up.
      </div>
   </li>
   <li>
      Only APF tags can be processed. Simple HTML tags are not covered and it may be necessary to provide wrapper
      implementations for an abstraction purpose.
   </li>
</ul>

<h4 id="Chapter-6-1-Simple-hierarchies"><a href="#Chapter-6-1-Simple-hierarchies">6.1. Simple hierarchies</a></h4>
<p>
   Having simple tag hierarchies, tags appear only once within different levels. There the parser restrictions only
   apply to the node that is currently processed - merely the current template file.
</p>
<p>
   As an example, let us take the following snippet that includes a further template:
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="..." /&gt;
&lt;core:importdesign
   namespace=""
   template="template2"
/&gt;
</gen:highlight>
<p>
   The template file <em>template2</em> - it represents the next hierarchy level within the DOM tree - contains the
   subsequent content:
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="" /&gt;
&lt;html:template name="..."&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Since both <em>&lt;html:placeholder /&gt;</em> tags are located within different template files they are correctly
   assigned to the appropriate level.
</p>
<div class="hint">
   Please note, that APF tags can only be processed if they are known to the APF parser. If you are using custom tags,
   you have to publish them using the <em>&lt;*:addtaglib /&gt;</em> tag.
</div>
<div class="warn">
   Publishing a custom tag using the <em>&lt;*:addtaglib /&gt;</em> tag only affects the current DOM node! In case you
   intend to re-use the tag within different hierarchy levels the tag must be published in all levels to use. Please
   note the hints on this within the next chapter.
</div>

<h4 id="Chapter-6-2-Complex-hierarchies"><a href="#Chapter-6-2-Complex-hierarchies">6.2. Complex hierarchies</a></h4>
<p>
   As an example for complex tag hierarchies we are using a tag that outputs translations identified by a unique key and
   the current language. The tag should be used directly within a template file, within a <em>&lt;html:template /&gt;</em>
   tag und within a custom tag.
</p>
<p>
   As a basis for the further discussion, the following template will be used:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="..."
   class="GetTextTag"
   prefix="html"
   name="text"
/&gt;
&lt;html:text key="..." /&gt;

&lt;html:template name=""&gt;
   &lt;core:addtaglib
         namespace="..."
         class="GetTextTag"
         prefix="template"
         name="text"
      /&gt;
   &lt;template:text key="..." /&gt;
&lt;/html:template&gt;

&lt;user:control-panel&gt;
   &lt;control-panel:text key="..." /&gt;
   &lt;control-panel:navi /&gt;
&lt;/user:control-panel&gt;
</gen:highlight>
<p>
   The <em>GetTextTag</em> is published using a <em>&lt;*:addtaglib /&gt;</em> tag within the first hierarchy level and
   within the <em>&lt;html:template /&gt;</em> tag. The <em>&lt;user:control-panel /&gt;</em> tag already knows it by
   the implementation.
</p>
<div class="warn">
   Due to the restrictions of the APF parser described in <a href="#Chapter-6-Tag-hierarchies">chapter 6</a> it is
   necessary to define a unique prefix using the <em>&lt;*:text /&gt;</em> tag within a <em>&lt;html:template /&gt;</em>
   and <em>&lt;user:control-panel /&gt;</em> tag. In case prefix and name of the <em>&lt;*:text /&gt;</em> tag are
   equal within all levels, the parser will assign the tags to the level the tag is published in first - in this case
   the first one.
</div>
<div class="hint">
   Because of the above reasons and to express the membership of a tag to a certain hierarchy it is recommended to
   choose prefix and name according to the hierarchy level. Within the above example the child tags of the
   <em>&lt;user:control-panel /&gt;</em> tag are using the <em>control-panel</em> prefix. For deeper structures the
   following example can be taken as a basis:
<gen:highlight type="apf-xml">
&lt;shop:basket&gt;
   &lt;basket:title /&gt;
   &lt;basket:products&gt;
      &lt;products:listing /&gt;
      &lt;products:sum /&gt;
   &lt;/basket:products&gt;
&lt;/shop:basket&gt;
</gen:highlight>
   Further notes can be found in the forum under
   <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=4&amp;t=38">Schachtelung TagLibs</a>
   (German).
</div>

<h3 id="Chapter-7-Examples"><a href="#Chapter-7-Examples">7. Examples</a></h3>
<p>
   This chapter contains implementation examples for tags that you may use as a basis for your day-to-day work or as a
   coding guideline. As a rule of thumb, please note:
</p>
<div class="hint">
   Implementing a tag is only necessary in case you are not able to realize your requirements with a
   <int:link pageid="047"/> - including all <int:link pageid="046" /> - and a <int:link pageid="006" /> (e.g. manipulation
   of the DOM tree). Moreover, it is recommended to write tags for functionality that is used within several templates
   or multiple projects especially to support code de-duplication and avoid huge inheritance structures of document
   controllers.
</div>

<h4 id="Chapter-7-1-Simple-tag-with-attributes"><a href="#Chapter-7-1-Simple-tag-with-attributes">7.1. Simple tag with attributes</a></h4>
<p>
   This chapter deals with the implementation of the <em>&lt;html:text /&gt;</em> tag from
   <a href="#Chapter-6-2-Complex-hierarchies">section 6.2</a>. The tag outputs a language dependent text identified by
   the applied key. Example:
</p>
<gen:highlight type="apf-xml">
&lt;html:text key="log-in.mousover.text" /&gt;
</gen:highlight>
<p>
   The implementation of the tag contains the processing of the attribute and the output of the text at transformation
   time. This can be done as follows:
</p>
<gen:highlight type="php">
class TranslationTextTag extends Document {

   public function transform() {
     return gettext($this->getAttribute('key'));
   }

}
</gen:highlight>
<p>
   In case attributes should be included in the output generation you may want to use the
   <em>getAttributesAsString()</em> method. As an example, let us take a tag that creates an image tag from an image
   of an external asset management referred to by an external id:
</p>
<gen:highlight type="apf-xml">
&lt;html:img
   key="IMG-12345"
   width="100"
   height="120"
   alt="This image contains a red car"
/&gt;
</gen:highlight>
<p>
   The implementation may look like this:
</p>
<gen:highlight type="php">
class MAMImageTag extends Document {

   public function transform() {

      $width = $this->getAttribute('width', '50');
      $height = $this->getAttribute('height', '50');
      $key = $this->getAttribute('key');

      $whiteList = array(
         'alt',
         'height',
         'width',
         'id',
         'style',
         'title'
      );

      return '<img src="'
            . $this->getImageUrl($key, $width, $height) . '" '
            . $this->getAttributesAsString($this->getAttributes(), $whiteList)
            . ' />';
   }

   private function getImageUrl($key, $width, $height) {
     ...
   }

}
</gen:highlight>
<p>
   Within the above code box <em>getAttribute()</em> is used to read the values of the desired tag attributes. Since
   some of the values should be re-used for output generation a white list - in this case a list of XHTML or HTML5
   compatible attributes - is passed to the <em>getAttributesAsString()</em> method together with the attributes of the
   tag. The result of the tag is then an image tag that can be formatted using the <em>id</em>, <em>style</em>, and
   <em>class</em> (HTML) attributes.
</p>

<h4 id="Chapter-7-2-Simple-tag-with-content"><a href="#Chapter-7-2-Simple-tag-with-content">7.2. Simple tag with content</a></h4>
<p>
   Besides the attributes a tag can define simple or complex content. As an implementation sample for this chapter, we
   are using the following tag definition:
</p>
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
<p>
   As the tag's output we expect an e-mail address that is encoded with HTML entities to protect it against bots or
   spiders. To encode the e-mail address, the content of the tag must be read during transformation. The implementation
   is as follows:
</p>
<gen:highlight type="php">
import('tools::string', 'StringAssistant');

class EntityEncodeTag extends Document {

   public function transform() {
      return StringAssistant::encodeCharactersToHTML($this->getContent());
   }

}
</gen:highlight>
<p>
   Using the <em>getContent()</em> function you can access the content of the tag. The content - in this case an e-mail
   address - is then encoded to HTML entities using the <em>StringAssistant</em>.
</p>

<h4 id="Chapter-7-3-Accessing-the-DOM-tree"><a href="#Chapter-7-3-Accessing-the-DOM-tree">7.3. Accessing the DOM tree</a></h4>
<p>
   As noted in <a href="#Chapter-1-Introduction">chapter 1</a> the <int:link pageid="098" /> creates a DOM tree from the
   template files and the tags contained there. You may compare this behaviour - except the way of creation - to a
   browser that creates a DOM tree from the received HTML document to create a graphical representation.
</p>
<p>
   Since tags and <int:link pageid="006" /> are part of the tree you can access all surrounding nodes. To do so, you
   may use the following methods:
</p>
<ul>
   <li><em>getParentObject()</em></li>
   <li><em>getChildren()</em></li>
</ul>
<p>
   Within a tag you can directly use those methods to traverse surrounding elements, in case of a <int:link pageid="006" />
   you need to refer to the current DOM node using the <em>getDocument()</em> function. Having the current document you
   can proceed as noted before.
</p>
<p>
   As an example for this chapter, please note the following template:
</p>
<gen:highlight type="apf-xml">
&lt;html:template name="test1"&gt;
   ...
&lt;/html:template&gt;
&lt;html:template name="test2"&gt;
   &lt;template:addtaglib
      namespace="..."
      class="TemplateNameDisplayTag"
      prefix="template"
      name="display-name"
   /&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   The <em>TemplateNameDisplayTag</em> is intended to display the name of all templates, that are located on the same
   level as the tag's father. This can be done with the subsequent implementation:
</p>
<gen:highlight type="php">
class TemplateNameDisplayTag extends Document {
   public function transform() {
      $template = &$this->getParentObject();
      $grandFather = &$template->getParentObject();

      $nodes = $grandFather->getChildren();

      $buffer = '<ul>';
      foreach ($nodes as $objectId => $DUMMY) {
         $buffer .= '<li>' . $nodes[$objectId]->getAttribute('name') . '</li>';
      }

      return $buffer . '</ul>';
   }
}
</gen:highlight>
<p>
   Please refer to
   <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=1152">Placeholder über Taglib füllen</a>
   (German) for further examples.
</p>

<h4 id="Chapter-7-4-Complex-tag-with-attributes-and-content"><a href="#Chapter-7-4-Complex-tag-with-attributes-and-content">7.4. Complex tag with attributes and content</a></h4>
<p>
   The previous chapters dealt with accessing attributes, output of attributes and the access and processing of tag
   content. Now, we will have a look at a more complex structure that includes deeper hierarchies, tag content, and
   attributes in their tag logic.
</p>
<p>
   As an example the following template is used as a basis. It displays navigation nodes of type
   <em>NavigationNode</em>:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="extensions::navigation::pres::tags"
   class="NavigationNodeTag"
   prefix="navi"
   name="template"
/&gt;
&lt;navi:template id="main-navi"&gt;&lt;!-- NavigationNodeTag --&gt;
   &lt;navi:item status="active"&gt;&lt;!-- NavigationItemTag --&gt;
      &lt;li class="active"&gt;
         &lt;item:content/&gt;&lt;!-- ItemTemplateContentTag --&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;
   &lt;navi:item status="inactive"&gt;
      &lt;li&gt;
         &lt;item:content/&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;

   &lt;ul id="main-navigation"&gt;
      &lt;navi:content/&gt;&lt;!-- NavigationContentTag --&gt;
   &lt;/ul&gt;
&lt;/navi:template&gt;
</gen:highlight>
<p>
   The tag is initialized/filled within a <int:link pageid="006" /> and displays a list of child elements of the applied
   navigation node according to the defined formatting. Thereby, the <em>&lt;navi:item /&gt;</em> tags describe the
   active and inactive status of the navigation nodes and the <em>&lt;navi:content/&gt;</em> let's you place the output
   into the desired HTML skeleton. <em>&lt;item:content/&gt;</em> places the output of a dedicated navigation node and
   allows you to add custom HTML. To easily remember the tag hierarchy and the corresponding tags, the above template
   contains the tag implementation class names as HTML comment.
</p>
<p>
   To fill the <em>&lt;navi:template /&gt;</em> tag within a template the following controller can be used:
</p>
<gen:highlight type="php">
import('extensions::navigation::biz', 'SimpleNavigationNode');

class NavigationTagExampleController extends base_controller {
   public function transformContent() {
      $root = new SimpleNavigationNode(null, null, null);
      $levelOne = new SimpleNavigationNode('Level 1', '#');

      $root->setChildren(array(
         clone $levelOne->setInactive(),
         clone $levelOne->setActive(),
         clone $levelOne->setInactive()
      ));

      $navi = $this->getDocument()->getChildNode('id', 'main-navi', 'NavigationNodeTag');
      $navi->setNode($root);
   }
}
</gen:highlight>
<p>
   The subsequent code box contains the tag implementation:
</p>
<gen:highlight type="php">
interface NavigationNode {
   public function getLabel();
   public function getUrl();
   public function getParent();
   public function getChildren();
}

class SimpleNavigationNode implements NavigationNode {

   private $label;
   private $url;
   private $isActive = false;
   private $parent;
   private $children = array();

   public function __construct($label, $url) {
      $this->label = $label;
      $this->url = $url;
   }

   public function getLabel() {
      return $this->label;
   }

   public function getUrl() {
      return $this->url;
   }

   public function isActive() {
      return $this->isActive;
   }

   public function setActive() {
      $this->isActive = true;
      return $this;
   }

   public function setInactive() {
      $this->isActive = false;
      return $this;
   }

   public function getParent() {
      return $this->parent;
   }

   public function getChildren() {
      return $this->children;
   }

   public function setParent(NavigationNode $node) {
      $this->parent = $node;
   }

   public function setChildren(array $nodes) {
      $this->children = $nodes;
   }

}

class NavigationNodeTag extends Document {

   private $node;

   public function __construct() {
      $this->__TagLibs = array(
         new TagLib('extensions::navigation::pres::tags', 'NavigationItemTag', 'navi', 'item'),
         new TagLib('extensions::navigation::pres::tags', 'NavigationContentTag', 'navi', 'content')
      );
   }

   public function setNode(NavigationNode $node) {
      $this->node = $node;
   }

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   public function transform() {

      $buffer = '';

      $navigationNodes = $this->node->getChildren();
      if (count($navigationNodes) > 0) {
         foreach ($navigationNodes as $node) {
            $buffer .= $this
               ->getTemplate($node->isActive() ? 'active' : 'inactive')
               ->getOutput($node);
         }
      }

      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof NavigationContentTag) {
            // fill the navi:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $buffer, $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }

      return $content;
   }

   private function getTemplate($status) {
      return $this->getChildNode('status', $status, 'NavigationItemTag');
   }

}

class NavigationItemTag extends Document {

   public function __construct() {
      $this->__TagLibs = array(
         new TagLib('extensions::navigation::pres::tags', 'ItemTemplateContentTag', 'item', 'content')
      );
   }

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   public function getOutput(NavigationNode $node) {
      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof ItemTemplateContentTag) {
            // fill the item:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $children[$objectId]->setNode($node)->transform(), $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }
      return $content;
   }

   public function transform() {
      return '';
   }

}

class ItemTemplateContentTag extends Document {

   private $node;

   public function setNode(NavigationNode $node) {
      $this->node = $node;
      return $this;
   }

   public function transform() {
      if ($this->node === null) {
         return '';
      }
      return '<a href="' . $this->node->getUrl() . '">' . $this->node->getLabel() . '</a>';
   }

}

class NavigationContentTag extends Document {
}
</gen:highlight>
<div class="warn">
   The above code sample is intended to show the APF's capabilities and is no reference implementation for navigation
   creation.
</div>

<h3 id="Chapter-8-Further-links"><a href="#Chapter-8-Further-links">8. Further links</a></h3>
<p>
   In case you need further information on writing tags, please refer to the following forum threads:
</p>
<ul>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=1126">TagLib unterschiedliche Zustände</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=982">Taglib innerhalb eines Templates</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=827">Taglib der Template rundherum läd</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=540">Taglibs</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=505">Mehrere Checkboxes taglib aus DB holen und ausgeben</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=456">Taglib-Call innerhalb eines Taglib-Call</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=191">transform() von eigenem taglib nicht ausgeführt</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=177">Menü taglib-modul</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=122">Performance TagLibs</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=37">Taglibs vs. Templates</a> (German)</li>
</ul>
<p>
   The APF wiki contains the following pages on APF tags:
</p>
<ul>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/de/All-in-one_Include-Tag">All-in-one Include-Tag</a> (German)</li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/de/Timing-Modell_des_Page-Controller">Timing-Modell des Page-Controller</a> (German)</li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/de/WYSIWYG_%2B_APF-Formulare">WYSIWYG + APF-Formulare</a> (German)</li>
</ul>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_147" />