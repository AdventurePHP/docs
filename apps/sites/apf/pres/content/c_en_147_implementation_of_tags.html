<doku:title parent="100" tags="taglib,taglibs,tag,parser" title="Implementation of tags" urlname="Implementation-of-tags">
   This chapter describes the concepts and the usage of tags/taglibs within the APF.
</doku:title>
<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   This chapter focuses on APF tags (a.k.a. Taglibs). It describes the concepts and supports development of custom tags.
</p>
<p>
   The <int:link pageid="098"/> is based on the same-name pattern and is one of the central elements of the APF. It
   enables you - as a developer - to inject custom functionality for the creation and transformation of the APF DOM tree.
   Thus, tags are not only a basis for the APF's HMVC concept but can be used to enhance it easily.
</p>
<p>
   Further, tags may be used to re-use functionality encapsulated within a tag within several projects. Since APF
   templates only process tags and no PHP code un-controlled spread of logic is prevented automatically. This means, that
   view logic can only reside within tags and controllers.
</p>

<h4 id="Chapter-1-1-Page-controller"><a href="#Chapter-1-1-Page-controller">1.1. Page controller</a></h4>
<p>
   The <int:link pageid="098"/> is responsible for creating and transforming of the internal template structure. For this
   reason he provides a tag API that parses tags - following a dedicated timing model -, creates documents within the
   DOM tree and finally creates the HTML output. Different formats such as XML can be produced, too. The parser itself
   is no &quot;real&quot; XML parser but resolves explicitly and self closing tags as well as unlimited tag hierarchies.
</p>
<div class="warn">
   Please note the restrictions of the APF parser within the <a href="#Chapter-6-Tag-hierarchies">Tag-Hierarchie</a>
   chapter.
</div>
<p>
   The <int:link pageid="046"/> shipped with the APF provide a series of standard functionality such as inclusion of
   further templates, definition of reusable template fragments and inclusion of custom tags.
</p>

<h4 id="Chapter-1-2-XML-parser"><a href="#Chapter-1-2-XML-parser">1.2. XML parser</a></h4>
<p>
   The <em>XMLParser</em> used by the page controller during creation of the <em>Document</em> instances is intended for
   analyzing tag definitions.
</p>
<div class="warn">
   Due to performance reasonsn, the <em>XMLParser</em> only processes tag attributes that are separated by blanks.
   Further, values must be delimited by double-quotes.
</div>

<h3 id="Chapter-2-Definition-of-a-tag"><a href="#Chapter-2-Definition-of-a-tag">2. Definition of a tag</a></h3>
<p>
   An APF tag is defined by the following parts:
</p>
<ul>
   <li>
      <strong>Prefix</strong>: the <em>prefix</em> is commonly used to group tags (e.g. <em>core</em> for tags that are
      shipped with the APF). This part is similar to XML namespaces.
   </li>
   <li>
      <strong>Name</strong>: the <em>Name</em> can be considered as declaration. This part is similar to XML tag names.
   </li>
   <li>
      <strong>Attributes</strong>: the attributes of a tag can be used for configuration. Attribute vales must not
      contain further tags.
   </li>
   <li>
      <strong>Content</strong>: the content area can contain further tags or simple text. The APF parser resolves tags
      defined there and adds them to the current hierarchy level. Simple text is also available within the tag for
      further usage.
   </li>
</ul>
<p>
   The tag contained in the subsequent code box can be used to print the current date to the template it is contained in:
</p>
<gen:highlight type="apf-xml">
<current:date format="H:i" />
</gen:highlight>
<p>
   Within this declaration, <em>current</em> is the prefix, <em>date</em> is the name, and the attribute <em>format</em>
   contains the output format. This tag does not define any content.
</p>
<p>
   To display an image gallery the following tag definition can be used:
</p>
<gen:highlight type="apf-xml">
<img:gallery>
   <h3>My holiday in 2012</h3>
   <p>
      These pictures are from my holiday in 2012:
   </p>
   <gallery:datasource
      namspace="..."
      class="..."
   />
</img:gallery>
</gen:highlight>
<p>
   In the above example the <em>&lt;img:gallery /&gt;</em> tag contains static HTML - that is used for formatting later
   on - as well as a further tag that defines the data source (z.B. database). Using this tag it must be made known to
   the APF parser.
</p>

<h3 id="Chapter-3-DOM-structure"><a href="#Chapter-3-DOM-structure">3. DOM structure</a></h3>
<p>
   As mentioned in <a href="#Chapter-1-1-Page-controller">chapter 2</a> the <int:link pageid="098"/> creates a DOM tree
   out of the tag structure within the template files. This tree is similar to a browser's DOM tree that creates a memory
   reference out of HTML tags.
</p>
<p>
   The difference between the DOM tree of a browser and the APF implementation is that each node provides logic for
   transformation and displaying that the page controller uses during the transformation phase.
   Details on the timing model of the page controller can be found <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram">here</int:link>.
</p>
<p>
   Each tag - or from a particular point in time it's instance - passes the same life cycle. At the beginning, the
   structure of the tag is analyzed, then it's substance (attributes and content). After that, a DOM node instance is
   created regarding the tag definition and the substance the <em>XMLParser</em> has extracted from the template.
</p>
<div class="hint">
   Please note that the page controller only processes tags that are known within the current node. For this reason,
   custom tags must be published to the current node. You can do so using the <em>&lt;core:addtaglib /&gt;</em> tag or
   adding
<gen:highlight type="php">
$this->__TagLibs[] = new TagLib(...);
</gen:highlight>
   to the constructor of your custom tag. Using the <em>&lt;core:addtaglib /&gt;</em> tag is necessary if you intend to
   add a custom tag within a template file, the PHP code sample can be used within custom tags to publish further
   hierarchies to the APF parser.
</div>
<p>
   Publishing your tag you need to specify <em>prefix</em> and <em>name</em> as well as <em>namespace</em> and
   <em>class name</em> of the tag implementation. Thereby, you can re-use one implementation in different hierarchy
   levels or projects using a different <em>prefix</em> and <em>name</em> declaration. The tag declaration class -
   <em>TagLib</em> - has the following signature (condensed):
</p>
<gen:highlight type="php">
final class TagLib {

   private $namespace;
   private $class;
   private $prefix;
   private $name;

   public function __construct($namespace, $class, $prefix, $name) {
   }

}
</gen:highlight>
<p>
   Details on tag hierarchies can be found in the <a href="#Chapter-6-Tag-hierarchies">tag hierarchies</a> chapter.
</p>

<h3 id="Chapter-4-Class-structure-of-tags"><a href="#Chapter-4-Class-structure-of-tags">4. Class structure of tags</a></h3>
<p>
   The structure of tags is defined by the <em>Document</em> class. This class is the mother of all tag implementations
   of the APF. It defines several methods that are used within the timing model of the page controller for different
   reasons.
</p>
<p>
   Please note the following signature (condensed):
</p>
<gen:highlight type="php">
class Document extends APFObject {

   protected $__ObjectID = null;
   protected $__ParentObject = null;
   protected $__Children = array();
   protected $__Content;
   protected $__TagLibs = array();

   public function __construct() {
   }

   public function onParseTime() {
   }

   public function onAfterAppend() {
   }

   public function transform() {
   }

}
</gen:highlight>
<p>
   The items from the code box have the following meaning:
</p>
<ul>
   <li>
      The field <em>__ObjectID</em> stores the internal unique object id the object receives from the APF parser during
      creation. The value is e.g. used for <int:link pageid="004"/> tags or to refer a DOM element by it's unique
      identifier.
   </li>
   <li>
      <em>__ParentObject</em> refers to the father object within the DOM tree. This reference can be used to navigate
      the DOM tree. The root node does not have a father.
   </li>
   <li>
      The list of <em>__Children</em> contains all child nodes of the current DOM node. This list can be used to navigate
      the DOM tree. In case a DOM node does not have children, the list is empty.
   </li>
   <li>
      The <em>__Content</em> field contains the textual content of the node as well as place holder tags created by the
      page controller during DOM tree creation in order to guarantee correct assembling of the HTML source code.
   </li>
   <li>
      The <em>__Attributes</em> list - inherited from <em>APFObject</em> - contains a list of tag attributes and their
      respective values. In case a tag defines no attributes the list is empty.
   </li>
   <li>
      The <em>__TagLibs</em> list contains all known tags for the current node. As mentioned in the previous chapter,
      the APF parser only processes tags that are known within a particular hierarchy level or within a DOM element
      respectively. Which tags are known and which are not is thus defined by this list.
      <div class="hint">
         The <em>__TagLibs</em> list can be used in custom tag implementations to publish new tags or to remove some or
         all of them. Since manipulation of this list directly influences the parser, please be careful!
      </div>
   </li>
   <li>
      The constructor of the tag class is callen when creating the tag instance. But the parser does not apply arguments.
      It can be used to add known tags to the current hierarchy or to initialize default values.
      <div class="warn">
         On execution time of the constructor neither tag attributes nor content has been initialized within the tag.
         Further, context and language are not available at this time, too.
      </div>
   </li>
   <li>
      After the tag has been parsed, the <em>onParseTime()</em> is called. At this particular point in time, the
      attributes and the content of the tag are available. Moreover, context and language are initialized. This method
      can be used the initialize the tag with the information available or to analyze the content of the tag (e.g. parse
      child tags).
   </li>
   <li>
      After the node has been added to the DOM tree - this means that the father node and the children are initialized -
      the <em>onAfterAppend()</em> is called. Within this method you may execute logic that affects father and child
      nodes.
   </li>
   <li>
      During transformation, the page controller calls the <em>transform()</em> method of your tag. Please place all
      logic needed for creating the appropriate HTML source code within this method. Tags that are intended for
      configuration or initialization often generate no output (e.g. the <em>&lt;core:addtaglib /&gt;</em> tag). However,
      it is up to you how your tag acts.
      <div class="hint">
         In case the <em>transform()</em> method is overwritten by your custom tag, you have to take care of the
         transformation of the child nodes by yourself. This may be done as follows:
<gen:highlight type="php">
foreach($this->__Children as $objectId => $DUMMY){
   $this->__Content = str_replace(
      '<'.$objectId.' />',
      $this->__Children[$objectId]->transform(),
      $this->__Content
   );
}
</gen:highlight>
         You can use the snippet above in case the parser function <em>__extractTagLibTags()</em> has been called within
         <em>onParseTime()</em> or <em>onAfterAppend()</em>. Further notes can be taken from the forum post
         <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a> (German).
      </div>
   </li>
</ul>

<h3 id="Chapter-5-Implementation"><a href="#Chapter-5-Implementation">5. Implementation</a></h3>

<h4 id="Chapter-5-1-Simple-tag"><a href="#Chapter-5-1-Simple-tag">5.1. Simple tag</a></h4>
<p>
   This chapter deals with a simple tag. &quot;Simple&quot; in this case means that the tag does a dedicated job but
   creates no extra hierarchy - precisely he has no children.
</p>
<p>
   As an example we use the tag from <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a> that displays the current
   time. The functionality of the tag is just to return the current time using the applied format at transformation time.
   There is no dependency to other tags within the DOM tree and there is no need for further initialization. The source
   code of the tag might be as follows (namespace: <em>examples::tags::pres</em>):
</p>
<gen:highlight type="php">
class HourDisplayTag extends Document {

   public function transform() {
     return date($this->getAttribute('format'));
   }

}
</gen:highlight>
<p>
   Within a template, the tag can be used as follows:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="examples::tags::pres"
   class="HourDisplayTag"
   prefix="current"
   name="date"
/&gt;
<current:date format="H:i:s" />
</gen:highlight>
<div class="hint">
   The constructor of the <em>Document</em> class defines a standard set of known tags that are not necessary in the
   current implementation. Hence, the constructor may be overwritten by your implementation to optimize memory
   consumption. This can be done because the tag has no need for further children.
</div>

<h4 id="Chapter-5-2-Complex-tag"><a href="#Chapter-5-2-Complex-tag">5.2. Complex tag</a></h4>
<p>
   A &quot;complex&quot; tag is a tag that defines further child nodes - not limited in their hierarchy.
</p>
<p>
   As an example we take the image gallery tag from <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a>. This tag
   defines static content that includes a headline and an introduction text. The content of the gallery itself is
   - represented by the <em>&lt;img:gallery /&gt;</em> tag - is created by the <em>&lt;gallery:datasource /&gt;</em> tag
   using a <em>Content-Providers</em>.
</p>
<div class="hint">
   Please note that the structure of this example has been chosen to depict essential attributes of the APF tag
   implementation. It is not a rule of how your tags and applications must be structured. To realize this particular
   use case, you may also define the content provider within the gallery tag using attributes and use a further formatting
   element to generate the output (e.g. using a mechanism like the <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator</int:link>
   tag).
</div>

<h5 id="Chapter-5-2-1-Basis"><a href="#Chapter-5-2-1-Basis">5.2.1. Basis</a></h5>
<p>
   The basic structure of the tag is as follows:
</p>
<gen:highlight type="php">
import('examples::tags::pres', 'GalleryDataSourceTag');

class GalleryTag extends Document {

   public function __construct() {
      $this->__TagLibs[] = new TagLib(
         'examples::tags::pres',
         'GalleryDataSourceTag',
         'gallery',
         'datasource'
      );
   }

   ...

}
</gen:highlight>
<p>
   Within the constructor the <em>&lt;gallery:datasource /&gt;</em> tag is published to the parser. In order to let the
   APF parser create child nodes, you need to include the implementation via <em>import()</em>.
</p>

<h5 id="Chapter-5-2-2-Configuration-of-the-content-provider"><a href="#Chapter-5-2-2-Configuration-of-the-content-provider">5.2.2. Configuration of the content provider</a></h5>
<p>
   Let us now turn to the configuration of the <em>Content-Providers</em>.


   Hierzu spendieren wir dem
   <em>&lt;img:gallery /&gt;</em>-Tag ein privates Feld und einen Setter, damit der <em>&lt;gallery:datasource /&gt;</em>-Tag
   die Instanz übergeben kann:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   private $contentProvider;

   ...

   public function setContentProvider(ImageGalleryContentProvider $provider) {
      $this->contentProvider = $provider;
   }

   ...

}
</gen:highlight>
<p>
   Der Provider selbst definiert sich durch folgendes Interface:
</p>
<gen:highlight type="php">
interface ImageGalleryContentProvider {
   /**
    * @return GalleryImage[]
    */
   public function getImages();
}

class GalleryImage {

   private $title;
   private $description;
   private $imageUrl;

   public function __construct($title, $description, $imageUrl) {
      $this->title = $title;
      $this->description = $description;
      $this->imageUrl = $imageUrl;
   }

   public function getDescription() {
      return $this->description;
   }

   public function getImageUrl() {
      return $this->imageUrl;
   }

   public function getTitle() {
     return $this->title;
   }

}
</gen:highlight>
<p>
   Gemäß unseres Beispieles ist der <em>&lt;gallery:datasource /&gt;</em>-Tag dafür zuständig den gewünschten Provider
   zu erzeugen und dem <em>GalleryTag</em> mitzugeben. Dies lässt sich innerhalb der <em>onAfterAppend()</em>-Methode
   erledigen, da zu diesem Zeitpunkt der Vater-Knoten bekannt ist:
</p>
<gen:highlight type="php">
class GalleryDataSourceTag extends Document {

   public function __construct() {
   }

   public function onAfterAppend() {
      $provider = &$this->getServiceObject(
         $this->getAttribute('namespace'),
         $this->getAttribute('class')
      );
      /* @var $parent GalleryTag */
      $parent = &$this->getParentObject();
      $parent->setContentProvider($provider);
   }

   public function transform() {
      return '';
   }

}
</gen:highlight>
<p>
   Da der <em>GalleryDataSourceTag</em> keine weiteren Kinder erwartet, wurde der Konstruktor von <em>Document</em> leer
   überschrieben. In der Methode <em>onAfterAppend()</em> erzeugt das Tag den gewünschten Provider mit Hilfe des
   <int:link pageid="107" anchor="Chapter-3-2-1-ServiceManager-Einfache-Services">ServiceManager</int:link> um der Instanz
   Kontext und Sprache des aktuellen Elements mitzugeben. Anschließend wird dem Vater-Element des DOM-Baumes - hier
   eine Instanz der Klasse <em>GalleryTag</em> wie mit dem Type-Hint angegeben wird - der Provider injiziert.
</p>
<p>
   Die leer überschriebene <em>transform()</em>-Methode sorgt dafür, dass keine weiteren Kind-Elemente transformiert oder
   eine Ausgabe erzeugt wird. Dies ist im aktuellen Beispiel nicht notwendig.
</p>

<h5 id="Chapter-5-2-4-Parsen-des-GalleryDataSourceTag"><a href="#Chapter-5-2-4-Parsen-des-GalleryDataSourceTag">5.2.4. Parsen des GalleryDataSourceTag</a></h5>
<p>
   Damit der <em>GalleryDataSourceTag</em> seine Arbeit verrichten kann muss der <em>GalleryTag</em> dafür sorgen, dass
   er auch vom Page-Controller erfasst und ausgeführt wird. Dazu bringt der Page-Controller bereits eine Parser-Methode
   mit, die in jeder von <em>Document</em> erbenden Klasse ausgeführt werden kann - <em>__extractTagLibTags()</em>.
</p>
<p>
   Zu welchem Zeitpunkt diese aufgerufen werden soll entscheiden zunächst Sie selbst. Beachten Sie dabei jedoch immer das
   <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Ablaufdiagramm des Page-Controller</int:link> um den für
   den Anwendungsfall richtigen Zeitpunkt zu wählen. In unserem Fall ist lediglich wichtig, dass der Provider <em>vor</em>
   der Erzeugung der Inhalte ausgeführt wird. Damit sind theoretisch drei Möglichkeiten denkbar:
</p>
<ul>
   <li>In einer eigenen <em>onParseTime()</em>-Methode.</li>
   <li>In einer eigenen <em>onAfterAppend()</em>-Methode.</li>
   <li>Zu Beginn der <em>transform()</em>-Methode.</li>
</ul>
<p>
   Üblicherweise schickt es sich für die Analyse von weiteren Kind-Strukturen die <em>onParseTime()</em>-Methode zu
   nutzen, da Sie damit sicherstellen, dass die weiteren Elemente im Baum ebenfalls die Möglichkeit haben, Kind-Knoten
   zeitlich korrekt zu erzeugen.
</p>
<p>
   Um den <em>GalleryDataSourceTag</em> zu erzeugen und auszuführen, reicht folgender Quellcode:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   ...

}
</gen:highlight>
<p>
   Alles Weitere erledigt der APF-Parser für Sie gemäß den bekannten Tags.
</p>

<h5 id="Chapter-5-2-3-Erzeugen-der-Ausgabe"><a href="#Chapter-5-2-3-Erzeugen-der-Ausgabe">5.2.3. Erzeugen der Ausgabe</a></h5>
<p>
   Die Ausgabe der Bildergalerie erfolgt in der Methode <em>transform()</em>, die vom Page-Controller bei der Transformation
   des Baumes aufgerufen wird. Diese muss nun dafür sorgen, dass die Bilder, die vom Provider geliefert werden
   entsprechend ausgegeben werden.
</p>
<p>
   Unter der Annahme, dass alle Bilder als ungeordnete Liste mit entsprechendem Platz für Beschreibungen ausgegeben werden,
   gestaltet sich die Methode <em>transform()</em> wie folgt:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<' . 'ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<' . 'li>'
            . '<' . 'img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
            . '<' . 'p>' . $image->getDescription() . '<' . '/p>'
            . '<' . '/li>';
      }
      $buffer .= '<' . '/ul>';

      $this->setContent($this->getContent() . $buffer);
   }

}
</gen:highlight>
<p>
   Mit der aktuellen Implementierung werden alle Bilder als Listen-Elemente nach dem im <em>&lt;img:gallery /&gt;</em>-Tag
   vorhandenen statischen Inhalt angezeigt.
</p>
<div class="hint">
   Soll in einem Tag kein statischer Inhalt zugelassen werden, so kann dieser in der <em>transform()</em>-Methode durch
   <em>setContent()</em> durch einen dynamisch erzeugten überschrieben werden.
</div>
<div class="hint">
   Damit bei der Transformation die Inhalte eines Tags an der korrekten Stelle ausgegeben werden,
   erzeugt die Methode <em>__extractTagLibTags()</em> Platzhalter der Form
   <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Dabei entspricht <em>{OBJECT_ID}</em>
   dem Wert der Klassen-Variable <em>$this->__ObjectID</em> und dem Array-Offset, in dem die
   Kind-Tags gespeichert werden (<em>$this->__Children</em>). Dieser Wert kann dann bei der
   Implementierung von eigenen <em>transform()</em>-Methoden für die Ersetzung des Inhalts
   genutzt werden.
</div>
<p>
   Im Fall des <em>&lt;img:gallery /&gt;</em>-Tags sollen die Kind-Tags keine Ausgabe erzeugen, was prinzipiell mit der
   <em>GalleryDataSourceTag::transform()</em>-Methode sichergestellt. Da der APF-Parser jedoch zur Positionierung der
   Ausgabe Platzhalter erzeugt, müssen diese in unserem Beispiel dennoch ersetzt werden. Dies kann durch folgende
   Erweiterung passieren:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<' . 'ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<' . 'li>'
         . '<' . 'img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
         . '<' . 'p>' . $image->getDescription() . '<' . '/p>'
         . '<' . '/li>';
      }
      $buffer .= '<' . '/ul>';

      $this->setContent($this->getContent() . $buffer);

      foreach ($this->__Children as $objectId => $DUMMY) {
         $this->__Content = str_replace(
            '<' . $objectId . ' />',
            $this->__Children[$objectId]->transform(),
            $this->__Content
         );
      }
   }

}
</gen:highlight>

<h4 id="Chapter-5-3-Document-API"><a href="#Chapter-5-3-Document-API">5.3. Document-API</a></h4>
<p>
   Zur Implementierung von Tag-Logik stehen zahlreiche Methoden zur Verfügung. Diese umfassen das Parsen von Tag-Strukturen,
   das Traversieren des Baumes und das Manipulieren oder Auslesen von Tag-Informationen. Diese sind:
</p>
<ul>
   <li>
      <strong>__extractTagLibTags()</strong>:
      Analysiert die bekannten Kind-Tags und erstellen den DOM-Baum daraus.
   </li>
   <li>
      <strong>getParentObject()</strong>:
      Liefert die Instanz des Vater-Tags im DOM-Baum. Sofern kein Vater vorhanden ist, liefert die Methode <em>null</em>.
   </li>
   <li>
      <strong>setParentObject()</strong>:
      Injiziert eine Instanz als Vater-Tags des entsprechenden DOM-Knotens..
   </li>
   <li>
      <strong>getChildren()</strong>:
      Liefert die Liste aller Kinder des Tags. Sofern keine Kinder vorhanden sind, wird eine leere Liste zurückgegeben.
   </li>
   <li>
      <strong>getContent()</strong>:
      Liefert den Inhalt des befragten DOM-Elements.
   </li>
   <li>
      <strong>setContent()</strong>:
      Beschreibt den Inhalt des entsprechenden DOM-Elements.
   </li>
   <li>
      <strong>getChildNode()</strong>:
      Liefert einen Kind-Knoten, der einem definierten Selektor genügt.
   </li>
   <li>
      <strong>getAttribute()</strong>:
      Liefert den Wert eines Attributes.
   </li>
   <li>
      <strong>setAttribute()</strong>:
      Definiert den Wert eines Attributes.
   </li>
   <li>
      <strong>getAttributes()</strong>:
      Liefert die Liste der aktuellen Attribute.
   </li>
   <li>
      <strong>getAttributesAsString()</strong>:
      Generiert eine XML-Repräsentation der übergebenen Attribute an Hand einer optionalen Whitelist.
   </li>
</ul>
<p>
   Weitere Methoden der Klasse <em>Document</em> oder der Basis-Klasse ihres aktuellen Tags finden Sie in der
   <int:link pageid="002"/>.
</p>

<h3 id="Chapter-6-Tag-hierarchies"><a href="#Chapter-6-Tag-hierarchies">6. Tag hierarchies</a></h3>
<p>
   Der Tag-Parser des APF besitzt aus Performance- und Konsistenz-Gründen einigen Restriktionen gegenüber einem
   &quot;echten&quot; XML-Parser. Diese sind:
</p>
<ul>
   <li>Tag-Attribute können nur durch Leerzeichen getrennt werden. Tab-Zeichen nicht nicht möglich.</li>
   <li>Der Inhalt von Tag-Attribute wird nur in doppelten Anführungszeichen erkannt.</li>
   <li>
      Tag-Hierarchien werden nur dann richtig aufgelöst, wenn ein Tag - bestehend aus Präfix und Namen - nur in einer
      Ebene bekannt sind. Dies erfordert die Registrierung einer Tag-Implementierung in unterschiedlichen Ebenen mit
      einer anderen Präfix-Name-Kombination.
      <div class="warn">
         Möchten Sie einen Tag auf &quot;höchster&quot; Ebene in einer Template-Datei und gleichzitig in einer tiefer
         gelegenen Struktur verwenden, ordnet der Parser die Instanzen falsch zu. Beispiel:
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="..."
   class="FooBarTag"
   prefix="foo"
   name="tag"
/&gt;
&lt;foo:bar id="..."/&gt;
&lt;html:template name="..."&gt;
   &lt;template:addtaglib
      namespace="..."
      class="FooBarTag"
      prefix="foo"
      name="tag"
   /&gt;
   &lt;foo:bar id="..."/&gt;
&lt;/html:template&gt;
</gen:highlight>
         In diesem Fall ordnet der Parser die Instanz des Tags <em>&lt;foo:bar /&gt;</em> der obersten Ebene zu. Im
         <em>&lt;html:template /&gt;</em>-Tag ist kein <em>&lt;foo:bar /&gt;</em> vorhanden, sondern lediglich ein
         Platzhalter und es kommt bei der Transformation zu einem Fehler bzw. einem nicht nachvollziehbaren Verhalten.
      </div>
   </li>
   <li>
      Als verarbeitbare Tags werden nur APF-Tags erkannt. Einfache HTML-Tags können nicht erfasst werden und dies
      erfordert u.U. die Implementierung von Wrapper-Tags für die Abstraktion.
   </li>
</ul>

<h4 id="Chapter-6-1-Einfache-Hierarchien"><a href="#Chapter-6-1-Einfache-Hierarchien">6.1. Einfache Hierarchien</a></h4>
<p>
   Einfache Tag-Hierarchien sind solche, bei denen Tags in unterschiedlichen Ebenen nur einmal vorkommen. Die Einschränkung
   des Tag-Parsers wirkt sich dabei vor allem auf den aktuell verarbeiteten Knoten - in der Regel das aktuelle Template -
   aus.
</p>
<p>
   Als Beispiel soll uns folgendes Template dienen, in dem ein weiteres eingebunden wird:
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="..." /&gt;
&lt;core:importdesign
   namespace=""
   template="template2"
/&gt;
</gen:highlight>
<p>
   Das per <em>template2</em> eingebundene Template - dieses stellt die nächste Hierarchie-Stufe im DOM-Baum dar - hat
   folgenden Inhalt:
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="" /&gt;
&lt;html:template name="..."&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Da die beiden <em>&lt;html:placeholder /&gt;</em>-Tags in unterschiedlichen Template-Dateien definiert sind, werden
   sie den jeweiligen Hierarchien korrekt zugeordnet.
</p>
<div class="hint">
   Bitte beachten Sie, dass APF-Tags nur dann verarbeitet werden können, wenn sie dem APF-Parser bekannt sind.
   Benutzen Sie eigene Tags, geben Sie diese bitte mit Hilfe der <em>&lt;*:addtaglib /&gt;</em>-Tags bekannt.
</div>
<div class="warn">
   Ein per <em>&lt;*:addtaglib /&gt;</em>-Tag bekannt gegebener Tag gilt nur innerhalb des aktuellen DOM-Knotens!
   Beabsichtigen Sie einen eigenen Tag sowohl in der ersten Hierarchie - quasi &quot;direkt&quot; in der Template-Datei
   - als auch einer tiefer gelegenen zu verwenden, so muss der Tag in beiden bekannt gegeben werden. Beachten Sie hierzu
   bitte die Hinweise im nächsten Kapitel.
</div>

<h4 id="Chapter-6-2-Komplexe-Hierarchien"><a href="#Chapter-6-2-Komplexe-Hierarchien">6.2. Komplexe Hierarchien</a></h4>
<p>
   Als Beispiel für komplexe Hierarchien, soll ein Tag dienen, der auf Basis eines Schlüssels Übersetzungen für die
   aktuell gewählte Sprache ausgibt. Er soll auf Ebene einer Template-Datei, innerhalb eines
   <em>&lt;html:template /&gt;</em>-Tags und in einem eigenen Tag eingesetzt werden.
</p>
<p>
   Als Basis für die weitere Diskussion soll folgende Template-Datei dienen:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="..."
   class="GetTextTag"
   prefix="html"
   name="text"
/&gt;
&lt;html:text key="..." /&gt;

&lt;html:template name=""&gt;
   &lt;core:addtaglib
         namespace="..."
         class="GetTextTag"
         prefix="template"
         name="text"
      /&gt;
   &lt;template:text key="..." /&gt;
&lt;/html:template&gt;

&lt;user:control-panel&gt;
   &lt;control-panel:text key="..." /&gt;
   &lt;control-panel:navi /&gt;
&lt;/user:control-panel&gt;
</gen:highlight>
<p>
   Der <em>GetTextTag</em> wird innerhalb der ersten Hierarchie und im <em>&lt;html:template /&gt;</em>-Tag durch einen
   <em>&lt;*:addtaglib /&gt;</em>-Tag bekannt gegeben, im <em>&lt;user:control-panel /&gt;</em>-Tag ist er bereits durch
   die Implementierung bekannt.
</p>
<div class="warn">
   Durch die in <a href="#Chapter-6-Tag-Hierarchie">Kapitel 6</a> beschriebene Einschränkungen des APF-Parsers ist es
   notwendig für die Verwendung des <em>&lt;*:text /&gt;</em>-Tags innerhalb von <em>&lt;html:template /&gt;</em> und
   <em>&lt;user:control-panel /&gt;</em> ein eigenes Präfix zu wählen. Sind Präfix und Name des <em>&lt;*:text /&gt;</em>-Tags
   in allen Hierarchien identisch wird der Parser die Instanzen derjenigen Hierarchie zuweisen in der er zuerst bekannt
   gegeben wurde - in diesem Fall der ersten.
</div>
<div class="hint">
   Aus den oben genannten Gründen und um die Zugehörigkeit eines Tags zu einer Hierarchie auszudrücken empfiehlt es sich,
   Präfix und Namen eines Tags gemäß der Hierarchie zu vergeben. Im obigen Beispiel wurden die Kind-Tags des
   <em>&lt;user:control-panel /&gt;</em> mit dem Präfix <em>control-panel</em> ausgestattet. Für tiefer strukturierte
   Hierarchien kann folgendes Beispiel als Vorlage dienen:
<gen:highlight type="apf-xml">
&lt;shop:basket&gt;
   &lt;basket:title /&gt;
   &lt;basket:products&gt;
      &lt;products:listing /&gt;
      &lt;products:sum /&gt;
   &lt;/basket:products&gt;
&lt;/shop:basket&gt;
</gen:highlight>
   Weitere Hinweise finden Sie im Forum unter
   <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=4&amp;t=38">Schachtelung TagLibs</a>.
</div>

<h3 id="Chapter-7-Anwendungsbeispiele"><a href="#Chapter-7-Anwendungsbeispiele">7. Anwendungsbeispiele</a></h3>
<p>
   In diesem Kapitel finden Sie Anwendungsbeispiele für Tags, die Sie in Ihrer täglichen Arbeit mit dem APF als
   Vorlage für eigene Implementierungen bzw. als Coding-Guideline nutzen können. Als Daumenregel gilt:
</p>
<div class="hint">
   Ein Tag wird erst notwendig, wenn die Anforderung mit Hilfe eines <int:link pageid="047"/> - inkl. aller
   <int:link pageid="046" /> - und einem <int:link pageid="006" /> nicht mehr zu realisieren ist (z.B. Manipulationen
   des DOM-Baums). Weiterhin empfielt es sich, Funktionalität in Tags abzufassen, wenn immer wieder verwendete Elemente
   in unterschiedlichen Templates genutzt werden soll ohne den Code zu duplizieren oder unnötige Vererbungshierarchien
   zu erzeugen.
</div>

<h4 id="Chapter-7-1-Einfacher-Tag-mit-Attributen"><a href="#Chapter-7-1-Einfacher-Tag-mit-Attributen">7.1. Einfacher Tag mit Attributen</a></h4>
<p>
   Als Beispiel für einen einfachen Tag soll uns der <em>&lt;html:text /&gt;</em>-Tag aus
   <a href="#Chapter-6-2-Komplexe-Hierarchien">Kapitel 6.2</a> dienen. Dieser gibt einen sprachabhängigen Text aus, der
   an Hand eines Attributs definiert wird. Beispiel:
</p>
<gen:highlight type="apf-xml">
&lt;html:text key="log-in.mousover.text" /&gt;
</gen:highlight>
<p>
   Die Implementierung des Tags beinhaltet die Verarbeitung des Attributs und die Ausgabe des Textes zur
   Transformationszeit. Dies kann mit folgender Implementierung bewerkstelligt werden:
</p>
<gen:highlight type="php">
class TranslationTextTag extends Document {

   public function transform() {
     return gettext($this->getAttribute('key'));
   }

}
</gen:highlight>
<p>
   Sollen die Attribute eines Tags bei der Generierung der Ausgabe einbezogen werden, kann die Methode
   <em>getAttributesAsString()</em> genutzt werden. Als Beispiel soll ein Tag genutzt werden, der die Ausgabe eines
   Bildes aus einer Medien-Datenbank an Hand einer externen ID erzeugt:
</p>
<gen:highlight type="apf-xml">
&lt;html:img
   key="IMG-12345"
   width="100"
   height="120"
   alt="Diese Bild zeigt ein rotes Auto"
/&gt;
</gen:highlight>
<p>
   Die zugehörige Implementierung kann wie folgt aussehen:
</p>
<gen:highlight type="php">
class MAMImageTag extends Document {

   public function transform() {

      $width = $this->getAttribute('width', '50');
      $height = $this->getAttribute('height', '50');
      $key = $this->getAttribute('key');

      $whiteList = array(
         'alt',
         'height',
         'width',
         'id',
         'style',
         'title'
      );

      return '<' . 'img src="'
            . $this->getImageUrl($key, $width, $height) . '" '
            . $this->getAttributesAsString($this->getAttributes(), $whiteList)
            . ' />';
   }

   private function getImageUrl($key, $width, $height) {
     ...
   }

}
</gen:highlight>
<p>
   In der obigen Code-Box wird die Methode <em>getAttribute()</em> dazu genutzt um die Werte der angegebenen Attribute
   auszulesen. Da einige der Attribute für die Ausgabe wiederverwendet werden sollen, wird der Methode
   <em>getAttributesAsString()</em> eine Liste an erlaubten Attributen - in diesem Fall kompatibel zur XHTML- bzw.
   HTML5-Spezifikation - mitgegeben. Die Ausgabe des Tags ist damit ein Image-Tag, der mit Hilfe der (HTML-)Attribute
   <em>id</em>, <em>style</em> und <em>class</em> formatiert werden kann.
</p>

<h4 id="Chapter-7-2-Einfacher-Tag-mit-Inhalt"><a href="#Chapter-7-2-Einfacher-Tag-mit-Inhalt">7.2. Einfacher Tag mit Inhalt</a></h4>
<p>
   Neben den Attributen eines Tags kann dieser auch einfachen und komplexen Inhalt definieren. Als Implementierungsbeispiel
   soll in diesem Kapitel folgender Tag genutzt werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
<p>
   Ausgabe des Tags soll eine in HTML-Entitäten codierte E-Mail-Adresse sein, um sie vor Bots oder Spidern zu schützen.
   Hierzu muss der Inhalt des Tags ausgelesen und im Rahmen der Transformation des Tags ausgegeben werden. Dies führt
   zu folgender Implementierung:
</p>
<gen:highlight type="php">
import('tools::string', 'StringAssistant');

class EntityEncodeTag extends Document {

   public function transform() {
      return StringAssistant::encodeCharactersToHTML($this->getContent());
   }

}
</gen:highlight>
<p>
   Mit der Methode <em>getContent()</em> kann auf den Inhalt des Tags zugegriffen werden. Dieser wird mit Hilfe des
   <em>StringAssistant</em> in HTML-Entitäten umgewandelt.
</p>

<h4 id="Chapter-7-3-Zugriff-auf-den-umliegenden-DOM-Baum"><a href="#Chapter-7-3-Zugriff-auf-den-umliegenden-DOM-Baum">7.3. Zugriff auf den umliegenden DOM-Baum</a></h4>
<p>
   Wie im <a href="#Chapter-1-Einfuehrung">Kapitel 1</a> angesprochen erzeugt der <int:link pageid="098" /> aus den
   genutzten Templates und den darin enthaltenen Tags einen DOM-Baum. Das Verhalten ist - bis auf die Art der Erzeugung
   - mit dem eines Browsers vergleichbar, der ebenfalls aus dem angelieferten HTML einen DOM-Baum erzeugt und diesen
   grafisch aufbereitet.
</p>
<p>
   Da Tags und <int:link pageid="006" /> Teil des Baumes sind haben Sie dort die Möglichkeit auf alle umliegenden Knoten
   zuzugreifen. Hierzu gibt es im Wesentlichen zwei Methoden:
</p>
<ul>
   <li><em>getParentObject()</em></li>
   <li><em>getChildren()</em></li>
</ul>
<p>
   Innerhalb eines Tags können Sie mit diesen Methoden direkt auf die umliegenden Elemente zugreifen, innerhalb eines
   <int:link pageid="006" /> beziehen Sie mit <em>getDocument()</em> eine Referenz auf den aktuellen DOM-Knoten und
   können ab diesem mit den oben genannten Methoden navigieren.
</p>
<p>
   Als Beispiel für den Zugriff auf soll folgendes Template dienen:
</p>
<gen:highlight type="apf-xml">
&lt;html:template name="test1"&gt;
   ...
&lt;/html:template&gt;
&lt;html:template name="test2"&gt;
   &lt;template:addtaglib
      namespace="..."
      class="TemplateNameDisplayTag"
      prefix="template"
      name="display-name"
   /&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Der <em>TemplateNameDisplayTag</em> hat dabei die Aufgabe, die Namen aller Templates auszugeben, die im Baum auf
   gleicher Ebene hängen wie sein Vater. Hierzu kann folgende Implementierung genutzt werden:
</p>
<gen:highlight type="php">
class TemplateNameDisplayTag extends Document {
   public function transform() {
      $template = &$this->getParentObject();
      $grandFather = &$template->getParentObject();

      $nodes = $grandFather->getChildren();

      $buffer = '<' . 'ul>';
      foreach ($nodes as $objectId => $DUMMY) {
         $buffer .= '<' . 'li>' . $nodes[$objectId]->getAttribute('name') . '<' . '/li>';
      }

      return $buffer . '<' . '/ul>';
   }
}
</gen:highlight>
<p>
   Ein weiterführendes Beispiel finden Sie im Forum unter
   <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=1152">Placeholder über Taglib füllen</a>.
</p>

<h4 id="Chapter-7-4-Komplexer-Tag-mit-Attributen-und-Inhalt"><a href="#Chapter-7-4-Komplexer-Tag-mit-Attributen-und-Inhalt">7.4. Komplexer Tag mit Attributen und Inhalt</a></h4>
<p>
   Die vorangegangenen Kapitel haben sich mit dem Zugriff auf Attribute, der Ausgabe von Attributen und dem Zugriff und
   der Verarbeitung von Tag-Inhalten beschäftigt. In diesem Abschnitt beschäftigen wir uns mit komplexeren Tags, die
   weitere Strukturen definieren und Inhalte sowie Attribute in die Abbildung ihrer Logik einbeziehen.
</p>
<p>
   Als Beispiel soll uns ein Tag dienen, der Navigationsknoten vom Typ <em>NavigationNode</em> ausgibt:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="extensions::navigation::pres::tags"
   class="NavigationNodeTag"
   prefix="navi"
   name="template"
/&gt;
&lt;navi:template id="main-navi"&gt;&lt;!-- NavigationNodeTag --&gt;
   &lt;navi:item status="active"&gt;&lt;!-- NavigationItemTag --&gt;
      &lt;li class="active"&gt;
         &lt;item:content/&gt;&lt;!-- ItemTemplateContentTag --&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;
   &lt;navi:item status="inactive"&gt;
      &lt;li&gt;
         &lt;item:content/&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;

   &lt;ul id="main-navigation"&gt;
      &lt;navi:content/&gt;&lt;!-- NavigationContentTag --&gt;
   &lt;/ul&gt;
&lt;/navi:template&gt;
</gen:highlight>
<p>
   Der Tag wird in einem <int:link pageid="006" /> gefüllt und stellt die Liste der Kinder des übergebenen
   Navigationsknotens gemäß den definierten Formatierungen dar. Dabei beschreiben die <em>&lt;navi:item /&gt;</em>-Tags
   die aktiven und inaktiven Zustände der Navigationsknotens und mit Hilfe von <em>&lt;navi:content/&gt;</em> lässt sich
   die Ausgabe in ein HTML-Gerüst packen. Der Tag <em>&lt;item:content/&gt;</em> platziert die Ausgabe eines konkreten
   Knotens und kann ebenfalls mit eigenem HTML versehen werden. Zur Erläuterung der Tag-Hierarchie sind die Namen der
   korrespondierenden Tags als HTML-Kommentar angefügt.
</p>
<p>
   Zur Befüllung des <em>&lt;navi:template /&gt;</em>-Tags in einem Template lässt sich folgender Controller nutzen:
</p>
<gen:highlight type="php">
import('extensions::navigation::biz', 'SimpleNavigationNode');

class NavigationTagExampleController extends base_controller {
   public function transformContent() {
      $root = new SimpleNavigationNode(null, null, null);
      $levelOne = new SimpleNavigationNode('Level 1', '#');

      $root->setChildren(array(
         clone $levelOne->setInactive(),
         clone $levelOne->setActive(),
         clone $levelOne->setInactive()
      ));

      $navi = $this->getDocument()->getChildNode('id', 'main-navi', 'NavigationNodeTag');
      $navi->setNode($root);
   }
}
</gen:highlight>
<p>
   Die folgende Code-Box zeigt nun die Implementierung der Tags:
</p>
<gen:highlight type="php">
interface NavigationNode {
   public function getLabel();
   public function getUrl();
   public function getParent();
   public function getChildren();
}

class SimpleNavigationNode implements NavigationNode {

   private $label;
   private $url;
   private $isActive = false;
   private $parent;
   private $children = array();

   public function __construct($label, $url) {
      $this->label = $label;
      $this->url = $url;
   }

   public function getLabel() {
      return $this->label;
   }

   public function getUrl() {
      return $this->url;
   }

   public function isActive() {
      return $this->isActive;
   }

   public function setActive() {
      $this->isActive = true;
      return $this;
   }

   public function setInactive() {
      $this->isActive = false;
      return $this;
   }

   public function getParent() {
      return $this->parent;
   }

   public function getChildren() {
      return $this->children;
   }

   public function setParent(NavigationNode $node) {
      $this->parent = $node;
   }

   public function setChildren(array $nodes) {
      $this->children = $nodes;
   }

}

class NavigationNodeTag extends Document {

   private $node;

   public function __construct() {
      $this->__TagLibs = array(
         new TagLib('extensions::navigation::pres::tags', 'NavigationItemTag', 'navi', 'item'),
         new TagLib('extensions::navigation::pres::tags', 'NavigationContentTag', 'navi', 'content')
      );
   }

   public function setNode(NavigationNode $node) {
      $this->node = $node;
   }

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   public function transform() {

      $buffer = '';

      $navigationNodes = $this->node->getChildren();
      if (count($navigationNodes) > 0) {
         foreach ($navigationNodes as $node) {
            $buffer .= $this
               ->getTemplate($node->isActive() ? 'active' : 'inactive')
               ->getOutput($node);
         }
      }

      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof NavigationContentTag) {
            // fill the navi:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $buffer, $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }

      return $content;
   }

   private function getTemplate($status) {
      return $this->getChildNode('status', $status, 'NavigationItemTag');
   }

}

class NavigationItemTag extends Document {

   public function __construct() {
      $this->__TagLibs = array(
         new TagLib('extensions::navigation::pres::tags', 'ItemTemplateContentTag', 'item', 'content')
      );
   }

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   public function getOutput(NavigationNode $node) {
      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof ItemTemplateContentTag) {
            // fill the item:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $children[$objectId]->setNode($node)->transform(), $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }
      return $content;
   }

   public function transform() {
      return '';
   }

}

class ItemTemplateContentTag extends Document {

   private $node;

   public function setNode(NavigationNode $node) {
      $this->node = $node;
      return $this;
   }

   public function transform() {
      if ($this->node === null) {
         return '';
      }
      return '<' . 'a href="' . $this->node->getUrl() . '">' . $this->node->getLabel() . '<' . '/a>';
   }

}

class NavigationContentTag extends Document {
}
</gen:highlight>
<div class="warn">
   Das hier beschriebene Beispiel dient dazu, die Möglichkeiten des APF aufzuzeigen und ist nicht als
   Referenz-Implementierung für die Ausgabe von Navigationen gedacht.
</div>

<h3 id="Chapter-8-Weiterfuehrende-Links"><a href="#Chapter-8-Weiterfuehrende-Links">8. Weiterführende Links</a></h3>
<p>
   Sofern Sie weitere Informationen benötigen, können Sie folgende Threads aus dem Forum nutzen:
</p>
<ul>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=1126">TagLib unterschiedliche Zustände</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=982">Taglib innerhalb eines Templates</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=827">Taglib der Template rundherum läd</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=540">Taglibs</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=505">Mehrere Checkboxes taglib aus DB holen und ausgeben</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=456">Taglib-Call innerhalb eines Taglib-Call</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=191">transform() von eigenem taglib nicht ausgeführt</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=177">Menü taglib-modul</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=122">Performance TagLibs</a></li>
   <li><a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=37">Taglibs vs. Templates</a></li>
</ul>
<p>
   Im Wiki finden sich folgende Seiten zu den APF-Tags:
</p>
<ul>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/de/All-in-one_Include-Tag">All-in-one Include-Tag</a></li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/de/Timing-Modell_des_Page-Controller">Timing-Modell des Page-Controller</a></li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/de/WYSIWYG_%2B_APF-Formulare">WYSIWYG + APF-Formulare</a></li>
</ul>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_147" />