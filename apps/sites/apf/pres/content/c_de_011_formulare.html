<doku:title parent="119" tags="forumlare,forums,aufbau,validierung,manipulation,befuellung,auslesen,dynamische formulare,controller" title="Formulare" urlname="Formulare">
  Diese Dokumentationsseite beschreibt den Aufbau und die Verwendung von Formularen so wie die
  M&ouml;glichkeiten, die sich aus dem APF-Form-Modell ergeben. Dazu z&auml;hlen die Validierung und
  das Vorausf&uuml;llen sowie die M&ouml;glichkeit, Formular-Elemente (=Objekte) im Controller zu
  Manipulieren, zu bef&uuml;llen oder diese auszulesen. In einem weiteren Kapitel wird beschrieben,
  wie dynamische Formulare erstellt werden k&ouml;nnen.
</doku:title>
<div class="warn">
   Diese Seite dokumentiert die Formular-Unterst&uuml;tzung des APF <strong>bis einschlie&szlig;lich der
   Version 1.10</strong>. In Release 1.11 wurde die Formular-Integration vollst&auml;ndig &uuml;berarbeitet.
   Die neue Dokumentation findet sich nun im Kapitel <int:link pageid="113" />.
</div>
<div class="hint">
   Die bis zum Release 1.10 enthaltenen Formular-Taglibs sind unter <int:link pageid="130" />
   dokumentiert.
</div>
Das Adventure PHP Framework unterst&uuml;tzt die dynamische Generierung und Abstraktion von Formularen
out-of-the-box. Durch den generischen Tag-Parser k&ouml;nnen Formulare durch Tags in Templates und die
entsprechenden DOM-Objekte im Objektbaum der Pr&auml;sentations-Schicht abgebildet werden. Dadurch ist
es m&ouml;glich Formular-Elementen "interne Intelligenz" mitzugeben. Hierrunter f&auml;llt das
automatische Ausf&uuml;llen anhand eines URL-Parameters und die Validierung von Benutzereingaben. Dies
beiden Features k&ouml;nnen einfach durch die Definition des Verhaltens in den Templates gesteuert
werden und der Entwickler ben&ouml;tigt keine weiteren Hilfmittel und Logiken mehr.
<br />
<br />
<br />
<h3 id="Chapter-1-Aufbau-von-Formularen"><a href="#Chapter-1-Aufbau-von-Formularen">1. Aufbau von Formularen</a></h3>
Formulare werden im Framework wie Templates behandelt und sind Kinder eines Baum-Knotens. Mit der
Methode <strong>__getForm()</strong> kann innerhalb eines Document-Controllers auf ein Formular
zugegriffen werden. Das Formular unterst&uuml;tzt folgende wichtige Funktionen:
<ul>
  <li>
    <strong>addFormElement()</strong>
    <br />
    F&uuml;gt ein Formular-Element zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContent()</strong>
    <br />
    F&uuml;gt (HTML-/Text-)Inhalt zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContentBeforeMarker()</strong>
    <br />
    F&uuml;gt (HTML-/Text-)Inhalt vor einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContentAfterMarker()</strong>
    <br />
    F&uuml;gt (HTML-/Text-)Inhalt nach einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormElementBeforeMarker()</strong>
    <br />
    F&uuml;gt ein Formular-Element vor einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormElementAfterMarker()</strong>
    <br />
    F&uuml;gt ein Formular-Element nach einem Marker-Tag zum Formular hinzu. Die Methode ist f&uuml;r
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>setPlaceHolder()</strong>
    <br />
    F&uuml;llt einen angegebenen Platzhalter mit einem Wert.
  </li>
  <li>
    <strong>setAction()</strong>
    <br />
    Setzt das "action"-Attribut des Formulars.
  </li>
  <li>
    <strong>getFormElementByName()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zur&uuml;ck.
  </li>
  <li>
    <strong>getFormElementByID()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zur&uuml;ck.
  </li>
  <li>
    <strong>getFormElementByObjectID()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zur&uuml;ck.
  </li>
  <li>
    <strong>getFormElementsByTagName()</strong>
    <br />
    Gibt eine Liste von Formular-Element-Referenzen zur&uuml;ck, die dem &uuml;bergebenen Tag-Namen
    (z.B. <em>form:text</em>) entsprechen.
  </li>
  <li>
    <strong>transformForm()</strong>
    <br />
    Erzeugt die HTML-Ausgabe eines Formular-Objekts und gibt diese zur&uuml;ck.
  </li>
  <li>
    <strong>transformOnPlace()</strong>
    <br />
    Definiert, dass das Formular an der Stelle, an der es im Template-File definiert wurde ausgegeben
    wird. Damit ist es nicht mehr n&ouml;tigt, das Formular per <em>transformForm()</em> zu transformieren
    und in einen Platzhalter einzusetzen.
  </li>
</ul>
Um ein Formular in einer Template-Datei zu definieren muss zuerst per
<gen:highlight type="apf-xml">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
</gen:highlight>
<strong>vor</strong> der Verwendung hinzugef&uuml;gt werden. Anschlie&szlig;end kann beispielsweise
ein Formular einer Login-Maske definiert werden:
<gen:highlight type="apf-xml">
  &lt;html:form name="AdminLogin" method="post" action=""&gt;
    &lt;form:placeholder name="LogInError" /&gt;
    Benutzer: &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    Passwort: &lt;form:password name="Password" class="eingabe_feld" style="width: 200px; margin-left: 16px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="AdminLogin" value="Login" class="eingabe_feld" style="margin-left: 227px;"/&gt;
  &lt;/html:form&gt;
</gen:highlight>
In Prosa: das Formular definiert die Attribute <strong>name</strong>, damit im Controller sp&auml;ter
auf dieses zugegriffen werden kann, <strong>method</strong> um die Methode des Abschickens zu
definieren und <strong>action</strong> um die Ziel-URL zu definieren. Letzteres muss in der Template-
Datei nicht zwingend gesetzt werden, da die TagLib dieses selbst mit der aktuellen URL setzt oder
f&uuml;llt, falls es nicht vorhanden ist.
<br />
<br />
Innerhalb des Formulars werden viel Formular-Elemente definiert: ein Platzhalter, f&uuml;r die Aufnahme
von Hinweistexten, ein Text- und ein Passwort-Feld und ein Button. Diese sind jeweils mit den unter
<int:link pageid="046" /> beschriebenen Attributen
ausgestattet. Im Document-Controller kann nun per
<gen:highlight type="php">
$Form__AdminLogin = &$this->__getForm('AdminLogin');
</gen:highlight>
eine Referenz auf das Formular geholt werden. Anschlie&szlig;end kann per
<gen:highlight type="php">
$Form__AdminLogin->setPlaceHolder('...','Login failed!');
</gen:highlight>
der Inhalt des Platzhalters manipuliert oder mit
<gen:highlight type="php">
  if($Form__AdminLogin->get('isValid') && $Form__AdminLogin->get('isSent')){

     // Aktion ausf&uuml;hren, die bei abgeschicktem und
     // valide ausgef&uuml;lltem Formular passieren soll...

   // end if
  }
</gen:highlight>
abgefragt werden, ob das Formular abgeschickt wurden und die Eingaben valide sind.
<br />
<br />
Um das Formular auszugeben gibt es zwei M&ouml;glichkeiten: Ausgabe &uuml;ber einen im Template-File
definierten Platzhalter oder Verwendung von <em>transformOnPlace()</em>:
<gen:highlight type="php">
   function transformContent(){

      ...

      // Formular transformieren und in einen Platzhalter einsetzen ...
      $this->setPlaceHolder('...',$Form__AdminLogin->transformForm());

      // ... oder das Formular an der Definitionsstelle ausgeben
      $Form__AdminLogin->tranformOnPlace();

      ...

    // end function
   }
</gen:highlight>
<br />
<h3 id="Chapter-2-Validierung"><a href="#Chapter-2-Validierung">2. Validierung</a></h3>
Wie bereits erw&auml;hnt ist die Validierung von Formular-Feldern bereits out-of-the-box m&ouml;glich.
Hierzu muss ein Formular-Feld lediglich um die Attribute
<ul>
  <li>validate</li>
  <li>validator</li>
  <li>button</li>
</ul>
wie unter <int:link pageid="046" />, Kapitel 2.3.,
beschrieben, erweitert werden. F&uuml;r die Validierung des oben genannten Login-Formulars muss das
Textfeld wie folgt definiert werden:
<gen:highlight type="apf-xml">
  &lt;form:text name="Username" validate="true" button="AdminLogin" /&gt;
</gen:highlight>
Wichtig ist die Angabe des Button-Namens, da das Formular erst nach dem Abschicken validiert werden
soll. Ist das Button-Attribut nicht gesetzt, wird von der TagLib ein Fehler ausgegeben. Zur
Ausgabe-Formatierung kann dieser Tag um weitere Attribute wie "class" und style" erweitert werden.
<gen:highlight type="apf-xml">
  &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
  validate="true" button="AdminLogin" /&gt;
</gen:highlight>
Ist das Attribut "validator" nicht gesetzt, so wird der Standard-Validator verwendet, der pr&uuml;ft,
ob das Feld exakt oder mehr als 3 Zeichen enth&auml;lt.
<br />
<br />
<div class="hint">
Soll zus&auml;tzlich zu einer roten Umrandung der Felder noch eine Meldung angezeigt werden, so kann
im Bereich des Eingabe-Feldes noch ein zus&auml;tzliches
<int:link pageid="130" anchor="Chapter-18-Generischer-Validator">&lt;form:genericval /&gt;</int:link>-Tag
platziert werden. Dieses gibt bei nicht erfolgreicher Validierung des angegebenen Feldes eine Text
aus.
</div>
<br />
<br />
<h3 id="Chapter-3-Manipulation-von-Formularelementen"><a href="#Chapter-3-Manipulation-von-Formularelementen">3. Manipulation von Formularwerten</a></h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige M&ouml;glichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen h&auml;ufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<h4 id="Chapter-3-1-Vorbefuellung"><a href="#Chapter-3-1-Vorbefuellung">3.1. Vorbef&uuml;llung von Formularen</a></h4>
Zur Vorbef&uuml;llung von Formularen (z.B. in einem Bearbeiten-Dialog) k&ouml;nnen Methoden
<strong>getFormElementByID()</strong>, <strong>getFormElementByID()</strong> oder
<strong>getFormElementByObjectID()</strong> eingesetzt werden um eine Referenz auf ein Formular-Element
zu beziehen. Anschlie&szlig;end stehen die Standard-Methoden <strong>get()</strong> und
<strong>getAttribute()</strong>, bzw. <strong>set()</strong> und <strong>setAttribute()</strong> zur
Verf&uuml;gung.
<br />
<br />
Die folgenden Codebox definiert ein Beispiel-Formular, das im anschlie&szlig;end
abgedruckten PHP-Code bef&uuml;llt wird:
<br />
<gen:highlight type="apf-xml">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserEdit" method="post"&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</gen:highlight>
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Edit = &$this->__getForm('UserEdit');

   // Referenz auf das Hidden-Feld beziehen und Wert befuellen
   $UserID = &$Form__Edit->getFormElementByName('userid');
   $UserID->setAttribute('value','...');

   // Referenz auf das FirstName-Feld beziehen und Wert befuellen
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   $FirstName->setAttribute('value','...');

   // Referenz auf das LastName-Feld beziehen und Wert befuellen
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   $LastName->setAttribute('value','...');
</gen:highlight>
<br />
<h4 id="Chapter-3-2-Befuellen-von-Select-Feldern"><a href="#Chapter-3-2-Befuellen-von-Select-Feldern">3.2. Bef&uuml;llen von Select-Feldern</a></h4>
Die Behandlung Select- und Multiselect-Feldern unterscheidet sich ein wenig von einfachen
Formular-Elementen. Das Framework stellt jedoch auch hier Methoden zur Verf&uuml;gung, mit denen das
Bef&uuml;llen von Feldern vereinfacht wird. Im nachfolgend aufgef&uuml;hrten Code wird ein Formular
vorausgef&uuml;llt, das zus&auml;tzlich zu den Standard-Text-Felder auch Auswahlfelder beinhaltet:
<gen:highlight type="apf-xml">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserCreate" method="post"&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;form:select name="Salutation" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;br /&gt;
    &lt;form:multiselect name="Group[]" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</gen:highlight>
Wie in der Definition des Multiselect-Feldes <strong>Groups[]</strong> zu sehen ist, m&uuml;ssen bei
einem Multiselect-Feld die Namen eckigen Klammern versehen werden. Vergisst der Template-Entwickler
dies, wird eine entsprechende Fehlermeldung ausgegeben.
<br />
<br />
Der folgende PHP-Code bef&uuml;llt das Formular:
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Create = &$this->__getForm('UserCreate');

   ...

   // Referenz auf das Salutation-Feld beziehen und Wert befuellen
   $Salutation = &$Form__Create->getFormElementByName('Salutation');

   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }


   // Referenz auf das Groups[]-Feld beziehen und Werte befuellen
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   ...
</gen:highlight>
<strong>Hinweis:</strong> Sollen beim Bef&uuml;llen eines Multiselect-Feldes bestimmte Optionen
bereits vorausgew&auml;hlt sein, so kann die Methode <strong>setOption2Selected()</strong> verwendet
werden. Der folgende Code zeigt, wie ein Multiselect-Feld zun&auml;chst mit Berechtigungen gef&uuml;llt
und anschlie&szlig;end gem&auml;&szlig; den Applikationsinformationen vorselektiert wird. Das Beispiel
ist aus dem im Release mitgelieferten
<a href="./?Seite=095-Module-Usermanagement" title="Usermanagement-Modul">Usermanagement-Modul</a>
entnommen.
<gen:highlight type="php">
// reference the form
$form = &$this->__getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</gen:highlight>
<br />
<h4 id="Chapter-3-3-Auslesen-von-Formular-Elementen"><a href="#Chapter-3-3-Auslesen-von-Formular-Elementen">3.3. Auslesen von Formular-Elementen</a></h4>
Das Auslesen von Formular-Elementen gestaltet sich &auml;hnlich wie das Bef&uuml;llen. Eine
Besonderheit stellen auch hier die Einfach- und Mehrfachselektionsfelder dar. Das folgende Code-Beispiel
zeigt, wie die Werte des unter 3.1 dargestellten Formulars im DocumentController ausgelesen werden
k&ouml;nnen:
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Edit = &$this->__getForm('UserEdit');

   // Hidden-Feld auslesen
   $UserID = &$Form__Edit->getFormElementByName('userid');
   echo $UserID->getAttribute('value');

   // FirstName-Feld auslesen
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   echo $FirstName->getAttribute('value');

   // LastName-Feld auslesen
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   echo $LastName->getAttribute('value');
</gen:highlight>
Um die selektierten Optionen eines Einfach- oder Mehrfachselektionsfeldes auszulesen, stehen die
Methoden <strong>getSelectedOption()</strong> und <strong>getSelectedOptions()</strong> zur
Verf&uuml;gung. Die folgende Codebox zeigt den Anwendungsfall:
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Create = &$this->__getForm('UserCreate');

   // Feld Salutation fuellen
   $Salutation = &$Form__Create->getFormElementByName('Salutation');
   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }

   // Salutation auslesen
   $Option = &$Salutation->getSelectedOption();
   echo $Option->getAttribute('value').', '.$Option->getContent();


   // Feld Group fuellen
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   // Gruppen auslesen
   $SelectedGroups = &$Group->getSelectedOptions();
   for($i = 0; $i < count($SelectedGroups); $i++){
      echo $SelectedGroups[$i]->getAttribute('value').', '.$SelectedGroups[$i]->getContent();
    // end for
   }
</gen:highlight>
<br />
<h3 id="Chapter-4-Dynamische-Formulare"><a href="#Chapter-4-Dynamische-Formulare">4. Dynamische Formulare</a></h3>
In einigen Anwendungsf&auml;llen ist es notwenig, Formulare dynamisch nach Anforderung zu erstellen.
Hierzu besitzt die Implementierung der Formular-TagLib (<em>html_taglib_form</em>) die Methoden
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
und seit dem Release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
an. Die ersten beiden Funktionen lassen sich dazu nutzen, Inhalte oder konkrete Formular-Elemente
an das Ende des Formulars anzuh&auml;ngen. Die zu letzt genannten Methoden sind dazu gedacht, Inhalte
oder Formular-Elemente an konkreten Stellen zu platzieren. Zur Positionierung steht das
<strong>&lt;form:marker /&gt;</strong>-Tag zur Verf&uuml;gung. Das Tag selbst generiert keine Ausgabe,
sondern dient lediglich als Positionierungshilfe.
<br />
<br />
Die folgenden Kapitel sollen zeigen, wie ein dynamisches Formular zur Eingabe von Form-Koordinaten
(Dreieck, Quadrat, ...) realisiert werden kann. Je nach Auswahl des Typs sollen die jeweils notwenigen
Felder angezeigt werden. Bei Auswahl des Typs "square" werden vier Felder angezeigt ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs square" />
<br />
<br />
... und bei Auswahl von "triangle" drei:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs triangle" />
<br />
<br />
<br />
<h4 id="Chapter-4-1-Formular-Definition"><a href="#Chapter-4-1-Formular-Definition">4.1. Formular-Definition</a></h4>
Bei der Definition des Formulars sollte bereits bedacht werden, welche Art der Formular-Generierung
angestrebt wird. Kommen die Methoden <em>addFormElement()</em> und/oder <em>addFormContent()</em>
zum Einsatz, ist keinen Marker erforderlich. In diesem Beispiel wird jedoch ein Marker eingesetzt, da
das Formular bereits Inhalte besitzt, die nach den dynamisch erzeugten Elementen angezeigt werden
sollen.
<br />
<br />
Die folgende Code-Box zeigt das notwenige Formular mit einem Auswahlfeld. Bei der Implementierung
wurde auf CSS-Formatierung verzichtet um die wesentlichen Elemente besser hervorheben zu k&ouml;nnen.
Das Formular besteht dabei aus einem statisch definierten Auswahlfeld, das den Typ der geometrischen
Form vorgibt und aus einem Marker-Tag, der als Positionierungshilfe f&uuml;r die dynamisch erzeugten
Felder dient. Weiterhin wird ein DocumentController definiert, der die gew&uuml;nschten Felder
dynamisch an der Stelle des Markers hinzuf&uuml;gt:
<gen:highlight type="apf-xml">
&lt;@controller namespace="..." file="..." class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h4 id="Chapter-4-2-Controller"><a href="#Chapter-4-2-Controller">4.2. Controller</a></h4>
Der DocumentController &uuml;bernimmt im beschriebenen Beispiel die Generierung der abh&auml;ngigen
Formularfelder, die je nach Auswahl angezeigt werden sollen. Hierzu wird im Controller zun&auml;chst
definiert, welche Formular-Felder f&uuml;r welchen Typ angezeigt werden. Anschlie&szlig;end wird
das Typ-Feld ausgewertet und das Formular mit Inhalten und Text-Feldern gem&auml;&szlig; Typ
erg&auml;nzt. Die folgende Code-Box zeigt die Implementierung des DocumentControllers:
<gen:highlight type="php">
class select_controller extends base_controller {

   // specify form element container
   var $__FormElements = array();

   function select_controller(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

   }

   function transformContent(){

      // get form reference
      $Form = &$this->__getForm('type');

      // get current decision
      $Select = &$Form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
      }
      else{
         $CurrentType = $Option->getAttribute('value');
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $Form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $CurrentElementID = $Form->addFormElementBeforeMarker(
                                          'fields',
                                          'form:text',
                                          array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                                                              );

         // configure further form element attributes
         $CurrentElement = &$Form->getFormElementByObjectID($CurrentElementID);
         $CurrentElement->setAttribute('style','width: 200px;');

         // add a line break
         $Form->addFormContentBeforeMarker('fields','<br />');

      }

      // display form
      $Form->transformOnPlace();

   }

}
</gen:highlight>
<br />
<h4 id="Chapter-4-3-Wichtige-Hinweise"><a href="#Chapter-4-3-Wichtige-Hinweise">4.3. Wichtige Hinweise</a></h4>
Ein APF-Formular-Element ben&ouml;tigt bereits bei der Erstellung des Objekts die Information &uuml;ber
den Namen des Feldes. Ist dieser nicht bekannt, kann es nicht vorausgef&uuml;llt oder validiert werden.
Um die Presetting und Validierung von Formular-Elementen nutzen zu k&ouml;nnen besitzen die Methoden
<em>addFormElement()</em>, <em>addFormElementBeforeMarker()</em> und <em>addFormElementBeforeMarker()</em>
einen optionalen, dritten Parameter. Dieser erwartet eine assoziative Liste von Tag-Attributen, die
dem Formular-Tag bei der Erstellung mitgegeben werden. Es daher sinnvoll, der Methode mindestens
den Namen des Feldes in der Form
<gen:highlight type="apf-xml">
array(
      'name' => 'current_name'
     )
</gen:highlight>
als drittes Argument mitzugeben. Dies kann unter Umst&auml;nden auch f&uuml;r die sp&auml;tere
Adressierung der Objekte &uuml;ber die Methoden <em>getFormElementByName()</em> und
<em>getFormElementByID()</em> von Interesse sein.
<br />
<br />
<br />
<h3 id="Chapter-5-Formular-Filter"><a href="#Chapter-5-Formular-Filter">5. Verwendung von Formular-Filtern</a></h3>
Seit dem 1.9er Zweig unterst&uuml;tzen die Formular-Elemente Filter. Als Basis f&uuml;r die Filterung
dienen die APF-Filter aus dem core-Namespace. Details zu den Filtern k&ouml;nnen dem Kapitel
<a href="./?Seite=087-Filter#Chapter-4-Aufbau-und-Funktion" title="Filter">Filter</a> entnommen werden.
<br />
<br />
Die Formular-Filter dienen dazu, die allgemeinen Eingabe-Filter (siehe
<a href="./?Seite=087-Filter#Chapter-5-Konfiguration" title="Konfiguration von Filtern">Konfiguration von Filtern</a>)
zu erweitern um in definierten Eingabefeldern nur gew&uuml;nschte Werte zu akzeptieren. Typisches
Anwendungsbeispiel ist die Filterung eines E-Mail-Eingabefeldes, das nur Zeichen, die dem regul&auml;ren
Ausdruck &quot;<strong>[a-z0-9-_@.]</strong>&quot; gen&uuml;gen, enthalten darf.
<br />
<br />
<br />
<h4 id="Chapter-5-1-Mitgelieferte-Filter"><a href="#Chapter-5-1-Mitgelieferte-Filter">5.1. Mitgelieferte Filter</a></h4>
Um die Arbeit mit Formular-Filtern zu erleichtern, wird bereits ein Satz an Filterm&ouml;glichkeiten
mitgeliefert. Die folgenden Filter-Aufgaben k&ouml;nnen von der Klasse <strong>FormFilter</strong>
aus dem Namespace <strong>tools::form::filter</strong> erledigt werden (Filter-Instructions):
<ul>
  <li><strong>string2Lower</strong>: Wandelt alle Gro&szlig;buchstaben in Kleinbuchstaben um.</li>
  <li><strong>string2Upper</strong>: Wandelt alle Kleinbuchstaben in Gro&szlig;buchstaben um.</li>
  <li><strong>stripTags</strong>: Verwirft Code-Tags</li>
  <li><strong>noSpecialCharacters</strong>: L&auml;sst keine Sonderzeichen zu.</li>
  <li><strong>onlyNumbers</strong>: L&auml;sst nur Zahlen zu.</li>
  <li><strong>onlyInteger</strong>: L&auml;sst nur Integer-Werte zu.</li>
  <li><strong>onlyLetters</strong>: L&auml;sst nur Buchstaben zu.</li>
  <li><strong>onlyHTMLEntities</strong>: Codiert alle HTML-Steuer-Zeichen.</li>
</ul>
<br />
<h4 id="Chapter-5-2-Anwendung"><a href="#Chapter-5-2-Anwendung">5.2. Anwendung</a></h4>
Die Anwendung der Filter gestaltet sich &auml;hnlich den Validatoren. Ist das Attribut
<strong>filter</strong> vorhanden, wird eine Filterung nach der im Wert des Attributs angegebenen
Filterinstruktion ausgef&uuml;hrt. Hierzu wird der Standard-Filter, wie im Kapitel 5.1. beschrieben,
verwendet.
<br />
<br />
Die folgende Code-Box zeigt die Anwendung von Filtern:
<gen:highlight type="apf-xml">
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="phone"
          filter="onlyNumbers"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
Beim Aufbau des Formulars wird der Inhalt des Feldes <strong>phone</strong> mit der Instruktion
<em>onlyNumbers</em> gefiltert. Beim Auslesen des Feldes kann der Entwickler nun sicher gehen, dass
sich keine unerlaubten Inhalte im Formularfeld befinden. Da die Filterung <em>vor</em> der Validierung
stattfindet, kann es nicht f&auml;lschlicherweise zu einer korrekten Validierung kommen.
<br />
<br />
<strong>Wichtig:</strong>
<ul>
  <li>
    Bitte beachten Sie, dass die Filter bisher nur auf Text-Eingabefelder angewendet werden
    k&ouml;nnen!
  </li>
  <li>
    Die Verkettung von Filtern wird in Kapitel
    <a href="#5-4-Verkettung-von-Filtern" title="5.4. Verkettung von Filtern">5.4. Verkettung von Filtern</a>
    besprochen.
  </li>
</ul>
<br />
<h4 id="Chapter-5-3-Erweiterung"><a href="#Chapter-5-3-Erweiterung">5.3. Erweiterung</a></h4>
Gen&uuml;gen die mitgelieferten Filter nicht, kann mit Hilfe des Attributes <strong>filterclass</strong>
eine andere Filter-Klasse f&uuml;r das Feld spezifiziert werden. Die Definition muss dabei in der
Form
<gen:highlight type="apf-xml">
filterclass="path::to::my::filter::class|MyFilterClassName"
</gen:highlight>
vorgenommen werden. Der erste Teil entspricht dem Namespace des Filters, der zweite dem Klasse- bzw.
Datei-Namens des Filters. Das Attribut <strong>filter</strong> beinhaltet auch bei Angabe einer
eigenen Filter-Klasse die Filter-Instruktion.
<br />
<br />
Wie im Kapitel
<a href="./?Seite=087-Filter#Chapter-4-Aufbau-und-Funktion" title="Aufbau und Funktion von Filtern">Aufbau und Funktion von Filtern</a>
beschrieben, muss eine Filter-Klasse immer (direkt oder indirekt) von <strong>AbstractFilter</strong>
erben und die Methode <strong>filter()</strong> implementieren. Die folgende Code-Box zeigt einen
Filter, der alle Vorkommen von &quot;cm^2&quot; durch &quot;cm&sup2;&quot; ersetzt:
<gen:highlight type="php">
class DefinitionFilter extends AbstractFormFilter {

   function filter($input){
      return str_replace('cm^2','cm&sup2;',$input);
   }

}
</gen:highlight>
<div class="hint">
   Im Fall von "normalen" Filtern (Ein- und Ausgabe-Filter) muss die Klasse <strong>AbstractFilter</strong>
   erweitert werden. F&uuml;r die Formular-Filter wurde nochmals eine weitere Basis-Klasse geschaffen,
   die sich um die Handhabung der Filter-Anweisungen k&uuml;mmert, die im Formular-Feld-Attribut
   <strong>filter</strong> mitgegeben wird. Dieser Wert wird in die interne Variable
   <em>$this->__Instruction</em> injiziert und steht beim Ausf&uuml;hren der Methode <em>filter()</em>
   zur Verf&uuml;gung.
</div>
<br />
Wie dem Beispiel zu entnehmen ist, kann in einfachen Anwendungsf&auml;llen, die Verwendung der
Filter-Instruktion zur Ablaufsteuerung entfallen. Dabei muss jedoch sichergestellt werden, dass das
Attribut <strong>filter</strong> einen nichtleeren (Dummy-)Werte enth&auml;lt.
<br />
<br />
Um einen Filter wiederverwendbar zu gestalten, ist es jedoch ratsam, gleichartige Filter-Funktionen
zusammenzufassen. Das folgende Beispiel zeigt einen Filter, der K&ouml;rperma&szlig;e filtert:
<gen:highlight type="php">
class MeasureFilter extends AbstractFormFilter {

   function filter($input){

      switch($this->__Instruction){

         case 'weight':
            $output = preg_replace('/[^0-9,.]/i','',$input);
         case 'size':
            $output = preg_replace('/[^0-9]/i','',$input);
         default:
            $output = $input;

      }

      return $output;

   }

}
</gen:highlight>
Die Anwendung des Filters gestaltet sich wie folgt:
<gen:highlight type="apf-xml">
&lt;html:form name="test" method="post"&gt;
  Name:
  &lt;form:text
          name="name"
          filter="noSpecialCharacters"
  /&gt;
  &lt;br /&gt;
  Weight:
  &lt;form:text
          name="weight"
          filterclass="my::special::filter|MeasureFilter"
          filter="weight"
  /&gt;
  kg
  &lt;br /&gt;
  Body size:
  &lt;form:area
          name="bodysize"
          filterclass="my::special::filter|MeasureFilter"
          filter="size"
  /&gt;
  cm
  &lt;br /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h4 id="Chapter-5-4-Verkettung-von-Filtern"><a href="#Chapter-5-4-Verkettung-von-Filtern">5.4. Verkettung von Filtern</a></h4>
Die Verkettung von Filtern kann &uuml;ber einen eigenen Filter abgebildet werden. Folgende Klasse,
die auch im Release enthalten ist, kann zur Bildung von Filterketten verwendet werden:
<gen:highlight type="php">
class MultiplexFormFilter extends FormFilter
{
   function filter($input){

      $instructionSet = explode('|',$this->__Instruction);
      $output = $input;

      foreach($instructionSet as $filterInstruction){
         $output = $this->{'__'.trim($filterInstruction)}($output);
      }

      return $output;

   }

}
</gen:highlight>
Die Verwendung gestaltet sich wie folgt:
<gen:highlight type="apf-xml">
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="specialfield"
          filterclass="tools::form::filter|MultiplexFormFilter"
          filter="noSpecialCharacters|string2Upper"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_011" />