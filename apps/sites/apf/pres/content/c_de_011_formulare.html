<doku:title parent="119" tags="forumlare,forums,aufbau,validierung,manipulation,befuellung,auslesen,dynamische formulare,controller" title="Formulare" urlname="Formulare">
  Diese Dokumentationsseite beschreibt den Aufbau und die Verwendung von Formularen so wie die
  Möglichkeiten, die sich aus dem APF-Form-Modell ergeben. Dazu zählen die Validierung und
  das Vorausfüllen sowie die Möglichkeit, Formular-Elemente (=Objekte) im Controller zu
  Manipulieren, zu befüllen oder diese auszulesen. In einem weiteren Kapitel wird beschrieben,
  wie dynamische Formulare erstellt werden können.
</doku:title>
<div class="warn">
   Diese Seite dokumentiert die Formular-Unterstützung des APF <strong>bis einschließlich der
   Version 1.10</strong>. In Release 1.11 wurde die Formular-Integration vollständig überarbeitet.
   Die neue Dokumentation findet sich nun im Kapitel <int:link pageid="113" />.
</div>
<div class="hint">
   Die bis zum Release 1.10 enthaltenen Formular-Taglibs sind unter <int:link pageid="130" />
   dokumentiert.
</div>
Das Adventure PHP Framework unterstützt die dynamische Generierung und Abstraktion von Formularen
out-of-the-box. Durch den generischen Tag-Parser können Formulare durch Tags in Templates und die
entsprechenden DOM-Objekte im Objektbaum der Präsentations-Schicht abgebildet werden. Dadurch ist
es möglich Formular-Elementen "interne Intelligenz" mitzugeben. Hierrunter fällt das
automatische Ausfüllen anhand eines URL-Parameters und die Validierung von Benutzereingaben. Dies
beiden Features können einfach durch die Definition des Verhaltens in den Templates gesteuert
werden und der Entwickler benötigt keine weiteren Hilfmittel und Logiken mehr.
<br />
<br />
<br />
<h3 id="Chapter-1-Aufbau-von-Formularen"><a href="#Chapter-1-Aufbau-von-Formularen">1. Aufbau von Formularen</a></h3>
Formulare werden im Framework wie Templates behandelt und sind Kinder eines Baum-Knotens. Mit der
Methode <strong>__getForm()</strong> kann innerhalb eines Document-Controllers auf ein Formular
zugegriffen werden. Das Formular unterstützt folgende wichtige Funktionen:
<ul>
  <li>
    <strong>addFormElement()</strong>
    <br />
    Fügt ein Formular-Element zum Formular hinzu. Die Methode ist für
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContent()</strong>
    <br />
    Fügt (HTML-/Text-)Inhalt zum Formular hinzu. Die Methode ist für
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContentBeforeMarker()</strong>
    <br />
    Fügt (HTML-/Text-)Inhalt vor einem Marker-Tag zum Formular hinzu. Die Methode ist für
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormContentAfterMarker()</strong>
    <br />
    Fügt (HTML-/Text-)Inhalt nach einem Marker-Tag zum Formular hinzu. Die Methode ist für
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormElementBeforeMarker()</strong>
    <br />
    Fügt ein Formular-Element vor einem Marker-Tag zum Formular hinzu. Die Methode ist für
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>addFormElementAfterMarker()</strong>
    <br />
    Fügt ein Formular-Element nach einem Marker-Tag zum Formular hinzu. Die Methode ist für
    die dynamische Generierung von Formularen gedacht.
  </li>
  <li>
    <strong>setPlaceHolder()</strong>
    <br />
    Füllt einen angegebenen Platzhalter mit einem Wert.
  </li>
  <li>
    <strong>setAction()</strong>
    <br />
    Setzt das "action"-Attribut des Formulars.
  </li>
  <li>
    <strong>getFormElementByName()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zurück.
  </li>
  <li>
    <strong>getFormElementByID()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zurück.
  </li>
  <li>
    <strong>getFormElementByObjectID()</strong>
    <br />
    Gibt eine Referenz auf ein Formular-Objekt zurück.
  </li>
  <li>
    <strong>getFormElementsByTagName()</strong>
    <br />
    Gibt eine Liste von Formular-Element-Referenzen zurück, die dem übergebenen Tag-Namen
    (z.B. <em>form:text</em>) entsprechen.
  </li>
  <li>
    <strong>transformForm()</strong>
    <br />
    Erzeugt die HTML-Ausgabe eines Formular-Objekts und gibt diese zurück.
  </li>
  <li>
    <strong>transformOnPlace()</strong>
    <br />
    Definiert, dass das Formular an der Stelle, an der es im Template-File definiert wurde ausgegeben
    wird. Damit ist es nicht mehr nötigt, das Formular per <em>transformForm()</em> zu transformieren
    und in einen Platzhalter einzusetzen.
  </li>
</ul>
Um ein Formular in einer Template-Datei zu definieren muss zuerst per
<gen:highlight type="apf-xml">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
</gen:highlight>
<strong>vor</strong> der Verwendung hinzugefügt werden. Anschließend kann beispielsweise
ein Formular einer Login-Maske definiert werden:
<gen:highlight type="apf-xml">
  &lt;html:form name="AdminLogin" method="post" action=""&gt;
    &lt;form:placeholder name="LogInError" /&gt;
    Benutzer: &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    Passwort: &lt;form:password name="Password" class="eingabe_feld" style="width: 200px; margin-left: 16px;"
    validate="true" button="AdminLogin" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="AdminLogin" value="Login" class="eingabe_feld" style="margin-left: 227px;"/&gt;
  &lt;/html:form&gt;
</gen:highlight>
In Prosa: das Formular definiert die Attribute <strong>name</strong>, damit im Controller später
auf dieses zugegriffen werden kann, <strong>method</strong> um die Methode des Abschickens zu
definieren und <strong>action</strong> um die Ziel-URL zu definieren. Letzteres muss in der Template-
Datei nicht zwingend gesetzt werden, da die TagLib dieses selbst mit der aktuellen URL setzt oder
füllt, falls es nicht vorhanden ist.
<br />
<br />
Innerhalb des Formulars werden viel Formular-Elemente definiert: ein Platzhalter, für die Aufnahme
von Hinweistexten, ein Text- und ein Passwort-Feld und ein Button. Diese sind jeweils mit den unter
<int:link pageid="046" /> beschriebenen Attributen
ausgestattet. Im Document-Controller kann nun per
<gen:highlight type="php">
$Form__AdminLogin = &$this->getForm('AdminLogin');
</gen:highlight>
eine Referenz auf das Formular geholt werden. Anschließend kann per
<gen:highlight type="php">
$Form__AdminLogin->setPlaceHolder('...','Login failed!');
</gen:highlight>
der Inhalt des Platzhalters manipuliert oder mit
<gen:highlight type="php">
  if($Form__AdminLogin->get('isValid') && $Form__AdminLogin->get('isSent')){

     // Aktion ausführen, die bei abgeschicktem und
     // valide ausgefülltem Formular passieren soll...

   // end if
  }
</gen:highlight>
abgefragt werden, ob das Formular abgeschickt wurden und die Eingaben valide sind.
<br />
<br />
Um das Formular auszugeben gibt es zwei Möglichkeiten: Ausgabe über einen im Template-File
definierten Platzhalter oder Verwendung von <em>transformOnPlace()</em>:
<gen:highlight type="php">
public function transformContent(){

   ...

   // Formular transformieren und in einen Platzhalter einsetzen ...
   $this->setPlaceHolder('...',$Form__AdminLogin->transformForm());

   // ... oder das Formular an der Definitionsstelle ausgeben
   $Form__AdminLogin->tranformOnPlace();

   ...

}
</gen:highlight>
<br />
<h3 id="Chapter-2-Validierung"><a href="#Chapter-2-Validierung">2. Validierung</a></h3>
Wie bereits erwähnt ist die Validierung von Formular-Feldern bereits out-of-the-box möglich.
Hierzu muss ein Formular-Feld lediglich um die Attribute
<ul>
  <li>validate</li>
  <li>validator</li>
  <li>button</li>
</ul>
wie unter <int:link pageid="046" />, Kapitel 2.3.,
beschrieben, erweitert werden. Für die Validierung des oben genannten Login-Formulars muss das
Textfeld wie folgt definiert werden:
<gen:highlight type="apf-xml">
  &lt;form:text name="Username" validate="true" button="AdminLogin" /&gt;
</gen:highlight>
Wichtig ist die Angabe des Button-Namens, da das Formular erst nach dem Abschicken validiert werden
soll. Ist das Button-Attribut nicht gesetzt, wird von der TagLib ein Fehler ausgegeben. Zur
Ausgabe-Formatierung kann dieser Tag um weitere Attribute wie "class" und style" erweitert werden.
<gen:highlight type="apf-xml">
  &lt;form:text name="Username" class="eingabe_feld" style="width: 200px; margin-left: 20px;"
  validate="true" button="AdminLogin" /&gt;
</gen:highlight>
Ist das Attribut "validator" nicht gesetzt, so wird der Standard-Validator verwendet, der prüft,
ob das Feld exakt oder mehr als 3 Zeichen enthält.
<br />
<br />
<div class="hint">
Soll zusätzlich zu einer roten Umrandung der Felder noch eine Meldung angezeigt werden, so kann
im Bereich des Eingabe-Feldes noch ein zusätzliches
<int:link pageid="130" anchor="Chapter-18-Generischer-Validator">&lt;form:genericval /&gt;</int:link>-Tag
platziert werden. Dieses gibt bei nicht erfolgreicher Validierung des angegebenen Feldes eine Text
aus.
</div>
<br />
<br />
<h3 id="Chapter-3-Manipulation-von-Formularelementen"><a href="#Chapter-3-Manipulation-von-Formularelementen">3. Manipulation von Formularwerten</a></h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige Möglichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen häufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<h4 id="Chapter-3-1-Vorbefuellung"><a href="#Chapter-3-1-Vorbefuellung">3.1. Vorbefüllung von Formularen</a></h4>
Zur Vorbefüllung von Formularen (z.B. in einem Bearbeiten-Dialog) können Methoden
<strong>getFormElementByID()</strong>, <strong>getFormElementByID()</strong> oder
<strong>getFormElementByObjectID()</strong> eingesetzt werden um eine Referenz auf ein Formular-Element
zu beziehen. Anschließend stehen die Standard-Methoden <strong>get()</strong> und
<strong>getAttribute()</strong>, bzw. <strong>set()</strong> und <strong>setAttribute()</strong> zur
Verfügung.
<br />
<br />
Die folgenden Codebox definiert ein Beispiel-Formular, das im anschließend
abgedruckten PHP-Code befüllt wird:
<br />
<gen:highlight type="apf-xml">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserEdit" method="post"&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</gen:highlight>
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Edit = &$this->getForm('UserEdit');

   // Referenz auf das Hidden-Feld beziehen und Wert befuellen
   $UserID = &$Form__Edit->getFormElementByName('userid');
   $UserID->setAttribute('value','...');

   // Referenz auf das FirstName-Feld beziehen und Wert befuellen
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   $FirstName->setAttribute('value','...');

   // Referenz auf das LastName-Feld beziehen und Wert befuellen
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   $LastName->setAttribute('value','...');
</gen:highlight>
<br />
<h4 id="Chapter-3-2-Befuellen-von-Select-Feldern"><a href="#Chapter-3-2-Befuellen-von-Select-Feldern">3.2. Befüllen von Select-Feldern</a></h4>
Die Behandlung Select- und Multiselect-Feldern unterscheidet sich ein wenig von einfachen
Formular-Elementen. Das Framework stellt jedoch auch hier Methoden zur Verfügung, mit denen das
Befüllen von Feldern vereinfacht wird. Im nachfolgend aufgeführten Code wird ein Formular
vorausgefüllt, das zusätzlich zu den Standard-Text-Felder auch Auswahlfelder beinhaltet:
<gen:highlight type="apf-xml">
  &lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
  &lt;html:form name="UserCreate" method="post"&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;form:select name="Salutation" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;FirstName&lt;/strong&gt;:
    &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;strong&gt;LastName&lt;/strong&gt;:
    &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;strong&gt;Salutation&lt;/strong&gt;:
    &lt;br /&gt;
    &lt;form:multiselect name="Group[]" validate="true" button="Edit" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;form:button name="Edit" value="Save" /&gt;
    &lt;form:hidden name="userid" /&gt;
  &lt;/html:form&gt;
</gen:highlight>
Wie in der Definition des Multiselect-Feldes <strong>Groups[]</strong> zu sehen ist, müssen bei
einem Multiselect-Feld die Namen eckigen Klammern versehen werden. Vergisst der Template-Entwickler
dies, wird eine entsprechende Fehlermeldung ausgegeben.
<br />
<br />
Der folgende PHP-Code befüllt das Formular:
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Create = &$this->getForm('UserCreate');

   ...

   // Referenz auf das Salutation-Feld beziehen und Wert befuellen
   $Salutation = &$Form__Create->getFormElementByName('Salutation');

   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }


   // Referenz auf das Groups[]-Feld beziehen und Werte befuellen
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   ...
</gen:highlight>
<strong>Hinweis:</strong> Sollen beim Befüllen eines Multiselect-Feldes bestimmte Optionen
bereits vorausgewählt sein, so kann die Methode <strong>setOption2Selected()</strong> verwendet
werden. Der folgende Code zeigt, wie ein Multiselect-Feld zunächst mit Berechtigungen gefüllt
und anschließend gemäß den Applikationsinformationen vorselektiert wird. Das Beispiel
ist aus dem im Release mitgelieferten
<a href="./?Seite=095-Module-Usermanagement" title="Usermanagement-Modul">Usermanagement-Modul</a>
entnommen.
<gen:highlight type="php">
// reference the form
$form = &$this->getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</gen:highlight>
<br />
<h4 id="Chapter-3-3-Auslesen-von-Formular-Elementen"><a href="#Chapter-3-3-Auslesen-von-Formular-Elementen">3.3. Auslesen von Formular-Elementen</a></h4>
Das Auslesen von Formular-Elementen gestaltet sich ähnlich wie das Befüllen. Eine
Besonderheit stellen auch hier die Einfach- und Mehrfachselektionsfelder dar. Das folgende Code-Beispiel
zeigt, wie die Werte des unter 3.1 dargestellten Formulars im Document-Controller ausgelesen werden
können:
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Edit = &$this->getForm('UserEdit');

   // Hidden-Feld auslesen
   $UserID = &$Form__Edit->getFormElementByName('userid');
   echo $UserID->getAttribute('value');

   // FirstName-Feld auslesen
   $FirstName = &$Form__Edit->getFormElementByName('FirstName');
   echo $FirstName->getAttribute('value');

   // LastName-Feld auslesen
   $LastName = &$Form__Edit->getFormElementByName('LastName');
   echo $LastName->getAttribute('value');
</gen:highlight>
Um die selektierten Optionen eines Einfach- oder Mehrfachselektionsfeldes auszulesen, stehen die
Methoden <strong>getSelectedOption()</strong> und <strong>getSelectedOptions()</strong> zur
Verfügung. Die folgende Codebox zeigt den Anwendungsfall:
<gen:highlight type="php">
   // Referenz auf das Form-Objekt beziehen
   $Form__Create = &$this->getForm('UserCreate');

   // Feld Salutation fuellen
   $Salutation = &$Form__Create->getFormElementByName('Salutation');
   for($i = 0; $i < count($Salutations); $i++){
      $Salutation->addOption($Salutations[$i]['Value'],$Salutations[$i]['DisplayName']);
    // end for
   }

   // Salutation auslesen
   $Option = &$Salutation->getSelectedOption();
   echo $Option->getAttribute('value').', '.$Option->getContent();


   // Feld Group fuellen
   $Group = &$Form__Create->getFormElementByName('Groups[]');

   for($i = 0; $i < count($Groups); $i++){
      $Group->addOption($Groups[$i]['Value'],$Groups[$i]['DisplayName']);
    // end for
   }

   // Gruppen auslesen
   $SelectedGroups = &$Group->getSelectedOptions();
   for($i = 0; $i < count($SelectedGroups); $i++){
      echo $SelectedGroups[$i]->getAttribute('value').', '.$SelectedGroups[$i]->getContent();
    // end for
   }
</gen:highlight>
<br />
<h3 id="Chapter-4-Dynamische-Formulare"><a href="#Chapter-4-Dynamische-Formulare">4. Dynamische Formulare</a></h3>
In einigen Anwendungsfällen ist es notwenig, Formulare dynamisch nach Anforderung zu erstellen.
Hierzu besitzt die Implementierung der Formular-TagLib (<em>html_taglib_form</em>) die Methoden
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
und seit dem Release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
an. Die ersten beiden Funktionen lassen sich dazu nutzen, Inhalte oder konkrete Formular-Elemente
an das Ende des Formulars anzuhängen. Die zu letzt genannten Methoden sind dazu gedacht, Inhalte
oder Formular-Elemente an konkreten Stellen zu platzieren. Zur Positionierung steht das
<strong>&lt;form:marker /&gt;</strong>-Tag zur Verfügung. Das Tag selbst generiert keine Ausgabe,
sondern dient lediglich als Positionierungshilfe.
<br />
<br />
Die folgenden Kapitel sollen zeigen, wie ein dynamisches Formular zur Eingabe von Form-Koordinaten
(Dreieck, Quadrat, ...) realisiert werden kann. Je nach Auswahl des Typs sollen die jeweils notwenigen
Felder angezeigt werden. Bei Auswahl des Typs "square" werden vier Felder angezeigt ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs square" />
<br />
<br />
... und bei Auswahl von "triangle" drei:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs triangle" />
<br />
<br />
<br />
<h4 id="Chapter-4-1-Formular-Definition"><a href="#Chapter-4-1-Formular-Definition">4.1. Formular-Definition</a></h4>
Bei der Definition des Formulars sollte bereits bedacht werden, welche Art der Formular-Generierung
angestrebt wird. Kommen die Methoden <em>addFormElement()</em> und/oder <em>addFormContent()</em>
zum Einsatz, ist keinen Marker erforderlich. In diesem Beispiel wird jedoch ein Marker eingesetzt, da
das Formular bereits Inhalte besitzt, die nach den dynamisch erzeugten Elementen angezeigt werden
sollen.
<br />
<br />
Die folgende Code-Box zeigt das notwenige Formular mit einem Auswahlfeld. Bei der Implementierung
wurde auf CSS-Formatierung verzichtet um die wesentlichen Elemente besser hervorheben zu können.
Das Formular besteht dabei aus einem statisch definierten Auswahlfeld, das den Typ der geometrischen
Form vorgibt und aus einem Marker-Tag, der als Positionierungshilfe für die dynamisch erzeugten
Felder dient. Weiterhin wird ein Document-Controller definiert, der die gewünschten Felder
dynamisch an der Stelle des Markers hinzufügt:
<gen:highlight type="apf-xml">
&lt;@controller namespace="..." [file="..."] class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h4 id="Chapter-4-2-Controller"><a href="#Chapter-4-2-Controller">4.2. Controller</a></h4>
Der Document-Controller übernimmt im beschriebenen Beispiel die Generierung der abhängigen
Formularfelder, die je nach Auswahl angezeigt werden sollen. Hierzu wird im Controller zunächst
definiert, welche Formular-Felder für welchen Typ angezeigt werden. Anschließend wird
das Typ-Feld ausgewertet und das Formular mit Inhalten und Text-Feldern gemäß Typ
ergänzt. Die folgende Code-Box zeigt die Implementierung des Document-Controllers:
<gen:highlight type="php">
class select_controller extends base_controller {

   // specify form element container
   private $__FormElements = array();

   public function __construct(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

   }

   public function transformContent(){

      // get form reference
      $Form = &$this->getForm('type');

      // get current decision
      $Select = &$Form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
      }
      else{
         $CurrentType = $Option->getAttribute('value');
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $Form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $CurrentElementID = $Form->addFormElementBeforeMarker(
                                          'fields',
                                          'form:text',
                                          array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                                                              );

         // configure further form element attributes
         $CurrentElement = &$Form->getFormElementByObjectID($CurrentElementID);
         $CurrentElement->setAttribute('style','width: 200px;');

         // add a line break
         $Form->addFormContentBeforeMarker('fields','<br />');

      }

      // display form
      $Form->transformOnPlace();

   }

}
</gen:highlight>
<br />
<h4 id="Chapter-4-3-Wichtige-Hinweise"><a href="#Chapter-4-3-Wichtige-Hinweise">4.3. Wichtige Hinweise</a></h4>
Ein APF-Formular-Element benötigt bereits bei der Erstellung des Objekts die Information über
den Namen des Feldes. Ist dieser nicht bekannt, kann es nicht vorausgefüllt oder validiert werden.
Um die Presetting und Validierung von Formular-Elementen nutzen zu können besitzen die Methoden
<em>addFormElement()</em>, <em>addFormElementBeforeMarker()</em> und <em>addFormElementBeforeMarker()</em>
einen optionalen, dritten Parameter. Dieser erwartet eine assoziative Liste von Tag-Attributen, die
dem Formular-Tag bei der Erstellung mitgegeben werden. Es daher sinnvoll, der Methode mindestens
den Namen des Feldes in der Form
<gen:highlight type="apf-xml">
array(
      'name' => 'current_name'
     )
</gen:highlight>
als drittes Argument mitzugeben. Dies kann unter Umständen auch für die spätere
Adressierung der Objekte über die Methoden <em>getFormElementByName()</em> und
<em>getFormElementByID()</em> von Interesse sein.
<br />
<br />
<br />
<h3 id="Chapter-5-Formular-Filter"><a href="#Chapter-5-Formular-Filter">5. Verwendung von Formular-Filtern</a></h3>
Seit dem 1.9er Zweig unterstützen die Formular-Elemente Filter. Als Basis für die Filterung
dienen die APF-Filter aus dem core-Namespace. Details zu den Filtern können dem Kapitel
<a href="./?Seite=087-Filter#Chapter-4-Aufbau-und-Funktion" title="Filter">Filter</a> entnommen werden.
<br />
<br />
Die Formular-Filter dienen dazu, die allgemeinen Eingabe-Filter (siehe
<a href="./?Seite=087-Filter#Chapter-5-Konfiguration" title="Konfiguration von Filtern">Konfiguration von Filtern</a>)
zu erweitern um in definierten Eingabefeldern nur gewünschte Werte zu akzeptieren. Typisches
Anwendungsbeispiel ist die Filterung eines E-Mail-Eingabefeldes, das nur Zeichen, die dem regulären
Ausdruck &quot;<strong>[a-z0-9-_@.]</strong>&quot; genügen, enthalten darf.
<br />
<br />
<br />
<h4 id="Chapter-5-1-Mitgelieferte-Filter"><a href="#Chapter-5-1-Mitgelieferte-Filter">5.1. Mitgelieferte Filter</a></h4>
Um die Arbeit mit Formular-Filtern zu erleichtern, wird bereits ein Satz an Filtermöglichkeiten
mitgeliefert. Die folgenden Filter-Aufgaben können von der Klasse <strong>FormFilter</strong>
aus dem Namespace <strong>tools::form::filter</strong> erledigt werden (Filter-Instructions):
<ul>
  <li><strong>string2Lower</strong>: Wandelt alle Großbuchstaben in Kleinbuchstaben um.</li>
  <li><strong>string2Upper</strong>: Wandelt alle Kleinbuchstaben in Großbuchstaben um.</li>
  <li><strong>stripTags</strong>: Verwirft Code-Tags</li>
  <li><strong>noSpecialCharacters</strong>: Lässt keine Sonderzeichen zu.</li>
  <li><strong>onlyNumbers</strong>: Lässt nur Zahlen zu.</li>
  <li><strong>onlyInteger</strong>: Lässt nur Integer-Werte zu.</li>
  <li><strong>onlyLetters</strong>: Lässt nur Buchstaben zu.</li>
  <li><strong>onlyHTMLEntities</strong>: Codiert alle HTML-Steuer-Zeichen.</li>
</ul>
<br />
<h4 id="Chapter-5-2-Anwendung"><a href="#Chapter-5-2-Anwendung">5.2. Anwendung</a></h4>
Die Anwendung der Filter gestaltet sich ähnlich den Validatoren. Ist das Attribut
<strong>filter</strong> vorhanden, wird eine Filterung nach der im Wert des Attributs angegebenen
Filterinstruktion ausgeführt. Hierzu wird der Standard-Filter, wie im Kapitel 5.1. beschrieben,
verwendet.
<br />
<br />
Die folgende Code-Box zeigt die Anwendung von Filtern:
<gen:highlight type="apf-xml">
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="phone"
          filter="onlyNumbers"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
Beim Aufbau des Formulars wird der Inhalt des Feldes <strong>phone</strong> mit der Instruktion
<em>onlyNumbers</em> gefiltert. Beim Auslesen des Feldes kann der Entwickler nun sicher gehen, dass
sich keine unerlaubten Inhalte im Formularfeld befinden. Da die Filterung <em>vor</em> der Validierung
stattfindet, kann es nicht fälschlicherweise zu einer korrekten Validierung kommen.
<br />
<br />
<strong>Wichtig:</strong>
<ul>
  <li>
    Bitte beachten Sie, dass die Filter bisher nur auf Text-Eingabefelder angewendet werden
    können!
  </li>
  <li>
    Die Verkettung von Filtern wird in Kapitel
    <a href="#5-4-Verkettung-von-Filtern" title="5.4. Verkettung von Filtern">5.4. Verkettung von Filtern</a>
    besprochen.
  </li>
</ul>
<br />
<h4 id="Chapter-5-3-Erweiterung"><a href="#Chapter-5-3-Erweiterung">5.3. Erweiterung</a></h4>
Genügen die mitgelieferten Filter nicht, kann mit Hilfe des Attributes <strong>filterclass</strong>
eine andere Filter-Klasse für das Feld spezifiziert werden. Die Definition muss dabei in der
Form
<gen:highlight type="apf-xml">
filterclass="path::to::my::filter::class|MyFilterClassName"
</gen:highlight>
vorgenommen werden. Der erste Teil entspricht dem Namespace des Filters, der zweite dem Klasse- bzw.
Datei-Namens des Filters. Das Attribut <strong>filter</strong> beinhaltet auch bei Angabe einer
eigenen Filter-Klasse die Filter-Instruktion.
<br />
<br />
Wie im Kapitel
<a href="./?Seite=087-Filter#Chapter-4-Aufbau-und-Funktion" title="Aufbau und Funktion von Filtern">Aufbau und Funktion von Filtern</a>
beschrieben, muss eine Filter-Klasse immer (direkt oder indirekt) von <strong>AbstractFilter</strong>
erben und die Methode <strong>filter()</strong> implementieren. Die folgende Code-Box zeigt einen
Filter, der alle Vorkommen von &quot;cm^2&quot; durch &quot;cm&sup2;&quot; ersetzt:
<gen:highlight type="php">
class DefinitionFilter extends AbstractFormFilter {

   function filter($input){
      return str_replace('cm^2','cm&sup2;',$input);
   }

}
</gen:highlight>
<div class="hint">
   Im Fall von "normalen" Filtern (Ein- und Ausgabe-Filter) muss die Klasse <strong>AbstractFilter</strong>
   erweitert werden. Für die Formular-Filter wurde nochmals eine weitere Basis-Klasse geschaffen,
   die sich um die Handhabung der Filter-Anweisungen kümmert, die im Formular-Feld-Attribut
   <strong>filter</strong> mitgegeben wird. Dieser Wert wird in die interne Variable
   <em>$this->__Instruction</em> injiziert und steht beim Ausführen der Methode <em>filter()</em>
   zur Verfügung.
</div>
<br />
Wie dem Beispiel zu entnehmen ist, kann in einfachen Anwendungsfällen, die Verwendung der
Filter-Instruktion zur Ablaufsteuerung entfallen. Dabei muss jedoch sichergestellt werden, dass das
Attribut <strong>filter</strong> einen nichtleeren (Dummy-)Werte enthält.
<br />
<br />
Um einen Filter wiederverwendbar zu gestalten, ist es jedoch ratsam, gleichartige Filter-Funktionen
zusammenzufassen. Das folgende Beispiel zeigt einen Filter, der Körpermaße filtert:
<gen:highlight type="php">
class MeasureFilter extends AbstractFormFilter {

   function filter($input){

      switch($this->__Instruction){

         case 'weight':
            $output = preg_replace('/[^0-9,.]/i','',$input);
         case 'size':
            $output = preg_replace('/[^0-9]/i','',$input);
         default:
            $output = $input;

      }

      return $output;

   }

}
</gen:highlight>
Die Anwendung des Filters gestaltet sich wie folgt:
<gen:highlight type="apf-xml">
&lt;html:form name="test" method="post"&gt;
  Name:
  &lt;form:text
          name="name"
          filter="noSpecialCharacters"
  /&gt;
  &lt;br /&gt;
  Weight:
  &lt;form:text
          name="weight"
          filterclass="my::special::filter|MeasureFilter"
          filter="weight"
  /&gt;
  kg
  &lt;br /&gt;
  Body size:
  &lt;form:area
          name="bodysize"
          filterclass="my::special::filter|MeasureFilter"
          filter="size"
  /&gt;
  cm
  &lt;br /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h4 id="Chapter-5-4-Verkettung-von-Filtern"><a href="#Chapter-5-4-Verkettung-von-Filtern">5.4. Verkettung von Filtern</a></h4>
Die Verkettung von Filtern kann über einen eigenen Filter abgebildet werden. Folgende Klasse,
die auch im Release enthalten ist, kann zur Bildung von Filterketten verwendet werden:
<gen:highlight type="php">
class MultiplexFormFilter extends FormFilter
{
   function filter($input){

      $instructionSet = explode('|',$this->__Instruction);
      $output = $input;

      foreach($instructionSet as $filterInstruction){
         $output = $this->{'__'.trim($filterInstruction)}($output);
      }

      return $output;

   }

}
</gen:highlight>
Die Verwendung gestaltet sich wie folgt:
<gen:highlight type="apf-xml">
&lt;html:form name="get_phone_number"&gt;
  Your phone number:
  &lt;form:text
          name="specialfield"
          filterclass="tools::form::filter|MultiplexFormFilter"
          filter="noSpecialCharacters|string2Upper"
  /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_011" />