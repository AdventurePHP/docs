<doku:title parent="071" tags="taglibs,specific,user" title="User specific taglibs" urlname="User-specific-taglibs">
  The present tutorial describes how user specific taglibs can be created. Beneath some theoretical
  description, real world examples are presented.
</doku:title>
<div class="warn">
   The documentation on this page is only valid for releases &lt;= 1.15. Please refer to <int:link pageid="147"/> for
   documentation since 1.16.
</div>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   The present page controller implementation creates a DOM tree while parsing templates. The
   functionality of each DOM node is defined within a taglib class. These taglib classes are based on
   the class <em>Document</em> that inherits from the central class <em>APFObject</em>. The class
   <em>Document</em> features the central parser method <em>__extractTagLibTags()</em> that searches a
   template file for known taglibs. Every XML tag generates another child node of the current DOM node.
   The XML attributes are added to the attribute list of the taglib implementation so that the taglib
   class can make use of them.
</p>

<h3 id="Chapter-2-Structure-of-a-taglib"><a href="#Chapter-2-Structure-of-a-taglib">2. Structure of a taglib</a></h3>
<p>
   Every XML tag listed under <int:link pageid="046" />
   is represented by a taglib class. This class implements the interface methods defined in the class
   <em>Document</em> or <em>APFObject</em> respectively.
</p>
<p>
   Every taglib class name must contain the part "<strong>_taglib_</strong>" between the prefix and the
   class description. If the developer is likely to introduce the XML tag
</p>
<gen:highlight type="apf-xml">
&lt;shop:basket /&gt;
</gen:highlight>
to one of the templates, the taglib class must be named
<gen:highlight type="php">
shop_taglib_basket
</gen:highlight>
<p>
   The part of the name that is marked with green color is called <strong>prefix</strong> the blue one
   is named <strong>class</strong>. Both parts can be chosen freely. Though it is recommended to
   structure the tags according to their dependency. Given the fact that the
   <strong>&lt;shop:basket /&gt;</strong> tag contains various sub tags and these sub tags should have the
   prefix <strong>basket</strong>. The following example shows this naming convention:
</p>
<gen:highlight type="apf-xml">
&lt;shop:basket&gt;
 &lt;basket:title /&gt;
 &lt;basket:products&gt;
   &lt;products:listing /&gt;
   &lt;products:sum /&gt;
 &lt;/basket:products&gt;
&lt;/shop:basket&gt;
</gen:highlight>
<p>
   The example implies, that during parsing of the <strong>&lt;shop:basket /&gt;</strong> tag, the sub tags
   should be parsed into child DOM objects, too. For this reason the constructor of the taglib
   implementation of the <strong>shop_taglib_basket</strong> must contain the definition of the known
   sub taglibs:
</p>
<gen:highlight type="php">
class shop_taglib_basket extends Document {

   public function __construct() {
      $this->__TagLibs[] = new TagLib('namespace::to::taglib','basket','title');
      $this->__TagLibs[] = new TagLib('namespace::to::taglib','basket','products');
   }

   [..]

}
</gen:highlight>
<p>
   Same rule applies for the implementation of the <strong>&lt;basket:products /&gt;</strong> tag (taglib
   class <strong>basket_taglib_products</strong>). Here the constructor must declare the tags
   <strong>&lt;products:listing /&gt;</strong> and <strong>&lt;products:sum /&gt;</strong>.
</p>

<h4 id="Chapter-2-1-Class-members"><a href="#Chapter-2-1-Class-members">2.1. Class member variables</a></h4>
<p>
   During parsing of the XML / HTML code within the template files known tags will be mapped to DOM
   objects. The content of the
</p>
<gen:highlight type="apf-xml">
&lt;php:highlight&gt;
   $var = 'value';
&lt;/php:highlight&gt;
</gen:highlight>
<p>
   tag will be stored in the private class member variable <strong>$this->__Content</strong>. The
   attributes of the tag are stored in the associative array <strong>$this->__Attributes</strong>. Due
   to that behavior the developer can access the attributes and content of the tag easily and the tags
   can be configured using XML / HTML attributes. Another advantage is that the tags can be configured
   with any attributes such as "class" or "style". This lightens the formatting of UI elements such as
   text fields or buttons independent of the PHP code.
</p>
<p>
   The private member variable <strong>$this->__ParentObject</strong> stores the reference to the parent
   object of the current node. Due to the fact, that the parent object inherits from <em>APFObject</em>,
   the methods <em>getParentObject()</em> and <em>getAttribute()</em> can be used to gather
   properties of the parent class instance. The detailed documentation of these methods can be seen
   in the <int:link pageid="002" />. Here the classes <em>Document</em> and <em>APFObject</em> are
   important.
</p>

<h4 id="Chapter-2-2-Class-methods"><a href="#Chapter-2-2-Class-methods">2.2. Class methods</a></h4>
<p>
   To implement functionality to a present taglib class there are several interface methods that are
   executed concerning a special page controller timing model. These functions have different meaning,
   too. Beside the interface methods, the developer can design the class methods freely. Please attend
   to the following points:
</p>
<ul>
  <li>
    <strong>Class declaration:</strong>
    <p>
       Each taglib class must inherit from the <em>Document</em> class, because this class is the
       interface class that serves the central parser method. The class name depends on the XML tag name
       as described above. To have an XML tag that is named <em>&lt;php:highlight /&gt;</em>, the first part of the name
       (prefix) must be "php", the middle part the common string "_taglib_" and the XML class string is
       "highlight". This leads to the taglib class name<strong>php_taglib_highlight</strong>. If this
       taglib is announced using the <strong>&lt;core:addtaglib /&gt;</strong> tag the parser searches
       for this tag in the current template file. Moreover, it is important that the file name is
       identical to the class name.
    </p>
  </li>
  <li>
    <strong>Constructor:</strong>
    <p>
       The constructor is intended to contain initializing of member variables or things like that. The
       constructor is given no argument. When no initializing must happen there must not be a constructor.
    </p>
    <p>
       In common the constructor should be uses to define known taglibs to the current DOM node, that
       are added as child nodes during DOM construction (see example above). For a detailed implementation
       example, please consult the <int:link pageid="002" />
       for the class <em>TemplateTag</em> or <em>html_taglib_form</em>.
    </p>
  </li>
  <li>
    <strong>onParseTime() implementation:</strong>
    <p>
      The method <em>onParseTime()</em> is executed by the page controller when the properties
    </p>
    <ul>
      <li>$this->__Context</li>
      <li>$this->__Attributes</li>
      <li>$this->__Content</li>
      <li>$this->__Language</li>
    </ul>
    <p>
       are set. At this time the taglib class has access to it's attributes and content and operations
       concerning this properties can be implemented. During execution of the method the node is not
       added to the DOM tree yet. If the developer must be able to access father or child nodes the
       function <em>onAfterAppend()</em> should be taken instead.
    </p>
    <div class="hint">
       This method is ideal for extracting sub tags or extracting document controller definitions. Therefore
       the private methods <em>__extractTagLibTags()</em> and <em>__extractDocumentController()</em>
       are present due to the fact, that each taglib inherits from the <em>Document</em> class. For
       details on this two methods please refer to the
       <int:link pageid="002" />.
    </div>
    <div class="hint">
       To preserve the position, a taglib was defined at and to ensure, that the transformed content
       is displayed at the correct position, the <em>__extractTagLibTags()</em> method creates
       place holder tags within the content of a taglib. The pattern of the place holders is:
       <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Thereby, <em>{OBJECT_ID}</em> is
       equal to the content of the class member <em>$this->__ObjectID</em> and the array offset
       where the child nodes are stored (<em>$this->__Children</em>). The place holders can be used
       during transformation and content placement of the transformed child tags.
    </div>
  </li>
  <li>
    <strong>onAfterAppend() implementation:</strong>
    <p>
       As all children of the current DOM node are added to the DOM tree the method
       <em>onAfterAppend()</em> is executed on them. At this moment a DOM node can access every neighbour
       node by the <em>$this->__ParentObject</em> or <strong>$this->__Children</strong> member variable.
       As mentioned above the methods <em>get()</em>, <em>set()</em> and so an grant access to the
       attributes of these neighbour nodes.
    </p>
  </li>
  <li>
    <strong>transform() implementation</strong>
    <p>
       The methods discussed above all are used to generate and process a DOM tree out of XML / HTML
       code. The function <strong>transform()</strong> is to produce XML / HTML code out of the object
       tree instead. Merely the implementation of the class <em>Document</em> can be taken for a newly
       created taglib class. For special purpose this method must be overridden be be present class. To
       generate an attribute string out of the attributes of the current node, the method
       <strong>getAttributesAsString()</strong> (or <strong>__getAttributesAsString()</strong>
       before version 1.14) can be taken.
    </p>
  </li>
</ul>
<div class="hint">
   In case, the <em>transform()</em> method is overridden within your custom taglib, the developer
   is himself responsible to transformation of the child nodes. This can possibly done by adding
<gen:highlight type="php">
foreach($this->__Children as $objectId => $DUMMY){
   $this->__Content = str_replace(
         '<'.$objectId.' />',
         $this->__Children[$objectId]->transform(),
         $this->__Content
   );
}
</gen:highlight>
   to your <em>transform()</em> method. Please note, that this does only work, of you have called
   the <em>__extractTagLibTags()</em> function in either the <em>onParseTime()</em> or the
   <em>onAfterAppend()</em>.
</div>

<h3 id="Chapter-3-Examples"><a href="#Chapter-3-Examples">3. Examples</a></h3>
<h4 id="Chapter-3-1-php_taglib_highlight">3.1. Taglib <em>php_taglib_highlight</em></h4>
<p>
   As already mentioned above the following example describes how to highlight and colorize the string
   between the tags
</p>
<gen:highlight type="apf-xml">
&lt;php:highlight&gt;
 [..]
&lt;/php:highlight&gt;
</gen:highlight>
<p>
   The implementation of this task is taken over by the class <strong>php_taglib_highlight</strong>.
   For this reason the method <em>transform()</em> is added to the class to modify the content contained
   in the property <strong>$this->__Content</strong> with aid of the <em>highlight_string()</em> PHP
   function. The code box shows how the class must look like:
</p>
<gen:highlight type="php">
class php_taglib_highlight extends Document {

   public function transform(){

      // count lines
      $LineCount = substr_count($this->__Content,"\n") - 1;

      // highlight source code
      // - Remove new lines at the beginning
      // - Remove new lines and blanks at the end
      // - Remove new lines and blanks around the whole text
      $HighlightedContent = highlight_string(trim('&lt;?php '.ltrim(rtrim($this-&gt;__Content),"\x0A..\x0D").' ?&gt;'),true);

      // replace php start tags
      $HighlightedContent = str_replace('&lt;font color="#007700"&gt;&lt;?&lt;/font&gt;','',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;&lt;?php&nbsp;','&lt;font color="#0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;php','&lt;font color="#0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;&nbsp;&lt;/font&gt;','',$HighlightedContent);

      // enhancement to the PHP5 support
      $HighlightedContent = str_replace('&lt;span style="color: #0000BB"&gt;&lt;?php&nbsp;','&lt;span style="color: #0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;span style="color: #0000BB"&gt;&lt;?php','&lt;span style="color: #0000BB"&gt;',$HighlightedContent);
      $HighlightedContent = str_replace('&lt;span style="color: #0000BB"&gt;?&gt;&lt;/span&gt;','',$HighlightedContent);

      // replace php end tags
      $HighlightedContent = str_replace('&lt;font color="#0000BB"&gt;?&gt;&lt;/font&gt;','',$HighlightedContent);

      // return div enclosed source code with height limit if necessary
      if($LineCount &gt; 27){
         return '&lt;div class="phpcode" style="height: 400px; overflow: auto;"&gt;'.$HighlightedContent.'&lt;/div&gt;';
      }
      else{
         return '&lt;div class="phpcode"&gt;'.$HighlightedContent.'&lt;/div&gt;';
      }

   }

}
</gen:highlight>

<h4 id="Chapter-3-2-html_taglib_entityencode">3.2. Taglib <em>html_taglib_entityencode</em></h4>
<p>
   The taglib <em>html:entityencode</em> provides a basis to convert text into HTML entities. This
   functionality can be used to encode e-mail addresses to protect them from getting crawled and used
   for spam. To provide this feature a new taglib class must be created using the method
   <strong>encodeCharactersToHTML</strong> of the class <strong>StringAssistant</strong> to do the
   encoding. After announcing the taglib via
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="path::to::namespace"
   class="html_taglib_entityencode"
   prefix="html"
   name="entityencode"
/&gt;
</gen:highlight>
the XML tag can be used as follows:
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
The source code of the web page delivered may then contain the following HTML code:
<gen:highlight type="apf-xml">
&amp;#110;&amp;#111;&amp;#98;&amp;#111;&amp;#100;&amp;#121;&amp;#64;&amp;#101;&amp;#120;&amp;#97;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#46;&amp;#99;&amp;#111;&amp;#109;
</gen:highlight>
<p>
   Since the core functionality is not included in the taglib class itself this operation can be reused
   in components like guestbook controllers. The code box shows how the class must look like:
</p>
<gen:highlight type="php">
import('tools::string','StringAssistant');

class html_taglib_entityencode extends Document {

   public function transform(){
      return StringAssistant::encodeCharactersToHTML($this->__Content);
   }

}
</gen:highlight>

<h4 id="Chapter-3-3-doc_taglib_createobject">3.3. Taglib <em>doc_taglib_createobject</em></h4>
<p>
   Giving another example the taglib <strong>&lt;doc:createobject /&gt;</strong> may be described here.
   This taglib is used to generate the content of this documentation page taking care of the chosen
   language and the content included there. The content is read from HTML files containing pure text,
   HTML code and XML strings that give advice to the page controller to include special modules. During
   parsing the source code is scanned to find known taglibs and new child nodes are created if a known
   taglib is found. To use this taglib it must be announced by using
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="tools::html::taglib"
   class="doc_taglib_createobject"
   prefix="doc"
   name="createobject"
/&gt;
</gen:highlight>
After that (directly after) the taglib can be used as follows:
<gen:highlight type="apf-xml">
&lt;doc:createobject requestparam="Seite" defaultvalue="Startseite" /&gt;
</gen:highlight>
<p>Taking a closer look into the source code the following logic is encapsulated there:</p>
<gen:highlight type="php">
import('tools::request','RequestHandler'); 

class doc_taglib_createobject extends Document {

   public function __construct() {
      parent::__construct();
   }

   public function onParseTime() {

      // get the attributes
      $requestParameter = $this->getAttribute('requestparam');
      $defaultValue = $this->getAttribute('defaultvalue');

      // get current request param
      $currentRequestParameter = RequestHandler::getValue($requestParameter, $defaultValue);

      // fill content
      $this->__Content = $this->loadContent($currentRequestParameter);

      // extract tags and document controller
      $this->__extractTagLibTags();
      $this->__extractDocumentController();

   }

   protected function loadContent($pageName) {

      $file = './frontend/content/c_' . $this->__Language . '_' . strtolower($pageName) . '.html';

      if (!file_exists($file)) {
         $file = './frontend/content/c_' . $this->__Language . '_404.html';
      }

      return file_get_contents($file);

   }

}
</gen:highlight>
<ul>
  <li>
    At the beginning of the file the <em>RequestHandler</em> is imported to be used later on.
  </li>
  <li>
    The constructor of the taglib calls the constructor of the parent class. This results in the
    availability of the known taglibs, that are defined in the constructor of the <em>Document</em>
    class. Each taglib is defined in the member variable <strong>$this->__TagLibs</strong> in form
    of the <em>TagLib</em> object. This array is used by the parser to extract the known taglibs.
    Please note that only known taglibs are found!
  </li>
  <li>
    The method <em>onParseTime()</em> is used to read the tag attributes and get the request
    parameters with aid of the <em>RequestHandler</em> to configure the tag. After that the content
    of the desired file is read using the private function <em>loadContent()</em> and filled into
    the content property. If done so the parser method <em>__extractTagLibTags()</em> is called to
    generate the document tree out of the known taglibs contained there. Moreover calling the
    <em>__extractDocumentController()</em> tries to find a document controller definition in the
    present content file.
  </li>
  <li>
    Within the method <em>loadContent()</em> the content of the specified file is read from the
    folder <em>./frontend/content</em> and given back at the end of the function. If the desired file
    is not found the content of a predefined error file is returned.
  </li>
</ul>
<p>
   For continuing application examples the form taglibs can be studied. This taglib classes are stored
   in the <strong>apps/tools/form/taglib/</strong> folder.
</p>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_045" />