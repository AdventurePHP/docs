<doku:title parent="119" tags="documentation,class reference,classes,reference,mysqlhandler" title="MySQLHandler" urlname="MySQLHandler">
  The MySQLHandler serves abstraction of a MySQL database against the application. It takes care
  of the database specific issues like configuration, connecting and standardises execution of
  statements.
</doku:title>
<div class="warn">
   This component is deprecated. As of release 1.10 only the
   <int:link pageid="031" anchor="Chapter-4-1-MySQL-driver" /> should be used. Although, the feature
   documentation for the MySQLx driver is the same.
</div>
The <strong>MySQLHandler</strong> serves abstraction of a MySQL database against the application.
It takes care of the database specific issues like configuration, connecting and standardises
execution of statements. Besides, two methods are available for the latter:
On the one hand <strong>executeTextStatement()</strong> can execute any SQL statement. If the developer
would like to use the statements in his application several times and at different places, statements
can also be stored in external statement files and be executed by the <strong>executeStatement()</strong>
method. The parameter description of these two methods can be found in the
<a href="./?Page=002-API-Documentation" title="API documentation">API documentation</a>.
<br />
<br />
<br />
<h3 id="Chapter-1-General-usage"><a href="#Chapter-1-General-usage">1. General usage</a></h3>
To be able to use the <strong>MySQLHandler</strong> it must be imported into the currend application
using
<gen:highlight type="php">
  import('core::database','MySQLHandler');
</gen:highlight>
Further the code fragment
<gen:highlight type="php">
   $SQL = &$this->__getServiceObject('core::database','MySQLHandler');
</gen:highlight>
creates the service layer and gives back a reference on it. Due to the fact, that this code snippet
makes use of the private method <em>__getServiceObject()</em> the developer can be save, that the
service is created just once within the application. This has not only an administrative advantages,
but in the case of database access, good performance impact. Inside, for example, database
connections must be produced only once and configurations must be read only once.
<br />
<br />
To provide configuration to the component, the configuration file
<gen:highlight type="code">
/apps/config/core/database/{CONTEXT}/{ENVIRONMENT}_connections.ini
</gen:highlight>
must be present. The place holder <strong>{CONTEXT}</strong> indicates the current application's
context and <strong>{ENVIRONMENT}</strong> must be filled with the value of the environment variable
stored in the global registry. Details on configuration can be read about in the
<a href="./Page=033-configuration" title="configuration">configuration chapter</a>. This file defines
which server to use, which credentials provide successful login and which database should be utilized
by the <em>MySQLHandler</em>. Typically the configuration file contains the following content:
<gen:highlight type="ini">
[MySQL]
DB.Host = ""
DB.User = ""
DB.Pass = ""
DB.Name = ""
DB.DebugMode = "true|false"
DB.Charset = ""
DB.Collation = ""
</gen:highlight>
<strong>DB.DebugMode</strong> indicates if the <em>MySQLHandler</em> creates a logfile with debug
information if an error occures or not. Default value is <strong>false</strong>. Set to
<strong>true</strong> the logfile will be created.
<br />
<br />
The two parameters <strong>DB.Charset</strong> and <strong>DB.Collation</strong> are used to
configure the <em>character set</em> and the <em>collation</em> of the MySQL connection. The
directive <strong>DB.Charset</strong> sets the MySQL variables
<ul>
   <li>character_set_client</li>
   <li>character_set_connection</li>
   <li>character_set_results</li>
</ul>
and the value of <strong>DB.Collation</strong> is applied to the variables
<ul>
   <li>collation_connection</li>
   <li>collation_database</li>
</ul>
Both params are optional and can be defined alternately. There is no need to specify both params at
the same time.
<br />
<br />
To read records from a database the following lines can be copied to an application:
<gen:highlight type="php">
$select = 'SELECT somefield, anotherfield
           FROM mytable
           WHERE somefield = \'somevalue\';';
$result = $SQL->executeTextStatement($select);
</gen:highlight>
The records selected by the statement above can now be fetched using a while loop:
<br />
<gen:highlight type="php">
while($data = $SQL->fetchData($result)){
   // ... //
}
</gen:highlight>
<br />
<h3 id="Chapter-2-Statement-outsourcing"><a href="#Chapter-2-Statement-outsourcing">2. Statement outsourcing</a></h3>
To use the statement posted above by an other application or at another place the method
<strong>executeStatement()</strong> can be used for this task. For this reason the statement must be
stored in a file named
<gen:highlight type="code">{ENVIRONMENT}_{StatementFileName}.sql</gen:highlight>
The MySQLHandler class expects this file to be stored in the folder
<gen:highlight type="code">{Namespace}/{CONTEXT}</gen:highlight>
similar to the configuration files. Under the acceptance that the statement "belongs" to a module
under the namespace <em>modules::testmodule</em>, the environment variable was not adjusted and the
context of the application is "sites::demosite" the file has to be named
<gen:highlight type="code">
DEFAULT_mystatement.sql
</gen:highlight>
and stored in the folder
<gen:highlight type="code">
/apps/config/modules/testmodule/sites/demosite
</gen:highlight>
To run this statement the method <strong>executeStatement()</strong> must be called as follows:
<gen:highlight type="php">
$params = array(
                'somefield' => 'somevalue'
                );
$result = $SQL->executeStatement('modules::testmodule','mystatement',$params);
</gen:highlight>
The third parameter of this method aims to configure the place holders provided within the statement.
Each place holder is marked with a leading "[", a name without blanks and a tailing "]" to end the
place holder. The name between the two brackets is the name of the place holder and must be used to
specify the value of this place holder. If one continues the example presented above the file
<strong>DEFAULT_mystatement.sql</strong> must contain the following SQL code:
<gen:highlight type="sql">
SELECT somefield, anotherfield
FROM mytable
WHERE somefield = '[somefield]';
</gen:highlight>
An application example is found in the
<a href="./?Page=032-Comment-function" title="contact form tutorial">contact form tutorial</a> under
chapter 4.3.
<br />
<br />
<br />
<h3 id="Chapter-3-Debugging"><a href="#Chapter-3-Debugging">3. Debugging</a></h3>
Sometimes, it is necessary to track the statements, that are sent to the database. For this reason,
the <strong>MySQLHandler</strong> features an additional parameter within the
<strong>executeTextStatement()</strong> and <strong>executeStatement()</strong> methods. Set to
<em>true</em>, the statement logging can be activated. Details can be taken from the
<a href="./?Page=002-API-Documentation" title="API documentation">API documentation</a>.
<br />
<br />
<br />
<h3 id="Chapter-4-More-features"><a href="#Chapter-4-More-features">4. More features</a></h3>
The MySQLHandler provides some more methods to assist implementation. During inserts the LAST_INSERT_ID
is stored automatically. After execution the value can be gathered by calling the
<strong>getLastID()</strong> method.
<br />
<br />
Moreover methods like <strong>getNumRows()</strong> and <strong>getAffectedRows()</strong> provide
access to the amount of rows that are affected during selects or updates of MySQL tables.
<strong>fetchData()</strong> was implemented to fetch the selected data from the database.