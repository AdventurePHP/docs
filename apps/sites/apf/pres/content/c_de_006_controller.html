<doku:title parent="119" tags="controller,zweck,mvc,templates,formulare,dynamische listen,generische einsetzbarkeit,flexibilit&auml;t" title="(Document-)Controller" urlname="Controller">
  (Document-)Controller sind Klassen, die nach dem MVC-Pattern f&uuml;r die Generierung des Inhalts
  eines DOM-Knotens eingesetzt werden k&ouml;nnen. Neben den TagLib-Funktionalit&auml;ten sind diese
  bei Bedarf einsetzbar.
</doku:title>
<h3 id="Chapter-1-Zweck-eines-Controllers"><a href="#Chapter-1-Zweck-eines-Controllers">1. Zweck eines (Document-)Controllers</a></h3>
<p>
   Wie unter <int:link pageid="046" /> und <int:link pageid="047" /> bereits mehrfach angesprochen, werden
   (MVC-Document-)Controller zur Generierung von dynamischen Inhalten verwendet. Um diese Aufgabe wahr
   nehmen zu k&ouml;nnen muss ein Document-Controller einem DOM-Knoten bekannt gemacht werden. Dies
   passiert in der ersten Zeile einer Template-Datei durch ein <strong>&lt;@controller @&gt;</strong>-Tag.
   Der Page-Controller weist dem aktuellen DOM-Knoten damit den dort angegebenen Document-Controller zu
   und f&uuml;hrt diesen bei der Transformation des Knotens aus.
</p>

<h3 id="Chapter-2-Aufbau-eines-Controllers"><a href="#Chapter-2-Aufbau-eines-Controllers">2. Aufbau eines (Document-)Controllers</a></h3>
<p>
   Jeder Document-Controller erbt vom Basis-Controller <em>base_controller</em>. Dieser besitzt zur
   Verarbeitung der bekannten TagLib-Tags notwendige Methoden. Beispiel hierf&uuml;r ist die Funktion
   <strong>__getTemplate()</strong> um eine Referenz auf ein im Knoten enthaltenes Template zugreifen zu
   k&ouml;nnen, oder die Methode <strong>setPlaceHolder()</strong>, mit der ein
   <strong>&lt;html:placeholder /&gt;</strong>-Tag gef&uuml;llt werden kann.
</p>
<p>Das Ger&uuml;st eines Document-Controllers hat immer folgende Gestalt:</p>
<gen:highlight type="php">
class my_document_controller extends base_controller {

   public function transformContent(){
   }

}
</gen:highlight>
<p>
   Ein Document-Controller ist im Prinzip eine PHP-Klasse "wie jede andere auch". Dem Entwickler steht
   es frei eigene Klassenvariablen zu definieren, eigene Methoden einzuf&uuml;hren und weitere Klassen
   einzubinden. Wichtig ist nur, dass das zuvor gezeigte Interface eingehalten wird.
</p>
<p>
   Wie der <int:link pageid="002" /> zu entnehmen ist verf&uuml;gt der <em>base_controller</em>
   &uuml;ber folgende Methoden:
</p>
<ul>
  <li>
    <strong>__getTemplate():</strong>
    <br />
    Methode um eine Referenz auf ein Template-Objekt zu holen.
  </li>
  <li>
    <strong>__getForm():</strong>
    <br />
    Funktion um auf ein Formular-Objekt zuzugreifen.
  </li>

  <li>
    <strong>__placeholderExists():</strong>
    <br />
    Pr&uuml;ft, ob in der Seite ein Platzhalter-Tag mit dem &uuml;bergebenen Namen existiert.
  </li>

  <li>
    <strong>__templatePlaceholderExists():</strong>
    <br />
    Pr&uuml;ft, ob in einem Template ein Platzhalter-Tag mit dem &uuml;bergebenen Namen existiert.
  </li>
</ul>
<p>
   Des Weiteren verf&uuml;gt der <em>base_controller</em> &uuml;ber alle Methoden der Klasse
   <em>APFObject</em>.
</p>
<div class="hint">
   <p>
      &Uuml;ber die bisher genannten Methoden besitzt jeder Document-Controller eine Referenz auf das
      Dokument im APF-DOM-Baum, f&uuml;r dessen Transformation er zust&auml;ndig ist. Diese findet
      sich in der Klassen-Variable <em>$this->__Document</em>. Mit Hilfe dieser Referenz kann
      beispielsweise via
      <gen:highlight type="php">$this->__Document->getAttribute('foo')</gen:highlight>
      auf den Wert des Attributs <em>foo</em> zugegriffen werden.
   </p>
   <p>
      Aus Gr&uuml;nden der Einfachheit besitzt ein Document-Controller auch alle Attribute des
      aktuellen DOM-Knotens. Diese k&ouml;nnen in der Klassen-Variable <em>$this->__Attributes</em>
      eingesehen und abgerufen werden.
   </p>
</div>

<h3 id="Chapter-3-Beispiele"><a href="#Chapter-3-Beispiele">3. Beispiele f&uuml;r (Document-)Controller</a></h3>
<h4 id="Chapter-3-1-Dynamische-META-Tags"><a href="#Chapter-3-1-Dynamische-META-Tags">3.1. Darstellung dynamischer Inhalte in Meta-Tags</a></h4>
<p>
   In diesem Kapitel soll nun die Implementierung eines Document-Controllers erl&auml;utert werden, der das
   in <int:link pageid="047" />, Kapitel 2.1, aufgef&uuml;hrte
   Template mit Inhalten f&uuml;llt. Dazu ist das Template zun&auml;chst um die Definition des
   Document-Controllers zu erweitern und sieht daher wie folgt aus:
</p>
<gen:highlight type="apf-xml">
&lt;@controller namespace="sites::apfdocupage::pres::documentcontroller" file="website_v1_controller"
class="website_v1_controller" @&gt;
[..]
&lt;meta name="keywords" lang="de" content="PHP,Framework,PageController,FrontController,Pattern,[..]" /&gt;
&lt;meta name="date" content="&lt;html:placeholder name="Date" /&gt;" /&gt;
&lt;meta name="robots" content="index,follow" /&gt;
&lt;meta name="revisit-after" content="5 days" /&gt;
[..]
</gen:highlight>
Der zugeh&ouml;rige Document-Controller implementiert in diesem Fall lediglich die Methode
<strong>transformContent()</strong> die bei der Transformation aufgerufen wird. Der Quellcode der
Klasse sieht dann wie folgt aus:
<br />
<gen:highlight type="php">
class website_v1_controller extends base_controller {

   public function transformContent(){

      // Platzhalter-Tag "URI" setzen
      $this->setPlaceHolder('URI',$_SERVER['REQUEST_URI']);

      // Platzhalter-Tag "Date" setzen
      $this->setPlaceHolder('Date',date('Y-m-d'));

   }

}
</gen:highlight>

<h4 id="Chapter-3-2-Dynamische-Listen"><a href="#Chapter-3-2-Dynamische-Listen">3.2. Darstellung dynamischer Listen</a></h4>
<p>
   Die folgenden Zeilen greifen das in <int:link pageid="047" />, Kapitel 2.2, aufgef&uuml;hrte
   Template zur Darstellung einer Liste. Dazu wird das Template - wie oben - zun&auml;chst um die
   Definition desc Document-Controllers erweitert:
</p>
<gen:highlight type="apf-xml">
&lt;@controller namespace="sites::apfdocupage::pres::documentcontroller" file="list_v1_controller"
class="list_v1_controller" @&gt;
[..]
&lt;html:placeholder name="List" /&gt;

&lt;html:template name="ListHeader"&gt;
  &lt;table cellpadding="0" cellspacing="0" border="0"&gt;
    &lt;tr&gt;
      &lt;td&gt;
         &lt;strong&gt;ExampleList&lt;/strong&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;template:placeholder name="TableElements" /&gt;
  &lt;/table&gt;
&lt;/html:template&gt;

&lt;html:template name="ListItem"&gt;
    &lt;tr&gt;
      &lt;td&gt;
         &lt;template:placeholder name="ItemValue" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
&lt;/html:template&gt;
</gen:highlight>
Der zugeh&ouml;rige Document-Controller implementiert nun einerseits die Methode <em>transformContent()</em>,
wird aber die privaten Methoden <strong>__buildList()</strong> und <strong>__buildListItem()</strong>
erweitert. Somit werden die Tasks nochmal in eigene "Helper-Methoden" verpackt und der Code gestaltet
sich &uuml;bersichtlicher und besser lesbar. Das Laden der Liste &uuml;bernimmt eine fiktive
Business-Komponente (<strong>listLoader</strong>), die eine Liste (=Array) von <strong>listItem</strong>-
Objekten zur&uuml;ckgibt. Letzters ist ein Daten-Objekt, das von <em>APFObject</em> erbt und genau
eine Eigenschaft mit dem Namen <strong>ListContent</strong> besitzt das mit <em>get()</em> abgefragt
werden kann. Die Liste wird dann iteriert und daraus eine HTML-Ausgabe generiert:
<br />
<gen:highlight type="php">
import('sites::demosite::biz','listLoader');

class list_v1_controller extends base_controller {

   public function transformContent(){

      // Liste in Platzhalter-Tag "List" einsetzen
      $this->setPlaceHolder('List',$this->buildList());

   }

   private function buildList(){

      // listLoader erzeugen
      $listLoader = &$this->__getServiceObject('sites::demosite::biz','listLoader');

      // Liste laden
      $List = $listLoader->loadList();

      // HTML-Puffer initialisieren
      $Buffer = (string)'';

      // Referenz auf Header-Template holen
      $Template__ListHeader = &$this->__getTemplate('ListHeader');

      // Liste durchlaufen und Items generieren
      foreach($List as $lKey => $lItem){

         // Ausgabe für Item generieren
         $Buffer .= $this->buildListItem($lItem);

      }

      // Items in das Header-Template einsetzen
      $Template__ListHeader->setPlaceHolder('TableElements',$Buffer);

      // Template transformieren und zurückgeben
      return $Template__ListHeader->transformTemplate();

   }

   private function buildListItem(&$listItem){

      // Referenz auf ListItem-Template holen
      $Template__ListItem = &$this->__getTemplate('ListItem');

      // Inhalt des Templates setzen
      $Template__ListItem->setPlaceHolder('ItemValue',$listItem->get('ListContent'));

      // Template transformieren und zurückgeben
      return $Template__ListItem->transformTemplate();

   }

}
</gen:highlight>

<h4 id="Chapter-3-3-Weitere-Beispiele"><a href="#Chapter-3-3-Weitere-Beispiele">3.3. Weiterf&uuml;hrende Beispiele</a></h4>
<p>
   Weiterf&uuml;hrende Controller-Beispiele sind unter <int:link pageid="057" /> und
   <int:link pageid="035" /> zu finden. Das Thema Formulare wird auf der Seite
   <int:link pageid="113" /> nochmals genauer behandelt.
</p>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_006" />