<doku:title parent="119" tags="controller,zweck,mvc,templates,formulare,dynamische listen,generische einsetzbarkeit,flexibilität" title="(Document-)Controller" urlname="Controller">
  (Document-)Controller sind Klassen, die nach dem MVC-Pattern für die Generierung des Inhalts
  eines DOM-Knotens eingesetzt werden können. Neben den TagLib-Funktionalitäten sind diese
  bei Bedarf einsetzbar.
</doku:title>
<h3 id="Chapter-1-Zweck-eines-Controllers"><a href="#Chapter-1-Zweck-eines-Controllers">1. Zweck eines (Document-)Controllers</a></h3>
<p>
   Wie unter <int:link pageid="046" /> und <int:link pageid="047" /> bereits mehrfach angesprochen, werden
   (MVC-Document-)Controller zur Generierung von dynamischen Inhalten verwendet. Um diese Aufgabe wahr
   nehmen zu können muss ein Document-Controller einem DOM-Knoten bekannt gemacht werden. Dies
   passiert in der ersten Zeile einer Template-Datei durch ein <strong>&lt;@controller @&gt;</strong>-Tag.
   Der Page-Controller weist dem aktuellen DOM-Knoten damit den dort angegebenen Document-Controller zu
   und führt diesen bei der Transformation des Knotens aus.
</p>

<h3 id="Chapter-2-Aufbau-eines-Controllers"><a href="#Chapter-2-Aufbau-eines-Controllers">2. Aufbau eines (Document-)Controllers</a></h3>
<p>
   Jeder Document-Controller erbt vom Basis-Controller <em>base_controller</em>. Dieser besitzt zur
   Verarbeitung der bekannten TagLib-Tags notwendige Methoden. Beispiel hierfür ist die Funktion
   <strong>getTemplate()</strong> um eine Referenz auf ein im Knoten enthaltenes Template zugreifen zu
   können, oder die Methode <strong>setPlaceHolder()</strong>, mit der ein
   <strong>&lt;html:placeholder /&gt;</strong>-Tag gefüllt werden kann.
</p>
<p>Das Gerüst eines Document-Controllers hat immer folgende Gestalt:</p>
<gen:highlight type="php">
class my_document_controller extends base_controller {

   public function transformContent(){
   }

}
</gen:highlight>
<p>
   Ein Document-Controller ist im Prinzip eine PHP-Klasse "wie jede andere auch". Dem Entwickler steht
   es frei eigene Klassenvariablen zu definieren, eigene Methoden einzuführen und weitere Klassen
   einzubinden. Wichtig ist nur, dass das zuvor gezeigte Interface eingehalten wird.
</p>
<p>
   Wie der <int:link pageid="002" /> zu entnehmen ist verfügt der <em>base_controller</em>
   über folgende Methoden:
</p>
<ul>
  <li>
    <strong>getTemplate():</strong>
    <br />
    Methode um eine Referenz auf ein Template-Objekt zu holen.
  </li>
  <li>
    <strong>getForm():</strong>
    <br />
    Funktion um auf ein Formular-Objekt zuzugreifen.
  </li>

  <li>
    <strong>__placeholderExists():</strong>
    <br />
    Prüft, ob in der Seite ein Platzhalter-Tag mit dem übergebenen Namen existiert.
  </li>

  <li>
    <strong>__templatePlaceholderExists():</strong>
    <br />
    Prüft, ob in einem Template ein Platzhalter-Tag mit dem übergebenen Namen existiert.
  </li>
</ul>
<p>
   Des Weiteren verfügt der <em>base_controller</em> über alle Methoden der Klasse
   <em>APFObject</em>.
</p>
<div class="hint">
   <p>
      Über die bisher genannten Methoden besitzt jeder Document-Controller eine Referenz auf das
      Dokument im APF-DOM-Baum, für dessen Transformation er zuständig ist. Diese findet
      sich in der Klassen-Variable <em>$this->__Document</em>. Mit Hilfe dieser Referenz kann
      beispielsweise via
      <gen:highlight type="php">$this->__Document->getAttribute('foo')</gen:highlight>
      auf den Wert des Attributs <em>foo</em> zugegriffen werden.
   </p>
   <p>
      Aus Gründen der Einfachheit besitzt ein Document-Controller auch alle Attribute des
      aktuellen DOM-Knotens. Diese können in der Klassen-Variable <em>$this->__Attributes</em>
      eingesehen und abgerufen werden.
   </p>
</div>

<h3 id="Chapter-3-Beispiele"><a href="#Chapter-3-Beispiele">3. Beispiele für (Document-)Controller</a></h3>
<h4 id="Chapter-3-1-Dynamische-META-Tags"><a href="#Chapter-3-1-Dynamische-META-Tags">3.1. Darstellung dynamischer Inhalte in Meta-Tags</a></h4>
<p>
   In diesem Kapitel soll nun die Implementierung eines Document-Controllers erläutert werden, der das
   in <int:link pageid="047" />, Kapitel 2.1, aufgeführte
   Template mit Inhalten füllt. Dazu ist das Template zunächst um die Definition des
   Document-Controllers zu erweitern und sieht daher wie folgt aus:
</p>
<gen:highlight type="apf-xml">
&lt;@controller namespace="sites::apfdocupage::pres::documentcontroller" file="website_v1_controller"
class="website_v1_controller" @&gt;
[..]
&lt;meta name="keywords" lang="de" content="PHP,Framework,Page-Controller,Front-Controller,Pattern,[..]" /&gt;
&lt;meta name="date" content="&lt;html:placeholder name="Date" /&gt;" /&gt;
&lt;meta name="robots" content="index,follow" /&gt;
&lt;meta name="revisit-after" content="5 days" /&gt;
[..]
</gen:highlight>
Der zugehörige Document-Controller implementiert in diesem Fall lediglich die Methode
<strong>transformContent()</strong> die bei der Transformation aufgerufen wird. Der Quellcode der
Klasse sieht dann wie folgt aus:
<br />
<gen:highlight type="php">
class website_v1_controller extends base_controller {

   public function transformContent(){

      // Platzhalter-Tag "URI" setzen
      $this->setPlaceHolder('URI',$_SERVER['REQUEST_URI']);

      // Platzhalter-Tag "Date" setzen
      $this->setPlaceHolder('Date',date('Y-m-d'));

   }

}
</gen:highlight>

<h4 id="Chapter-3-2-Dynamische-Listen"><a href="#Chapter-3-2-Dynamische-Listen">3.2. Darstellung dynamischer Listen</a></h4>
<p>
   Die folgenden Zeilen greifen das in <int:link pageid="047" />, Kapitel 2.2, aufgeführte
   Template zur Darstellung einer Liste. Dazu wird das Template - wie oben - zunächst um die
   Definition desc Document-Controllers erweitert:
</p>
<gen:highlight type="apf-xml">
&lt;@controller namespace="sites::apfdocupage::pres::documentcontroller" file="list_v1_controller"
class="list_v1_controller" @&gt;
[..]
&lt;html:placeholder name="List" /&gt;

&lt;html:template name="ListHeader"&gt;
  &lt;table cellpadding="0" cellspacing="0" border="0"&gt;
    &lt;tr&gt;
      &lt;td&gt;
         &lt;strong&gt;ExampleList&lt;/strong&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;template:placeholder name="TableElements" /&gt;
  &lt;/table&gt;
&lt;/html:template&gt;

&lt;html:template name="ListItem"&gt;
    &lt;tr&gt;
      &lt;td&gt;
         &lt;template:placeholder name="ItemValue" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
&lt;/html:template&gt;
</gen:highlight>
Der zugehörige Document-Controller implementiert nun einerseits die Methode <em>transformContent()</em>,
wird aber die privaten Methoden <strong>__buildList()</strong> und <strong>__buildListItem()</strong>
erweitert. Somit werden die Tasks nochmal in eigene "Helper-Methoden" verpackt und der Code gestaltet
sich übersichtlicher und besser lesbar. Das Laden der Liste übernimmt eine fiktive
Business-Komponente (<strong>listLoader</strong>), die eine Liste (=Array) von <strong>listItem</strong>-
Objekten zurückgibt. Letzters ist ein Daten-Objekt, das von <em>APFObject</em> erbt und genau
eine Eigenschaft mit dem Namen <strong>ListContent</strong> besitzt das mit <em>get()</em> abgefragt
werden kann. Die Liste wird dann iteriert und daraus eine HTML-Ausgabe generiert:
<br />
<gen:highlight type="php">
import('sites::demosite::biz','listLoader');

class list_v1_controller extends base_controller {

   public function transformContent(){

      // Liste in Platzhalter-Tag "List" einsetzen
      $this->setPlaceHolder('List',$this->buildList());

   }

   private function buildList(){

      // listLoader erzeugen
      $listLoader = &$this->getServiceObject('sites::demosite::biz','listLoader');

      // Liste laden
      $List = $listLoader->loadList();

      // HTML-Puffer initialisieren
      $Buffer = (string)'';

      // Referenz auf Header-Template holen
      $Template__ListHeader = &$this->getTemplate('ListHeader');

      // Liste durchlaufen und Items generieren
      foreach($List as $lKey => $lItem){

         // Ausgabe für Item generieren
         $Buffer .= $this->buildListItem($lItem);

      }

      // Items in das Header-Template einsetzen
      $Template__ListHeader->setPlaceHolder('TableElements',$Buffer);

      // Template transformieren und zurückgeben
      return $Template__ListHeader->transformTemplate();

   }

   private function buildListItem(&$listItem){

      // Referenz auf ListItem-Template holen
      $Template__ListItem = &$this->getTemplate('ListItem');

      // Inhalt des Templates setzen
      $Template__ListItem->setPlaceHolder('ItemValue',$listItem->get('ListContent'));

      // Template transformieren und zurückgeben
      return $Template__ListItem->transformTemplate();

   }

}
</gen:highlight>

<h4 id="Chapter-3-3-Weitere-Beispiele"><a href="#Chapter-3-3-Weitere-Beispiele">3.3. Weiterführende Beispiele</a></h4>
<p>
   Weiterführende Controller-Beispiele sind unter <int:link pageid="057" /> und
   <int:link pageid="035" /> zu finden. Das Thema Formulare wird auf der Seite
   <int:link pageid="113" /> nochmals genauer behandelt.
</p>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_006" />