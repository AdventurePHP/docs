<doku:title parent="119" tags="service,object,dependency,injection,di,framework,factory,service manager,manager,business services" title="Services" urlname="Services">
  The present chapter describes the object creation mechanisms contained in the framework. In
  particular, it details the dependency injection container added in release 1.10. The
  DIServiceManager enables the developer to use objects pre-configured by dependency injection.
</doku:title>
<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   Encapsulation of functionality within separate components is common in the object orientated world.
   The advantages of this method is described by the <strong>tree tier architecture pattern</strong>.
   Thereby, the different layers have different duties concerning their layer.
</p>
<p>
   Due to the fact, that the <em>layers</em> or <em>services</em> are commonly represented by one
   or more classes each developer is faced with the task to create classes for a dedicated layer or
   a part of a layer. Further, according to the DRY principle each developer is told to design
   reusable components - <strong>Services</strong> - that have a clear representation and configuration
   interface. For example data layers often require a component, that has access to databases and
   a business component needs knowledge about the context it is executed in.
</p>

<h3 id="Chapter-2-Basics"><a href="#Chapter-2-Basics">2. Basics</a></h3>
<p>
   As described in the
   <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram" title="Page controller - Activity diagram"/>
   chapter the Adventure PHP Framework provides a special way of creating objects that are responsible
   for creating UI elements. Since business and data layer object must also know about the context
   they are executed in (see
   <int:link pageid="134" anchor="Chapter-2-1-Configuration-scheme">configuration scheme</int:link>)
   it is necessary to transport this information into the service objects.
</p>
<p>
   For this reason, the APF provides two different components that let you create objects within
   your application that have all the information necessary injected. This enables you to write
   clean and reusable applications.
</p>
<p>
   The subsequent chapters describe the mentioned components and their meaning to development.
</p>
<h3 id="Chapter-3-Object-creation-mechanism"><a href="#Chapter-3-Object-creation-mechanism">3. Object creation mechanism</a></h3>
<p>
   The Adventure PHP Framework has several mechanisms to create and initialize objects. To provide
   the necessary information for each object (DOM nodes, business services, etc.) the environment
   attributes are passed to the new object using <strong>dependency injection</strong>.
</p>
<p>
   Due to the fact, that the framework includes a generic way to create singleton and session
   singleton objects the implementation avoids constructor injection to be able to provide a
   generic way of object creation and to preserve testability. For this reason, initialization is
   only done using <strong>method injection</strong> / <strong>setter injection</strong>.
</p>

<h4 id="Chapter-3-1-GUI-objects"><a href="#Chapter-3-1-GUI-objects">3.1. GUI objects</a></h4>
<p>
   Creation of presentation layer objects is done by factory methods of the
   <int:link pageid="098" anchor="Chapter-2-2-Description" title="Page controller - description" />.
   Each object is injected the context, the current language and the attributes of the DOM node
   by interface methods.
</p>
<p>
   In case you just apply taglibs or parser methods provided by the release you don't have to care
   about that mechanism. Notes on custom taglib implementation can be read about in chapter
   <int:link pageid="147" />.
</p>

<h4 id="Chapter-3-2-Service-objects"><a href="#Chapter-3-2-Service-objects">3.2. Service objects</a></h4>
<p>
   To ease development concerning creation of services or further objects representing an application
   layer and to not have to deal with the internal mechanisms of the framework's dependency injection
   the developer is provided three different possibilities to create pre-configured objects. Thererfore
   the <strong>APFObject</strong> class provides wrapper methods for the <strong>ServiceManager</strong>
   and the <strong>DIServiceManager</strong>.
<p>
<p>
   Details on the method signatures can be found within the <int:link pageid="002" /> or by the
   code completion functions of your IDE (see <int:link pageid="131" />).
</p>

<h5 id="Chapter-3-2-1-ServiceManager-Simple-services"><a href="Chapter-3-2-1-ServiceManager-Simple-services">3.2.1. Simple services using the ServiceManager</a></h5>
<p>
   Using <em>getServiceObject()</em> you will receive an object, that is initialized with the 
   context and the language of the current environment. Within this method, the
   <strong>ServiceManager</strong>s is used (see <int:link pageid="002" />). Due to the fact, that
   the wrapper function uses the context and the language of the current object you are able to
   configure different contexts within one application (e.g. different contexts for different modules).
</p>
<h5 id="Chapter-3-2-1-ServiceManager-Initialized-services"><a href="#Chapter-3-2-1-ServiceManager-Initialized-services">3.2.2. Initialized services using the ServiceManager</a></h5>
<p>
   The <em>getAndInitServiceObject()</em> enhances the method from chapter 3.2.1 with dynamic
   initialization. You can pass the initialization parameter as a the third argument that is passed
   to the <strong>init()</strong> method of the service. This parameter is typeless what means that
   you can pass any type of data type.
</p>
<p>
   This method of initialization included one disadvantage: the initialization parameter must be
   known by the service consumer. For this reason you should use this mechanism in conjunction with
   service initialization by application specific information (e.g. providing an application id
   <int:link pageid="032" anchor="Chapter-4-5-Presentation-layer">defined within a tag attribute</int:link>).
</p>

<h5 id="Chapter-3-2-3-DIServiceManager-Complex-services"><a href="Chapter-3-2-3-DIServiceManager-Complex-services">3.2.3. Complex services using the DIServiceManager</a></h5>
<p>
   The <em>getDIServiceObject()</em> method is a wrapper function for the <strong>DIServiceManager</strong>
   call, that provides a user-level <strong>dependency injection container</strong> for the APF.
   Services can be initialized by other services or static parameters.
</p>
<p>
   Using the <strong>DIServiceManager</strong> better separates application code and configuration.
   Parameters are injected from outside the source code and service creation must not ne part of the
   code. This leads to loosly coupled services that are easily reusable. Further, testability is
   much more better, because database access can easily be replaced by a MOCK layer.
</p>

<h3 id="Chapter-4-Samples"><a href="#Chapter-4-Samples">4. Samples</a></h3>
<p>
   Applying the theoretical knowledge descibed above is really a piece of cake. The subsequent
   chapters give you an example of the application of the methods.
</p>
<h4 id="Chapter-4-1-ServiceManager-Simple-services"><a href="#Chapter-4-1-ServiceManager-Simple-services">4.1. Simple services</a></h4>
<p>
   As described in chapter 3.2.1 <em>getServiceObject()</em> returns a simple service object:
</p>
<gen:highlight type="php">
class MyObject extends APFObject {
   public function doSomething(){
      $myService =
         &$this->getServiceObject(
            'namespace::of::my::service',
            'ServiceName'
         );
      $myService->doSomething();
}
</gen:highlight>
<strong>Notes:</strong>
<ul>
   <li>
      The service implementation must not be included using <strong>import()</strong> before usage.
      This is done by the <em>ServiceManager</em> for you.
   </li>
   <li>
      The name of the service object addressed here is equal to the name of the class. Same is
      for the namespace.
   </li>
</ul>

<h4 id="Chapter-4-2-ServiceManager-Initialized-services"><a href="#Chapter-4-2-ServiceManager-Initialized-services">4.2. Initialized services</a></h4>
<p>The creation of a pre-configured service is as follows:</p>
<gen:highlight type="php">
class MyObject extends APFObject {
   public function doSomething(){
      $initParam = 'foo';
      $myService =
         &$this->getAndInitServiceObject(
            'namespace::of::my::service',
            'ServiceName',
            $initParam
         );
      $myService->doSomething();
}
</gen:highlight>
<strong>Notes:</strong>
<ul>
   <li>
      The service implementation must not be included using <strong>import()</strong> before usage.
      This is done by the <em>ServiceManager</em> for you.
   </li>
   <li>
      The name of the service object addressed here is equal to the name of the class. Same is
      for the namespace.
   </li>
</ul>

<h4 id="Chapter-4-3-DIServiceManager-Complex-services"><a href="#Chapter-4-3-DIServiceManager-Complex-services">4.3. Complex services</a></h4>
<p>
   Creating services with the <em>dependency injection</em> container of the APF is different to the
   object initialization described in the last two chapters. First of all, each DI service is
   represented by a configuration. This is due to the fact, that one service is no standalone object
   but can be used for initialization of other services, too.
</p>

<h5 id="Chapter-4-3-1-Configuration"><a href="#Chapter-4-3-1-Configuration">4.3.1. Configuration</a></h5>
<p>
   In order to create a service named <strong>MyService</strong> for namespace
   <strong>modules::mymodule::services</strong> the configuration file must be created:
</p>
<gen:highlight type="code">
/config/modules/mymodule/services/{CONTEXT}/{ENVIRONMENT}_serviceobjects.ini
</gen:highlight>
<p>
   The definition of the service itself (including implementation and initialization) is done
   as follows:
</p>
<gen:highlight type="ini">
[{ServiceName}]
servicetype = ""
namespace = ""
class = ""
[init.{INITKEY}.method = ""
init.{INITKEY}.namespace = ""
init.{INITKEY}.name = ""]
[conf.{INITKEY}.method = ""
conf.{INITKEY}.value = ""]
</gen:highlight>
<strong>Definition:</strong>
<ul>
   <li>
      The <strong>servicetype</strong> directive defines the kind of service. You can use
      <em>SINGLETON</em>, <em>SESSIONSINGLETON</em> and <em>NORMAL</em>. Details on the types can
      be take from the
      <int:link pageid="030" anchor="Chapter-3-ServiceManager-usage">ServiceManager usage</int:link>
      chapter.
   </li>
   <li><strong>namespace</strong> definines the namespace of the service implementation.</li>
   <li><strong>class</strong> defines the class name of the service implementation.</li>
   <li>
      The <strong>init</strong> section is responsible for dynamic initialization using 
      <em>dependency injection</em> the <strong>conf</strong> section can inject static
      configuration params.
   </li>
   <li>
      The <strong>method</strong> attribute of an <em>init</em> sub section defines the method that
      is used to inject the desired service. <strong>namespace</strong> and <strong>name</strong>
      is used to refer a desired service to initialize the current with. Please note, that these two
      parameters do refer to a service definition not a service implementation (i.e. class)! The
      refered service must be described by a configuration section as described above.
   </li>
   <li>
      The <strong>method</strong> attribute of the <em>conf</em> sub section defines the method that
      is used to inject the desired configuration parameter. The service is thus provided the content
      that is defined within the <strong>value</strong> attribute.
   </li>
</ul>

<h5 id="Chapter-4-3-2-Example"><a href="#Chapter-4-3-2-Example">4.3.2. Example</a></h5>
<p>
   As an example a business component should be initialized with static configuration parameters,
   a data layer component, and a provider that is responsible for configuration issues. For
   convenience, the name of the service is <strong>GuestbookService</strong> and the namespace is
   <strong>modules::guestbook</strong>. The implementation of the service is provided by the
   <strong>GuestbookManager</strong> class located in namespace <strong>modules::guestbook::biz</strong>.
</p>
<p>
   In order to use the dependency injection mechanism we have to create a configuration file that
   represents the <em>GuestbookService</em>. Having the last few lines in mind the file must be
   named as shown in the next code box:
</p>
<gen:highlight type="code">
/config/modules/guestbook/{CONTEXT}/{ENVIRONMENT}_serviceobjects.ini
</gen:highlight>
<p>For a first instance, the service definition is as follows:</p>
<gen:highlight type="ini">
[GuestbookService]
class = "GuestbookManager"
namespace = "modules::guestbook::biz"
servicetype = "SINGLETON"
</gen:highlight>
<p>
   Please note, that the config provider must be represented by another configuration section. 
   Thereby namespace of the data layer component <strong>DataService</strong> is
   <strong>modules::guestbook</strong> and the <strong>ExtendedConfigProvider</strong>'s namespace is
   <strong>modules::guestbook::provider</strong>. Due to the fact, that the namespaces of the
   <em>GuestbookService</em> and the data layer service are are equal, they can be placed within the
   same configuration file. The <em>ExtendedConfigProvider</em> must be configures within another
   confiuration file:
</p>
<gen:highlight type="code">
/config/modules/guestbook/provider/{CONTEXT}/{ENVIRONMENT}_serviceobjects.ini
</gen:highlight>
<p>
   To sum things up, the content of the service definition file <em>{ENVIRONMENT}_serviceobjects.ini</em>
   located in the <em>modules::guestbook</em> namespace looks like this:
</p>
<gen:highlight type="ini">
[GuestbookService]
namespace = "modules::guestbook::biz"
class = "GuestbookManager"
servicetype = "..."

[DataService]
namespace = "modules::guestbook::biz"
class = "GuestbookMapper"
servicetype = "..."
</gen:highlight>
<p>
   The <em>ExtendedConfigProvider</em> is configured within the service definition file
   <em>{ENVIRONMENT}_serviceobjects.ini</em> (namespace: <em>modules::guestbook::provider</em>):
</p>
<gen:highlight type="ini">
[ExtendedConfigProvider]
namespace = "modules::guestbook::biz::provider"
class = "SpecialConfigProvider"
servicetype = "..."
</gen:highlight>
<p>
   To inform the <strong>DIServiceManager</strong> to initialize the <strong>GuestbookService</strong>
   using the services described above it's configuration section must be added two dynamic and
   two static initialization sub sections:
</p>
<gen:highlight type="ini">
init.database.method = "setDBService"
init.database.name = "modules::guestbook"
init.database.namespace = "DataService"

init.exconf.method = "setConfigProvider"
init.exconf.name = "modules::guestbook::provider"
init.exconf.namespace = "ExtendedConfigProvider"

conf.appname.method = "setAppId"
conf.appname.value = "123"

conf.cache.method = "setCacheActive"
conf.cache.value = "false"
</gen:highlight>
<p>
   As you can take from the above code box you can define various initialization sub sections. Please
   note, that each sub section must includes a unique sub section key.
</p>
<p>Using the <strong>GuestbookService</strong> is as follows:</p>
<gen:highlight type="php">
class ServiceConsumer extends APFObject {
   public function doSomething(){
      $service =
         &$this->getDIServiceObject(
            'modules::guestbook',
            'GuestbookService'
         );
      $service->doSomething();
}
</gen:highlight>
<p>
   Concerning the service definition, the service implementation (class: <em>GuestbookManager</em>)
   must include at least the listed methods:
</p>
<gen:highlight type="php">
class GuestbookManager extends APFObject {

   public function setDBService($dbService){
      $this->dbService = $dbService;
   }

   public function setConfigProvider($provider){
      $this->configProvider = $provider;
   }

   public function setAppId($appId){
      $this->appId = $appId;
   }

   public function setCacheActive($cacheActive){
      $this->cacheActive = $cacheActive;
   }

   public function doSomething(){
   }

   ...

}
</gen:highlight>
<p>
   Within <strong>doSomething()</strong> you can access all the services and configuration values
   that are injected into the service.
</p>
<div class="hint">
   Another application sample is described on
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/Erzeugen_des_GORM_mit_dem_DIServiceManager" title="Erzeugen des GORM mit dem DIServiceManager">Erzeugen des GORM mit dem DIServiceManager</a>
   (German).
</div>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_107" />