<doku:title parent="100" tags="artikel,gaestebuch,impleemntierung,design" title="Objektorientierte Implementierung eines Gästebuchs" urlname="Objektorientierte-Implementierung-eines-Gaestebuchs">
   Aufbauend auf dem Artikel Objektorientiertes Design eines Gästebuchs soll dieser Teil zeigen,
   wie die Implementierung des Moduls mit dem Adventure PHP Framework (APF) umgesetzt werden kann.
   Es wird dabei nicht nur auf die Möglichkeiten des Frameworks eingegangen, sondern auch das im
   ersten Teil erarbeitete, Technologie-unabhängige Design erweitert.
</doku:title>
<img src="http://media.adventure-php-framework.org/img/illustrations/guestbook.png" alt="Objektorientierte Implementierung eines Gästebuchs" class="leftTeaser"/>
<p>
   Aufbauend auf dem Artikel Objektorientiertes Design eines Gästebuchs soll dieser Teil zeigen,
   wie die Implementierung des Moduls mit dem Adventure PHP Framework (APF) umgesetzt werden kann.
   Es wird dabei nicht nur auf die Möglichkeiten des Frameworks eingegangen, sondern auch das im
   <int:link pageid="112">ersten Teil</int:link> erarbeitete, Technologie-unabhängige Design
   erweitert.
</p>
<h3 id="Chapter-1-Einleitung"><a href="#Chapter-1-Einleitung">1. Einleitung</a></h3>
<p>
   Im ersten Teil dieser Serie wurden die Anforderungen an das Gästebuch aufgezeigt, analysiert
   und die Planung der Umsetzung mit Hilfe von Use Case- und Klassen-Diagramme beschrieben. Bei den
   UML-Diagrammen wurde auf eine Technologie-unabhängige Darstellung geachtet um die
   Möglichkeit zu geben, das beschriebene Design in unterschiedlichen Programmier-Sprachen und
   mit beliebigen Werkzeugen umzusetzen. Dies ist in vielen Fällen – etwa für ein
   Grob-Konzept oder zur genaueren Abschätzung der Aufwende eines Projekts – auch nützlich
   und ausreichend, für die konkrete Umsetzung einer Anwendung, muss dieses jedoch noch
   verfeinert werden.
</p>
<p>
   In diesem Teil soll daher nicht nur das Design konkretisiert werden, sondern es soll vor allem
   auf die praktische Umsetzung eingegangen werden. Als Hilfsmittel zur Umsetzung soll das Adventure
   PHP Framework (kurz: APF) zum Einsatz kommen. Dieses verfügt mit dem Page-Controller
   über eine Möglichkeit, beliebig komplexe GUI-Strukturen ohne Einschränkung des
   Komplexitäts-Grades aufzubauen und Views bzw. Module einfach per XML-Tags einzuklinken.
   Durch den Einsatz von aus dem JAVA-Bereich bekannten Taglibs ist es zudem auf sehr einfache
   Weise möglich, widerverwendbare GUI-Elemente (Widgets) zu schaffen.
</p>
<p>
   Der fertige Quellcode ist sowohl im SVN-Repository des APF als auch im aktuellen Release 1.11
   enthalten. Es wird empfohlen, diesen auf der <int:link pageid="008" />-Seite herunter zu laden
   und begleitend zum Artikel zu lesen.
</p>

<h3 id="Chapter-2-Einfuehrung-in-das-APF"><a href="#Chapter-2-Einfuehrung-in-das-APF">2. Einführung in das APF</a></h3>
<p>
   Das Adventure PHP Framework versteht sich als Hilfsmittel zur Implementierung von
   objektorientierten, generischen und widerverwendbaren PHP-Web-Applikationen. Der Entwickler wird
   dabei unterstützt Anwendungen nach anerkannten OO-Design-Pattern zu implementieren und das
   Framework bietet bereits eine Vielzahl von Lösungen für bekannte Problemstellungen.
</p>
<p>
   Es versteht sich bewusst nicht als Applikation, die lediglich konfiguriert werden muss, sondern
   als technische Basis und Design-Guide für den Entwurf von Anwendungen.
</p>
<p>
   Das Herzstück des Applikations-Frameworks bildet der Page-Controller. Seine Funktion besteht
   darin, Anfragen entgegen zu nehmen und einen allgemeingültigen Rahmen für Applikationen
   zu bieten, die nach dem HMVC-Muster erstellt werden. Er verfügt daher über Mechanismen
   zum Laden und Verarbeiten von Templates mit Hilfe der Funktionen von Taglibs, zur Ausführung
   von (MVC-)Controllern und zum Handling des HMVC-DOM-Baumes, der mit Hilfe der Taglibs erzeugt wird.
</p>
<p>
   Da der Page-Controller selbst einen Funktions-Rahmen bereitstellt, kann die Applikations-Logik
   durch eigene Taglibs und (MVC-)Controller direkt vom Entwickler beeinflusst werden. Die
   Komponente selbst handelt dabei unabhängig von der in Taglibs definierter Logik. Auf diese
   Weise ist es möglich, Tags mit sehr unterschiedlichen Funktionen wie beispielsweise
   Platzhalter oder Formulare zu erstellen.
</p>
<p>
   In den folgenden Abschnitten soll dieser Mechanismus dazu genutzt werden, das Template-Layout
   des Gästebuchs so granular zu gestalten, dass die einzelnen Bereiche klein und
   übersichtlich bleiben. So sind Erweiterungen später einfacher zu bewerkstelligen.
</p>

<h3 id="Chapter-3-Und-Action"><a href="#Chapter-3-Und-Action">3. Und ... Action!</a></h3>
<p>
   Für den Einstieg in das APF lohnt es sich, einen Blick auf das Hallo Welt!-Tutorial unter
   <int:link pageid="014" /> zu werfen. Dieses beschreibt, wie eine einfache Webseite erstellt
   werden kann. Um die Entwicklung des Gästebuches einfacher zugestalten, legen wir zunächst
   ein solches Projekt an. Hierzu beziehen wir die Bibliotheken (apf-codepack-1.11*) des
   Frameworks und erstellen einen neuen Ordner oder VHOST in unserem lokalen Webserver. Um im
   Weiteren eine einheitliche Sprachregelung hinsichtlich der Ordner-Struktur zu haben, soll das
   Projekt unter
</p>
<gen:highlight type="code">/var/www/html/guestbook</gen:highlight>
<p>
   angelegt werden. Dort erstellen wir nun einen Ordner apps und entpacken darin die Bibliotheken.
</p>
<p>
   Parallel zu apps legen wir zusätzlich eine index.php an. Diese dient als so genannte 
   Bootstrap-Datei, da das APF dafür ausgelegt ist, eine komplette Webseite mit einer einzigen
   PHP-Datei auszuliefern. Für ein erstes Erfolgserlebnis erstellen wir ein Template, das
   später zur Einbindung des Gästebuchs dient.
</p>
<p>
   Für das Template zur Ausgabe des Gästebuchs legen wir dann den Ordner
</p>
<gen:highlight type="code">/var/www/html/guestbook/apps/gb/templates</gen:highlight>
<p>
   an und erstellen darin eine Datei mit dem Namen
</p>
<gen:highlight type="code">guestbook.html</gen:highlight>
<p>
   Diese füllen wir zunächst mit einem beliebigen Text und widmen uns der Bootstrap-Datei.
   Um das Anlegen einfach zu gestalten, kopieren wir den Code aus dem oben genannten
   Hallo-Welt!-Tutorial und passen die Parameter entsprechend an:
</p>
<gen:highlight type="php">
include('./apps/core/pagecontroller/pagecontroller.php');
import('core::frontcontroller', 'Frontcontroller');
$fC = &Singleton::getInstance('Frontcontroller');
echo $fC->start('gb::templates', 'guestbook');
</gen:highlight>
<p>
   Das Code-Snippet zeigt bereits wichtige Konventionen des APF: Klassen und Template-Dateien werden 
   immer relativ zum Installations-Ordner der Basis-Bibliotheken (hier: apps) adressiert.
   Verzeichnisse (Namespaces) werden mit &rdquo;::&ldquo; statt &rdquo;/&ldquo; getrennt und 
   Datei-Namen ohne Endung notiert.Template-Dateien tragen die Endung &rdquo;.html&ldquo;,
   PHP-Klassen &rdquo;.php&ldquo;.
</p>
<p>
   Rufen wir nun die Datei index.php im Browser auf, sehen wir den im Template abgespeicherten Text. 
   Damit ist unser erste APF-Webseite fertig!
</p>

<h3 id="Chapter-4-Domain-Model"><a href="#Chapter-4-Domain-Model">4. Domain-Model</a></h3>
<p>
   Das im ersten Teil beschriebe Domänen-Modell ist für alle Schichten der Software 
   relevant und soll daher zuerst implementiert werden.
</p>
<p>
   Da die Instanz eines Gästebuchs zu einem Zeitpunkt in exakt einer Sprache angezeigt wird, 
   haben wir uns beim Design dazu entschieden ein einfaches Objektmodell ohne Sprach-Differenzierung
   zu erstellen. Hierzu zählen die Klassen Guestbook, User und Entry. Diese sind einfache
   Daten-Objekte, wodurch sich die Implementierung relativ einfach gestaltet. Die Klassen besitzen
   für jede (private) Eigenschaft jeweils eine get()- und eine set()-Methode. Um einen Eintrag
   (Entry) vollständig anzeigen zu können ist der zugehörige Benutzer (User)
   notwendig. Aus diesem Grund besitzt die Klasse Entry eine komplexe Eigenschaft editor, die den
   Autor des Eintrags beinhaltet.
</p>
<gen:highlight type="php">
final class Entry {
   private $title;
   private $text;
   private $creationTimestamp;
   private $modificationTimestamp;
   private $user;
   private $id;

   public function getEditor(){
      return $this->user;
   }

   public function setEditor($user){
      $this->user = $user;
   }
   ...
}
</gen:highlight>
<p>
   Die Klasse Guestbook kennt zudem alle Einträge des Gästebuchs, erhält deshalb eine 
   komplexe Eigenschaft entries:
</p>
<gen:highlight type="php">
final class Guestbook {
   private $title;
   private $description;
   private $entries = array();

   public function getEntries(){
      return $this->entries;
   }

   public function setEntries($entries){
      $this->entries = $entries;
   }

   public function addEntry($entry){
      $this->entries[] = $entry;
   }
   ...
}
</gen:highlight>
<p>
   Die Klasse User repräsentiert sowohl den Autor eines Eintrags als auch den Administrator 
   eines Gästebuchs. Diese hat folgende Definition:
</p>
<gen:highlight type="php">
final class User {

   private $username;
   private $password;
   private $name;
   private $email;
   private $website;
   private $id;

   public function setName($name){
      $this->name = $name;
   }

   public function getName(){
      return $this->name;
   }
   ...
}
</gen:highlight>
<p>
   In den folgenden Abschnitten werden die Klassen als Schnittstellen-Objekte für den
   Datenaustausch zwischen Präsentations- und Business-Schicht sowie Business- und Datenschicht
   verwendet werden. Dadurch wird der Code lesbarer und die API ist typisiert.
</p>
<p>
   Um die einzelnen Komponenten unserer Software einfacher wieder zu finden, legen wir eine
   Ordner-Struktur gemäß der Schichten der Applikation im apps-Ordner an. Da das
   Gästebuch ein widerverwendbares Modul sein soll, wird dieses im Ordner modules abgelegt und
   mit einem eindeutigen Kennzeichner versehen. Die Ordner-Struktur von apps gestaltet sich dann
   wie folgt:
</p>
<gen:highlight type="code">
/modules/guestbook2009/
                       pres/
                       biz/
                       data/
</gen:highlight>
<p>
   Der Ordner pres dient der Ablage der Bestandteile der Präsentations-Schicht, unter biz
   werden alle Inhalte der Business-Schicht der Applikation abgelegt und data beinhaltet die
   Datenschicht-Komponenten.
</p>
<p>
   Die Klassen Guestbook, User und Entry werden, da sie zur Business-Schicht zählen, im Ordner
   biz unter den Namen Guestbook.php, User.php und Entry.php abgelegt. Das APF sieht dabei ebenfalls
   die Namenskonvention Klasse=Datei-Name vor. Später kann dann die Klasse User daher via
</p>
<gen:highlight type="php">
import(
   'modules::guestbook2009::biz',
   'User'
);
</gen:highlight>
<p>eingebunden werden.</p>

<h3 id="Chapter-5-Use-Cases-und-Views"><a href="#Chapter-5-Use-Cases-und-Views">5. Use Cases und Views</a></h3>
<p>
   Das Kapitel Use Cases des ersten Teils beschreibt die Interaktionen eines Benutzers mir dem
   Gästebuch. Werden diese möglichst realitätsnah im UML-Diagramm abgebildet, so
   lassen sich daraus üblicherweise direkt die Views der Applikation ableiten. Als View wird
   ein Bereich einer Applikation oder einer Webseite bezeichnet, dem eine definierte Aufgabe
   zugeschrieben werden kann. Dabei ist es sehr wohl möglich, einen View durch mehrere weitere
   Views zu beschreiben.
</p>

<img src="http://media.adventure-php-framework.org/content/uml_use_cases.png" alt="Gästebuch Use Cases" />

<p>
   Aus dem Diagramm, das im ersten Teil das Ergebnis des Designs war, ergeben sich folgende Views
   für den Besucher und den Webmaster einer Webseite:
</p>
<ul>
   <li>Anzeige der Einträge des Gästebuchs</li>
   <li>Anzeige eines einzelnen Eintrags</li>
   <li>Anzeige eines Pagers</li>
   <li>Anzeige eines Formulars</li>
   <li>Anzeige einer Login-Maske</li>
   <li>Anzeige eines Auswahlmenüs</li>
</ul>
<p>
   Es bietet sich daher an, diese logischen Views auch in View-Templates oder Template-Fragmente 
   abzubilden. Das erleichtert nicht nur die Implementierung sondern garantiert auch, dass der Code
   im Falle einer Erweiterung einfacher lesbar ist.
</p>

<h3 id="Chapter-6-Gestaltung-der-Praesentationsschicht"><a href="#Chapter-6-Gestaltung-der-Praesentationsschicht">6. Gestaltung der Präsentationsschicht</a></h3>
<p>
   Für den Entwurf und die Implementierung einer Anwendung gibt es zwei verbreitete 
   Ansätze: top-down- oder bottom-up-Methode. Die erste der beiden beschreibt die Idee,
   zunächst die Oberfläche einer Anwendung zu erstellen und dann sukzessive die Funktionen
   zu integrieren. Der bottom-up-Ansatz bedeutet, die Basis-Funktion vor der GUI bereitzustellen.
   Daneben existieren noch einige weitere Vorgehensweisen, die die genannten jedoch lediglich
   erweitern bzw. granulieren.
</p>
<p>
   In diesem Workshop entscheiden wir uns für die erste Variante, da in Web-Anwendungen die 
   grafische Präsentation der Anwendung im Vordergrund steht.
</p>
<p>
   Zudem ist der Vorgehensweise dieser Vorgehensweise nicht zu vernachlässigen, dass für 
   den Kunden schnell ein präsentierbares Resultat entsteht. Dieses kann dann beispielsweise
   als Prototyp für das look&amp;feel der Anwendung oder als Gesprächsgrundlage für die
   Ausgestaltung der Funktionen dienen.
</p>
<p>
   In der folgenden Skizze ist der Aufbau der Präsentations-Schicht des Gästebuch-Moduls 
   schemenhaft dargestellt:
</p>

<img src="http://media.adventure-php-framework.org/content/perspektiven_und_views.png" alt="Perspektiven-Design des APF-Gästebuchs" />

<p>
   Der grün umrandete Bereich beschreibt den View, der das komplette Gästebuch darstellt.
   Dieser beinhaltet zwei weitere Views (rot): den Header mit dem Titel und der Beschreibung des
   Gästebuchs und den Inhalt. Im Falle der Anzeige der Gästebuch-Einträge gliedert
   sich dieser wiederum in drei Bereiche (blau): dem Header, dem Pager und der Liste der Einträge.
</p>
<p>
   Bei der technischen Umsetzung können wir uns die Funktion des Page-Controllers zu Nutze
   machen. Dieser strukturiert alle Elemente als (MVC-)View-Elemente innerhalb eines Baumes. Damit
   repräsentieren die genannten, fachlichen Views später auch die technischen Views.
   Hierauf wird im Abschnitt Einbindung des Gästebuchs näher eingegangen.
</p>

<h3 id="Chapter-7-Formatierung-per-CSS"><a href="#Chapter-7-Formatierung-per-CSS">7. Formatierung per CSS</a></h3>
<p>
   Um die Formatierung des Gästebuchs und damit den Einsatz auf einer bestehenden Seite zu 
   erleichtern, soll beim HTML-Markup Wert auf ein konsequentes Container-Layout mit Hilfe von
   div-Elementen gelegt werden. Um Überschneidungen der Klassen-Benennung mit bestehenden
   Komponenten zu vermeiden, werden alle CSS-Klassen mit dem Präfix gb-- ausgestattet.
   Weiterhin wird pro Formatierungs-Bereich eine weitere &rdquo;Unter-Klasse&ldquo; eingeführt.
   Das folgende HTML-Fragment zeigt die Idee:
</p>
<gen:highlight type="html">
<div class="gb--main">
   <div class="gb--main-heading">
      ...
   </div>
   <div class="gb--main-text">
      ...
   </div>
   <div class="gb--list-entries">
      ...
   </div>
</div>
</gen:highlight>
<p>
   Da das CSS-Design nicht im Fokus dieses Artikels steht, wird dieses Thema im Folgenden ausgespart. 
   Ein fertiges CSS-Stylesheet kann jedoch aus dem SVN bzw. dem aktuellen APF-Release 1.10 bezogen
   werden.
</p>

<h3 id="Chapter-8-Generische-Einbindung-von-Modulen"><a href="#Chapter-8-Generische-Einbindung-von-Modulen">8. Generische Einbindung von Modulen</a></h3>
<p>
   In den Anforderungen wurde definiert, dass die Einbindung des Gästebuchs als
   eigenständiges Modul möglich sein soll. Nun stellt sich die Frage: &rdquo;Was ist ein
   Modul und wie muss die Schnittstelle zur Einbindung aussehen?&ldquo;.
</p>
<p>
   Unter einem Modul versteht der Autor ein abgeschlossenes Stück Software, das – mit einigen
   Umgebungs-Informationen versorgt – für sich alleine lauffähig ist. Bei der Gestaltung
   von mehrfach einsetzbaren Modulen ist es zudem wichtig, dass diese keine direkte Abhängigkeit
   zu bestehenden Funktionalitäten einer Webseite oder Applikation besitzen. Andernfalls ist
   es nicht möglich, diese ohne Änderungen des Quellcodes in andere Projekte einzubinden.
   Hier sieht sich der Anwender dann schnell damit konfrontiert, Abhängigkeiten zu URL-Parametern
   der umgebenden Software manuell auflösen zu müssen.
</p>
<p>
   Wie angedeutet, benötigt ein Modul Informationen aus der Umgebung, in der es eingebunden ist. 
   Zu diesen zählen:
</p>
<ul>
   <li>die Sprache einer Webseite bzw. Applikation,</li>
   <li>die Applikation, in der das Modul eingebettet ist und</li>
   <li>die Umgebung auf der die Software läuft.</li>
</ul>
<p>
   Stehen diese drei Rahmenbedingungen zur Verfügung ist es problemlos möglich ein 
   abgegrenztes und widerverwendbares Modul zu erstellen.
</p>
<p>
   Zur Einbindung eines Moduls – oder allgemeiner – eines neuen GUI-Elements, stellt das APF einen
   generischen Mechanismus zur Verfügung: den Page-Controller. Dieser injiziert die genannten
   Informationen in jeden neu erstellten DOM-Knoten.
</p>
<p>
   Dieses Verfahren soll auch im Fall des Gästebuchs genutzt werden um das separat entwickelte
   Modul später in beliebige Projekte einbinden zu können. Die oben benannten Parameter
   werden im APF etwas anderes bezeichnet. Dies ist im Folgenden kurz beschrieben.
</p>
<p>
   Die Sprache steht in jedem APF-DOM-Knoten in der Klassen-Variable $this->__Language zur 
   Verfügung. Dies gilt insbesondere auch für Document-Controller. Sie wird bei der
   Initialisierung des Page- oder Front-Controllers gesetzt und gilt für den kompletten Baum.
   Sofern notwendig, kann die Sprache in einem Knoten auch manuell verändert werden. Dies kann
   notwendig sein, wenn in einer mehrsprachigen Anwendung ein Modul nur in englischer Sprache
   eingebunden werden soll.
</p>
<p>
   Der Context kennzeichnet die Applikation, in der ein Modul oder eine Funktion eingebunden ist.
   Diese steht in jedem Knoten in der Klassen-Variable $this->__Context zur Verfügung. Für
   die Initialisierung und die Veränderbarkeit gelten dieselben Regeln wie bei der Sprache.
</p>
<p>
   Die Umgebung, auf der die Anwendung ausgeführt wird, ist in der zentralen Registry-Instanz 
   abgelegt. Hierzu steht im Namespace apf::core die Direktive Environment zur Verfügung. Dieser
   Wert wird nicht, wie die zuvor genannten, direkt im DOM-Knoten vorgehalten. Grund dafür ist, 
   dass es sich hierbei um eine für alle Knoten identische und nicht veränderliche
   Information handelt. Sie beschreibt eine physikalische Maschine oder ein Cluster, auf dem die
   Applikation gehostet wird. Sofern notwendig, kann die Umgebung via
</p>
<gen:highlight type="php">Registry::etrieve('apf::core','Environment');</gen:highlight>
<p>von der Registry bezogen werden.</p>

<h3 id="Chapter-9-Einbindung-des-Gaestebuchs"><a href="#Chapter-9-Einbindung-des-Gaestebuchs">9. Einbindung des Gästebuchs</a></h3>
<p>
   Zur Unterstützung des Entwicklers enthält das APF den &lt;core:importdesign />-Tag.
   Dieser ermöglicht es, ein Modul in eine bestehende Anwendung basierend auf der im
   vorangegangenen Abschnitt beschriebenen Schnittstelle einzubinden.
</p>
<p>
   Um die Integration des Gästebuchs für den Anwender noch komfortabler zu gestalten und
   innerhalb der Applikation eine einfache Möglichkeit zu schaffen auf die Id des anzuzeigenden
   Gästebuchs zuzugreifen, soll die Funktion des Tags erweitert und die Gästebuch-Id in
   einem Model abgelegt werden.
</p>
<p>Hierzu erstellen wir zunächst eine Klasse, die die Gästebuch-Id verwaltet:</p>
<gen:highlight type="php">
class GuestbookModel extends APFObject {
   protected $__GuestbookId;
}
</gen:highlight>
<p>
   Da ein Model im Sinne der eingesetzten 3-Schicht-Architektur zur Business-Schicht zählt,
   legen wird diese Klasse unter dem Namespace (=Ordner)
</p>
<gen:highlight type="code">modules::guestbook2009::biz</gen:highlight>
<p>
   ab. Durch die Vererbung besitzt das Objekt bereits eine get()- und set()-Methode zur Manipulation
   der GuestbookId.
</p>
<p>
   Anschließend erweitern wir die Funktion der oben genannten Taglib um das Füllen
   des Models:
</p>
<gen:highlight type="php">
class gb_taglib_import extends core_taglib_importdesign {

   public function __construct(){
      parent::__construct();
   }

   public function onParseTime(){

      $model = &$this->getServiceObject('modules::guestbook2009::biz','GuestbookModel');
      $guestbookId = $this->getAttribute('gbid');

      // do not include the guestbook, if gbid is not set/existent
      if($guestbookId == null || ((int)$guestbookId) == 0){
         throw new InvalidArgumentException('[gb_taglib_import::onParseTime()] The attribute '
            .'"gbid" is empty or not present or the value is not an id. Please specify the '
            .'attribute correctly in order to include the guestbook module!');
      }

      $model->setGuestbookId($guestbookId);

      $this->__Attributes['namespace'] = 'modules::guestbook2009::pres::templates';
      $this->__Attributes['template'] = 'guestbook';
      parent::onParseTime();

   }

}
</gen:highlight>
<p>
   Wie das Code-Listing zeigt, wird das Model mit Hilfe der Methode getServiceObject() erzeugt.
   Diese ist ein Proxy auf die Klasse ServiceManager, die im APF dafür verantwortlich ist,
   Objekte zu erzeugen und gleichzeitig zu initialisieren. In der oben verwendeten Form liefert die
   Methode ein Singleton-Objekt zurück. Greifen die übrigen Komponenten auf dieselbe Weise
   auf das Objekt zu, steht die Informationen allen gleichermaßen zur Verfügung.
</p>
<p>
   Verglichen mit der ursprünglichen Implementierung der Taglib, werden die für die
   Einbindung des Gästebuchs notwendigen Parameter bereits in der erweiterten Taglib gesetzt
   werden. Dadurch kann das Gästebuch wie folgt im Template guestbook.html eingebunden werden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
  namespace="modules::guestbook2009::pres::taglib"
  prefix="gb"
  class="import"
/>
<gb:import gbid=&ldquo;1&ldquo; />
</gen:highlight>
<p>
   Details zur Implementierung von Taglibs können unter <int:link pageid="045" /> nachgelesen
   werden.
</p>

<h3 id="Chapter-10-Der-Basis-View"><a href="#Chapter-10-Der-Basis-View">10. Der Basis-View</a></h3>
<p>
   Rufen wir nun die URL in unserem Browser auf, erscheint eine Fehlermeldung, die darauf hinweist,
   dass das Template guestbook(.html) aus dem Namespace modules::guestbook2009::pres::templates
   nicht geladen werden kann. Hintergrund ist, dass im letzten Abschnitt der Ablage-Ort und der
   Name des Basis-Templates bereits implizit definiert wurden. Innerhalb des pres-Ordners wurde
   zur besseren Gliederung folgende Struktur aufgebaut:
</p>
<gen:highlight type="code">
guestbook2009/pres/
                   controller/
                   taglib/
                   templates/
</gen:highlight>
<p>
   Der Ordner controller dient später zur Ablage der MVC-Document-Controller-Klassen, im Ordner
   taglib wurde die oben besprochene Klasse gb_taglib_import abgelegt und templates ist der Ordner,
   in dem alle Templates gespeichert werden. Diese Konvention hat sich in der Vergangenheit als sehr
   angenehm erwiesen.
</p>
<p>
   Wie im Abschnitt Gestaltung der Präsentationsschicht beschrieben, soll die Ausgabe des
   Gästebuchs in mehrere View-Templates aufgeteilt werden. Das Haupt-Template beinhaltet
   demnach den Header des Gästebuchs und die Einbindung eines Content-Views:
</p>
<gen:highlight type="apf-xml">
   <@controller
  namespace="modules::guestbook2009::pres::controller"
  file="guestbook_controller"
  class="guestbook_controller"
@>
&lt;div class="gb--main">
  ...
  &lt;html:placeholder name="title" />
  ...
  &lt;html:placeholder name="desc" />
  ...
  &lt;core:importdesign
    namespace="modules::guestbook2009::pres::templates"
    template="[gbview=list]"
    incparam="gbview"
  />
&lt;/div>
</gen:highlight>
<p>
   An dieser Stelle wird eine Besonderheit des &lt;core:importdesign />-Tags genutzt, der neben
   einer &rdquo;statischen&ldquo; Einbindung ermöglicht, einen View abhängig von einem
   definierten URL-Parameter einzubinden. In diesem Anwendungsfall wird der Inhalt des
   Request-Parameters gbview dazu verwendet, zu entscheiden, welches Template eingebunden wird. Ist
   der Parameter nicht im Request vorhanden, wird das Template list.html geladen. Enthält
   dieser den Wert &rdquo;create&ldquo;, so wird das Template create.html verwendet.
</p>
<p>
   Wie im Abschnitt Einführung in das APF angesprochen, bietet das APF neben den Taglibs eine
   zweite Möglichkeit für die Generierung von dynamischen Inhalten: den Document-Controller.
</p>
<p>
   Die ersten Zeilen des oben abgedruckten Templates definieren, welcher Controller bei der
   des Templates zum Einsatz kommen soll. Die Deklaration besagt, dass in diesem Fall die Klasse
   guestbook_controller aus dem Namespace modules::guestbook2009::pres::controller verwendet
   werden soll. Der Page-Controller erwartet, dass die Controller-Klasse implizit oder explizit
   von base_controller erbt und die Methode transformContent() implementieren. Die übrige
   Gestaltung einer Controller-Klasse obliegt dabei dem Entwickler. Das folgende Listing zeigt den
   zur Ausgabe des Titels und der Beschreibung notwendigen Code:
</p>
<gen:highlight type="php">
   class guestbook_controller extends base_controller {
   public function transformContent(){
      $gS = &$this->getDIServiceObject(
         'modules::guestbook2009::biz',
         'GuestbookService'
      );
      $guestbook = $gS->loadGuestbook();
      $this->setPlaceHolder(
         'title',
         $guestbook->getTitle()
      );
      $this->setPlaceHolder(
         'description',
         $guestbook->getDescription()
      );
   }
}
</gen:highlight>
<p>
   In den ersten Zeilen wird die Instanz des aktuell anzuzeigenden Gästebuchs geladen und
   anschließend werden die im Template definierten Platzhalter gefüllt. Zur Beschaffung
   der Daten wird der GuestbookService genutzt. Dieser hat Zugriff auf das zuvor beschriebene
   GuestbookModel und liefert deshalb die gewünschten Inhalte ohne Übergabe der
   Gästebuch-ID.
</p>

<h3 id="Chapter-11-Der-Ausgabe-View"><a href="#Chapter-11-Der-Ausgabe-View">11. Der Ausgabe-View</a></h3>
<p>
   Das im Abschnitt Gestaltung der Präsentationsschicht gezeigte Schaubild skizziert die im
   Ausgabe-View relevanten Bereiche in blauer Farbe. Zu diesen zählt der Header, mit der
   Möglichkeit einen neuen Eintrag zu erstellen, der Pager-Ausgabe zum Blättern der
   Einträge und die Liste der Einträge auf der gewählten Seite.
</p>
<p>
   Auch in diesem Template stehen dem Entwickler alle Möglichkeiten zur Gestaltung der Inhalte
   frei und er kann beliebige weiter Templates einbinden. Hier ist es jedoch nicht notwendig, da die
   drei darzustellenden Bereiche sehr gut abgrenzbar sind. Für den Header- und Pager-Bereich
   können einfache Platzhalter verwendet werden, für die Ausgabe der Inhalte kommt eine
   weitere Taglib zum Einsatz: &lt;html:template />. Diese bietet die Möglichkeit,
   wiederverwendbare, parametrisierte HTML-Fragmente innerhalb einer Template-Datei zu definieren.
   Im Controller kann diese dann genutzt werden um alle Einträge in einer Schleife auszugeben:
</p>
<gen:highlight type="apf-xml">
<@controller
  namespace="modules::guestbook2009::pres::controller"
  file="list_controller"
  class="list_controller"
@>
...
&lt;html:placeholder name="link" />
...
&lt;html:placeholder name="pager" />
...
&lt;html:placeholder name="content" />

&lt;html:template name="entry">
  ...
  <template:placeholder name="title" />
  ...
  <template:placeholder name="name" />,
  <template:placeholder name="web" />
  ...
  <template:placeholder name="text"/>
  ...
  Datum:
  <template:placeholder name="date" />,
  Uhrzeit:
  <template:placeholder name="time" />
  ...
</html:template>
</gen:highlight>
<p>
   Für die Ausgabe der Liste wurde das &lt;html:template /> mit Platzhaltern ausgestattet, die
   die Inhalte eines Entry-Objekts repräsentieren. Die fertigen Liste wird dann dem Platzhalter
   &lt;html:placeholder name="content" /> mitgegeben.
</p>
<p>
   Dass ein Document-Controller von der Klasse base_controller erben muss ist nicht nur reine
   Konvention, sondern bietet auch eine Reihe von Vorteilen. Die Klasse beinhaltet eine Vielzahl
   von Methoden, die das Erzeugen von dynamischem Inhalt erleichtern. Zu diesen zählt die
   Funktion getTemplate($tmplName), die eine Referenz auf die mit $tmplName benannte Instanz der
   Taglib &lt;html:placeholder /> zurück liefert. So kann in einem Controller bequem auf die
   im DOM-Baum umliegenden Objekte zugegriffen werden.
</p>
<p>
   In diesem Fall handelt es sich dabei um ein Kind-Objekt des DOM-Knotens, der mit Hilfe der
   Template-Datei list.html erzeugt wurde. Die Instanz der Taglib &lt;template:placeholder /> ist
   wiederum ein Kind der Instanz der Taglib &lt;html:template />. Da über die Methode <em>$this->getDocument()</em>
   eine Referenz auf das aktuelle DOM-Objekt bezogen werden kann, kann auch in einem Controller auf die umliegenden
   Objekte direkt zugegriffen werden:
</p>
<gen:highlight type="php">
class list_controller extends base_controller {

   public function transformContent() {

      // get the guestbook service
      $gS = &$this->getDIServiceObject('modules::guestbook2009::biz', 'GuestbookService');
      $entryList = $gS->loadPagedEntryList();

      $tmpl_entry = &$this->getTemplate('entry');
      $buffer = (string) '';
      foreach ($entryList as $entry) {

         $editor = $entry->getEditor();
         $tmpl_entry->setPlaceHolder('name', $editor->getName());
         $tmpl_entry->setPlaceHolder('website', $editor->getWebsite());

         $tmpl_entry->setPlaceHolder('title', $entry->getTitle());
         $tmpl_entry->setPlaceHolder('text', $entry->getText());

         $creationTimestamp = $entry->getCreationTimestamp();
         $tmpl_entry->setPlaceHolder('time', date('H:i:s', strtotime($creationTimestamp)));
         $tmpl_entry->setPlaceHolder('date', date('d.m.Y', strtotime($creationTimestamp)));

         $buffer .= $tmpl_entry->transformTemplate();
      }
      $this->setPlaceHolder('content', $buffer);

      // add the pager
      $this->setPlaceHolder('pager', $gS->getPagerOutput());

      // add dyamic link
      $link = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array('gbview' => 'create')));
      $this->setPlaceHolder('createlink', $link);
   }

}
</gen:highlight>
<p>
   Die Funktion des Controllers besteht darin, die aktuell anzuzeigenden Einträge von der 
   Business-Schicht entgegen zu nehmen, in einer Schleife die Instanz des Templates zu befüllen
   und das Ergebnis in einen Ausgabe-Puffer zu schreiben. Anschließend wird dieser zusammen
   mit der fertig generierten Ausgabe des Pagers und des Links in die jeweiligen Platzhalter-Tags
   eingesetzt.
</p>
<p>
   Auch bei diesem Document-Controller lässt sich erkennen, dass die Granulierung der
   Funktionalität die Logik im Controller übersichtlich erscheinen lässt.
</p>

<h3 id="Chapter-12-MOCK-Testing"><a href="#Chapter-12-MOCK-Testing">12. MOCK-Testing</a></h3>
<p>
   In den beiden Controller-Klassen wurde stillschweigend davon ausgegangen, dass die
   Business-Komponente GuestbookService bereits implementiert und zum Einsatz bereit ist. Da wir
   jedoch den top-down-Ansatz für die Erstellung der Applikation gewählt haben, ist das
   natürlich nicht der Fall. Möchten wir trotzdem jetzt schon die Applikation testen um
   dem Kunden beispielsweise das look&amp;feel zu präsentieren, bietet sich das mock'en (siehe
   <a class="external" href="http://de.wikipedia.org/wiki/Mock-Objekt" title="Mock-Objekte">Mock-Objekte</a>)
   der Business-Schicht an.
</p>
<p>
   Das Konzept von Mock-Testing besteht darin, notwendige Komponenten durch Klassen zu ersetzen, die 
   die Funktionen statisch implementieren und so genannte Mock-Objekte – Test-Daten –
   zurückliefern. In unserem Fall ist das die Liste der Einträge – eine Liste von
   Entry-Objekten –, eine Instanz eines Gästebuchs und die Ausgabe des Pagers. Letztere
   können wir für einen ersten Test ignorieren und statt der HTML-Ausgabe einfach einen
   Leer-String zurückgeben. Die Liste der Inhalte und das Gästebuch erstellen wir in den
   Methoden des Mock-Gästebuch-Services manuell:
</p>
<gen:highlight type="php">
class MockGuestbookService extends APFObject {
   public function loadGuestbook(){
      $gb = new Guestbook();
      $gb->setTitle('Mein Gästebuch');
      $gb->setDescription('Dies ist mein erster Test des neuen Gästebuchs. Die Einträge werden von einer Mock-Schicht zur Verfügung gestellt.');
      return $gb;
   }

   public function loadPagedEntryList(){
      $entry = new Entry();
      $entry->setTitle('MOCK-Eintrag');
      $entry->setText(
         'Dies ist ein MOCK-Text ...'
      );
      $entry->setCreationTimestamp(
         date('Y-m-d H:i:s')
      );
      $editor = new User();
      $editor->setName('MOCK-Benutzer');
      $editor->setEmail('test@test.de');
      $editor->setWebsite(
         'http://test.de'
      );
      $entry->setEditor($editor);
      $entries = array();
      for($i = 0; $i < 10; $i+){
         $entries[] = $entry;
      }
      return $entries;
   }

   public function getPagerOutput(){
      return (string)'';
   }
}
</gen:highlight>
<p>Die Klasse legen wir im Ordner biz unter dem Namen MockGuestbookService.php ab.</p>

<h3 id="Chapter-13-Kopplung-von-Schichten"><a href="#Chapter-13-Kopplung-von-Schichten">13. Kopplung von Schichten</a></h3>
<p>
   In den Beispielen zuvor tauchte immer wieder die Methode getDIServiceObject() auf. Diese stellt
   eine Facade für den Aufruf des DIServiceManager (siehe
   <int:link pageid="107" anchor="3-2-3-__getDIServiceObject" />) dar und liefert einen per
   dependency injection konfigurierten Service zurück. Ein Service zeichnet sich dabei durch
   eine Sektion in einer Konfigurationsdatei aus. Diese besitzt folgendes Schema:
</p>
<gen:highlight type="ini">
[GuestbookService]
servicetype = ""
namespace = ""
class = ""

[init.{INITKEY}.method = ""
init.{INITKEY}.namespace = ""
init.{INITKEY}.name = ""]

[conf.{CONFKEY}.method = ""
conf. {CONFKEY}.value = ""]
</gen:highlight>
<p>Für den Service-Typ gibt es drei mögliche Werte:</p>
<ul>
   <li>NORMAL: Service wird &rdquo;normal&ldquo; mit Hilfe des new-Operators instanziiert,</li>
   <li>SINGLETON: es wird pro Request exakt ein Service erzeugt,</li>
   <li>SESSIONSINGLETON: es wird pro Session exakt ein Service erzeugt.</li>
</ul>
<p>
   Die Parameter namespace und class beschreiben die Implementierung eines Services – eine
   PHP-Klasse –, mit den übrigen Parametern kann die Konfiguration des Services vorgenommen
   werden. Alle mit conf beginnenden Parameter enthalten eine statische Konfiguration, alle init
   Definitionen nehmen eine dynamische Konfiguration mit Hilfe von weiteren Service-Objekten vor.
</p>
<p>
   Durch die Einführung des DIServiceManager wurde bei der vorliegenden Applikation bereits
   implizit die Möglichkeit geschaffen, MOCK-Objekte einzusetzen. So können wir ohne 
   Änderung des Codes den im letzten Abschnitt implementierten Mock-Service einsetzen. Dazu
   muss dieser lediglich in der Konfigurationsdatei unter der Sektion GuestbookService eingetragen
   werden. Da die Mock-Schicht keinerlei Konfiguration benötigt, besteht die Konfigurationsdatei
   aus folgenden Zeilen:
</p>
<gen:highlight type="ini">
[GuestbookService]
servicetype = "SINGLETON"
namespace = "modules::guestbook2009::biz"
class = "MockGuestbookService"
</gen:highlight>

<h3 id="Chapter-14-Konfiguration"><a href="#Chapter-14-Konfiguration">14. Konfiguration</a></h3>
<p>
   Um unser MOCK-up einem ersten Test unterziehen zu können, muss die Komponente 
   GuestbookService noch zur Verwendung konfiguriert werden. Der vollständige Pfad einer
   Konfigurationsdatei setzt sich beim APF aus fünf verschiedenen Bestandteilen zusammen:
</p>
<p>
   Basis-Ordner config: alle Konfigurationen werden in einem eigenen Verzeichnis verwaltet um Code
   und Konfiguration zu trennen.
</p>
<p>
   Der Namespace: dieser beschreibt den zweiten Pfad-Abschnitt. Er ist üblicherweise identisch 
   zum Namespace des verfassten Moduls/Tools. Dadurch wird die die Zugehörigkeit der
   Konfigurationen zum betreffenden Modul/Tool gekennzeichnet.
</p>
<p>
   Der Context: Dieser fügt dem Pfad noch eine individuelle Unterscheidung hinzu. Das APF ist 
   hinsichtlich der Konfiguration so ausgelegt, dass ein Modul/Tool in mehreren Applikationen
   eingebunden werden kann. Hierzu ist eine Unterscheidung notwendig, in welchem Umfeld dieses
   gerade läuft, um dafür spezialisierte Konfigurationen laden zu können. So kann
   mit einer Code-Basis eine beliebige Anzahl an Applikationen betrieben werden.
</p>
<p>
   Die Umgebung (=Environment) ist Teil des Datei-Namens und bestimmt innerhalb eines Einsatzgebietes
   die Umgebung, auf der das Modul/Tool eingesetzt wird. Damit kann ohne Änderung der
   Applikation und der Konfiguration ein Modul auf unterschiedlichen Umgebungen (Dev/Test/Live)
   deployed werden.
</p>
<p>
   Der Name der Datei bildet den Rumpf der Konfigurations-Datei. Als Endung wird .ini verwendet.
</p>
<p>
   Zusammengefasst wird der Name einer Konfigurations-Datei durch folgendes Schema definiert:
</p>
<gen:highlight type="code">/config/{NAMESPACE}/{CONTEXT}/{ENVIRONMENT}__{NAME}.ini</gen:highlight>
<p>
   Mit diesen Parametern ist es möglich Software für den Einsatz in unterschiedlichen
   Applikationen und Webseiten zu konfigurieren.
</p>

<h3 id="Chapter-15-Ein-erster-Test"><a href="#Chapter-15-Ein-erster-Test">15. Ein erster Test!</a></h3>
<p>
   Vor einem ersten Test müssen wir nun noch die Konfiguration für die Verwendung des
   DIServiceManager in den beiden Document-Controllern anlegen. Da die aktuell angelegte index.php
   den Context der Anwendung noch nicht definiert, müssen wir dies nun nachholen. Aus diesem
   Grund fügen in der index.php wir zwischen
</p>
<gen:highlight type="php">$fC = &Singleton::getInstance('Frontcontroller');</gen:highlight>
<p>und</p>
<gen:highlight type="php">echo $fC->start('gb::templates', 'guestbook');</gen:highlight>
<p>ein</p>
<gen:highlight type="php">$fC->setContext('testproject');</gen:highlight>
<p>hinzu. Damit wird der Context des Page-Controllers auf den Wert testproject gesetzt.</p>
<p>
   Wie der Dokumentation zu entnehmen ist, erwartet der Aufruf der Methode getDIServiceObject() 
   zwei Parameter: den Namespace, unter dem die Konfiguration abgelegt ist und den Namen der Sektion,
   in der der Service definiert ist. In diesem Fall lautet der Namespace modules::guestbook2009::biz.
   Daraus resultiert der folgende Konfigurations-Pfad:
</p>
<gen:highlight type="code">/var/www/html/guestbook/apps/config/modules/guestbook2009/biz/testproject/DEFAULT_serviceobjects.ini</gen:highlight>
<p>
   Diese Datei füllen wir nun mit der Konfiguration des MOCK-Services (siehe Abschnitt Kopplung
   von Schichten). Beim Aufruf der zu Anfang angelegten index.php sehen wir nun die Ausgabe des
   Gästebuchs mit 10 Einträgen. Voila!
</p>

<h3 id="Chapter-16-Sprachabhaengigkeit"><a href="#Chapter-16-Sprachabhaengigkeit">16. Sprachabhängigkeit</a></h3>
<p>
   Die Templates zur Ausgabe enthalten an den relevanten Stellen explizite Texte wie z.B. Datum. Um
   das Gästebuch in mehreren Sprachen einsetzbar zu gestalten, könnten pro Sprache eigene
   Templates angelegt oder die Werte durch Platzhalter ersetzt werden. Die erste Möglichkeit
   erzeugt redundanten Code, der Pflege und Erweiterung des Moduls erschwert, die zweite Variante
   bedingt, dass die Platzhalter-Werte für jede Sprache gepflegt werden müssen.
</p>
<p>
   Das APF bietet für diese Aufgabenstellung eine Lösung für die Umsetzungs-Variante
   2 in Form von Taglibs an. Die sprachabhängigen Werte werden dabei aus einer
   Konfigurations-Datei bezogen. Die aktuell gewählte Sprache wird entnimmt die Taglib direkt
   aus dem Attribut $this->__Language, das durch den Page-Controller in jeden DOM-Knoten injiziert
   wird. Die Signatur des Tags ist laut Dokumentation die folgende:
</p>
<gen:highlight type="apf-xml">
&lt;html:getstring
   namespace=""
   config=""
   entry=""
/>
</gen:highlight>
<p>
   Mit dem Attribut namespace wird der Ablage-Ort der Sprach-Konfiguration definiert, config 
   enthält den Namen der Konfiguration und entry referenziert den Wert, der statt des
   Platzhalter-Tags ausgegeben werden soll. Damit kann das fest codierte Datum im Ausgabe-View
   folgendermaßen ersetzt werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:getstring
  namespace="modules::guestbook2009::pres"
  config="language.ini"
  entry="list.date"
/>:
<template:placeholder name="date" />, ...
</gen:highlight>
<p>Die korrespondierende Konfigurations-Datei ist wie im nachfolgenden Listing beschrieben aufgebaut:</p>
<gen:highlight type="ini">
[de]
list.date = "Datum"
...
[en]
list.date = "Date"
...
</gen:highlight>
<p>
   Da sich die Signaturen der Tags in den Templates nur um das Attribut entry unterscheiden, kann
   die Einbindung nochmals durch die Implementierung einer eigenen Taglib vereinfacht werden. In der
   verküzten Form wird die Beschriftung des Datums dann per
</p>
<gen:highlight type="apf-xml">
&lt;form:langlabel
  entry="form.label.email"
/>:
<template:placeholder name="date" />, ...
</gen:highlight>
<p>
   erledigt. Die Implementierung der Taglib &lt;form:langlabel /> nutzt dabei die im APF enthaltene
   Klasse ui_getstring und erweitert diese um die Definition der feststehenden Attribute. Da diese
   Funktion nicht nur innerhalb eines Formulars, sondern auch bei der Ausgabe der Einträge
   verwendet wird, leitet die Klasse form_taglib_langlabel nochmals von einer Basis-Klasse ab:
</p>
<gen:highlight type="php">
class langlabel_base extends ui_getstring {
   public function langlabel_base(){
      $this->__Attributes['namespace'] =
         'modules::guestbook2009::pres';
      $this->__Attributes['config'] =
         'language';
   }
}
class form_taglib_langlabel extends langlabel_base {
   public function form_taglib_langlabel(){
      parent::langlabel_base();
   }
}
</gen:highlight>

<h3 id="Chapter-17-Formulare"><a href="#Chapter-17-Formulare">17. Formulare</a></h3>
<p>
   Eine Besonderheit des APF ist die Formular-Unterstützung. Auf Basis des Taglib-Konzeptes
   wurden alle in HTML verfügbaren Formular-Elemente in Taglibs gekapselt. Damit können
   diese wie bei der Erstellung von HTML-Templates frei definiert werden, verfügen jedoch
   über Features wie Auto-Ausfüllen, Validierung und Filterung. Ein Formular lässt
   sich so vollständig mit Hilfe von Taglibs definieren ohne eine Zeile PHP-Code verfassen zu
   müssen. Hieraus ergibt sich zudem eine aus objektorientierter Sicht sehr elegante
   Möglichkeit Formulare zu kapseln.
</p>
<p>
   Innerhalb eines Document-Controllers steht ein Formular als eigenständiges DOM-Objekt zur
   Verfügung, das alle seine Elemente als Kind-Knoten beinhaltet. Es besitzt Methoden um auf
   Formular-Elemente zugreifen und dynamische Formulare erstellen zu können. Ein typisches
   APF-Formular gestaltet sich wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="tools::form::taglib"
   prefix="html"
   class="form"
/>
&lt;html:form name="search" method="post">
  &lt;html:text name="searchterm" />
  <form:button name="send" value="GO"/>
</html:form>
</gen:highlight>
<p>
   In diesem Formular wird das Attribut action selbst gefüllt, so dass mit dem gezeigten Code
   bereits ohne Zutun ein Postback auf die aktuelle Seite möglich ist. Die notwendigen
   HTML-Attribute werden von jedem Tag selbst erzeugt. Wie bei den übrigen Taglibs des APF hat
   der Entwickler die Möglichkeit generische Attribute wie beispielsweise class oder id
   hinzuzufügen um Formatierungen vorzunehmen oder eine Adressierung per JavaScript zu
   erleichtern.
</p>
<p>
   Um das oben gezeigte Formular darzustellen wird ein Document-Controller benötigt. Dies ist
   notwendig, da ein Formular immer an dynamische Aktionen gebunden ist, die vom Entwickler gemeint
   definiert werden müssen. Um das Such-Formular immer auf der Seite darzustellen genügt
   der folgende Code:
</p>
<gen:highlight type="php">
class search_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('search');
      $form->transformOnPlace();
   }
}
</gen:highlight>

<h3 id="Chapter-18-Der-Create-View"><a href="#Chapter-18-Der-Create-View">18. Der Create-View</a></h3>
<p>
   Um einen Eintrag verfassen zu können, benötigen wir ein Formular. Hierzu definieren
   wir ein neues Template, das wegen der Definition des &lt;core:importdesign />-Tags durch
   Ändern des URL-Paramaters gbwiew aufgerufen werden kann. Das Template trägt den
   Namen create.html und muss im selben Namespace wie auch list.html liegen.
</p>
<p>
   Der View selbst definiert nun das Formular mit den in den Anforderungen gewünschten Feldern:
</p>
<gen:highlight type="apf-xml">
<@controller
  namespace="modules::guestbook2009::pres::controller"
  file="create_controller"
  class="create_controller"
@>
...
&lt;html:form name="create_entry" ...>
  Name:
  <form:text
    maxlength="100" name="name"
    validate="true" button="send"
    filter="noSpecialCharacters"
  />
  <br />
  E-Mail:
  <form:text
    maxlength="100" name="email"
    validate="true" button="send"
    validator="EMail" filter="stripTags"
  />
  <br />
  ...
  Text:
  <br />
  <form:area
    name="text" validate="true"
    button="send" filter="stripTags"
  />
  ...
  <br />
  <form:button name="send" />
  ...
</html:form>
</gen:highlight>
<p>
   Zur Sicherung der Eingabe wird eine Zeichen-Begrenzung via HTML definiert und Validierung und 
   Filterung aktiviert. Zur Konfiguration der Validierung sind die Tag-Attribute validate, validator
   und button definiert. Sobald validate auf den Wert true eingestellt ist, wird ein
   Formular-Element auf das Klick-Event des angegebenen Buttons validiert. Die Art der Validierung
   kann mit dem Attribut validator bestimmt werden.
</p>
<p>
   Die Filterung basiert auf einer ähnlichen Konfiguration, jedoch wird hierfür lediglich 
   das Attribut filter hinzugefügt. Dieses referenziert entweder einen mitgelieferten Filter
   oder unter Angabe einer Filter-Klasse (Attribute: filterclass) einen eigenen Filter.
</p>
<p>
   Aufgabe des Controllers ist es nun, das Formular solange darzustellen, bis dieses gemäß 
   der Validator-Definition korrekt ausgefüllt ist um anschließend die Daten zur
   Speicherung an den GuestbookService zu übergeben:
</p>
<gen:highlight type="php">
class create_controller extends base_controller {
   public function transformContent(){
      $form =
        &$this->getForm('create_entry');
      if($form->get('isSent')
            && $form->get('isValid')){
         $name = &$form->getFormElementByName('name');
         $email = &$form->getFormElementByName('email');
         $web = &$form->getFormElementByName('website');
         $user = new User();
         $user->setName(
            $name->getAttribute('value')
         );
         $user->setEmail(
            $email->getAttribute('value')
         );
         $user->setWebsite(
            $web->getAttribute('value')
         );
         $title = &$form->getFormElementByName('title');
         $text = &$form->getFormElementByName('text');
         $entry = new Entry();
         $entry->setTitle(
            $title->getAttribute('value')
         );
         $entry->setText(
            $text->getContent()
         );
         $entry->setEditor($user);

         $gbService = &$this->getDIServiceObject('modules::guestbook2009::biz','GuestbookService');
         $gbService->saveEntry($entry);

      }
      ...
      $form->transformOnPlace();
      ...
   }
}
</gen:highlight>
<p>Ist das Formular weder abgeschickt noch valide, wird es per</p>
<gen:highlight type="php">$form->transformOnPlace();</gen:highlight>
<p>
   ausgegeben. Wurde das Formular abgeschickt und wunschgemäß ausgefüllt, so werden 
   mit Hilfe der Methode
</p>
<gen:highlight type="php">$form->getFormElementByName('...');</gen:highlight>
<p>
   die Formular-Elemente referenziert und die Werte wie von &rdquo;normalen&ldquo; HTML-Elementen
   eines Formulars ausgelesen. Da der GuestbookService aus Gründen einer konsistenten und
   typisierten API nur mit einem Domänen-Objekt versorgt werden darf, müssen die
   Informationen des Formulars in das Domänen-Modell überführt werden. Die Logik
   zur Speicherung des Eintrags und zur Anzeige des Ausgabe-Views wird dann vom GuestbookService
   übernommen.
</p>

<h3 id="Chapter-19-Front-Controller"><a href="#Chapter-19-Front-Controller">19. Front-Controller</a></h3>
<p>
   Im letzten Abschnitt wurde die Anforderung, das Formular durch ein CAPTCHA zu schützen
   ausgespart. Der Grund dafür ist, dass das APF dazu bereits ein fertiges Modul anbietet, das
   lediglich konfiguriert und in das Formular eingebaut werden muss. Das Modul besteht aus einer
   Taglib, die das CAPTCHA-Bild und ein Text-Feld anzeigt und sich selbständig um die
   Validierung der Eingabe kümmert. Die Anzeige des Bildes wird dabei von einer
   Front-Controller-Action übernommen. Hierbei wird der Umstand ausgenutzt, dass Actions vom
   Typ prepagecreate vor dem Aufbau der Seite ausgeführt werden. Dadurch kann ein dynamisch
   erzeugtes Bild mit derselben Bootstrap-Datei ausgeliefert werden, wie die Applikation selbst.
</p>
<p>
   Um das unter <int:link pageid="094" /> beschriebene Modul nutzen zu können, muss
   zunächst die Taglib in das Eingabe-Formular integriert werden:
</p>
<gen:highlight type="apf-xml">
&lt;form:addtaglib
  namespace="modules::captcha::pres::taglib"
  prefix="form"
  class="captcha"
/>
&lt;form:captcha
  validate="true" button="send"
  clearonerror="true"
/&gt;
</gen:highlight>
<p>
   Wie der Code-Box zu entnehmen ist, wird die verwendete Taglib zunächst dem Formular bekannt
   gegeben. Bauen wir die Zeilen in das Template des Create-Views ein, stellen wir zunächst
   fest, dass kein CAPTCHA-Bild ausgegeben wird. Um dies zu ermöglichen, muss die
   Bootstrap-Datei angepasst und die Auslieferung der Seite über den Front-Controller geregelt
   werden. Die index.php muss gemäß <int:link pageid="094" /> damit folgende Gestalt haben:
</p>
<gen:highlight type="php">
include('./apps/core/pagecontroller/pagecontroller.php');
import(
   'core::frontcontroller',
   'Frontcontroller'
);
$fC = &Singleton::getInstance(
   'Frontcontroller'
);
$fC->setContext('testproject');
echo $fC->start(
   'gb::templates',
   'guestbook'
);
</gen:highlight>
<p>
   Der Front-Controller ist eine Erweiterung des Page-Controllers, der vor dem Erstellen der Seite,
   nach dem Aufbau des DOM-Baumes und nach der Transformation so genannte Actions ausführt.
   Diese können für verschiedene Aufgaben innerhalb einer Applikation wie beispielsweise
   das Befüllen eines Models eingesetzt werden.
</p>
<p>
   Der Front-Controller führt jedoch nur bekannte Actions aus. Diese können statisch in
   der index.php oder dynamisch über Anweisungen in der URL bekannt gegeben werden. Da in den
   URL-Anweisungen nicht alle Informationen zur Ausführung enthalten sind, muss ein URL-Mapping
   definiert sein.
</p>
<p>
   Die für die Auslieferung des CAPTCHA-Bildes notwendige Konfiguration können wir aus
   dem apf-configpack-*-Release-Paket entnehmen. Hierzu befindet sich im Ordner
   <em>modules/captcha/biz/actions/</em> eine Date mit dem Namen <em>EXAMPLE_actionconfig.ini</em>.
</p>
<p>
   Für die Ablage der Konfigurations-Datei gilt auch hier das im Abschnitt Konfiguration
   beschrieben Schema. Die Action-Definition muss deshalb im Ordner
</p>
<gen:highlight type="code">/var/www/html/guestbook/apps/config/modules/captcha/biz/actions/testproject/</gen:highlight>
<p>unter dem Namen</p>
<gen:highlight type="code">DEFAULT_actionconfig.ini</gen:highlight>
<p>abgelegt werden. Der folgende Code-Block zeigt den Inhalt der Action-Definition:</p>
<gen:highlight type="ini">
[showCaptcha]
FC.ActionNamespace = "modules::captcha::biz::actions"
FC.ActionFile = "ShowCaptchaImageAction"
FC.ActionClass = "ShowCaptchaImageAction"
FC.InputFile = "ShowCaptchaImageInput"
FC.InputClass = "ShowCaptchaImageInput"
FC.InputParams = ""
</gen:highlight>
<p>
   Die ersten drei Parameter referenzieren die Klasse, die die Action im Code repräsentiert, 
   die folgenden beschreiben die Klasse, die zur Kapselung der Parameter eingesetzt wird. Die
   Direktive FC.InputParams kann dazu verwendet werden, Standard-Parameter für eine Action zu
   definieren.
</p>
<p>
   Rufen wir nun die Bootstrap-Datei via <em>index.php?gbview=create</em> auf, so wird das 
   CAPTCHA-Bild angezeigt:
</p>

<img src="http://media.adventure-php-framework.org/content/captcha.png" alt="CAPTCHA-Taglib des APF" />

<h3 id="Chapter-20-Login-und-Authentifizierung"><a href="#Chapter-20-Login-und-Authentifizierung">20. Login und Authentifizierung</a></h3>
<p>
   Im Abschnitt Der Basis-View haben wir bereits die Möglichkeit geschaffen, im Inhaltsbereich
   des Gästebuchs verschiedene Views über den URL-Parameter gbview einblenden zu
   können. Der Login-View kann deshalb parallel zu den bereits implementierten View-Templates
   angelegt werden.
</p>
<p>
   Zur Authentifizierung eines Gästebuch-Administrators soll gemäß Design
   Benutzer-Name und Passwort verwendet werden. Aus diesem Grund präsentiert der Login-View
   ein Formular zur Eingaben der relevanten Daten. Aus Gründen der Einfachheit wird das Backend
   nur in englischer Sprache angeboten:
</p>
<gen:highlight type="apf-xml">
<@controller
  namespace="modules::guestbook2009::pres::controller"
  class="login_controller"
  file="login_controller"
@>
&lt;core:addtaglib
  namespace="tools::form::taglib"
  prefix="html" class="form"
/>
Please log in to administrate the guestbook.
&lt;html:form name="login" method="post">
  <form:placeholder name="error" />
  <label>Username:</label>
  <form:text
    maxlength="100" name="username"
    class="gb--login-field-username"
    validate="true" button="login"
  />
  ...
  <label>Password:</label>
  <form:password
    maxlength="100" name="password"
    validate="true" button="login"
  />
  ...
  <form:button
    name="login" value="Login"
  />
</html:form>
&lt;html:template name="error">
  ... The given user credentials are wrong! ...
</html:template>
</gen:highlight>
<p>
   Zur Ausgabe der Fehlermeldung wurde ein Template angelegt, das die relevante Meldung beinhaltet.
   Dieses wird im Fehlerfall in den Formular-Platzhalter error injiziert um den Benutzer auf falsche
   Authentifizierungs-Daten hinzuweisen.
</p>
<p>
   Der Controller übernimmt dabei die Aufgabe, die Inhalte des Formulars in ein
   Domänen-Objekt zu übersetzten und dieses dem GuestbookService zur Prüfung zu
   übergeben. Schlägt diese fehl, so wird die zuvor erwähnte Fehlermeldung angezeigt:
</p>
<gen:highlight type="php">
class login_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('login');
      if($form->get('isSent')
            && $form->get('isValid')){
         $fieldUser =
            &$form->getFormElementByName(
               'username'
            );
         $fieldPass =
            &$form->getFormElementByName(
               'password'
            );
         $user = new User();
         $user->setUsername(
            $fieldUser->getAttribute(
               'value'
            )
         );
         $user->setPassword(
            $fieldPass->getAttribute(
               'value'
            )
         );
         $gS =
            &$this->getDIServiceObject(
            'modules::guestbook2009::biz',
            'GuestbookService'
         );
         if(
            !$gS->validateCredentials(
               $user)
           ){
            $error =
               &$this->getTemplate(
                  'error'
               );
            $form->setPlaceHolder(
               'error',
               $error->transformTemplate()
            );
         }
      }
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Wird der Benutzer erfolgreich authentifiziert, sorgt der GuestbookService dafür, dass der
   entsprechende View des Backends angezeigt wird.
</p>

<h3 id="Chapter-21-Die-Administration"><a href="#Chapter-21-Die-Administration">21. Die Administration</a></h3>
<p>
   Das Backend des Gästebuchs bietet die Möglichkeit, Einträge zu editieren und zu
   löschen. Damit für das Backend keine weitere Installation des Frameworks und des
   Gästebuch-Moduls notwendig ist, soll der dieses direkt in das Modul integriert werden. Hierzu
   nutzen wir den Inhalts-View, der auch schon die Ausgabe, das Formular und das Login darstellt.
</p>
<p>
   Der Admin-View – den wir parallel zu den bisher erstellten Templates anlegen – beinhaltet zwei
   weitere Views: das Menü zur Steuerung der Funktionen und den Inhaltsbereich, in dem die
   administrativen Aktionen vorgenommen werden können. Die folgende Abbildung zeigt den Aufbau:
</p>

<img src="http://media.adventure-php-framework.org/content/admin_views.png" alt="Die Admin-Ansicht des APF-Gästebuch" />

<p>
   Implementierungs-technisch bedeutet ein weiterer View dabei lediglich die Verwendung eines
   weiteren &lt;core:importdesign />-Tags im Admin-View-Template. Da der Inhaltsbereich bereits
   über den URL-Parameter gbview gesteuert wird, muss an dieser Stelle darauf geachtet werden,
   dass der Steuer-Parameter einen anderen Namen erhält: adminview. Der Übersichtlichkeit
   halber werden die Dateien des Backends im Ordner admin abgelegt, der sowohl unter pres/templates/
   als auch unter pres/controller/ angelegt wird. Gemäß des zuvor gezeigten Aufbaus
   beinhaltet das Template admin.html folgenden Quellcode:
</p>
<gen:highlight type="apf-xml">
<@controller
  namespace="modules::guestbook2009::pres::controller"
  file="admin_controller"
  class="admin_controller"
@>
<a href="&lt;html:placeholder name="editLink" />"Edit entry</a>
<a href="&lt;html:placeholder name="deleteLink" />">Delete entry</a>
<a href="&lt;html:placeholder name="logoutLink" />">Logout</a>
...
&lt;core:importdesign
  namespace="modules::guestbook2009::pres::templates::admin"
  template="[adminview=start]"
  incparam="adminview"
/>
</gen:highlight>
<p>
   Wie auch im Haupt-Template des Gästebuchs, wurde auch hier der statische Teil – das
   Admin-Menü – nicht in ein eigenes Template ausgelagert. Sofern notwendig, kann dies jedoch
   im Rahmen einer Weiterentwicklung ohne weiteres durchgeführt werden.
</p>
<p>
   Das &lt;core:importdesign />-Tag inkludiert je nach Wert des Parameters adminview das Template,
   das die Aktionen des jeweiligen Menü-Punktes der Administration darstellt.
</p>
<p>
   Der zugehörige Controller delegiert dabei die Prüfung, ob das Administrations-Interface 
   aufgerufen werden darf, an den GuestbookService und füllt die Platzhalter mit den
   gewünschten Links:
</p>
<gen:highlight type="php">
class admin_controller extends base_controller {

   public function transformContent() {

      // invoke the service to check, if the current user may request this page
      $gS = &$this->getDIServiceObject('modules::guestbook2009::biz', 'GuestbookService');
      $gS->checkAccessAllowed();

      // generate the admin menu links using the fc linkhander to
      // be able to include the module in either page.
      $editLink = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'admin',
                          'adminview' => 'edit'
                      )));
      $this->setPlaceHolder('editLink', $editLink);

      $deleteLink = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'admin',
                          'adminview' => 'delete'
                      )));
      $this->setPlaceHolder('deleteLink', $deleteLink);

      $logoutLink = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'admin',
                          'adminview' => 'logout'
                      )));
      $this->setPlaceHolder('logoutLink', $logoutLink);
   }

}
</gen:highlight>
<p>
   Zur Link-Generierung wurde die auch bereits zuvor genutzte Klasse <em>LinkGenerator</em>
   verwendet. Diese bietet gegenüber der manuellen Link-Definition den Vorteil, dass nur
   diejenigen Parameter der aktuellen URL beeinflusst werden, die für das aktuelle Modul
   wirklich relevant sind. So können verschiedene Module sehr einfach auf einer Seite platziert
   werden, ohne dass Abhängigkeiten manuell auflösen zu müssen. Die URL-Parameter
   anderer Komponenten bleiben einfach unverändert in der URL enthalten.
</p>

<h3 id="Chapter-22-Auslagerung-von-Templates"><a href="#Chapter-22-Auslagerung-von-Templates">22. Auslagerung von Templates</a></h3>
<p>
   Die Templates zum Bearbeiten und Löschen eines Eintrags beinhalten gemäß der
   zuvor festgelegten Struktur beide ein Auswahl-Menü für das zu behandelnde Entry-Objekt.
   Um keinen redundanten Code zu erzeugen, kann für das Auswahl-Menü ein eigenes Template
   und ein eigener Controller erstellt werden.
</p>
<p>
   Die DOM-Struktur des APF erlaubt es dann – ähnlich einer Prä-Compiler-Direktive – ein
   ausgelagertes Template an die gewünschte Stelle einzubinden. Im Document-Controller
   können die darin definierten Elemente dann wie direkt im Template vorhandene Objekte
   behandelt werden.
</p>
<p>
   Um zu verhindern, dass der PHP-Code zum Befüllen und Ausgeben des Formulars redundant
   vorhanden ist, erstellen wir eine abstrakte Basis-Klasse, von der die konkreten Controller
   ableiten. Diese beinhaltet die Funktion, das Formular darzustellen:
</p>
<gen:highlight type="php">
abstract class backend_base_controller extends base_controller {

   protected function displayEntrySelection($adminView) {

      // fill the select list
      $form = &$this->getForm('selectentry');
      $select = &$form->getFormElementByName('entryid');

      $gS = &$this->getDIServiceObject('modules::guestbook2009::biz', 'GuestbookService');
      $entriesList = $gS->loadEntryListForSelection();

      foreach ($entriesList as $entry) {
         /* @var $entry Entry */
         $select->addOption($entry->getTitle() . ' (#' . $entry->getId() . ')', $entry->getId());
      }

      // define form action url concerning the view it is rendered in
      $action = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'admin',
                          'adminview' => $adminView
                      )));

      $form->setAttribute('action', $action);

      $form->transformOnPlace();
   }

}
</gen:highlight>
<p>
   Das Einbinden des widerverwendbaren Template-Fragments gestaltet sich ähnlich dem Einbinden
   eines View-Templates:
</p>
<gen:highlight type="apf-xml">
&lt;core:appendnode
   namespace="modules::guestbook2009::pres::templates::admin"
   template="choose"
/>
</gen:highlight>

<h3 id="Chapter-23-Bearbeiten-eines-Eintrags"><a href="#Chapter-23-Bearbeiten-eines-Eintrags">23. Bearbeiten eines Eintrags</a></h3>
<p>
   Das Bearbeiten eines Eintrags verhält sich weitestgehend identisch zur Erstellung. Unter
   Die Administration haben wir durch die Menü-Struktur und die Definition der Views bereits 
   implizit vorgegeben, dass das Template edit.html die Darstellung für die Bearbeitung eines
   Entry-Objektes übernimmt. Dies umfasst das Menü zur Auswahl des gewünschten Eintrags
   und ein Formular zur Manipulation der Werte:
</p>
<gen:highlight type="apf-xml">
<@controller
  namespace="modules::guestbook2009::pres::controller::admin"
  file="edit_controller"
class="edit_controller"
@>
&lt;core:addtaglib
  namespace="core::pagecontroller"
  prefix="core"
  class="appendnode"
/>
Please select an entry to edit!
&lt;core:appendnode
  namespace="modules::guestbook2009::pres::templates::admin"
  template="choose"
/>
&lt;core:addtaglib
  namespace="tools::form::taglib"
  prefix="html"
  class="form"
/>
&lt;html:form name="edit_entry" method="post">
  ...
  <form:button name="send" value="Save" />
  <form:hidden name="entryid" />
  <form:hidden name="editorid" />
</html:form>
</gen:highlight>
<p>
   Da auf den Aufbau des Formulars bereits im Abschnitt Der Create-View besprochen wurde, ist die
   Darstellung dieses Templates auf das Wesentliche reduziert. Neben dem Formular beinhaltet es
   noch die Definition des zuständigen Controllers und die Einbindung des Auswahl-Menüs
   mit Hilfe des &lt;core:appendnode />-Tags. Das Template choose.html selbst beinhaltet dabei die
   Definition des Auswahl-Formulars:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="selectentry" method="post">
   <label>Select entry:</label>
   <form:select
      name="entryid"
   />
   <form:button
      name="choose"
      value="OK"
   />
</html:form>
</gen:highlight>
<p>
   Der Controller ist nun dafür zuständig, im ersten Schritt das Auswahl-Menü
   anzuzeigen und im zweiten Schritt die Bearbeitung des Eintrags zu ermöglichen:
</p>
<gen:highlight type="php">
class edit_controller extends backend_base_controller {
   public function transformContent(){
      $entryId = RequestHandler::getValue('entryid');
      if($entryId === null){
         $this->__displayEntrySelection(
            'edit'
         );
         return;
      }
      $gS = &$this->getDIServiceObject(
         'modules::guestbook2009::biz',
         'GuestbookService'
      );
      $form = &$this->getForm(
         'edit_entry'
      );
      if(!$form->get('isSent')){
         $entry = $gS->loadEntry(
            $entryId
         );
         $editor = $entry->getEditor();
         $name = &$form->getFormElementByName('name');
         $name->setAttribute(
            'value',$editor->getName()
         );
         ...
      }
      else{
         if($form->get('isValid')){
            // ... collect values ...
            $gS->saveEntry($entry);
         }
      }
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Die Unterscheidung der Anzeige-Schritte wird dabei über die Id des zu bearbeitenden
   Eintrags vorgenommen. Ist diese noch nicht im Request vorhanden – das Formular wurde noch nicht
   abgesendet –, wird das Auswahl-Menü angezeigt, wurde ein Eintrag zur Bearbeitung
   ausgewählt, wird das Formular angezeigt. Sofern das Formular zum ersten Mal dargestellt wird,
   fragt der Document-Controller die Werte bei der Business-Schicht an und füllt die Felder mit
   den Werten des gewählten Beitrags. Wurde das Formular gemäß den Validator-Regeln
   ausgefüllt und abgeschickt, so liest der Controller die Inhalte des Formulars aus,
   befüllt die relevanten Domänen-Objekte und übergibt diese dem GuestbookService
   zur Speicherung.
</p>

<h3 id="Chapter-24-Loeschen-eines-Eintrags"><a href="#Chapter-24-Loeschen-eines-Eintrags">24. Löschen eines Eintrags</a></h3>
<p>
   Möchte ein Administrator einen Eintrag löschen, so muss dieser zunächst den
   gewünschten Eintrag auswählen. Anschließend wird ein Bestätigungs-Dialog
   angezeigt, damit Beiträge nicht versehentlich gelöscht werden können. Da die
   Definition des Auswahlmenüs bereits besteht, beschreibt das Template delete.html lediglich
   einen Bestätigungs-Dialog in Form von zwei Formularen:
</p>
<gen:highlight type="apf-xml">
<@controller
  namespace="modules::guestbook2009::pres::controller::admin"
  file="delete_controller"
  class="delete_controller"
@>
...
Please select an entry to delete!
&lt;core:appendnode
  namespace="modules::guestbook2009::pres::templates::admin"
  template="choose"
/>
&lt;html:template name="confirm_text">
  Do you really want do delete this entry?
</html:template>
&lt;html:form name="delete_yes" method="post">
  <form:button name="yes" value="Yes" />
  <form:hidden name="entryid" />
</html:form>
&lt;html:form name="delete_no" method="post">
  <form:button name="no" value="No" />
</html:form>
</gen:highlight>
<p>
   Der zugehörige Controller bietet – ähnlich wie im letzten Abschnitt – die Liste der
   Einträge zur Auswahl an und kümmert sich um die Verarbeitung der Eingabe:
</p>
<gen:highlight type="php">
class delete_controller extends backend_base_controller {
   public function transformContent(){
      $entryId = RequestHandler::getValue('entryid');
      if($entryId === null){
         $this->__displayEntrySelection('delete');
         return;
      }

      $gS = &$this->getDIServiceObject(
         'modules::guestbook2009::biz',
         'GuestbookService'
      );
      $form_yes = &$this->getForm(
         'delete_yes'
      );
      $form_no = &$this->getForm(
         'delete_no'
      );
      if($form_no->get('isSent') ||
         $form_yes->get('isSent')){
         $entry = null;
         if($form_yes->get('isSent')){
            $entry = new Entry();
            $entry->setId($entryId);
         }
         $gS->deleteEntry($entry);
         return;
      }

      $hidden_yes = &$form_yes->getFormElementByName('entryid');
      $hidden_yes ->setAttribute('value',$entryId);
      $form_yes->transformOnPlace();
      $form_no->transformOnPlace();

      $confirm = $this->getTemplate(
         'confirm_text'
      );
      $confirm->transformOnPlace();
   }
}
</gen:highlight>

<h3 id="Chapter-25-Die-Business-Schicht"><a href="#Chapter-25-Die-Business-Schicht">25. Die Business-Schicht</a></h3>
<p>
   Nach dem wir die Funktion der Präsentations-Schicht nun vollständig implementiert
   haben, widmen wir uns der Business-Schicht. Dieser kommt die zentrale Steuerung der Anwendung zu.
   Sie sorgt dafür, dass ein Event mit dem Anzeigen eines dafür vorgesehenen Views
   quittiert wird und die in der Applikation behandelten Daten an die Präsentations- oder
   Daten-Schicht weitergegeben werden. Sie kümmert sich zudem um das Thema Paging und die
   Benutzer-Authentifizierung für das Backend.
</p>
<p>
   Wie im Abschnitt Kopplung von Schichten beschrieben ist, wird der DIServiceManager (siehe [5]) 
   zur Entkoppelung der Schichten genutzt. Dies ermöglicht nicht nur einen einfachen Austausch
   von Schichten, sondern kann ebenfalls dazu verwendet werden, eine Komponente zu konfigurieren.
   Zur Anzeige der blätterbaren Liste kommt das Pager-Modul (siehe <int:link pageid="092" />)
   des APF zum Einsatz. Dieses benötigt zur Initialisierung den Namen der zu verwendenden
   Konfiguration. Um diese Abhängigkeit für die Business-Schicht transparent zu halten und
   die Möglichkeit zu wahren, dies von außen steuern zu können, wird diese Information
   via dependency injection mitgegeben. Dazu fügen wir eine Konfigurations-Anweisung zur
   Service-Definition hinzu und ändern gleichzeitig den Service-Typ auf SINGLETON, damit die
   Business-Schicht nur einmal innerhalb der Applikation existiert:
</p>
<gen:highlight type="ini">
[GuestbookService]
servicetype = "SINGLETON"
namespace = "modules::guestbook2009::biz"
class = "GuestbookService"
conf.pager.method = "setPagerConfigSection"
conf.pager.value = "Guestbook2009"
</gen:highlight>
<p>
   Beim Erzeugen des GuestbookService wird der Methode setPagerConfigSection() der Wert
   Guestbook2009 mitgegeben. Damit sichergestellt ist, dass der Service immer korrekt konfiguriert
   wird muss die Implementierung der Klasse folgendes Grundgerüst aufweisen:
</p>
<gen:highlight type="php">
final class GuestbookService extends APFObject {
   private $__PagerConfigSection;
   public function setPagerConfigSection($section){
      $this->__PagerConfigSection =
         $section;
   }
}
</gen:highlight>
<p>
   Da der Pager – wie auch die CAPTCHA-Taglib –fertige Komponenten sind, soll dieser hier nicht 
   weiter betrachtet werden.
</p>

<h3 id="Chapter-26-Laden-des-Gaestebuchs"><a href="#Chapter-26-Laden-des-Gaestebuchs">26. Laden des Gästebuchs</a></h3>
<p>
   Beginnen wir bei der Implementierung des GuestbookService mit dem Laden des Gästebuchs.
   Für diese Aufgabe stellt die Business-Schicht die Methode loadGuestbook() zur Verfügung:
</p>
<gen:highlight type="php">
final class GuestbookService extends APFObject {
   public function loadGuestbook(){
      $mapper = &$this->__getMapper();
      return $mapper->loadGuestbook();
   }
   private function &__getMapper(){
      return $this->getDIServiceObject(
         'modules::guestbook2009::data',
         'GuestbookMapper');
   }
}
</gen:highlight>
<p>
   Wie dem Quellcode entnommen werden kann, wird das Laden des gewünschten Guestbook-Objektes
   an die Datenschicht delegiert. Dies erfolgt deshalb, da bei diesem Vorgang keine weitere
   Interaktion der Business-Schicht notwendig ist. Die Rückgabe des Mapper-Aufrufs enthält
   das gewünschte Gästebuch-Domänen-Objekt.
</p>
<p>
   Auch in der Business-Schicht wird der DIServiceManager zur Adressierung eines Services – in
   diesem Fall der Datenschicht – genutzt. Damit ist es möglich, die Business-Schicht mit Hilfe
   einer MOCK-Daten-Schicht vollständig automatisiert zu testen und die Datenschicht mit der
   notwendigen Konfiguration zu versorgen.
</p>

<h3 id="Chapter-27-Laden-der-Eintraege"><a href="#Chapter-27-Laden-der-Eintraege">27. Laden der Einträge</a></h3>
<p>
   Wie bereits angesprochen, wird zum Laden der Einträge der Pager des APF eingesetzt. Im 
   Gegensatz zu der im vorangegangenen Abschnitt besprochenen Aufgabe ist hier das Eingreifen der
   Business-Schicht notwendig.
</p>
<p>
   Daher wird zunächst die Liste der Einträge über den Pager bezogen.
   Anschließend wird die Daten-Schicht-Komponente dazu genutzt um die Instanzen der
   Einträge zu laden. Die Methode __getPager() kümmert sich dabei um die Bereitstellung
   der konfigurierten Instanz des Pagers:
</p>
<gen:highlight type="php">
public function loadPagedEntryList(){
   $pager = &$this->__getPager();
   $model = &$this->getServiceObject(
      'modules::guestbook2009::biz',
      'GuestbookModel'
   );
   $entryIds = $pager->loadEntries(
      array(
         'GuestbookID' =>
         $model->get('GuestbookId'))
      );

   $entries = array();
   $mapper = &$this->__getMapper();
   foreach($entryIds as $entryId){
      $entries[] =
         $mapper->loadEntry($entryId);
   }
   return $entries;
}
private function &__getPager(){
   $pMF = &$this->getServiceObject(
      'modules::pager::biz',
      'PagerManagerFabric'
   );
   return $pMF->getPagerManager(
      $this->__PagerConfigSection
   );
}
</gen:highlight>

<h3 id="Chapter-28-Authentifizierung"><a href="#Chapter-28-Authentifizierung">28. Authentifizierung</a></h3>
<p>
   Wie in der Implementierung der Präsentations-Schicht bereits festgelegt, soll die
   Business-Schicht die Methode validateCredentials() bereitstellen, um die vom Nutzer eingegebenen
   Zugangsdaten zu validieren. Die Methode wird dabei gleichzeitig dazu verwendet, den Benutzer im
   Erfolgsfall in der Session als eingeloggt zu markieren und den Admin-View anzuzeigen:
</p>
<gen:highlight type="php">
public function validateCredentials(User $user) {

   $mapper = &$this->getMapper();
   if ($mapper->validateCredentials($user)) {

      // log user in
      $model = &$this->getServiceObject('modules::guestbook2009::biz', 'GuestbookModel');
      $guestbookId = $model->getGuestbookId();
      $session = new SessionManager('modules::guestbook2009::biz::' . $guestbookId);
      $session->saveSessionData('LoggedIn', 'true');

      // redirect to admin page
      $adminLink = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'admin',
                          'adminview' => null
                      )));
      HeaderManager::forward($adminLink);
   }
   return false;
}
</gen:highlight>
<p>
   Am Aufruf des LinkGenerator lässt sich erkennen, dass das Konzept der View-Definition hinsichtlich
   der Adressierung deutliche Vorteile aufweist. So ist es bei der Generierung des Links lediglich
   notwendig, die View-Parameter ungeachtet der Hierarchie entsprechend dem gewünschten Szenario
   in der URL zu platzieren.
</p>

<h3 id="Chapter-29-Speichern-von-Eintraegen"><a href="#Chapter-29-Speichern-von-Eintraegen">29. Speichern von Einträgen</a></h3>
Eine weitere Aufgabe besteht in der Speicherung von Einträgen. Hier ergeben sich zwei Anwendungsfälle: das Anlegen eines Eintrags und das Speichern des Eintrags nach erfolgter Administration. Die Speicherung des Eintrags selbst wird dabei über eine Methode des Mappers abgebildet, die beide Anwendungsfälle abdeckt. Die Anzeige des Views wird daran festgemacht, ob der Eintrag bereits eine Id besitzt oder nicht:
<gen:highlight type="php">
public function saveEntry(Entry $entry) {

   $mapper = &$this->getMapper();
   $mapper->saveEntry($entry);

   // Forward to the desired view to prevent F5-bugs.
   $entryId = $entry->getId();
   if (!empty($entryId)) {
      $link = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'admin'
                      )));
   } else {
      $link = LinkGenerator::generateUrl(Url::fromCurrent()->mergeQuery(array(
                          'gbview' => 'list'
                      )));
   }
   HeaderManager::forward($link);
}
</gen:highlight>
<p>
   Die Implementierung der übrigen Funktionalitäten der Business-Schicht können der 
   Klasse GuestbookService unter [1] direkt entnommen werden.
</p>

<h3 id="Chapter-30-Die-Datenschicht"><a href="#Chapter-30-Die-Datenschicht">30. Die Datenschicht</a></h3>
<p>
   Die Datenschicht des Gästebuchs stellt den komplexesten Teil der Anwendung dar. Dies ist
   darin begründet, dass das Design des Gästebuchs vorsieht, das Mapping der in der
   Datenbank gespeicherten, Sprach-abhängigen, Objekte in die einsprachigen Domänen-Objekte
   in der Datenschicht vorzunehmen.
</p>
<p>
   Um die Speicherung und Bearbeitung der Daten-Objekte zu erleichtern, wird bei der Implementierung
   auf den GenericORMapper (siehe <int:link pageid="063" />) zurückgegriffen. Dieser
   übernimmt bereits einen Großteil der Aufgaben und stellt eine Schnittstelle zur
   Verwaltung von Objekten und deren Beziehungen in einer relationalen Datenbank bereit. Ein weiterer
   Vorteil des GenericORMapper ist, dass die Benennungen der Objekte und Beziehungen aus dem Design
   1:1 in die Konfiguration des Mappers einfließen und sich im Code wieder finden.
</p>
<p>
   Rufen wir uns zunächst noch einmal das UML-Diagramm der Objekte der Datenschicht in
   Erinnerung:
</p>

<img src="http://media.adventure-php-framework.org/content/uml_data_object_model.png" alt="Das Datenmodell des APF-Gästebuch" />

<p>
   Dieses sieht vor, dass die Sprach-abhängigen Werte eines Domänen-Objekts über
   Attribut-Objekte abgebildet werden, die zu einer Sprache assoziiert sind. Beim Laden eines
   Entry-Objektes müssen demnach alle Attribut-Objekte geladen werden, die sowohl unter dem
   Entry-Stellvertreter-Objekt komponiert als auch zur aktuell gewählten Sprache assoziiert
   sind. Anschließend kann damit das Entry-Domänen-Objekt gefüllt werden. Bei der
   Speicherung eines Domänen-Objekts muss der umgekehrte Weg beschritten und die einzelnen,
   Sprach-abhängigen Attribute in Attribute-Objekte mit einer Assoziation zur aktuell aktiven
   Sprache übersetzt werden. Dieselbe Vorgehensweise gilt für das Laden und die Speicherung
   von Guestbook-Domänen-Objekten.
</p>

<h3 id="Chapter-31-Der-OR-Mapper"><a href="#Chapter-31-Der-OR-Mapper">31. Der O/R-Mapper</a></h3>
<p>
   Zur Nutzung des GenericORMapper, müssen zunächst die im UML-Diagramm abgebildeten
   Objekte und deren Beziehung in je einer Konfiguration definiert werden. Dazu dienen zwei
   Konfigurations-Dateien: DEFAULT_*_objects.ini für die Definition der Objekte und
   DEFAULT_*_relations.ini für die Beschreibung der Beziehungen. Die Objekt-Definition hat
   gemäß UML folgenden Inhalt:
</p>
<gen:highlight type="ini">
[Guestbook]

[Entry]

[Attribute]
Name = "VARCHAR(100)"
Value = "TEXT"

[Language]
DisplayName = "VARCHAR(100)"
ISOCode = "VARCHAR(2)"

[User]
Name = "VARCHAR(100)"
Email = "VARCHAR(100)"
Website = "VARCHAR(100)"
Username = "VARCHAR(100)"
Password = "VARCHAR(100)"
</gen:highlight>
<p>
   Die Sektionen Guestbook und Entry beinhalten keine Objekt-Attribute, da es sich bei diesen nur
   um Stellvertreter-Objekte handelt. Die im UML beschriebenen Beziehungen werden wie folgt
   konfiguriert:
</p>
<gen:highlight type="ini">
[Guestbook2LangDepValues]
Type = "COMPOSITION"
SourceObject = "Guestbook"
TargetObject = "Attribute"

[Entry2LangDepValues]
Type = "COMPOSITION"
SourceObject = "Entry"
TargetObject = "Attribute"

[Guestbook2Adminstrator]
Type = "ASSOCIATION"
SourceObject = "Guestbook"
TargetObject = "User"

[Editor2Entry]
Type = "ASSOCIATION"
SourceObject = "User"
TargetObject = "Entry"

[Guestbook2Entry]
Type = "COMPOSITION"
SourceObject = "Guestbook"
TargetObject = "Entry"

[Attribute2Language]
Type = "ASSOCIATION"
SourceObject = "Attribute"
TargetObject = "Language"
</gen:highlight>
<p>
   Zur Verwaltung der Objekte bringt der O/R-Mapper die Klasse GenericDomainObject mit, die zur
   Repräsentation der gespeicherten Daten-Objekte verwendet wird. Nach dem Setup der Datenbank
   (siehe nachfolgender Abschnitt) kann ein User-Objekt mit Hilfe des Mappers wie folgt gespeichert
   werden:
</p>
<gen:highlight type="php">
$user = new GenericDomainObject('User');
$user->setProperty('Name','');
$user->setProperty('Email','');
$orm->saveObject($user);
Die Variable $orm beinhaltet dabei eine Instanz des Mappers, der durch
$ormFactory =
   &$this->getServiceObject(
      'modules::genericormapper::data',
      'GenericORMapperFactory'
);
$orm = &$ormFactory->getGenericORMapper(
   'modules::guestbook2009::data',
   'guestbook2009',
   '...'
);
</gen:highlight>
<p>erzeugt wurde.</p>

<h3 id="Chapter-32-Setup-der-Datenbank"><a href="#Chapter-32-Setup-der-Datenbank">32. Setup der Datenbank</a></h3>
<p>
   Der GenericORMapper bietet eine komfortable Möglichkeit, aus der erstellten Konfiguration
   das Setup der Datenbank zu generieren. Hierzu liegen dem APF die Komponente GenericORMapperSetup
   und eine Anleitung zum Setup der Datenbank bei. Um die Datenbank direkt initialisieren zu
   können, muss jedoch eine gültige Datenbank-Konfiguration vorliegen. Da der
   GenericORMapper den ConnectionManager als Datenbank-Abstraktions-Schicht nutzt, muss dem
   Setup-Tool lediglich eine gültige Konfigurations-Sektion übergeben werden.
</p>
<p>
   Datenbank-Konfigurationen werden dabei unter dem Namespace core::database und dem jeweiligen 
   Context der Applikation in der Datei DEFAULT_connections.ini erwartet. Diese folgt dem
   anschließend abgedruckten Schema:
</p>
<gen:highlight type="ini">
[guestbook2009]
DB.Host = "localhost"
DB.User = "..."
DB.Pass = "..."
DB.Name = "phpjournal"
DB.Type = "MySQLx"
[DB.Charset = "utf8"]
[DB.Collation = "utf8_general_ci"]
</gen:highlight>
<p>
   Die Direktive DB.Type definiert den Datenbank-Treiber, der für die Verbindung verwendet
   werden soll. In diesem Fall verwenden wir MySQLx, da die Daten in einer MySQL gespeichert werden
   sollen.
</p>
<p>
   Um mit dem Setup beginnen zu können, müssen wir die oben beschrieben
   Konfigurations-Dateien im richtigen Verzeichnis ablegen. Um innerhalb eines Moduls mehrere
   Mapper-Konfigurationen verwenden zu können, wird jeder Satz an Konfigurations-Dateien
   nochmals mit einem eigenen Namens-Zusatz ausgestattet. Im Code-Beispiel des letzten Abschnitts
   wurde dieses bereits auf guestbook2009 festgelegt. Damit lautet der Pfad der Konfigurations-Dateien
   wie folgt:
</p>
<gen:highlight type="code">
/config/modules/guestbook2009/data/testproject/DEFAULT_guestbook2009_objects.ini
/config/modules/guestbook2009/data/testproject/DEFAULT_guestbook2009_relations.ini
</gen:highlight>
<p>Nach dem Anlegen können wir das Setup der Datenbank mit dem folgenden Script ausführen:</p>
<gen:highlight type="php">
include('apps/core/pagecontroller/pagecontroller.php');
import(
  'modules::genericormapper::data::tools',
  'GenericORMapperSetup'
);
$setupMapper = new GenericORMapperSetup();
$setupMapper->setContext('testproject');
$setupMapper->setupDatabase(
   'modules::guestbook2009::data',
   'guestbook2009',
   'guestbook2009'
);
</gen:highlight>
<p>Ein Blick in die Datenbank zeigt uns, welche Tabellen erstellt wurden:</p>

<img src="http://media.adventure-php-framework.org/content/table_setup.png" alt="Das Tabellen-Layout des APF-Gästebuch" />

<p>
   Tabellen mit dem Präfix ass_ speichern die Zuordnung von zwei Objekten über eine
   Assoziation, Tabellen mit der Kennzeichnung cmp_ referenzieren zwei Objekte über eine
   Komposition und Tabellen mit ent_ zu Beginn des Namens sind für die Haltung der eigentlichen
   Objekt-Attribute reserviert. Diese Art des Tabellen-Designs wird auch als Teil-Normalisierung
   bezeichnet, da die Beziehungen im Gegensatz zur Vollständigen De-Normalisierung von den
   Objekt-Daten getrennt gespeichert werden.
</p>

<h3 id="Chapter-33-Laden-von-Eintraegen"><a href="#Chapter-33-Laden-von-Eintraegen">33. Laden von Einträgen</a></h3>
<p>
   Beginnen wir zunächst mit dem Laden einer Liste von Einträgen, für die Anzeigen
   der Auswahl im Backend:
</p>
<gen:highlight type="php">
public function loadEntryListForSelection(){
   $sortCrit =
      new GenericCriterionObject();
   $sortCrit->addOrderIndicator(
      'CreationTimestamp','DESC');
   $gb = $this->__getCurrentGuestbook();
   $list = $gb->loadRelatedObjects(
      'Guestbook2Entry',$sortCrit
   );
   return $list;
}
</gen:highlight>
<p>
   Der GenericORMapper bietet die Möglichkeit, Daten mit Hilfe eines GenericCriterionObjects zu 
   laden. Über dieses können Limitierung, Sortierung, Beziehungs-Indikatoren und
   Einschränkungen über Attribute für die zu ladenen Objekte definiert werden. In
   diesem Fall werden die Einträge durch die Definition des gezeigten Such-Kriteriums nach
   Datum absteigend angeordnet.
</p>
<p>
   Anschließend können mit Hilfe der Gästebuch-Instanz alle über die Beziehung
   Guestbook2Entry verknüpften Einträge geladen werden. Die Rückgabe der Methode
   enthält eine Liste von GenericDomainObject-Instanzen. Diese müssen später noch in
   die eigentlichen Domänen-Objekte übersetzt werden.
</p>
<p>
   Die private Methode __getCurrentGuestbook() liefert die Instanz des Guestbook-Objekts 
   (GenericDomainObject). Dieses repräsentiert das aktuell angezeigte Gästebuch in der
   Datenbank. Hierzu wird die Methode loadObjectByID() des GenericORMapper genutzt:
</p>
<gen:highlight type="php">
private function __getCurrentGuestbook(){
   $orm = &$this->__getGenericORMapper();
   $model = &$this->getServiceObject(
      'modules::guestbook2009::biz',
      'GuestbookModel'
   );
   return $orm->loadObjectByID(
      'Guestbook',
      $model->get('GuestbookId')
   );
}
</gen:highlight>
<p>
   Da die Rückgabe an die Business-Schicht in der Form von Domänen-Objekten erfolgen soll,
   müssen die generischen Domänen-Objekte des O/R-Mappers übersetzt werden. Hierzu
   wird die Methode __mapGenericEntries2DomainObjects() verwendet, die im folgenden Kasten
   abgebildet ist:
</p>
<gen:highlight type="php">
private function __mapGenericEntries2DomainObjects($entries = array(),$addEditor = true){

   // return empty array, because having no entries means nothing to do!
   if(count($entries) == 0){
      return array();
   }

   // invoke benchmarker to be able to monitor the performance
   $t = &Singleton::getInstance('BenchmarkTimer');
   $t->start('__mapGenericEntries2DomainObjects()');

   // load the language object for the current language to enable
   // language dependent mapping!
   $orm = &$this->__getGenericORMapper();
   $lang = $this->__getCurrentLanguage();

   // define the criterion
   $critEntries = new GenericCriterionObject();
   $critEntries->addRelationIndicator('Attribute2Language',$lang);

   $gbEntries = array();
   foreach($entries as $current){

      // Check, whether there are attributes related in the current language.
      // If not, do NOT add an entry, because it will be empty!
      $attributes = $orm->loadRelatedObjects($current,'Entry2LangDepValues',$critEntries);
      if(count($attributes) > 0){

         // load the entry itself
         $entry = new Entry();
         $entry->setCreationTimestamp($current->getProperty('CreationTimestamp'));

         foreach($attributes as $attribute){

            if($attribute->getProperty('Name') == 'title'){
               $entry->setTitle($attribute->getProperty('Value'));
            }
            if($attribute->getProperty('Name') == 'text'){
               $entry->setText($attribute->getProperty('Value'));
            }
         }

         // add the editor's data
         if($addEditor === true){
            $editor = new User();
            $user = $orm->loadRelatedObjects($current,'Editor2Entry');
            $editor->setName($user[0]->getProperty('Name'));
            $editor->setEmail($user[0]->getProperty('Email'));
            $editor->setWebsite($user[0]->getProperty('Website'));
            $editor->setId($user[0]->getProperty('UserID'));
            $entry->setEditor($editor);
         }

         $entry->setId($current->getProperty('EntryID'));
         $gbEntries[] = $entry;
      }
   }

   $t->stop('__mapGenericEntries2DomainObjects()');
   return $gbEntries;
}
private function __getCurrentLanguage(){

   $crit = new GenericCriterionObject();
   $crit->addPropertyIndicator('ISOCode',$this->__Language);
   $orm = &$this->__getGenericORMapper();
   return $orm->loadObjectByCriterion('Language',$crit);
}
</gen:highlight>
<p>
   Diese nimmt eine Liste von generischen Domänen-Objekte entgegen und übersetzt sie in 
   eine Liste von Anwendungs-Objekte.
</p>
<p>
   Um die Attribute eines Eintrags zu laden, wird das Entry-Stellvertreter-Objekt auf der einen
   Seite und die aktuell angezeigte Sprache auf der anderen Seite als Kriterium genutzt, um die
   Menge der zu ladenden Attribute-Objekte einzuschränken. Sofern die Datenstruktur keinen
   Fehler enthält werden dann exakt die relevanten Attribute vom O/R-Mapper zurückgegeben.
</p>
<p>
   Anschließend können die Werte der Attribute-Objekte in die Entry-Domänen-Objekte
   übernommen und die Beziehung zum Autor eines Eintrags aufgelöst werden. Auch in diesem
   Fall kann eine Beziehungen – Editor2Entry – als Kriterium für das Laden des User-Objekts aus
   der Datenbank genutzt werden.
</p>

<h3 id="Chapter-34-Speichern-eines-Eintrags"><a href="#Chapter-34-Speichern-eines-Eintrags">34. Speichern eines Eintrags</a></h3>
<p>
   Die Speicherung eines Eintrags gestaltet sich etwas umfangreicher als der reine Lesezugriff auf
   die Datenstruktur. Dies ist nicht nur der Tatsache geschuldet, dass die hierfür
   bereitgestellte Methode das Anlegen und das Bearbeiten eines Eintrags berücksichtigt muss,
   sondern, dass die Beziehungen zwischen Eintrag und Autor sowie den Sprach-abhängigen
   Attributen aufgelöst werden muss.
</p>
<p>
   Die Idee ist auch hier, die Domänen-Objekt-Struktur zunächst in die generische
   Datenstruktur zu übersetzen und diese dann mit Hilfe des GenericORMapper zu speichern. Die
   spiegelt sich auch in der Signatur der Methode saveEntry() wieder:
</p>
<gen:highlight type="php">
public function saveEntry($entry){
   $genericEntry =
    $this->__mapDomainObject2GenericEntry(
      $entry
   );
   $orm = &$this->__getGenericORMapper();
   $orm->saveObject($genericEntry);
}
</gen:highlight>
<p>
   Die Übersetzung der Struktur übernimmt nun die Methode __mapDomainObject2GenericEntry(),
   die im folgenden Kasten abgebildet ist:
</p>
<gen:highlight type="php">
private function __mapDomainObject2GenericEntry($domEntry){

   $lang = $this->__getCurrentLanguage();

   $domEditor = $domEntry->getEditor();
   $editor = new GenericDomainObject('User');
   $editor->setProperty('Name',$domEditor->getName());
   $editor->setProperty('Email',$domEditor->getEmail());
   $editor->setProperty('Website',$domEditor->getWebsite());
   $editorId = $domEditor->getId();
   if(!empty($editorId)){
      $editor->setProperty('UserID',$editorId);
   }

   // try to load an existing title attribute to avoid new attributes
   // on updates and merge changes
   $title = $this->__getGenericAttribute($domEntry,'title');
   $title->setProperty('Name','title');
   $title->setProperty('Value',$domEntry->getTitle());
   $title->addRelatedObject('Attribute2Language',$lang);

   $text = $this->__getGenericAttribute($domEntry,'text');
   $text->setProperty('Name','text');
   $text->setProperty('Value',$domEntry->getText());
   $text->addRelatedObject('Attribute2Language',$lang);

   // setup generic domain object structure to preserve the relations
   $entry = new GenericDomainObject('Entry');
   $entry->addRelatedObject('Entry2LangDepValues',$title);
   $entry->addRelatedObject('Entry2LangDepValues',$text);
   $entry->addRelatedObject('Editor2Entry',$editor);
   $gb = $this->__getCurrentGuestbook();
   $entry->addRelatedObject('Guestbook2Entry',$gb);

   $entryId = $domEntry->getId();
   if(!empty($entryId)){
      $entry->setProperty('EntryID',$entryId);
   }
   return $entry;
}
private function __getGenericAttribute($domEntry,$name){

   // try to load
   $entry = new GenericDomainObject('Entry');
   $entry->setProperty('EntryID',$domEntry->getId());

   $orm = &$this->__getGenericORMapper();

   $crit = new GenericCriterionObject();
   $crit->addPropertyIndicator('Name',$name);
   $crit->addRelationIndicator('Attribute2Language',$this->__getCurrentLanguage());

   $attributes = $orm->loadRelatedObjects($entry,'Entry2LangDepValues',$crit);
   if(isset($attributes[0])){
      return $attributes[0];
   }
   return new GenericDomainObject('Attribute');
}
</gen:highlight>
<p>
   Diese schreibt zunächst die Domänen-Objekte in die korrespondierenden
   GenericDomainObject-Instanzen um und löst anschließend in Sprach-abhängigen
   Attribute in Attribute-Objekte auf. Hierbei wird berücksichtigt, ob ein Attribut bereits in
   der Datenbank angelegt wurde, um mehrfache Speicherung verhindern. Sofern beim Anlegen eines
   Eintrags noch kein Attribut existiert, liefert die Methode __getGenericAttribute() eine neue
   Instanz zurück.
</p>
<p>
   Am Ende der Methode wird die Objekt-Struktur gemäß dem UML-Design zusammengefügt.
   Die Sprach-abhängigen Attribute werden unterhalb der Entry-Objekte komponiert, zur aktuellen
   Sprache assoziiert und selbst unterhalb des aktuellen Gästebuchs komponiert. Die Herstellung
   der Beziehungen erfolgt dabei durch Hinzufügen eines GenericDomainObject zu einem anderen
   über die Methode addRelatedObject() unter Angabe des Beziehungs-Schlüssels.
</p>

<h3 id="Chapter-35-Loeschen-eines-Eintrags"><a href="#Chapter-35-Loeschen-eines-Eintrags">35. Löschen eines Eintrags</a></h3>
<p>
   Das Löschen eines Eintrags gestaltet sich verhältnismäßig einfach. Bei der
   Ausführung muss lediglich die Besonderheit des GenericORMapper beachtet werden, dass Objekte,
   die weitere Objekte komponieren, nicht gelöscht werden können. Dieses Feature stellt
   sicher, dass keine Daten-Leichen durch versehentliches Löschen von Objekten entstehen.
</p>
<p>
   Im aktuellen Anwendungsfall müssen deshalb zunächst die Attribute- und User-Objekte
   selektiert und eliminiert werden, bevor das eigentliche Entry-Objekt gelöscht werden darf:
</p>
<gen:highlight type="php">
public function deleteEntry($domEntry){
   $orm = &$this->__getGenericORMapper();
   $entry = new GenericDomainObject(
      'Entry'
   );
   $entry->setProperty(
      'EntryID',$domEntry->getId()
   );
   $attibutes = $orm->loadRelatedObjects(
      $entry, 'Entry2LangDepValues'
   );
   foreach($attributes as $attribute){
      $orm->deleteObject($attribute);
   }
   $users = $orm->loadRelatedObjects(
      $entry,'Editor2Entry'
   );
   foreach($users as $user){
      $orm->deleteObject($user);
   }
   $orm->deleteObject($entry);
}
</gen:highlight>
<p>
   Das manuelle Auflösen von Assoziationen ist nicht notwendig, diese werden vom O/R-Mapper
   automatisch gelöscht.
</p>
<p>
   Die Implementierung der übrigen Funktionalität der Daten-Schicht können der Klasse
   GuestbookMapper unter [1] direkt entnommen werden.
</p>

<h3 id="Chapter-36-That-s-it"><a href="#Chapter-36-That-s-it">36. That's it!</a></h3>
<p>
   Lassen wir die im ersten Teil beschriebenen Anforderungen noch einmal Revue passieren, so bietet
   die vorliegende Implementierung eine gute Grundlage für zukünftige Erweiterungen.
   Sofern neue Ausgabe-Bereiche eingebunden werden sollen, kann dies sehr einfach in den jeweiligen
   View-Templates bewerkstelligt werden. Wünscht der Kunde die Möglichkeit, Einträge
   mit weiteren Attributen auszustatten, genügt ein neuer Eintrag in der O/R-Mapper-Konfiguration
   und ein paar Zeilen Mapping-Code.
</p>
<p>
   Wie der Umfang des Artikels zeigt, ist die Implementierung des Gästebuchs keine zu
   unterschätzende Aufgabe. Der geneigte Leser mag an dieser Stelle sicher schmunzeln und ein
   &rdquo;Das hätte man aber einfacher haben können!&ldquo; auf den Lippen haben, es war
   jedoch Ziel dieses Artikels, eine Vorgehensweise aufzuzeigen, die bei komplexen Anwendungen
   notwendig ist. Einige Tools und Frameworks verfolgenden zwar den Ansatz, Applikationen an Hand
   der Konfigurationen vollständig zu generieren, dies scheitert jedoch bei höherer
   Komplexität und treibt den manuellen Anpassungsaufwand deutlich in die Höhe. Aus diesem
   Grund ist es ratsam, komplexere Applikationen – und das Gästebuch zähle ich bereits
   hinzu – weiterhin selbst zu implementieren und auf den Einsatz von bewährten Tools zu
   erstellen. Dabei – und vor allem dabei – gilt: &rdquo;Think before you start to write code!&ldquo;.
</p>