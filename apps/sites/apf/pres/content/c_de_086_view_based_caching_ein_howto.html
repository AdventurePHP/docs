<doku:title parent="100" tags="view,based,caching,performance,importdesign,extension" title="View based caching - ein HOWTO" urlname="View-based-caching-ein-HOWTO">
  Dieser Artikel beschreibt, wie view based caching mit dem Adventure PHP Framework implementiert
  werden kann.
</doku:title>
<h3 id="Chapter-1-Einfuehrung"><a href="#Chapter-1-Einfuehrung">1. Einführung</a></h3>
Während einer Diskussion im
<a class="external" href="http://www.developers-guide.net/forums/7173,alles-zum-zend-framework-1-7-a,page2#post65410" title="developers-guide.net" linkrewrite="false">developers-guide.net Forum</a> wurde die Idee des
view based caching geboren. Ausgelöst durch einen Einwurf von <em>Alberto</em> begannen wir
über Performance-Optimierungen und verschiedene Caching-Methoden zu sprechen. Am Ende der
Diskussion kamen die Beteiligten darüber ein, dass das Caching von einzelnen Teilen einer
Applikation ein effektives Mittel für die Steigerung der Performance ist.
<br />
<br />
Dies kann durch eine auf cURL basierende Lösung, die von <em>Alberto</em> vorgestellt wurde oder
durch view based caching erreicht werden. Der Vorteil von view based caching ist, dass die Applikation
selbst nicht an die Cache-Strategie angepasst werden muss. Dieser Artikel beschreibt die technische
Idee und die Umsetzung mit den Mitteln des Adventure PHP Framework.
<br />
<br />
<br />
<h3 id="Chapter-2-Views"><a href="#Chapter-2-Views">2. Views?</a></h3>
Um die Idee besser verdeutlichen zu können, zunächst ein paar Worte zum Thema <em>Views</em>.
In APF-Terminologie sind Views nichts anderes als Templates, die von anderen eingebunden werden. Ein
Webseiten-Layout, das importdesign-Tags beinhaltet definiert bereits Views. Wie im Kapitel
<a href="./?Seite=016-Klassen#Chapter-2-DOM-Model-der-GUI" title="Klassen">Klassen</a>
beschrieben wird, erzeugt die Page-Controller-Implementierung einen Objektbaum aus den bekannten Tags
in einem Template.
<br />
<br />
Jeder Tag besteht dabei aus seiner Definition - etwa
<gen:highlight type="apf-xml">
&lt;my:tag attr1="value1" attr2="value2" /&gt;
</gen:highlight>
- und der Implementierung der Funktion des Tags, sog. TagLibs. Jede TagLib muss das folgende Interface
implementieren:
<gen:highlight type="php">
class my_taglib_tag extends Document {

   public function onParseTime(){
   }

   public function onAfterAppend(){
   }

   public function transform(){
   }

}
</gen:highlight>
Details zur Implementierung von TagLibs und welche Funktionalität sich hinter den einzelnen
Methoden versteckt bzw. verstecken müssen, kann im Tutorial
<a href="./?Seite=045-TagLibs-erstellen#Chapter-2-2-Klassen-Methoden" title="TagLibs erstellen">TagLibs erstellen</a>
nachgelesen werden.
<br />
<br />
Wie kann diese Information nun genutzt werden um view based caching zu implementieren? Ganz einfach:
dank der generischen Page-Controller-Implementierung kann der Entwickler eigene Taglibs erzeugen, die
die bisherige Funktion einer Taglib erweitern. Das bedeutet, dass der bisherige Template-Include-Mechanismus
einfach um eine Caching-Funktion ergänzt werden muss - die Basis von view based
caching!
<br />
<br />
<br />
<h3 id="Chapter-3-Implementierung"><a href="#Chapter-3-Implementierung">3. Implementierung</a></h3>
<h4 id="Chapter-3-1-Lets-get-started"><a href="#Chapter-3-1-Lets-get-started">3.1. Let's get started</a></h4>
Wie im Kapitel <int:link pageid="046" anchor="Chapter-1-2-Importdesign" />
beschrieben ist, kann der <strong>&lt;core:importdesign /&gt;</strong>-Tag dazu verwendet werden,
ein Template als Kind des aktuellen DOM-Knoten einzubinden. Hierzu muss lediglich der Namespace des
Templates und dessen Namen in den Attributen des Tags spezifiziert werden. Wie bereits weiter oben
bemerkt, kann dieser Tag dazu verwendet werden, um einen View innerhalb eines Layout-Templates zu
definieren. Ein View kann dabei z.B. den Header, Footer oder die Navigation einer Seite beinhalten.
Da wir nur den Inhalt von speziellen Views einer Seite cachebar gestalten wollen, kann diese TagLib
als Basis genutzt werden.
<br />
<br />
Um das zu verdeutlichen, ist in der folgenden Codebox die Implementierung der Taglib dargestellt:
<gen:highlight type="php">
class core_taglib_importdesign extends Document {

   public function __construct(){
      parent::__construct();
   }

   public function onParseTime(){

      $Namespace = trim($this->__Attributes['namespace']);
      $Template = trim($this->__Attributes['template']);

      if(isset($this->__Attributes['context'])){
         $this->__Context = trim($this->__Attributes['context']);
      }

      if(isset($this->__Attributes['incparam'])){
         $IncParam = $this->__Attributes['incparam'];
      }
      else{
         $IncParam = 'pagepart';
      }

      ...

      $this->__loadContentFromFile($Namespace,$Template);
      $this->__extractDocumentController();
      $this->__extractTagLibTags();

   }

}
</gen:highlight>
Die eigentliche Funktion des Tags besteht darin, die Attribute des Tags zu analysieren, den Inhalt
des gewünschten Templates zu laden und den Inhalt zu analysieren. Hierzu werden die Methoden
<strong>__extractDocumentController()</strong> und <strong>__extractTagLibTags()</strong> genutzt,
die bereits im der Klasse <em>Document</em> definiert sind. Es fehlt also nur noch der Caching-Part!
<br />
<br />
<br />
<h4 id="Chapter-3-2-Der-CacheManager"><a href="#Chapter-3-2-Der-CacheManager">3.2. Der CacheManager</a></h4>
Das Framework beinhaltet mit dem CacheManager eine flexible Caching-Komponente mit verschiedenen
Backends. In diesem Fall ist jedoch ein einfacher Text-Cache-Mechanismus ausreichend, der im Kapitel
<int:link pageid="084" anchor="Chapter-3-1-Text-Cache-Provider">Text-Cache-Provider</int:link>
der CacheManager-Dokumentation beschrieben ist. Um diesen verwenden zu können, ist es notwendig,
eine Konfiguration anzulegen. Diese hat gemäß der Dokumentation die folgende Gestalt:
<gen:highlight type="ini">
[view_based_cache]
Cache.Provider.Namespace = "tools::cache::provider"
Cache.Provider.Class = "TextCacheProvider"
Cache.Active = "true"
Cache.BaseFolder = "/path/to/my/cache/base/folder"
Cache.Namespace = "view::one"
</gen:highlight>
Zum Schreiben und Lesen des Caches kann der folgende Code verwendet werden:
<gen:highlight type="php">
// get the cache manager
$cMF = &$this->getServiceObject('tools::cache','CacheManagerFabric');
$cM = &$cMF->getCacheManager('view_based_cache');

// calculate cache key
$cacheKey = /* ... */;

// read the cache
$cacheContent = $cM->getFromCache($cacheKey);

// write to the cache
if($cacheContent === null){
   $cacheContent = /* generate content */;
   $cM->writeToCache($cacheKey,$cacheContent);
}
</gen:highlight>
<br />
<h4 id="Chapter-3-3-Endmontage"><a href="#Chapter-3-3-Endmontage">3.3. Endmontage</a></h4>
Um den Inhalt eines Views cachen zu können, werden nun die beiden Teile aus Kapitel 3.1 und
3.2 zusammengefügt:
<gen:highlight type="php">
class cache_taglib_importdesign extends core_taglib_importdesign {

   private $__CacheContent = null;

   public function __contruct(){

      // call the parent's constructor to fill the known taglib list
      parent::__construct();

   }

   public function onParseTime(){

      // get the cache manager
      $cMF = &$this->getServiceObject('tools::cache','CacheManagerFabric');
      $cM = &$cMF->getCacheManager('view_based_cache');

      // calculate the cache key
      $cacheKey = md5(
                      $this->getAttribute('namespace').
                      $this->getAttribute('template').
                      get_class($this->__ParentObject)
                     );

      // try to read from the cache
      $this->__CacheContent = $cM->getFromCache($cacheKey);

      // check if the document was cached before. If not
      // execute the parent's onParseTime()
      if($this->__CacheContent === null){
         parent::onParseTime();
      }

   }

   public function transform(){

      // generate the node's output or return the cached content
      if($this->__CacheContent === null){

         // get the cache manager
         $cMF = &$this->getServiceObject('tools::cache','CacheManagerFabric');
         $cM = &$cMF->getCacheManager('view_based_cache');

         // calculate the cache key
         $cacheKey = md5(
                         $this->getAttribute('namespace').
                         $this->getAttribute('template').
                         get_class($this->__ParentObject)
                        );

         // generate output and cache it
         $output = parent::transform();
         $cM->writeToCache($cacheKey,$output);

         // return the tag's output
         return $output;
      }
      else{
         return $this->__CacheContent;
      }

   }

}
</gen:highlight>
Wie im Code-Block zu sehen ist, wurden die Methoden <em>onParseTime()</em> und <em>transform()</em>
um das Cache-Handling ergänzt. Um innerhalb der Klasse erkennen zu können, ob der Inhalt
aus dem Cache gelesen werden kann, wurde die private Variable <em>__CacheContent</em> eingeführt.
Bitte beachten Sie, dass der Code teilweise redundant vorhanden ist. Diese wurde jedoch nur zu
Demonstrationszwecken so gewählt.
<br />
<br />
<br />
<h3 id="Chapter-4-Anwendung"><a href="#Chapter-4-Anwendung">4. Anwendung</a></h3>
Die Anwendung der Caching-TagLib unterscheidet sich kaum von der Verwendung des
<em>&lt;core:importdesign /&gt;</em> Tags. Der einzige Unterschied ist, dass eine Konfigurationssektion
für den CacheManager existieren muss:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="" prefix="cache" class="importdesign" /&gt;
&lt;cache:importdesign namespace="my::namespace" template="my_template" /&gt;
</gen:highlight>
<br />
<h3 id="Chapter-5-Zusammenfassung-und-Ausblick"><a href="#Chapter-5-Zusammenfassung-und-Ausblick">5. Zusammenfassung und Ausblick</a></h3>
Dank der Page-Controller-Implementierung des APF ist es sehr einfach, view based caching auf Basis
von TagLibs zu implementieren. Um eine wiederverwendbare und in allen Bereichen einsetzbare TagLib
zu erhalten, sollte die in Kapitel 3.3 abgedruckte Klasse noch um ein oder zwei weitere Attribute
erweitert werden, die die Cache-Konfiguration und den Cache-Schlüssel übergeben. Das stellt
sicher, dass die TagLib innerhalb der Applikation einfacher an unterschiedlichen Stellen gleichzeitig
genutzt werden kann.
<br />
<br />
Beim Thema Cache-Verwaltung hat der Entwickler zwei Möglichkeiten: manuelles Leeren des Caches
oder der Einsatz eines Caching-Backends, das Cache-Lebenszeit unterstützt. Falls die Notwendigkeit
besteht, sich selbst erneuernden Cache zu haben, so kann der CacheManager wie im Kapitel
<int:link pageid="084" anchor="Chapter-4-Erweiterung">Erweiterung</int:link>
aufgezeigt erweitert werden.
<br />
<br />
<br />
<h3 id="Chapter-6-Download"><a href="#Chapter-6-Download">6. Download</a></h3>
Um das oben gezeigte Konzept lokal ausprobieren zu können, habe ich eine Beispiel-Implementierung
für PHP 5 erstellt, die die in Kapitel 5 besprochenen Optimierungen bereits enthalten. Um das
Beispiel lokal auszuführen, bitte die Datei
<a href="http://media.adventure-php-framework.org/content/view-based-caching-1.8-2009-01-16-1649-php5.zip" title="view-based-caching-1.8-RC1-2008-11-29-2257-php5.zip">view-based-caching-...-php5.zip</a>
herunterladen und im DOCUMENT_ROOT des Webservers entpacken. Bitte beachten Sie dabei, dass der
Benutzer, unter dem der Webserver ausgeführt wird, Schreibrechte auf das aktuelle Verzeichnis
besitzt. Falls ein anderer Ordner als Cache-Basis-Ordner verwendet werden soll, einfach die Datei
<em>/apps/config/tools/cache/sites/vbc/DEFAULT_cacheconfig.ini</em> anpassen.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_086" />