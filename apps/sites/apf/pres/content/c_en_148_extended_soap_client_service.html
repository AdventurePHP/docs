<doku:title parent="119" tags="soap" title="ExtendedSoapClientService" urlname="ExtendedSoapClientService">
   The APF ships a custom SOAP client implementation since 1.15. It is built on the PHP SOAP extension and easily
   integrates with the APF. Besides, the API of the custom implementation has been straightened to gain ease of use.
</doku:title>
<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   The APF ships a custom SOAP client implementation since 1.15. It is built on the PHP
   <a class="external" href="http://www.php.net/soap">SOAP extension</a> and easily integrates with the APF. Besides,
   the API of the custom implementation has been straightened to gain ease of use.
</p>
<p>
   The APF SOAP client implementation supports all functionalities of PHP's native <em>SoapClient</em> but eases
   configuration of the <em>ExtendedSoapClientService</em> using the APF DI container.
</p>

<h3 id="Chapter-2-Configuration"><a href="#Chapter-2-Configuration">2. Configuration</a></h3>
<p>
   The configuration of the <em>ExtendesSoapClientService</em> can be done in two flavours: directly within the code
   or using the
   <int:link pageid="107" anchor="Chapter-3-2-3-DIServiceManager-Complex-services">DIServiceManager</int:link>.
</p>

<h4 id="Chapter-2-1-Configuration-by-code"><a href="#Chapter-2-1-Configuration-by-code">2.1. Configuration by code</a></h4>
<p>
   Using the <em>ExtendedSoapClientService</em> requires a WSDL and a service location. In order to send a login request
   you may use the following code:
</p>
<gen:highlight type="php">
$service = new ExtendedSoapClientService();
$service->setWsdlUrl('./login-service.wsdl');
$service->setLocation('https://example-com/services/login/soap');

$result = $service->Login(array(
   'user' => $user,
   'pass' => $pass
));
</gen:highlight>
<p>
   In the first two lines the initial configuration of the SOAP client is done. This sample assumes the WSDL file located
   on the local storage. Of course, remote WSDL files are supported.
</p>
<p>
   In case the service endpoint is directly included in the WSDL definition, line 3 may be omitted. Line 5 shows up a
   sample call of one of the methods defined within the WSDL.
</p>
<div class="hint">
   In order to optimize construction time of the <em>ExtendedSoapClientService</em> it is recommended to use local WSDL
   files. In case this is no option, you should enable the <em>soap.wsdl_cache_enabled</em> option within your
   <em>php.ini</em>. To get optimal results, <em>soap.wsdl_cache_ttl</em> and <em>soap.wsdl_cache_limit</em> should be
   set to suitable values.
</div>

<h4 id="Chapter-2-2-Configuration-by-DIServiceManager"><a href="#Chapter-2-2-Configuration-by-DIServiceManager">2.2. Configuration by DIServiceManager</a></h4>
<p>
   Using the <int:link pageid="107" anchor="Chapter-3-2-3-DIServiceManager-Complex-services">DIServiceManager</int:link>
   to create the SOAP client has two main advantages: configuration and application can be separated and MOCK
   implementations can easily be configured for development and/or test reasons.
</p>
<p>
   In order to use the <em>ExtendedSoapClientService</em> the following (minimal) configuration is necessary:
</p>
<gen:highlight type="ini">
[LoginService]
servicetype = "..."
namespace = "tools::soap"
class = "ExtendedSoapClientService"

conf.wsdl.method = "setWsdlUrl"
conf.wsdl.value = "./login-service.wsdl"

conf.service.method = "setLocation"
conf.service.value = "https://example-com/services/login/soap"
</gen:highlight>
<p>
   Having this configuration you are now able to use the <em>LoginService</em> within a controller or any other component
   of your software as described in the next code box:
</p>
<gen:highlight type="php">
$service = $this->getDIServiceObject('...', 'LoginService');

$result = $service->Login(array(
   'user' => $user,
   'pass' => $pass
));
</gen:highlight>
<p>
   The namespace argument of the <em>getDIServiceObject()</em> call depends on the setup of your application. Details
   on the configuration of services can be read about in the
   <int:link pageid="107" anchor="Chapter-4-3-DIServiceManager-Complex-services">complex services</int:link>
   chapter, <int:link pageid="134"/> contains hints on the definition of configurations using the APF in general.
</p>
<div class="hint">
   <p>
      Please have a look at the <em>config/tools/soap/EXAMPLE_serviceobjects.ini</em> file within the
      <em>apf-configpack-*</em>release package for a detailed configuration example.
   </p>
   <p>
      Further configuration parameters may be adapted using the methods listed in
      <a href="#Chapter-2-3-Parameter-overview">chapter 2.3</a> in combination with a custom DI service configuration
      subsection like this:
<gen:highlight type="ini">
conf.xyz.method = "..."
conf.xyz.value = "..."
</gen:highlight>
   </p>
</div>

<h4 id="Chapter-2-3-Parameter-overview"><a href="#Chapter-2-3-Parameter-overview">2.3. Parameter overview</a></h4>
<p>
   The follwing list contains all configuration directives of the <em>ExtendedSoapClientService</em> and the respective
   methods. The can be used for configuring the client by code or by a DI service definition:
</p>
<table>
   <thead>
      <tr>
         <td>Parameter</td>
         <td>Method</td>
         <td>Description</td>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>wsdlUrl</td>
         <td><em>setWsdlUrl()</em></td>
         <td>
            Using this parameter the service contract (WSDL file) is defined. WSDL files may be located on the local
            disk or on a remote server.
         </td>
      </tr>
      <tr>
         <td>location</td>
         <td><em>setLocation()</em></td>
         <td>
            Defines the url of the service endpoint. May be defined explicitly or within a WSDL file.
         </td>
      </tr>
      <tr>
         <td>login</td>
         <td><em>setHttpAuthUsername()</em></td>
         <td>
            Defines the user for <em>HTTP base authentication</em> secured services.
         </td>
      </tr>
      <tr>
         <td>password</td>
         <td><em>setHttpAuthPassword()</em></td>
         <td>
            Defines the passwordfor <em>HTTP base authentication</em> secured services.
         </td>
      </tr>
      <tr>
         <td>compression</td>
         <td><em>setCompressionLevel()</em></td>
         <td>
            Activates compressed transmission of payload of SOAP requests and responses. Allowed values are the
            constants <em>SOAP_COMPRESSION_ACCEPT</em>, <em>SOAP_COMPRESSION_GZIP</em>, <em>SOAP_COMPRESSION_DEFLATE</em>,
            or a combination of them.
         </td>
      </tr>
      <tr>
         <td>connection_timeout</td>
         <td><em>setConnectionTimeout()</em></td>
         <td>
            Defines the timout of connections to the SOAP service. Please note, that this value does not avoid issues
            with slo response times. In order to set the maximum time for SOAP requests, please use the
            <em>default_socket_timeout</em> directive within your <em>php.ini</em>.
         </td>
      </tr>
      <tr>
         <td>cache_wsdl</td>
         <td><em>setCacheWsdl()</em></td>
         <td>
            Activates WSDL caching for remote files. Please note the configuration parameters within your <em>php.ini</em>!
         </td>
      </tr>
      <tr>
         <td>encoding</td>
         <td><em>setEncoding()</em></td>
         <td>
            Defines the character set of the applied and returned characters. Default value is <em>UTF-8</em>.
         </td>
      </tr>
      <tr>
         <td>soap_version</td>
         <td><em>setSoapVersion()</em></td>
         <td>
            Defines the SOAP version to use. Possible values are the constants <em>SOAP_1_1</em> and <em>SOAP_1_2</em>.
         </td>
      </tr>
      <tr>
         <td>classmap</td>
         <td><em>registerWsdlObjectMapping()</em></td>
         <td>
            Using this method you may define object mappings. It requires an instance of the <em>WsdlObjectMapping</em>
            class. Details can be read about in
            <a href="#Chapter-3-3-Configuration-of-object-mappings">chapter 3.3 </a>.
         </td>
      </tr>
      <tr>
         <td>proxy_host</td>
         <td><em>setProxyHost()</em></td>
         <td>
            In case SOAP communication is initiated through a proxy you may define the proxy's host name with this method.
         </td>
      </tr>
      <tr>
         <td>proxy_port</td>
         <td><em>setProxyPort()</em></td>
         <td>
            In case SOAP communication is initiated through a proxy you may define the proxy's port with this method.
         </td>
      </tr>
      <tr>
         <td>proxy_login</td>
         <td><em>setProxyUsername()</em></td>
         <td>
            If the proxy requires authentication, please provide the appropriate user name with this method.
         </td>
      </tr>
      <tr>
         <td>proxy_password</td>
         <td><em>setProxyPassword()</em></td>
         <td>
            If the proxy requires authentication, please provide the appropriate password with this method.
         </td>
      </tr>
      <tr>
         <td>user_agent</td>
         <td><em>setUserAgent()</em></td>
         <td>
            In order to announce yourself as a particular client, please use this method. The content passing to this
            method is transferred to the SOAP server by the <em>UserAgent</em> header.
         </td>
      </tr>
      <tr>
         <td>features</td>
         <td><em>enableFeature()</em></td>
         <td>
            The PHP SOAP client implementation supports various features. Details can be taken from
            <a class="external" href="http://www.php.net/soap">php.net/soap</a>. Using this method, you can activate
            one or more features.
         </td>
      </tr>
   </tbody>
</table>
<p>
   Details on the signatures of the above methods can be taken from the <int:link pageid="002"/>.
</p>
<div class="hint">
   The configuration methods support the <em>fluent interface</em> technique. Using configuration by code you may use the
   following way:
<gen:highlight type="php">
$service = new ExtendedSoapClientService();
$service
   ->setProxyHost('proxy-server')
   ->setProxyPort(8080)
   ->setProxyUsername('foo')
   ->setProxyPassword('bar');
</gen:highlight>
</div>
<p>
   Details on the features of the entire PHP SOAP extension can be found on
   <a class="external" href="http://www.php.net/manual/en/soapclient.soapclient.php">php.net/manual/en/soapclient.soapclient.php</a>.
</p>

<h3 id="Chapter-3-Usage"><a href="#Chapter-3-Usage">3. Usage</a></h3>
<p>
   Using the <em>ExtendendSoapClientService</em> you can use two flavours of SOAP communication: XML-based or
   object-based. The next two chapters describe both ways in detail.
</p>
<div class="hint">
   In order to ease the way of using the result from SOAP requests it is recommended to use an object-style communication.
   This helps you to keep the signatures of your application's methods clean and strongly typed.
</div>

<h4 id="Chapter-3-1-Communication-via-XML"><a href="#Chapter-3-1-Communication-via-XML">3.1. Communication via XML</a></h4>
<p>

   Nutzen Sie die <em>executeRequest()</em>-Methode des <em>ExtendedSoapClientService</em>, so wird die gewünschte
   Anfrage im XML-Format erwartet. Hierzu ist es empfehlenswert, <a class="external" href="http://soapui.org">SoapUI</a>
   einzusetzen. Mit Hilfe dieses Tools lassen sich mit der gewünschten WSDL-Datei sehr einfach Beispiel-Anfragen generieren
   und testen. Diese können Sie dann anschließend direkt in Ihren Quellcode übernehmen und mit den entsprechenden Werten
   befüllen.
</p>
<p>
   Die Methode <em>executeRequest()</em> nimmt dabei die auszuführende SOAP-Action und ein Anfrage-XML entgegen. Als
   Ergebnis wird ein XML-Dokument basierend auf einem <em>SimpleXMLElement</em> zurückgeliefert. Beispiel:
</p>
<gen:highlight type="php">
$request = '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
               <soapenv:Header/>
               <soapenv:Body>
                  <type:AuthenticateRequest>
                     <type:ConsumerIdentification>
                        <type:ConsumerAuthentication>
                           <type:Principal>...</type:Principal>
                           <type:Credential>...</type:Credential>
                        </type:ConsumerAuthentication>
                     </type:ConsumerIdentification>
                     <type:Authentication>
                        <type:Identification>
                           <type:Alias>...</type:Alias>
                        </type:Identification>
                        <type:Security>
                           <type:SecretType>...</type:SecretType>
                           <type:Secret>...</type:Secret>
                        </type:Security>
                     </type:Authentication>
                  </type:AuthenticateRequest>
               </soapenv:Body>
            </soapenv:Envelope>';
$client = new ExtendedSoapClientService();
$client->setWsdlUrl('https://example.com/services/v1?wsdl');
$client->setLocation('https://example.com/services/v1');
$responseXml = $client->executeRequest('Authenticate', $request);
</gen:highlight>
<p>
   Der Inhalt der Variable <em>$responseXml</em> (Instanz eines <em>SimpleXMLElement</em>) kann nun innerhalb Ihrer
   Applikation direkt weiter verwendet werden.
</p>

<h4 id="Chapter-3-2-Kommunikation-ueber-DTOs"><a href="#Chapter-3-2-Kommunikation-ueber-DTOs">3.2. Kommunikation über DTOs</a></h4>
<p>
   Nutzen Sie die <em>__call()</em>-Methode des <em>ExtendedSoapClientService</em> haben Sie die Möglichkeit, das
   Objekt-Mapping-Feature zu nutzen. Dabei wird eine Anfrage als assoziatives Array formuliert und das Ergebnis Ihrer
   Anfrage als DTO(s) zurück gegeben.
</p>
<p>
   Die Methode <em>__call()</em> - bzw. die entsprechende SOAP-Methode - nimmt ein assoziatives Array der
   Anfrage-Parameter entgegen. Als Antwort erhalten Sie die Struktur der Antwort in Form der zuvor definierten DTOs
   zurück. Beispiel:
</p>
<gen:highlight type="php">
$request = array(
   'ConsumerIdentification' => array(
      'ConsumerAuthentication' => array(
         'Principal' => '...',
         'Credential' => '...'
      )
   ),
   'Authentication' => array(
      'Identification' => array(
         'Alias' => '...'
      ),
      'Security' => array(
         'SecretType' => '...',
         'Secret' => '...'
      )
   )
);
$client = new ExtendedSoapClientService();
$client->setWsdlUrl('https://example.com/services/v1?wsdl');
$client->setLocation('https://example.com/services/v1');
$response = $client->Authenticate($request);
</gen:highlight>
<div class="warn">
   <p>
      Bitte beachten Sie, dass der Aufbau des Anfrage-Arrays hinsichlich der Hierarchie mit der Typ-Definition in der
      WSDL übereinstimmen muss. Andernfalls kann die PHP SOAP-Entension die Werte nicht korrekt zuordnen und es kommt
      zu Fehlern.
   </p>
   <p>
      Die Namen der Array-Offsets müssen mit den XSD-Daten-Typ-Namen übereinstimmen (vergleiche Anfrage-Struktur aus
      <a href="#Chapter-3-1-Kommunikation-per-XML">Kapitel 3.1</a>).
   </p>
</div>
<p>
   In der Variable <em>$response</em> steckt nun die Instanz einer DTO-Klasse. Bitte beachten Sie die Hinweise zur
   Konfiguration von Objekt-Mappings in <a href="#">Kapitel 3.3</a>.
</p>

<h4 id="Chapter-3-3-Configuration-of-object-mappings"><a href="#Chapter-3-3-Configuration-of-object-mappings">3.3. Configuration of object mappings</a></h4>
<p>
   Das Mapping von XSD-Typen auf PHP-Objekte ist ein mächtiges Werkzeug das jedoch gleichzeitig einige Tücken besitzt.
   Aus diesem Grund stellt der <em>ExtendedSoapClientService</em> ein einfaches Interface für die Konfiguration zur
   Verfügung. Dieses basiert auf der Klasse <em>WsdlObjectMapping</em>, die folgende Signatur besitzt:
</p>
<gen:highlight type="php">
class WsdlObjectMapping extends APFObject {

   public function __construct($wsdlType = null,
                               $phpClassNamespace = null,
                               $phpClassName = null) {
      ...
   }

   public function setPhpClassName($phpClassName) {
      ...
   }

   public function getPhpClassName() {
      ...
   }

   public function setPhpClassNamespace($phpClassNamespace) {
      ...
   }

   public function getPhpClassNamespace() {
      ...
   }

   public function setWsdlType($wsdlType) {
      ...
   }

   public function getWsdlType() {
      ...
   }

}
</gen:highlight>
<p>
   Zur Konstruktion einer Mapping-Definition ist die Typ-Deklaration aus der WSDL bzw. XSD, der Namespace der PHP-Klasse
   und deren Namen notwendig.
</p>
<div class="warn">
   Der Name der Typ-Deklaration muss dem Namen des WSDL- bzw. XSD-Typs entsprechen, nicht dem Tag-Namen bei der
   Verwendung desselben. Wird im Rahmen einer Anfrage eine Struktur der Form
<gen:highlight type="xml">
<type:Identification>
   <type:Alias>...</type:Alias>
</type:Identification>
</gen:highlight>
   verwendet und liegt eine Typ-Deklaration von
<gen:highlight type="xml">
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
   <xs:element name="MemberIdentificationType">
      <xs:complexType>
         <xs:sequence>
            <xs:element type="xs:string" name="Alias"/>
         </xs:sequence>
      </xs:complexType>
   </xs:element>
</xs:schema>
</gen:highlight>
   vor, so ist <em>$wsdlType</em> mit dem Wert <em>MemberIdentificationType</em> zu belegen. Verwenden Sie statt dessen
   <em>Identification</em> oder <em>type:Identification</em> schlägt das Mapping fehl.
</div>
<p>
   Die Konfiguration von Mapping-Definitionen kann entweder über die Service-Konfiguration bei Verwendung des
   <a href="#Chapter-2-2-Konfiguration-per-DIServiceManager">DIServiceManager</a> und zusätzlich oder ausschließlich
   durch Nutzung der <em>registerWsdlObjectMapping()</em>-Methode erledigt werden.
</p>

<h5 id="Chapter-3-3-1-Konfiguration-ueber-Service-Konfiguration"><a href="#Chapter-3-3-1-Konfiguration-ueber-Service-Konfiguration">3.3.1. Konfiguration über Service-Konfiguration</a></h5>
<p>
   Der APF DI-Container bietet die Möglichkeit, Services mit anderen Services zu konfigurieren. Dies lässt sich im
   Fall des <em>ExtendedSoapClientService</em> dazu nutzen, um Mapping-Definitionen zu injitieren.
</p>
<p>
   Soll der im vorangegangenen Kapitel beschriebene Typ bei der Konstruktion des Services hinzugefügt werden, kann dies
   mit folgender Service-Definition erfolgen:
</p>
<gen:highlight type="ini">
[LoginService]
servicetype = "..."
namespace = "tools::soap"
class = "ExtendedSoapClientService"

conf.wsdl.method = "setWsdlUrl"
conf.wsdl.value = "./login-service.wsdl"

conf.service.method = "setLocation"
conf.service.value = "https://example-com/services/login/soap"

init.auth-response.method = "registerWsdlObjectMapping"
init.auth-response.namespace = "..."
init.auth-response.name = "AuthenticationResponseMapping"

[AuthenticationResponseMapping]
servicetype = "NORMAL"
namespace = "tools::soap"
class = "WsdlObjectMapping"

conf.type.method = "setWsdlType"
conf.type.value = "AuthenticationResponseType"
conf.ns.method = "setPhpClassNamespace"
conf.ns.value = "sample::namespace"
conf.class.method = "setPhpClassName"
conf.class.value = "AuthenticationResponse"
</gen:highlight>
<p>
   Der &quot;Service&quot; <em>AuthenticationResponseMapping</em> definiert dabei über die Klasse <em>WsdlObjectMapping</em>
   das Objekt-Mapping für den XSD-Typ <em>AuthenticationResponseType</em>. Bei der Konstruktion des Service
   <em>LoginService</em> wird dieser injiziert und steht bei der Verwendung zur Verfügung. Die Anzahl der
   Mapping-Definitionen ist nicht begrenzt.
</p>
<p>
   Damit Antworten mit einer Instanz der Klasse <em>AuthenticationResponse</em> repräsentiert werden kann, muss diese
   erstellt werden. Die Klasse selbst ist dabei eine einfache PHP-Klasse mit entsprechenden Variablen für die Inhalte
   der Antwort. Das folgende Beispiel geht davon aus, dass bei einem erfolgreichen Login das Datum der letzten Anmeldung
   und bei einem Fehler eine Exception zurückgegeben wird. Die erfolgreiche Antwort hat folgende XML-Struktur:
</p>
<gen:highlight type="xml">
<type:AuthenticateResponse>
   <type:LastLoginDate>...</type:LastLoginDate>
</type:AuthenticateResponse>
</gen:highlight>
<p>
   Die zugehörige PHP-Klasse hat damit folgende Signatur:
</p>
<gen:highlight type="php">
class AuthenticationResponse {

   private $LastLoginDate;

   public function getLastLoginDate() {
      ...
   }

}
</gen:highlight>
<div class="warn">
   <p>
      Das obenstehende Beispiel geht davon aus, dass die Antwort keine komplexen Typen beinhaltet. Sofern dies der Fall
      ist, ist es erforderlich, die Typen aller Ergebnis-Typen zu registrieren. Ferner müssen die DTO-Klassen die Struktur
      der zurückgelieferten Typen beachten. Dies bedeutet beispielsweise, dass für das komplexe Ergebnis innerhalb des
      <em>AuthenticationResponse</em> eine Variable für einen komplexen Typen vorgesehen werden muss.
   </p>
   <p>
      Ist das Mapping hinsichtlich der Hierarchie unterbrochen oder wurde kein Mapping definiert, liefert PHP eine
      Struktur bestehend aus Instanzen von <em>stdClass</em> zurück.
   </p>
</div>
<div class="hint">
   Wird eine Instanz des <em>ExtendedSoapClientService</em> für mehrere Anwendungsfälle genutzt und dies beziehen sich
   auf gleiche XSD-Typen empfiehlt sich ebenso die Konfiguration der Objekt-Mappings per Service-Konfiguration. Die
   übrigen Typen können dann pro Anwendungsfall wie im folgenden Kapitel beschrieben nachgereicht werden.
</div>

<h5 id="Chapter-3-3-2-Konfiguration-ueber-registerWsdlObjectMapping"><a href="#Chapter-3-3-2-Konfiguration-ueber-registerWsdlObjectMapping">3.3.2. Konfiguration über registerWsdlObjectMapping()</a></h5>
<p>
   Soll für eine SOAP-Anfrage ein Datentyp oder ein zusätzlicher Datentyp registriert werden, können Sie wie folgt
   vorgehen:
</p>
<gen:highlight type="php">
$client->registerWsdlObjectMapping(
   new WsdlObjectMapping(
      'AuthenticationResponseType',
      '...',
      'AuthenticationResponse'
   )
);
</gen:highlight>
<p>
   <em>$client</em> ist dabei eine Instanz des <em>ExtendedSoapClientService</em> der wie in
   <a href="#Chapter-2-Konfiguration">Kapitel 2</a> beschrienen erzeugt wurde. Der Namespace des DTOs (zweites Argument
   der Klasse <em>WsdlObjectMapping</em>) ist dabei abhängig von Ihrer Projekt-Struktur.
</p>
<p>
   Durch mehrfachen Aufruf von <em>registerWsdlObjectMapping()</em> ist es analog zu mehrfach vorhandenen
   Konfigurationssektionen möglich, mehrere Typen zu registrieren.
</p>

<h3 id="Chapter-4-Beispiele"><a href="#Chapter-4-Beispiele">4. Beispiele</a></h3>

<h4 id="Chapter-4-1-Logging"><a href="#Chapter-4-1-Logging">4.1. Logging</a></h4>
<p>
   Bei der Nutzung eines SOAP-Interface können unterschiedliche Arten von Störungen auftreten: fachliche und technische.
   Damit während des Betriebs ausreichend Informationen für eine Fehleranalyse zur Verfügung stehen, ist es empfehlenswert
   die wesentlichen Informationen in Log-Dateien zu schreiben.
</p>
<p>
   Hierzu können Sie die Möglichkeiten des <int:link pageid="023" /> und die Methoden <em>getLastRequest()</em> und
   <em>getLastResponse()</em> des <em>ExtendedSoapClientService</em> nutzen. Führen wir das Beispiel aus
   <a href="#Chapter-3-Anwendung">Kapitel 3</a> weiter, so können Sie im Fehlerfall die relevanten Funktionen wie
   folgt in eine Log-Datei schreiben:
</p>
<gen:highlight type="php">
/* @var $client ExtendedSoapClientService */
$client = $this->getDIServiceObject('...', 'LoginService');

/* @var $logger Logger */
$logger = Singleton::getInstance('Logger');

try {
   $response = $client->Authenticate($request);
} catch (Exception $e) {
   $logger->logEntry(
                     'service_calls',
                     $e->getMessage() . ' Details: ' . $e,
                     LogEntry::SEVERITY_ERROR);
}
</gen:highlight>
<p>
   Sollen zusätzlich die Anfrage und Antwort der Anfrage aufgezeichnet werden, lässt sich das Schwellwert-Feature des
   <em>Logger</em>s nutzen:
</p>
<gen:highlight type="php">
/* @var $client ExtendedSoapClientService */
$client = $this->getDIServiceObject('...', 'LoginService');

/* @var $logger Logger */
$logger = Singleton::getInstance('Logger');

$logFileName = 'service_calls';
try {
   $response = $client->Authenticate($request);
   $logger->logEntry(
                     $logFileName,
                     $client->getLastRequest(),
                     LogEntry::SEVERITY_TRACE);
   $logger->logEntry(
                     $logFileName,
                     $client->getLastResponse(),
                     LogEntry::SEVERITY_TRACE);
} catch (Exception $e) {
   $logger->logEntry(
                     $logFileName,
                     $e->getMessage() . ' Details: ' . $e,
                     LogEntry::SEVERITY_ERROR);
   $logger->logEntry(
                     $logFileName,
                     $client->getLastRequest(),
                     LogEntry::SEVERITY_INFO);
   $logger->logEntry(
                     $logFileName,
                     $client->getLastResponse(),
                     LogEntry::SEVERITY_INFO);
}
</gen:highlight>
<p>
   Die Inhalte der aktuellen Anfrage und der zugehörigen Antwort werden innerhalb der <em>try</em>-Klammer nur dann
   in die Log-Datei geschrieben, wenn der Schwellwert entsprechend konfiguriert ist. In jedem Fall wird die Anfrage bei
   einer fehlerbehafteten Antwort aufgezeichnet.
</p>
<p>
   Um das beschriebene Verhalten zu erreichen, muss die Einstellung
</p>
<gen:highlight type="php">
$logger->setLogThreshold(Logger::$LOGGER_THRESHOLD_ALL);
</gen:highlight>
<p>
   für den Entwicklungsbetrieb und
</p>
<gen:highlight type="php">
$logger->setLogThreshold(Logger::$LOGGER_THRESHOLD_INFO);
</gen:highlight>
<p>
   für den Produktionsbetrieb vorgenommen werden.
</p>

<h4 id="Chapter-4-2-Auslesen-von-registrierten-Typen-und-Funktionen"><a href="#Chapter-4-2-Auslesen-von-registrierten-Typen-und-Funktionen">4.2. Auslesen von registrierten Typen und Funktionen</a></h4>
<p>
   Die PHP SOAP-Implementierung unterstützt die Ausgabe von für einen Service definierte Daten-Typen und Methoden. Dies
   ist nicht nur für die Definition von <a href="#Chapter-3-3-Konfiguration-Objekt-Mapping">Objekt-Mappings</a> interessant,
   sondern gibt auch auskunft darüber, ob PHP die geladene WSDL korrekt verarbeitet hat.
</p>
<p>
   Um die für einen Service definierten Typen auszugeben, nutzen Sie bitte
</p>
<gen:highlight type="php">
echo $client->getTypes();
</gen:highlight>
<p>
   für die registrierten Methoden
</p>
<gen:highlight type="php">
echo $client->getFunctions();
</gen:highlight>
<p>
   Um die Lesbarkeit zu verbessern können die zurückgegebenen Arrays mit Hilfe von <em>var_dump()</em>, <em>print_r()</em>
   oder der APF-Funktion <em>printObject()</em> ausgegeben werden.
</p>

<h4 id="Chapter-4-3-Kapselung-eines-SOAP-Services"><a href="#Chapter-4-3-Kapselung-eines-SOAP-Services">4.3. Kapselung eines SOAP-Services</a></h4>
<p>
   Die Kapselung von Funktionen gilt gemeinhin als Vorteil für die Wartbarkeit und Austauschbarkeit von Funktionalitäten
   innerhalb einer Software. Im Sinne einer mehrschichtigen Architektur ist es daher sinnvoll, eine externe Schnittstelle
   vom Rest der Anwendung zu kapseln. Damit lässt sich nicht nur die Schnittstelle eigenständig implementieren und testen,
   sondern bei Bedarf auch gegen eine andere Implementierung oder Technologie austauschen.
</p>
<p>
   Zur Unterstützung bietet das APF die Nutzung des APF
   <int:link pageid="107" anchor="Chapter-3-2-3-DIServiceManager-Komplexe-Services">DI-Containers</int:link>
   in Verbindung mit Interfaces an. Damit lässt sich die genutzte Service-Implementierung per Konfiguration austauschen
   und gegebenenfalls gegen eine MOCK-Implementierung austauschen. Erstellen Sie einen Service nach den genannten
   Prinzipien und Techniken, lässt sich der erstellte Code zumeist einfacher mit Unit-Tests validieren.
</p>
<p>
   Ein weiterer Vorteil dieser Vorgehensweise ist ebenso, dass sich die Service-Implementierung nicht mehr um die
   Erstellung und Konfiguration des SOAP-Client kümmern muss. Dies übernimmt der DI-Container und stellt der Anwendung
   einen sofort einsetzbaren Service zur Verfügung.
</p>
<p>
   Als Beispiel für dieses Kapitel soll die oben beschrieben Authentifizierungsschnittstelle genutzt werden. Aufgabe ist
   es nun, einer Anwendung einen Service zur Verfügung zu stellen, der eine Authentifizierung gegegüber einem Dritten -
   in diesem Fall unserem SOAP-Interface - durchführt.
</p>

<h5 id="Chapter-4-3-1-Definition-des-Interfaces"><a href="#Chapter-4-3-1-Definition-des-Interfaces">4.3.1. Definition des Interfaces</a></h5>
<p>
   Zur internen Repräsentation des Authentifizierungsservice (=&quot;Wahrnehmung&quot; des Services innerhalb der
   Applikation) soll folgendes Interface dienen:
</p>
<gen:highlight type="php">
interface AuthenticationService {

   /**
    * @param string $username The user's name.
    * @param string $password The user's password.
    * @return bool True in case the authentication succeeded, false if it fails.
    */
   public function authenticate($username, $password);
}
</gen:highlight>

<h5 id="Chapter-4-3-2-Implementierung-des-Service"><a href="#Chapter-4-3-2-Implementierung-des-Service">4.3.2. Implementierung des Service</a></h5>
<p>
   Ausgehend von der Interface-Definition aus dem vorangegangenen Kapitel kann nun der Service implementiert werden. Da
   dieser den <em>ExtendedSoapClientService</em> nutzt und über den DI-Container konfiguriert wird, muss eine entsprechende
   Methode zur Injektion des SOAP-Client bereitestellt werden.
</p>
<gen:highlight type="php">
class AuthenticationServiceImpl implements AuthenticationService {

   /**
    * @var ExtendedSoapClientService
    */
   private $client;

   public function setClient(ExtendedSoapClientService $client) {
     $this->client = $client;
   }

   public function authenticate($username, $password) {
      /* @var $logger Logger */
      $logger = &Singleton::getInstance('Logger');

      $request = array(
         'ConsumerIdentification' => array(
            'ConsumerAuthentication' => array(
               'Principal' => '...',
               'Credential' => '...'
            )
         ),
         'Authentication' => array(
            'Identification' => array(
               'Alias' => $username
            ),
            'Security' => array(
               'SecretType' => 'Password',
               'Secret' => $password
            )
         )
      );

      try {
         $this->client->Authenticate($request);
         return true;
      } catch (Exception $e) {
         $logger->logEntry(
                           'service_calls',
                           'Authentication failed: ' . $e->getMessage(),
                           LogEntry::SEVERITY_ERROR);
         return false;
      }
   }
}
</gen:highlight>

<h5 id="Chapter-4-3-3-Konfiguration-des-Service"><a href="#Chapter-4-3-3-Konfiguration-des-Service">4.3.3. Konfiguration des Service</a></h5>
<p>
   Um den Login-Service nutzen zu können, ist eine Konfiguration für den DI-Container erforderlich. Diese übernimmt die
   Konfiguration des <em>AuthenticationService</em> und die Parametrisierung des SOAP-Clients.
</p>
<p>
   Der APF DI-Container bietet Ihnen die Möglichkeit, Services als abhängige Resource von weiteren Services zu verwenden.
   Der <em>AuthenticationService</em> ist im aktuellen Beispiel vom SOAP-Service abhänigig. Damit könnte der SOAP-Service
   in weiteren Interface-Implementierungen genutzt werden.
</p>
<p>
   Um die Komplexität der Konfiguration zu begrenzen, wird im weiteren davon ausgegangen, dass beide Service-Definitionen
   in einer Datei abgebildet werden. Dies beschränkt die Wiederverwendung nicht, erhöht jedoch die Übersichtlichkeit
   des Beispiels.
</p>
<p>
   Die Konfiguration des <em>LoginService</em> gestaltet sich damit wie folgt:
</p>
<gen:highlight type="ini">
[LoginService]
servicetype = "SINGLETON"
namespace = "projects::foo::biz"
class = "AuthenticationServiceImpl"

init.soap-client.method = "setClient"
init.soap-client.namespace = "projects::foo::biz"
init.soap-client.name = "SoapService"

[SoapService]
servicetype = "SINGLETON"
namespace = "tools::soap"
class = "ExtendedSoapClientService"

conf.wsdl.method = "setWsdlUrl"
conf.wsdl.value = "http://example.com/.../soap?wsdl"

conf.service.method = "setLocation"
conf.service.value = "http://example.com/.../soap"
</gen:highlight>

<h5 id="Chapter-4-3-4-Nutzung-des-Service"><a href="#Chapter-4-3-4-Nutzung-des-Service">4.3.4. Nutzung des Service</a></h5>
<p>
   Unter der Annahme, dass die Konfiguration im Namespace <em>projects::foo::biz</em> abgelegt ist, kann der
   <em>LoginService</em> wie folgt verwendet werden:
</p>
<gen:highlight type="php">
/* @var $service AuthenticationServiceImpl */
$service = &$this->getDIServiceObject('projects::foo::biz', 'LoginService');

if ($service->authenticate($username, $password)) {
   echo 'Login succeeded!';
} else {
   echo 'Login failed!';
}
</gen:highlight>
<p>
   Details zur Definition von Konfigurationen mit dem APF entnehmen Sie bitte dem Kapitel <int:link pageid="134" />,
   mehr Informationen zur Service-Konfiguration über den DI-Container finden sich im Kapitel <int:link pageid="107" />.
</p>

<h3 id="Chapter-5-Tipps-und-Tricks"><a href="#Chapter-5-Tipps-und-Tricks">5. Tipps und Tricks</a></h3>
<p>
   Dieses Kapitel stellt aus der Entwicklung gewonnene Erfahrungen zusammen. Diese sollen die Arbeit mit der
   PHP-SOAP-Extension erleichtern und Sie auf bekannten Hürden hinweisen.
</p>
<ul>
   <li>
      <strong><em>executeRequest()</em> erwartet eine vollständige XML-Anfrage</strong>:
      Nutzen Sie die Methode <em>executeRequest()</em>, so erwartet die PHP-SOAP-Extension wie im
      <a href="#Chapter-3-1-Kommunikation-per-XML">Kapitel 3.1</a> beschrieben ein vollständiges Anfrage-XML. Wird nur
      der Inhalt des Body gesendet schlägt die Anfrage fehl.
   </li>
   <li>
      <strong>Abbildung Einzelelemente auf Arrays</strong>:
      Beinhaltet das XSD-Schema des konsumierten Services Listen, die auch Einzelelemente beinhalten können, so es
      empfehlenswert das Feature <em>SOAP_SINGLE_ELEMENT_ARRAYS</em> zu aktivieren. Damit werden auch Einzelelemente als
      Liste abgebildet und führt innerhalb einer Anwendung (z.B. in einer <em>foreach</em>-Schleife) nicht zu Fehlern.
   </li>
   <li>
      <strong>Vererbung nicht implementiert</strong>:
      Die PHP-SOAP-Extension unterstützt keine Vererbung von Typen innerhalb einer Schema-Definition (siehe
      <em>&lt;xsd:redefine /&gt;</em>). Hierzu existiert bereits ein Bug unter
      <a class="external" href="https://bugs.php.net/bug.php?id=61343">bugs.php.net</a>.
   </li>
   <li>
      <strong>Objekt-Mapping nur per magic call nutzbar</strong>:
      Die PHP-SOAP-Extension führt das Objekt-Mapping nur in Verbindung mit der Nutzung der <em>__call()</em>-Methode
      des <em>ExtendedSoapClientService</em> aus. Dieses Verhalten lässt sich auch bei nativer Nutzung des
      <em>SoapClient</em> feststellen.
   </li>
</ul>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_148"/>