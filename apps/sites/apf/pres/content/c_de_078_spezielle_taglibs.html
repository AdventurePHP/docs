<doku:title parent="119" tags="dokumentation,taglibs,front,controller" title="Spezielle TagLibs" urlname="Spezielle-TagLibs">
  Auf dieser Dokumentationsseite werden Funktionen des Frameworks besprochen die f&uuml;r spezielle
  Anwendungsf&auml;lle oder komplexere Designs verwendet werden k&ouml;nnen.
</doku:title>
Auf dieser Dokumentationsseite werden Funktionen des Frameworks besprochen die f&uuml;r spezielle
Anwendungsf&auml;lle oder komplexere Designs verwendet werden k&ouml;nnen.
<div class="hint">
   <strong>Hinweis:</strong> Bitte beachten Sie, dass innerhalb von Tag-Definitionen ausschlie&szlig;lich
   Leerzeichen eingesetzt werden d&uuml;rfen. Tabs oder Zeilenumbr&uuml;che werden nicht erkannt und es
   kommt u.U. zu Fehlern beim Auslesen der Tag-Definitionen!
</div>

<h3 id="Chapter-1-Iterator"><a href="#Chapter-1-Iterator">1. Iterator</a></h3>
Das Iterator-Tag wurde in Version 1.6 (final) eingef&uuml;hrt um die Ausgabe von Listen von Objekten
oder assoziativen Arrays zu erleichtern. Dazu muss in einer Template-Datei ein Iterator definiert und
in einem Controller mit den gew&uuml;nschten Daten best&uuml;ckt werden. Die Definition des Tags
gestaltet sich wie folgt:
<gen:highlight type="apf-xml">
&lt;html:iterator name=""&gt;
 ...
 [&lt;iterator:addtaglib namespace="" prefix="" class="" /&gt;]
 [&lt;iterator:getstring namespace="" config="" entry="" /&gt;]
 ...
 &lt;iterator:item [getter=""]&gt;
   &lt;item:placeholder name="" /&gt;
  [<item:getstring namespace="" config="" entry="" />]
  [<item:addtaglib namespace="" prefix="" class="" />]
 &lt;/iterator:item&gt;
 ...
&lt;/html:iterator&gt;
</gen:highlight>
Dabei ist der Tag <strong>&lt;html:iterator /&gt;</strong> die Definition des Iterators und
<strong>&lt;iterator:item /&gt;</strong> enth&auml;lt die optische Beschreibung eines Daten-Elementes.
Innerhalb eines Daten-Elementes k&ouml;nnen beliebig viele Platzhalter (<strong>&lt;item:placeholder /&gt;</strong>)
und HTML-Tags definiert werden. Der Name des Platzhalters repr&auml;sentiert dabei ebenso den Namen
des auszugebenden Attributes einer Klasse, bzw. den Namen des Offset eines assoziativen Arrays. Das
optionale Attribut <strong>getter</strong> des <strong>&lt;iterator:item /&gt;</strong>-Tags definiert
den Namen derjenigen Methode, mit deren Hilfe das Attribut aus einem Daten-Objekt ausgelesen werden
kann. Im Standard-Fall wird die Methode <strong>get()</strong> als "Getter" verwendet.
<br />
<br />
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong> (1): Name des Iterators.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9]</code>)
  </li>
  <li>
    <strong>getter</strong>: Name der Methode, mit der Attribute eines Objekts abgerufen werden k&ouml;nnen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>name</strong> (2): Name des Platzhalters.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9]</code>)
  </li>
</ul>
Um den Iterator verwenden zu k&ouml;nnen muss das Tag zuerst per
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::taglib" prefix="html" class="iterator" /&gt;
</gen:highlight>
im aktuellen <em>Document</em> bekannt gemacht werden. Weiterhin muss der im <em>Document</em>
definierte DocumentController von der Klasse <strong>iteratorBaseController</strong>, die im Namespace
<strong>tools::html::taglib::documentcontroller</strong> abgelegt ist, erben. Innerhalb des
DocumentControllers, kann der Iterator dann wie folgt verwendet werden:
<gen:highlight type="php">
import('tools::html::taglib::documentcontroller','iteratorBaseController');

class list_controller extends iteratorBaseController {

   function list_controller(){
   }

   function transformContent(){
      ...

      // Referenz auf den Iterator holen
      $Iterator = &$this->__getIterator('...');

      // Datencontainer mit einer Liste von Objekten oder assoziativen Arrays fuellen
      $Iterator->fillDataContainer(...);

      // Am Ort der Definition ausgeben ...
      $Iterator->transformOnPlace();
      // ... oder den Inhalt in einen Platzhalter einsetzen
      $this->setPlaceHolder('...',$Iterator->transformIterator());

      ...

   }

}
</gen:highlight>
<div class="hint">
   F&uuml;r die Ausgabe von sprachabh&auml;ngigen Werten k&ouml;nnen die Tags
   <em>&lt;iterator:getstring /&gt;</em> sowie <em>&lt;item:getstring /&gt;</em> verwendet werden.
   Diese funktionieren analog zum Tag
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>.
   Reicht die Funktionalit&auml;t nicht aus, k&ouml;nnen per <em>&lt;iterator:addtaglib /&gt;</em> 
   und <em>&lt;item:addtaglib /&gt;</em> eigene Taglibs analog zu
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link>
   eingebunden werden.
</div>

<h3 id="Chapter-2-Mediastream"><a href="#Chapter-2-Mediastream">2. Mediastream-Tags</a></h3>
Die Mediastream-Tags erm&ouml;glichen es dem Entwickler, Ressourcen zur Gestaltung der GUI direkt
im Namespace des Moduls abzulegen und daraus auszuliefern. Hierzu stellt das Framework einerseits
eine abstrakte TagLib-Implementierung und einige konkrete TagLibs zur Verf&uuml;gung, die eine
Medien-URL generieren, andererseite eine allgemeing&uuml;ltig verwendbare FrontController-Action,
die die adressierten Medien ausliefert.
<br />
<br />
Um die Tags einsetzen zu k&ouml;nnen, muss sichergestellt sein, dass f&uuml;r die Action, die mit
der Auslieferung betraut ist eine validie Konfiguration f&uuml;r den aktuellen Applikations-Kontext
existiert. Die Konfiguration wird dabei unter
<gen:highlight type="code">/config/tools/media/actions/{CONTEXT}/{ENVIRONMENT}_actionconfig.ini</gen:highlight>
erwartet. Der Inhalt der Datei kann der nachfolgenden Code-Box entnommen werden:
<gen:highlight type="ini">
[streamMedia]
FC.ActionNamespace = "tools::media::actions"
FC.ActionFile = "StreamMediaAction"
FC.ActionClass = "StreamMediaAction"
FC.InputFile = "StreamMediaInput"
FC.InputClass = "StreamMediaInput"
FC.InputParams = ""
</gen:highlight>
Eine Beispieldatei findet sich ebenfalls in der <strong>adventure-configpack-*</strong>-Release-Datei
unter <strong>tools/media/actions/</strong>.
<br />
<br />
F&uuml;r den konkreten Einsatz existieren bereits folgende TagLibs:
<ul>
  <li><strong>form_taglib_mediastream:</strong> Einsatz innerhalb des html:form-Tags</li>
  <li><strong>html_taglib_mediastream:</strong> Einsatz innerhalb einer Template-Datei</li>
  <li><strong>template_taglib_mediastream:</strong> Einsatz innerhalb des html:template-Tags</li>
</ul>
Um das Tag einzusetzen, muss dieses im gew&uuml;nschten G&uuml;ltigkeitsbreich mit dem
<strong>&lt;*:importdesign /&gt;</strong>-Tag bekannt gemacht werden. Die folgende Code-Box zeigt die
Anwendung innerhalb eines Formulars:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="TestFormular"&gt;
  &lt;form:addtaglib namespace="tools::media::taglib" prefix="form" class="mediastream" /&gt;
  &lt;img src="&lt;form:mediastream namespace="modules::mymodule::pres::images" filename="phone_icon.png" /&gt;" alt="" /&t;
  &lt;form:text name="phonenumber" /&gt;
  &lt;br /&gt;
  &lt;form:button name="send" value="Absenden" /&gt;
&lt;/html:form&gt;
</gen:highlight>
Wie dem Beispiel zu entnehmen ist, erwarten die <strong>&lt;*:mediastream /&gt;</strong>-Tags folgende
Attribute:
<ul>
  <li>
    <strong>namespace</strong>: Namespace zur gew&uuml;nschten Medien-Datei.
    (<strong>Zeichen:</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>filename</strong>: Name der Medien-Datei.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_.-]</code>)
  </li>
</ul>
<br />
<strong>Tipp:</strong>
<br />
M&ouml;chten Sie den Namespace der auszuliefernden Datei zus&auml;tzlich beeinflussen um z.B. diese
beispielsweise abh&auml;ngig vom aktuellen Kontext im config-Namespace ablegen zu k&ouml;nnen, so
kann folgende Vorgehenweise gew&auml;hlt werden:
<br />
<br />
<ol>
  <li>
    Ausstatten des Tags mit einer eindeutigen ID:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::media::taglib" prefix="html" class="mediastream" /&gt;
&lt;img src="&lt;html:mediastream
                     namespace="config::modules::mymodule::pres::images"
                     filename="phone_icon.png"
                     id="PhoneIcon"
             /&gt;"
        alt=""
/&gt;
</gen:highlight>
  </li>
  <li>
    Manipulieren des Namespaces im DocumentController:
<gen:highlight type="php">
class example_controller extends base_controller
{
   function transformContent(){
      $mediaStreamTag = &$this->__getMediaStreamTagByID('PhoneIcon');
      $mediaStreamTag->setAttribute($mediaStreamTag->getAttribute().'::'.$this->__Context);
   }

   function &__getMediaStreamTagByID($id){
      $children = &$this->__Document->getChildren();
      foreach($children as $objectId => $DUMMY){
         if(get_class($children[$objectId]) == 'html_taglib_mediastream'){
            return $children[$objectId];
         }
      }
      $null = null;
      return $null;
   }
}
</gen:highlight>
  </li>
</ol>
<br />
<h3 id="Chapter-3-Generischer-importdesign-Tag"><a href="#Chapter-3-Generischer-importdesign-Tag">3. Generischer importdesign-Tag</a></h3>
In komplexeren Applikationen ist es oft notwendig, die durch <strong>&lt;*:importdesign /&gt;</strong>-Tags
definierten Views dynamisch f&uuml;llen zu k&ouml;nnen. Vielfach m&ouml;chte der Entwickler in
aufw&auml;ndigeren Strukturen die Informationen des Applikationsmodels verwenden. Um dies
uneingeschr&auml;nkt zu erm&ouml;glichen und eine Applikationssteuerung aus der Business-Schicht zu
erm&ouml;glichen, wurde das Framework mit einem generischen importdesign-Tag ausgestattet, der es
erlaubt sowohl den Namen des Templates aus auch den Namespace desselben dynamisch aus einem
Model-Objekt zu beziehen.
<br />
<br />
Die Signatur des generischen Tags gestaltet sich dabei wie folgt:
<gen:highlight type="apf-xml">
&lt;generic:importdesign
   modelnamespace=""
   modelfile=""
   modelclass=""
   modelmode="NORMAL|SINGLETON|SESSIONSINGLETON"
   namespaceparam=""
   templateparam=""
   [getmethod=""]
   [dependentactionnamespace=""
   dependentactionname=""
   [dependentactionparams=""]]
/&gt;
</gen:highlight>
Den Attributen kommt dabei folgende Bedeutung zu:
<ul>
  <li>
    <strong>modelnamespace</strong>: Namespace der Model-Klasse.
    (<strong>Zeichen:</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>modelfile</strong>: Name der Model-Datei.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>modelclass</strong>: Name der Model-Klasse.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>modelmode</strong>: Instanzierungsmodus des Models.
    (<strong>Erlaubte Werte</strong>: <code>NORMAL|SINGLETON|SESSIONSINGLETON</code>)
  </li>
  <li>
    <strong>namespaceparam</strong>: Name des Model-Parameters f&uuml;r den Template-Namespace.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_.-]</code>)
  </li>
  <li>
    <strong>templateparam</strong>: Name des Model-Parameters f&uuml;r den Template-Namen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_.-]</code>)
  </li>
  <li>
    <strong>getmethod</strong>: Name der Mode-Methode mit dem die Parameter abgefragt werden
    k&ouml;nnen. Dieser wird der Wert des <em>namespaceparam</em> bzw. <em>templateparam</em> als
    Parameter &uuml;bergeben und erwartet den zugeh&ouml;rigen R&uuml;ckgabewert.
    Standardm&auml;&szlig;ig wird die Funktion <strong>getAttribute()</strong> verwendet.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>dependentactionnamespace</strong> / <strong>dependentactionname</strong> /
    <strong>dependentactionparams</strong>: Die drei Optionen dienen dazu, eine abh&auml;ngige Action
    automatisch beim Frontcontroller zu registrieren. Dies ist vor Allem dann hilfreich, wenn ein
    Modul &uuml;ber das Tag eingebunden wird und eine Frontcontroller-Action zur Steuerung der
    Navigation verwendet wird.
    <br />
    <br />
    Das Attribut <strong>dependentactionnamespace</strong> definiert den Namespace der Action (z.B.
    <em>sites::mysite::biz</em>) und <strong>dependentactionname</strong> den Namen/Alias der Action
    (z.B. <em>Navigate</em>). <strong>dependentactionparams</strong> beinhaltet die Parameter der
    Action in der Form <strong>param1:value1|param2:value2</strong>, wie aus dem URL-Layout des
    Frontcontrollers bekannt.
  </li>
</ul>
<br />
Um das Tag anwenden zu k&ouml;nen, muss dieses zun&auml;chst via
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::taglib" prefix="generic" class="importdesign" /&gt;
</gen:highlight>
im aktuellen G&uuml;ltigkeitsbereich bekannt gemacht werden.
<br />
<br />
<strong>Hinweise:</strong>
<ul>
  <li>
    Als Anwendungsbeispiel kann der Artikel
    <a href="./Page/079-Behind-the-site">behind the site</a>
    (englisch) herangezogen werden. Dieser beschreibt, wie die vorliegende Dokuentationswebseite
    aufgebaut ist und welche Mittel des Frameworks sie nutzt.
  </li>
  <li>
    Soll eine Frontcontroller-Action zu Navigationszwecken verwendet werden, so muss bei der
    Klassendefinition die Variable <strong>$__KeepInURL</strong> mit <strong>true</strong>
    initialisiert werden. Dies bewirkt, dass die Action bei der Link-Generierung mit dem
    <a href="./?Seite=012-Frontcontroller#Chapter-2-4-Generierung-von-Links" title="FrontcontrollerLinkHandler">FrontcontrollerLinkHandler</a>
    erfasst wird.
  </li>
  <li>
    Die Registrierung der Action wird nur dann durchgef&uuml;hrt, wenn die Attribute
    <strong>dependentactionnamespace</strong> und <strong>dependentactionname</strong> gef&uuml;llt
    sind und die Action noch nicht gegistriert ist. Die Angabe von Parametern ist optional.
  </li>
</ul>

<h3 id="Chapter-4-Core-appendnode"><a href="#Chapter-4-Core-appendnode">4. core:appendnode-Tag</a></h3>
<p>
   Aus einer Diskussion &uuml;ber wiederverwendbare Template-Fragmente (z.B. Formulare) entstand die
   Idee, eine TagLib zu entwerfen, die Inhalte aus einem beliebigen Template in den aktuellen
   G&uuml;ltigkeitsbereich zu importieren. Durch die generische DOM-Struktur der GUI-Elemente des
   Frameworks ist dies auf sehr einfache Weise m&ouml;glich.
</p>
<p>
   Um die Funktion allgemeing&uuml;ltig zur Verf&uuml;gung zu stellen, wurde im 1.8er-Zweig der
   <strong>&lt;core:appendnode /&gt;</strong>-Tag hinzugef&uuml;gt, der beliebige Templates
   "importieren" kann. Der Tag erwartet - &auml;hnlich dem importdesign-Tag - die statischen Attribute
   <strong>namespace</strong> und <strong>template</strong>.
</p>
<div class="hint">
   Ab Version 1.12 ist zus&auml;tzlich das Attribut <em>includestatic</em> verf&uuml;gbar. Ist
   dieses vorhanden und auf den Wert <em>true</em> eingestellt, so wird s&auml;mtlicher Inhalt
   des inkludierten Templates &uuml;bernommen. Enth&auml;lt es einen anderen Wert oder ist nicht
   vorhanden, werden nur die aktuell im eingebundenen Template enthaltenen DOM-Knoten (Instanzen von
   Taglibs) &uuml;bernommen.
</div>

<h4 id="Chapter-4-1-Einbindung-von-Templates"><a href="#Chapter-4-1-Einbindung-von-Templates">4.1. Einbindung von Templates</a></h4>
<p>
   Um ein wiederverwendbares Template einbinden zu k&ouml;nnen, muss das Tag im gew&uuml;nschten
   Template wir folgt platziert werden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="core::pagecontroller" prefix="core" class="appendnode" /&gt;
&lt;core:appendnode namespace="..." template="..." [includestatic="true" ]/&gt;
</gen:highlight>
<p>
   Soll beispielweise ein Template zur Ausgabe eines Dom&auml;nen-Objekts in mehreren View-Templates
   eingesetzt werden, so schickt es sich, dieses in einem eigenen Template (Namespace:
   <em>sites::testsite::pres::templates::generic</em>; Template: <em>generic_templates</em>) zu
   definieren. Die Definition kann dabei folgende Gestalt haben:
</p>
<gen:highlight type="apf-xml">
&lt;html:template name="ReusableTemplate"&gt;
  ...
  &lt;template:placeholder name="DisplayName"&gt;
  ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Um das Template in einem anderen verwenden zu k&ouml;nnen, muss die Template-Datei wie folgt in die
   bestehende eingebunden werden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="core::pagecontroller" prefix="core" class="appendnode" /&gt;
&lt;core:appendnode namespace="sites::testsite::pres::templates::generic" template="generic_templates" /&gt;
</gen:highlight>

<h4 id="Chapter-4-2-Verwendung-der-Elemente"><a href="#Chapter-4-2-Verwendung-der-Elemente">4.2. Verwendung der Elemente</a></h4>
<p>
   Die Verwendung der durch das <strong>&lt;core:appendnode /&gt;</strong>-Tag eingebundenen Elements
   gestaltet sich identisch zur bisherigen Vorgehensweise, da die Elemente in den G&uuml;ltigkeitsbereich
   des gew&uuml;nschten Templates importiert werden. Damit k&ouml;nnen weiterhin die im
   DocumentController zur Verf&uuml;gung stehenden Methoden (z.B. <em>__getTemplate()</em>) verwendet
   werden.
</p>
<p>Das im Kapitel 4.1 aufgezeigte Template k&ouml;nn wie auch bisher mit</p>
<gen:highlight type="php">
$tmpl = &$this->__getTemplate('ReusableTemplate');
</gen:highlight>
<p>adressiert werden.</p>

<h4 id="Chapter-4-3-Wichtige-Hinweise"><a href="#Chapter-4-3-Wichtige-Hinweise">4.3. Wichtige Hinweise</a></h4>
<p>
   Das Parsen des eingebundenen Templates erfolgt identisch zu den per importdesign-Tag eingebundenen
   Template-Dateien. Das bedeutet, dass der Entwickler daf&uuml;r Sorge tragen muss, dass die
   gew&uuml;nschten Tags im eingebundenen Template auch erkannt werden.
</p>
<p>
   Die <strong>&lt;core:appendnode /&gt;</strong>-TagLib legt im Ursprungstemplate Marker-Tags an, damit
   die <strong>transformOnPlace()</strong>-Methoden genutzt werden k&ouml;nnen. Bitte beachten Sie, dass
   die eingebundenen Kinder in der Reihenfolge der Definition im zus&auml;tzlichen Template eingebunden
   werden!
</p>
<p>Sofern auch statischer Inhalt des eingebundenen Templates wie z.B.</p>
<gen:highlight type="apf-xml">
<div class="formattingContainer">
   &lt;html:template name="ReusableTemplate"&gt;
     ...
   &lt;/html:template&gt;
</div>
</gen:highlight>
<p>
   &uuml;bernommen werden soll, muss das Attribut <em>includestatic</em> auf den Wert <em>true</em>
   gestellt werden.
</p>
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_078" />