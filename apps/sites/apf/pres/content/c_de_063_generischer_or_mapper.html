<doku:title parent="119" tags="object,relational,mapping,or,mapper,generisch,beziehungen,objekte,objektb&auml;ume,objekt strukturen,konfiguration,verwendung" title="Generischer O/R-Mapper" urlname="Generischer-OR-Mapper">
  Das Modul genericormapper bietet einen generischen O/R-Mapper, der voll in das APF integriert ist
  uns dessen Mechanismen - z.B. Konfiguration - nutzt um die gew&uuml;nschten Objekte und deren
  Beziehungen zu konfigurieren.
</doku:title>
<h3 id="Chapter-1-Einleitung"><a href="#Chapter-1-Einleitung">1. Einleitung</a></h3>
In der objektorientierten Welt wird der Anspruch erhoben, Applikationen m&ouml;glichst komplett
objektorientiert entwerfen und entwickeln zu k&ouml;nnen. Um dieser Forderung gerecht zu werden,
st&ouml;&szlig;t jeder Entwickler unweigerlich auf das Problem, dass Daten in relationalen
Datenbanken gehalten werden (m&uuml;ssen). Steht kein Hilfsmittel zur Verf&uuml;gung, muss der
<em>DataMapper</em> in jeder Applikation neu geschrieben werden. Das kostet nicht nur Zeit und Geld,
sondern ist gegen den Ansatz "<strong>don't repeat yourself</strong>", denn diese Vorgehensweise
produziert redundaten Quellcode.
<br />
<br />
Das APF-Modul <strong>genericormapper</strong> stellt eine Abstraktionsschicht zur Verf&uuml;gung,
die dem Entwickler einen Gro&szlig;teil der Mapping-Arbeit abnimmt. Der Mapper &uuml;bernimmt dabei
<ul>
  <li>Verwaltung von Objekten,</li>
  <li>Verwaltung von Beziehungen zwischen Objekten (Komposition und Assoziation) und</li>
  <li>CRUD-Funktionen auf Objekte und Objektstrukturen.</li>
</ul>
F&uuml;r diese Aufgaben stehen eine Reihe von API-Funktionen zur Verf&uuml;gung, die das Laden,
Manipulieren und L&ouml;schen von definierten Objekten in der Datenbank abbilden. Das
allgemeing&uuml;ltige Dom&auml;nen-Objekt <strong>GenericDomainObject</strong> kann dabei entweder
direkt verwendet oder nochmals innerhalb der Datenschicht der Applikation in die Dom&auml;nen-Objekte
der Anwendung &uuml;bersetzt werden.
<br />
<br />
Die folgenden Kapitel zeigen, wie der O/R-Mapper konfiguriert und eingesetzt werden kann. Das im
APF-Release enthaltene Modul <em>usermanagement</em> basiert auf dem O/R-Mapper und kann als
weiterf&uuml;hrendes Beispiel herangezogen werden. Das usermanagement-Modul wird unter
<int:link pageid="095" /> n&auml;her beschrieben.
<br />
<br />
<br />
<h3 id="Chapter-2-Konfiguration"><a href="#Chapter-2-Konfiguration">2. Konfiguration des O/R-Mappers</a></h3>
<br />
<h4 id="Chapter-2-1-Grundlagen"><a href="#Chapter-2-1-Grundlagen">2.1. Grundlagen</a></h4>
Um den O/R-Mapper verwenden zu k&ouml;nnen, m&uuml;ssen zwei Konfigurationsdateien angelegt werden:
<ul>
  <li>{ENVIRONMENT}_{NAMEAFFIX}_objects.ini</li>
  <li>{ENVIRONMENT}_{NAMEAFFIX}_relations.ini</li>
</ul>
Dabei definiert die erste Datei die Objekte und deren Attribute, die zweite Konfigurationsdatei die
Beziehungen zwischen den Objekten aus der ersten. Da der <strong>GenericORRelationMapper</strong> den
<a href="./?Seite=031-Klassenreferenz-connectionManager" title="Klassenreferenz connectionManager">connectionManager</a>
zum Aufbau der Datenbankverbindung nutzt, muss gegebenenfalls noch eine Sektion in der
Datenbank-Verbindungskonfiguration angelegt werden.
<br />
<br />
Der Abschnitt <strong>{ENVIRONMENT}</strong> im Namen der beiden Konfigurationsdateien wird dabei
dem Registry-Wert <strong>Environment</strong> aus dem Namespace <strong>apf::core</strong> entnommen,
der Abschnitt <strong>{NAMEAFFIX}</strong> kann frei gew&auml;hlt werden. Er dient als weiteres
Unterscheidungsmerkmal und erm&ouml;glicht, dass unterschiedliche Mapper-Konfigurationen pro
Applikation verwendet werden k&ouml;nnen. Letzeres ist vor allem dann interessant, wenn eine
Applikation mehrere Datenquellen bedienen m&ouml;chte/muss.
<br />
<br />
<br />
<h4 id="Chapter-2-2-Konfigurationsbeispiel"><a href="#Chapter-2-2-Konfigurationsbeispiel">2.2. Konfigurationsbeispiel</a></h4>
Ein Entwickler m&ouml;chte ein G&auml;stebuch entwickeln. Die
Quellcode-Dateien sind dabei im Namespace <strong>modules::myguestbook</strong> abgelegt und das
G&auml;stebuch ben&ouml;tigt nur einen O/R-Mapper. Weiterhin wurde der globale Registry-Wert
<strong>Environment</strong> nicht manipuliert, die aktuelle Anwendung wird im Context
<strong>sites::mysite</strong> ausgef&uuml;hrt und der Namenszusatz (NAMEAFFIX) lautet
<strong>guestbook</strong>. In diesem Fall tragen die beiden Konfigurationsdateien den Namen
<gen:highlight type="code">DEFAULT_guestbook_objects.ini</gen:highlight>
sowie
<gen:highlight type="code">DEFAULT_guestbook_relations.ini</gen:highlight>
und m&uuml;ssen im Ordner
<gen:highlight type="code">/apps/config/modules/myguestbook/sites/mysite</gen:highlight>
abgelegt sein. Weitere Details zu Konfigurationsdateien, Namespaces und Kontext k&ouml;nnen im
Kapitel <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a> nachgelesen
werden.
<br />
<br />
<br />
<h4 id="Chapter-2-3-Objekt-und-Beziehungsdefinition"><a href="#Chapter-2-3-Objekt-und-Beziehungsdefinition">2.3. Aufbau der Objekt- und Beziehungsdefinition</a></h4>
Die Syntax der Objekt- und Beziehungsdefinition gestaltet sich wie folgt:
<br />
<br />
<h5 id="Chapter-2-3-1-Objektdefinition"><a href="#Chapter-2-3-1-Objektdefinition">2.3.1. Objektdefinition</a></h5>
Der <strong>GenericORRelationMapper</strong> stellt, wie bereits in der Einleitung angesprochen, ein
allgemeing&uuml;ltiges Dom&auml;nen-Objekt zur Verf&uuml;gung (<strong>GenericDomainObject</strong>),
das ein Objekt in der Datenhaltung repr&auml;sentiert. Der Typ des Objekts beschreibt sich dabei
nicht durch den Klassennamen, sondern durch das Attribut <strong>ObjectName</strong> der Klasse.
<br />
<br />
Die Definition der Objekte beinhaltet daher lediglich den Namen des Objekts (=Name der Sektion) und
die Attribute (=Properties der Klasse <strong>GenericDomainObject</strong>). Die folgende Codebox
zeigt den Aufbau einer typischen Objektdefinition:
<br />
<gen:highlight type="ini">
[Application]
DisplayName = "VARCHAR(100)"

[User]
DisplayName = "VARCHAR(100)"
FirstName = "VARCHAR(100)"
LastName = "VARCHAR(100)"
EMail = "VARCHAR(100)"
Username = "VARCHAR(100)"
Password = "VARCHAR(100)"

[Group]
DisplayName = "VARCHAR(100)"

[Role]
DisplayName = "VARCHAR(100)"
</gen:highlight>
Die Werte der Attribute bestimmen dabei die Auslegung der Felder in der Datenbank. Der Mapper kennt
dabei die allgemeing&uuml;ltigen Werte
<ul>
  <li>VARCHAR(<strong>{LENGTH}</strong>)</li>
  <li>TEXT</li>
  <li>DATE</li>
</ul>
die eigenst&auml;ndig in die entsprechenden SQL-Anweisungen "&uuml;bersetzt" werden. Der Platzhalter
<strong>{LENGTH}</strong> kann dabei durch eine beliebige Zeichenkettenl&auml;nge ersetzt werden.
Alle dar&uuml;ber hinaus gehenden Feldtypen m&uuml;ssen &auml;hnlich der Feldbeschreibung bei einer
<em>CREATE TABLE</em>-Anweisung formuliert werden. Mit den hier aufgef&uuml;hrten Werten lassen sich
jedoch die meisten Anwendungsf&auml;lle abbilden.
<div class="hint">
   Seit dem Release 1.11 unterst&uuml;tzt der Generic O/R-Mapper auch die Maskierung von BIT-Feldern.
   Hierzu muss der Wert einer Property-Definition eine g&uuml;ltige Definition eines BIT-Feldes wie
   z.B.
   <gen:highlight type="sql">bit(7) NOT NULL default b'0'</gen:highlight>
   Dabei ist es grunds&auuml;tzlich nicht erheblich, dass das Feld einen Default-Wert besitzt. Wichtig
   ist die Definition eines BIT-Feldes mit dem Schl&uuml;sselwort &quot;BIT&quot;. Details k&ouml;nnen
   der Foren-Diskussion unter
   <a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=8&amp;t=234" title="Fehler mit BIT-Feldern" linkrewrite="false">Fehler mit BIT-Feldern</a>
   entnommen werden.
</div>
Die Attribute eines beliebigen Objekts k&ouml;nnen dann wie folgt adressiert werden:
<gen:highlight type="php">
...
$User = new GenericDomainObject('User');
$User->setProperty('FirstName','Christian');
$User->setProperty('LastName','Achatz');
...
echo 'Vorname: '.$User->getProperty('FirstName');
echo 'Name: '.$User->getProperty('LastName');
...
</gen:highlight>

<h5 id="Chapter-2-3-2-Beziehungsdefinition"><a href="#Chapter-2-3-2-Beziehungsdefinition">2.3.2. Beziehungsdefinition</a></h5>
Die Datei <strong>*_relations.ini</strong> definiert die Beziehungen zwischen den im vorherigen
Kapitel beschriebenen Objekten. Der Mapper kennt dabei zwei Arten von Beziehungen: Komposition und
Assoziation. Da Kompositionen im Gegensatz zu Assoziationen starke Bindungen sind, k&ouml;nnen Objekte,
die weitere Objekte komponieren, nicht gel&ouml;scht werden, da sonst den komponierten Objekten die
Existenzberechtigung entzogen werden w&uuml;rde. Dieser Fall wird vom Mapper deshalb mit einer
entsprechenden Meldung quittiert.
<br />
<br />
<strong>Hinweis:</strong>
Die Datenhaltungstheorie spricht bei der Auslegung der Beziehungen davon, dass jedes Objekt genau
einmal komponiert sein soll, da es in der Realit&auml;t nur eine starke Zugeh&ouml;rigkeit eines
Objekts zu einem anderen geben kann. Weiterhin definiert eine Komposition eine Abh&auml;ngigkeit
oder auch Existenzberechtigung eines Objekts. Bei der Definition der Beziehungen muss daher darauf
geachtet werden, dass abh&auml;ngige Objekte entsprechend komponiert sind. Ein G&auml;stebucheintrag
kann beispielsweise nicht ohne ein G&auml;stebuch existieren, der Benutzer, dem der Eintrag zugeordnet
ist, dageben sehr wohl. In diesem Fall muss die Beziehung zwischen G&auml;stebuch und
G&auml;stebucheintrag von der Qualit&auml;t "Komposition" sein, die Beziehung zwischen
G&auml;stebucheintrag und dem Benutzer vom Typ "Assoziation".
<br />
<br />
Die folgende Codebox zeigt den Aufbau einer typischen Relationsdefinition:
<gen:highlight type="ini">
[Application2Group]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Group"

[Group2User]
Type = "ASSOCIATION"
SourceObject = "Group"
TargetObject = "User"

[Role2User]
Type = "ASSOCIATION"
SourceObject = "Role"
TargetObject = "User"

[Application2User]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "User"

[Application2Role]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Role"
</gen:highlight>
Der Sektionsname (z.B. <strong>Group2User</strong>) sollte sprechend gew&auml;lt werden, da dieser
sowohl zum Laden von zu einem Objekt in Beziehung stehenden Objekten als auch f&uuml;r die
Inbeziehungssetzung beim Speichern von Objekten Verwendung findet. Der Typ beinhaltet die Qualit&auml;t
der Beziehung, die Parameter <strong>SourceObject</strong> und <strong>TargetObject</strong> sind
eine Referenz auf die Sektion der Objektdefinition.
<br />
<br />
<strong>Hinweise:</strong>
<ul>
  <li>
    Die Anzahl der Beziehungsdefinitionen ist nicht limitiert, die Definitionen sollten jedoch den
    Anforderungen der Applikation gerecht werden. Hierbei gilt die Daumenregel, dass bei mehrmaliger
    und gleichbedeutender Verwendung eines Attributs eines Objekts dieses in ein eigenes Objekt
    ausgelagert und das jeweilige Objekt in Beziehung (Assoziation) zu diesem gesetz werden soll.
    Typisches Beispiel ist die Sprache eines Objekts.
  </li>
  <li>
    Wurde mit Hilfe der Methode <strong>addRelatedObject()</strong> ein Objektbaum aufgebaut, so
    k&ouml;nnen die in Beziehung stehenden Objekte mit der Methode <strong>getRelatedObjects()</strong>
    aus dem <strong>GenericDomainObject</strong> ausgelesen und ggf. weiterverarbeitet oder manipuliert
    werden.
  </li>
</ul>
<br />
<h3 id="Chapter-3-Datenbank-Setup"><a href="#Chapter-3-Datenbank-Setup">3. Setup der Datenbank</a></h3>
Nachdem die Konfigurationsdateien fertiggestellt sind, muss die Datenbank f&uuml;r die Verwendung
vorkonfiguriert werden. Dies kann manuell oder automatisiert vorgenommen passieren. Die manuelle
Variante kann unter
<a href="./?Seite=064-Generischer-OR-Mapper-Manuelles-Setup-der-Datenbank" title="Generischer OR-Mapper - Manuelles Setup der Datenbank">Manuelles Setup der Datenbank</a>
nachgelesen werden.
<br />
<br />
Das folgende Skript zeigt, wie das Datenbank-Setup mit Hilfe des <strong>GenericORMapperSetup</strong>-Tools
das Layout der Tabellen automatisiert erstellt werden kann. Eine Vorlage f&uuml;r dieses Skript
befindet sich zudem im Ordner <em>/apps/modules/genericormapper/data/tools</em> des jeweiligen
<em>adventure-codepack-*</em> Releases und tr&auml;gt den Namen <em>setup.php</em>. Dieses muss
gem&auml;&szlig; den Bemerkungen unterhalb der Codebox f&uuml;r den entstprechenden Anwendungsfall
angepasst werden. Hier das Setup-Skript im &Uuml;berblick:
<gen:highlight type="php">
// PageController einbinden
require('../../apps/core/pagecontroller/pagecontroller.php');

// Ggf. Werte der Registry anpassen
$Reg = &Singleton::getInstance('Registry');
$Reg->register('apf::core','Environment',{ENVIRONMENT});

// SetupMapper einbinden
import('modules::genericormapper::data::tools','GenericORMapperSetup');

// SetupMapper instanziieren
$SetupMapper = new GenericORMapperSetup();

// Context der Applikation bekannt geben (wichtig f&uuml;r die Konfigurationsdateien!)
$SetupMapper->set('Context',{CONTEXT});

// Ggf. MySQL Storage-Engine anpassen (Standard is MyISAM)
$SetupMapper->set('StorageEngine','...');

// Datenbanklayout erstellen
$SetupMapper->setupDatabase({CONFIG_NAMESPACE},{CONFIG_NAME_AFFIX},{CONNECTION_NAME});

// Datenbanklayout lediglich anzeigen
$SetupMapper->setupDatabase({CONFIG_NAMESPACE},{CONFIG_NAME_AFFIX});
</gen:highlight>
Die eingesetzten Platzhalter haben folgende Bedeutung:
<ul>
  <li>
    <strong>{ENVIRONMENT}</strong>: Umgebungsvariable der Applikation. Diese wird bei der Adressierung
    von Konfigurationsdateien verwendet und muss auf den Wert gesetzt werden, der auch in der
    Zielanwendung verwendet wird. Siehe hierzu Kapitel
    <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a>.
    <br />
    <br />
  </li>
  <li>
    <strong>{CONTEXT}</strong>: Context der Applikation. Dieser wird zur Addressierung der
    Konfigurationsdateien verwendet und muss auf den Wert gesetzt werden, der auch in der
    Zielanwendung verwendet wird. Siehe hierzu Kapitel
    <a href="./?Seite=033-Konfiguration" title="Konfiguration">Konfiguration</a>.
    <br />
    <br />
  </li>
  <li>
    <strong>{CONFIG_NAMESPACE}</strong>: Namespace, unter dem die Konfigurationsdateien f&uuml;r den
    O/R-Mapper liegen (siehe Kapitel 2.2).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONFIG_NAME_AFFIX}</strong>: Namenszusatz der Konfigurationsdateien (siehe Kapitel 2.1).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONNECTION_NAME}</strong>: Name der Datenbankverbindung, die f&uuml;r das Setup genutzt
    werden soll.
    <br />
    <br />
  </li>
</ul>
Weiterhin ist wichtig, dass die zu initialisierende Datenbank bereits existiert und der in der
Verbindungskonfiguration aufgef&uuml;hrte Benutzer <em>CREATE TABLE</em>-Rechte f&uuml;r diese
besitzt. Wird nach der Ausf&uuml;hrung des Codes kein Fehler angezeigt, wurde das Setup erfolgreich
abgeschlossen. Das Ergebnis kann dann beispielsweise mit phpMyAdmin oder dem MySQLAdmin
&uuml;berpr&uuml;ft werden.
<br />
<br />
Die Ausgabe des obigen Scripts sollte bei erfolgreicher Ausf&uuml;hrung folgendes anzeigen:
<gen:highlight type="sql">
CREATE TABLE IF NOT EXISTS `ent_application` (
  `ApplicationID` TINYINT(5) NOT NULL auto_increment,
  `DisplayName` VARCHAR(100) character set utf8 NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY (`ApplicationID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `ent_user` (
  `UserID` TINYINT(5) NOT NULL auto_increment,
  `DisplayName` VARCHAR(100) character set utf8 NOT NULL default '',
  `FirstName` VARCHAR(100) character set utf8 NOT NULL default '',
  `LastName` VARCHAR(100) character set utf8 NOT NULL default '',
  `EMail` VARCHAR(100) character set utf8 NOT NULL default '',
  `Username` VARCHAR(100) character set utf8 NOT NULL default '',
  `Password` VARCHAR(100) character set utf8 NOT NULL default '',
  `CreationTimestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
  `ModificationTimestamp` timestamp NOT NULL default '0000-00-00 00:00:00',
  PRIMARY KEY (`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

...

CREATE TABLE IF NOT EXISTS `cmp_application2user` (
  `CMPID` TINYINT(5) NOT NULL auto_increment,
  `ApplicationID` TINYINT(5) NOT NULL default '0',
  `UserID` TINYINT(5) NOT NULL default '0',
  PRIMARY KEY  (`CMPID`),
  KEY `JOININDEX` (`ApplicationID`,`UserID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

CREATE TABLE IF NOT EXISTS `cmp_application2role` (
  `CMPID` TINYINT(5) NOT NULL auto_increment,
  `ApplicationID` TINYINT(5) NOT NULL default '0',
  `RoleID` TINYINT(5) NOT NULL default '0',
  PRIMARY KEY  (`CMPID`),
  KEY `JOININDEX` (`ApplicationID`,`RoleID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
</gen:highlight>
In phpMyAdmin sollte ungef&auml;hr folgende Ansicht erscheinen:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/ormapper_phpmyadmin.png" alt="PHPMyadmin-Ansicht"/>
<br />
Damit ist die Konfiguration des Mappers abgeschlossen und dieser kann in der Anwendung verwendet
werden. &Auml;nderungen am Datenmodell k&ouml;nnen (noch) nicht automatisiert abgeglichen werden.
Hierzu m&uuml;ssen die Tabellen manuell angepasst werden. Da das Tabellendesign einigen wenigen
Grundregeln folgt, ist dieses jedoch einfach zu bewerkstelligen. Hilfestellungen k&ouml;nnen dem
Kapitel
<a href="./?Seite=064-Generischer-OR-Mapper-Manuelles-Setup-der-Datenbank" title="Generischer O/R-Mapper - Manuelles Setup der Datenbank">Manuelles Setup der Datenbank</a>
entnommen werden.
<div class="hint">
   F&uuml;r das Update einer mit dem Setup-Tool konfigurierten Datenbank steht seit dem Release 1.11
   ein Update-Tool zur Verf&uuml;gung. Die Bedienung ist unter <int:link pageid="128" /> beschrieben.
</div>
<h3 id="Chapter-4-Verwendung"><a href="#Chapter-4-Verwendung">4. Verwendung des O/R-Mappers</a></h3>
Der O/R-Mapper, oder genauer die Komponente <strong>GenericORRelationMapper</strong>, bietet eine Reihe
von API-Methoden an, die zur Manipulation von Daten und Beziehungen eingesetzt werden k&ouml;nnen.
Hier ein &Uuml;berblick &uuml;ber die Methoden, deren Parameter und Bedeutung:
<ul>
  <li>
    <strong>loadObjectListByCriterion()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines Kriterien-Objekts.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByCriterion()</strong>:
    L&auml;d ein Objekt an Hand eines Kriterien-Objekts.
    <br />
    <br />
  </li>
  <li>
     <strong>loadRelatedObjects()</strong>:
     L&auml;d eine Liste von Objekten, die mit diesem &uuml;ber eine definierte Beziehung
     verkn&uuml;pft sind.
     <br />
     <br />
  </li>
  <li>
     <strong>loadNotRelatedObjects()</strong>:
     L&auml;d eine Liste von Objekten, die mit diesem &uuml;ber nicht &uuml;ber eine definierte
     Beziehung verkn&uuml;pft sind.
     <br />
     <br />
  </li>
  <li>
     <strong>loadRelationMultiplicity()</strong>:
     L&auml;d die Anzahl der zu einem Objekt verk&uuml;pften Objekte unter Angabe der Beziehungskennung.
     <br />
     <br />
  </li>
  <li>
     <strong>saveObject()</strong>:
     Speichert ein Objekt oder einen Objektbaum, der aus in Beziehung stehenden Domain-Objekten
     besteht.
     <br />
     <br />
  </li>
  <li>
     <strong>deleteObject()</strong>:
     L&ouml;scht ein Objekt. Dabei werden bestehende Assoziationen und Kompositionen aufgel&ouml;st.
     <br />
     <br />
  </li>
  <li>
    <strong>createAssociation()</strong>:
    Erzeugt eine Assoziation zwischen zwei Objekten.
    <br />
    <br />
  </li>
  <li>
    <strong>deleteAssociation()</strong>:
    L&ouml;scht die Assoziation zwischen zwei Objekten.
    <br />
    <br />
  </li>
  <li>
    <strong>isAssociated()</strong>:
    Pr&uuml;ft, ob eine Assoziation zwischen zwei Objekten besteht.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectListByStatement()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectListByTextStatement()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines &uuml;bergebenen SQL-Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectListByIDs()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines &uuml;bergebenen Arrays.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByStatement()</strong>:
    L&auml;d ein Objekt an Hand eines Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByTextStatement()</strong>:
    L&auml;d eine Liste von Objekten an Hand eines &uuml;bergebenen SQL-Statements.
    <br />
    <br />
  </li>
  <li>
    <strong>loadObjectByID()</strong>:
    L&auml;d ein Objekt an Hand einer &uuml;bergebenen ID.
    <br />
    <br />
  </li>
</ul>
Die <strong>*Statement*</strong>-Methoden werden aus Performance-Gr&uuml;nden angeboten (siehe
Kapitel
<a href="./?Seite=065-Generischer-OR-Mapper-Performance-Hacks" title="Generischer O/R-Mapper - Performance-Hacks">Performance-Hacks</a>).
Datails zu Argumenten und R&uuml;ckgabewerten k&ouml;nnen der
<a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation der Module</a>
entnommen werden, im Folgenden finden die wichtigsten Methoden jedoch Verwendung.
<br />
<br />
<br />
<h4 id="Chapter-4-1-Erzeugen-einer-Instanz"><a href="#Chapter-4-1-Erzeugen-einer-Instanz">4.1. Erzeugen einer Instanz</a></h4>
Die Instanz eines O/R-Mappers muss &uuml;ber die zugeh&ouml;rige Factory (<strong>GenericORMapperFactory</strong>)
erzeugt werden. Dies ist zum einen deshalb notwendig, um den konkreten O/R-Mapper vor der Verwendung
zu initialisieren und zum anderen, damit mehrere O/R-Mapper innerhalb einer Applikation verwendet
werden k&ouml;nnen. Letzteres ist in einfachen Anwendungen sicher nicht notwenig, in komplexeren
Konstrukten ist dies jedoch eine notwendige Anforderung.
<br />
<br />
Die folgende Codebox zeigt einen typischen Aufruf eines O/R-Mappers:
<gen:highlight type="php">
// Inkludieren der Factory
import('modules::genericormapper::data','GenericORMapperFactory');

// Factory erstellen
$ORMFactory = $this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper von der Factory beziehen
$ORM = &$ORMFactory->getGenericORMapper(
                                        {CONFIG_NAMESPACE},
                                        {CONFIG_NAME_AFFIX},
                                        {CONNECTION_NAME},
                                        {SERVICE_OBJECT_TYPE}[,
                                        $logStatements = false]
                                       );
</gen:highlight>
Die Platzhalter haben dabei folgende Bedeutung:
<ul>
  <li>
    <strong>{CONFIG_NAMESPACE}</strong>: Namespace, unter dem die Konfigurationsdateien f&uuml;r den
    O/R-Mapper liegen (siehe Kapitel 2.2).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONFIG_NAME_AFFIX}</strong>: Namenszusatz der Konfigurationsdateien (siehe Kapitel 2.1).
    <br />
    <br />
  </li>
  <li>
    <strong>{CONNECTION_NAME}</strong>: Name der Datenbankverbindung, die f&uuml;r das Setup und die
    produktive Verwendung genutzt werden soll.
    <br />
    <br />
  </li>
  <li>
    <strong>{SERVICE_OBJECT_TYPE}</strong>: Art der Instanziierung des Mappers. G&uuml;ltige Werte
    sind "SINGLETON" und "SESSIONSINGLETON", Standard ist "SINGLETON". Details k&ouml;nnen dem Kapitel
    <a href="./?Seite=033-Konfiguration#Chapter-3-Serviceobjekte" title="Service objects">Service-Objekte</a>
    entnommen werden.
    <br />
    <br />
  </li>
</ul>
Wichtig ist dabei weiterhin, dass die Factory mit der Methode <strong>__getServiceObject()</strong>
erzeugt wird, da es sonst zu unerw&uuml;nschten Seiteneffekten hinsichtlich Konfiguration der Mapper
kommen kann.
<br />
<br />
<div class="hint">
Um Statement-Logging f&uuml;r Debug-Zwecke zu aktivieren, muss der optionale Parameter
<em>$logStatements</em> mit dem Wert <em>true</em> belegt werden. Diese Option sollte im Live-Betrieb
jedoch nicht verwendet werden! Details zum Parameter k&ouml;nnen der
<a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
entnommen werden.
</div>
<br />
<br />
<h4 id="Chapter-4-2-Laden-von-Daten"><a href="#Chapter-4-2-Laden-von-Daten">4.2. Laden von Daten</a></h4>
Um die Beschreibung der Features plastischer gestalten zu k&ouml;nnen, soll folgendes UML als Basis
f&uuml;r Beispiele dienen. Das Diagramm enth&auml;lt die Definition der Business-Objekte des
<a href="./?Seite=095-Module-Usermanagement" title="Module-Usermanagement">Usermanagement</a>-Moduls.
Die im Kapitel 4.2. verwendeten Code-Beispiele sind dabei dem genannten Modul entnommen.
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/usermanagement_domain_model.png" />
<br />
<br />
<h5 id="Chapter-4-2-1-Laden-von-Objekten"><a href="#Chapter-4-2-1-Laden-von-Objekten">4.2.1. Laden von Objekten</a></h5>
F&uuml;r das Laden von Objekten stehen die Methoden
<ul>
  <li><strong>loadObjectByCriterion()</strong></li>
  <li><strong>loadObjectByTextStatement()</strong></li>
  <li><strong>loadObjectByStatement()</strong></li>
  <li><strong>loadObjectByID()</strong></li>
</ul>
zur Verf&uuml;gung. M&ouml;chte der Entwickler auf einer Seite die Details eines Benutzers (siehe
UML-Diagramm) darstellen, so k&ouml;nnen die aufgef&uuml;hrten Methoden wie in der anschlie&szlig;end
dargestellten Codebox beschreiben eingesetzt werden:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer laden (1)
$Crit = new GenericCriterionObject();
$Crit->addPropertyIndicator('UserID',1);
$User = $ORM->loadObjectByCriterion('User',$Crit);

// Benutzer laden (2)
$select = 'SELECT * FROM ent_user WHERE UserID = \'1\';';
$User = $ORM->loadObjectByTextStatement('User',$select);

// Benutzer laden (3)
$User = $ORM->loadObjectByStatement('User','modules::usermanagement','load_user_by_id');

// Benutzer laden (4)
$User = $ORM->loadObjectByID('User',1);
</gen:highlight>
Der Inhalt der Statement-Datei <strong>load_user_by_id</strong> ist dabei
<gen:highlight type="sql">SELECT * FROM ent_user WHERE UserID = '1';</gen:highlight>
Details zur Ausf&uuml;hrung von Statement-Dateien k&ouml;nnen dem Kapitel
<a href="./?Seite=018-KlassenReferenz-MySQLHandler" title="KlassenReferenz-MySQLHandler">KlassenReferenz-MySQLHandler</a>
entnommen werden.
<br />
<br />
<br />
<h5 id="Chapter-4-2-2-Laden-von-Listen"><a href="#Chapter-4-2-2-Laden-von-Listen">4.2.2. Laden von Objekt-Listen</a></h5>
F&uuml;r das Laden von Objekt-Listen stehen die Methoden
<ul>
  <li><strong>loadObjectListByCriterion()</strong></li>
  <li><strong>loadObjectListByTextStatement()</strong></li>
  <li><strong>loadObjectListByStatement()</strong></li>
  <li><strong>loadObjectListByIDs()</strong></li>
</ul>
zur Verf&uuml;gung. M&ouml;chte der Entwickler auf einer Seite eine Liste von Benutzern (siehe
UML-Diagramm) darstellen, so k&ouml;nnen die aufgef&uuml;hrten Methoden wie in der anschlie&szlig;end
dargestellten Codebox beschreiben eingesetzt werden:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer-Liste laden (1)
$Crit = new GenericCriterionObject();
$Crit->addPropertyIndicator('DisplayName','a%');
$UserList = $ORM->loadObjectListByCriterion('User',$Crit);

// Benutzer-Liste laden (2)
$select = 'SELECT * FROM ent_user WHERE DisplayName LIKE \'a%\';';
$UserList = $ORM->loadObjectListByTextStatement('User',$select);

// Benutzer-Liste laden (3)
$UserList = $ORM->loadObjectListByStatement('User','modules::usermanagement','load_user_list');

// Benutzer-Liste laden (4)
$UserList = $ORM->loadObjectListByIDs('User',array(1,2,3,4,5,6));
</gen:highlight>
Der Inhalt der Statement-Datei <strong>load_user_list</strong> ist dabei
<gen:highlight type="sql">SELECT * FROM ent_user WHERE DisplayName LIKE 'a%';</gen:highlight>
<br />
<h5 id="Chapter-4-2-3-Nachladen-von-Beziehungsobjekten"><a href="#Chapter-4-2-3-Nachladen-von-Beziehungsobjekten">4.2.3. Nachladen von Beziehungsobjektlisten</a></h5>
Besteht die Notwendigkeit, bei der Auflistung der Benutzer, deren zugeordnete Gruppen mit
aufzuf&uuml;hren, k&ouml;nnen die Gruppen an Hand der Beziehung nachgeladen werden. F&uuml;r das
Nachladen von zu einem Objekt in Beziehung stehenden Objekten kann die Methode
<ul>
  <li><strong>loadRelatedObjects()</strong></li>
</ul>
eingesetzt werden. Das folgende Beispiel zeigt, wie die einem Benutzer zugeordneten Gruppen
geladen werden k&ouml;nnen:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer-Liste laden
$Crit = new GenericCriterionObject();
$Crit->addOrderIndicator('DisplayName','ASC');
$UserList = $ORM->loadObjectListByCriterion('User',$Crit);

// Ausgeben der Liste inkl. Gruppen des Benutzers
for($i = 0; $i < count($UserList); $i++){

   // Name des Benutzers ausgeben
   echo '<br />'.$UserList[$i]->getProperty('DisplayName');

   // Gruppen nachladen
   $GroupList = $ORM->loadRelatedObjects($UserList[$i],'Group2User');

   // Gruppen ausgeben
   echo ' ,Gruppen: ';
   for($j = 0; $j < count($GroupList); $j++){
      echo $GroupList[$j]->getProperty('DisplayName').' ';
   }

   // Neue Zeile ausgeben
   echo '<br />';

}
</gen:highlight>
Zur Vereinfachung des Nachladens besitzt auch das Objekt <strong>GenericDomainObject</strong> die
Methode <strong>loadRelatedObjects()</strong>. Damit ist es m&ouml;glich in der Pr&auml;sentationsschicht,
und &uuml;berall dort, wo keine Instanz des Mappers zur Verf&uuml;gung steht, in Beziehung stehende
Objekte nachzuladen. Im obigen Beispiel k&ouml;nnen die einem Benutzer zugeordneten Gruppen damit auch
per
<gen:highlight type="php">
$GroupList = $UserList[$i]->loadRelatedObjects('Group2User');
</gen:highlight>
geladen werden.
<br />
<br />
<strong>Hinweis:</strong> Die Menge der nachgeladenen Daten kann auch hier mit einem
<strong>GenericCriterionObject</strong> eingeschr&auml;nkt werden. Die im Beispiel genannte
Gruppen-Liste kann wie folgt limitiert werden:
<gen:highlight type="php">
// Definieren der Limitierungsindikatoren
$Crit = new GenericCriterionObject();
$Crit->addOrderIndicator('DisplayName','ASC');
$Crit->addPropertyIndicator('DisplayName','A%');
$Crit->addCountIndicator(10);

// Laden der Liste ueber das Dom&auml;nen-Objekt selbst
$GroupList = $UserList[$i]->loadRelatedObjects('Group2User',$Crit);

// Laden der Liste direkt ueber den O/R-Mapper
$GroupList = $ORM->loadRelatedObjects($UserList[$i],'Group2User',$Crit);
</gen:highlight>
<br />
<h5 id="Chapter-4-2-4-Nachladen-von-Nichtbeziehungsobjekten"><a href="#Chapter-4-2-4-Nachladen-von-Nichtbeziehungsobjekten">4.2.4. Nachladen von "Nichtbeziehungsobjekten"</a></h5>
Oft besteht die Notwendigkeit, Objekte zu selektieren, die zu einem bestimmten Objekt (noch) nicht
in Beziehung stehen, f&uuml;r die jedoch eine Beziehung definiert ist. Ein konkreter Anwendungsfall
bezogen auf das oben gezeigte UML-Diagramm ist die Selektion aller Gruppen, zu denen ein Benutzer
noch keine Assoziation hat um diesen zur Gruppe hinzuf&uuml;gen zu k&ouml;nnen. Zu diesem Zweck
kann die Methode
<ul>
  <li><strong>loadNotRelatedObjects()</strong></li>
</ul>
eingesetzt werden. Das folgende Beispiel zeigt, wie alle Gruppen selektiert werden k&ouml;nnen, zu
denen der genannte Benutzer noch keine Beziehung besitzt:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer selektieren
$Crit = new GenericCriterionObject();
$Crit->addpropertyIndicator('DisplayName','Mustermann, Max');
$User = $ORM->loadObjectByCriterion('User',$Crit);

// Selektieren der nicht assoziierten Gruppen
$GroupList = $ORM->loadNotRelatedObjects($User,'Group2User');

// Ausgeben der Liste der noch nicht assoziierten Gruppen
for($i = 0; $i < count($GroupList); $i++){
   echo '<br />'.$GroupList[$i]->getProperty('DisplayName');
}
</gen:highlight>
<strong>Hinweis:</strong> Auch hier kann die Menge der nachgeladenen Objekte mit Hilfe des
<strong>GenericCriterionObject</strong> eingeschr&auml;nkt werden. H&auml;ufiger Anwendungsfall ist
hier die Einschr&auml;nkung &uuml;ber weitere Beziehungen der gew&uuml;nschten Objekte zu anderen.
Im folgenden Beispiel sollen nur diejenigen Gruppen selektiert werden, zu denen der gew&uuml;hlte
Benutzer noch keine Beziehung besitzt, die jedoch unterhalb eines definierten
<em>Application</em>-Objekts komponiert sind:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer selektieren
$Crit = new GenericCriterionObject();
$Crit->addpropertyIndicator('DisplayName','Mustermann, Max');
$User = $ORM->loadObjectByCriterion('User',$Crit);

// Additived Beziehungskriterium definieren
$Crit = new GenericCriterionObject();
$App = new GenericDomainObject('Application');
$App->setProperty('ApplicationID',1);
$Crit->addRelationIndicator('Application2Group',$App);

// Selektieren der nicht assoziierten Gruppen
$GroupList = $ORM->loadNotRelatedObjects($User,'Group2User',$Crit);

// Ausgeben der Liste der noch nicht assoziierten Gruppen
for($i = 0; $i < count($GroupList); $i++){
   echo '<br />'.$GroupList[$i]->getProperty('DisplayName');
}
</gen:highlight>
<br />
<h4 id="Chapter-4-2-5-Laden-der-Beziehungsmultiplizitaet"><a href="#Chapter-4-2-5-Laden-der-Beziehungsmultiplizitaet">4.2.5 Laden der Beziehungsmultiplizit&auml;t</a></h4>
Um herauszufinden, wie viele Objekte in Beziehung zu einem anderen gesetzt wurden, steht dem
Entwickler die Methode
<ul>
  <li><strong>loadRelationMultiplicity()</strong></li>
</ul>
zur Verf&uuml;gung. Diese gibt die erfragte Anzahl an Hand eines Objekts und eines
Beziehungsschl&uuml;ssels zur&uuml;ck. Soll die Anzahl der Benutzer einer Gruppe abgefragt werden,
so kann dies mit folgendem Code bewerkstelligt werden:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Gruppe selektieren
$Group = $ORM->loadObjectByID('Group',1);

// Selektieren und Ausgeben der Anzahl der Benutzer einer Gruppe
echo $ORM->loadRelationMultiplicity($Group,'Group2User');
</gen:highlight>
<br />
<h4 id="Chapter-4-3-Speichern-von-Objekten"><a href="#Chapter-4-3-Speichern-von-Objekten">4.3. Speichern von Objekten</a></h4>
F&uuml;r das Speichern von Objekten steht die Methode
<ul>
  <li><strong>saveObject()</strong></li>
</ul>
zur Verf&uuml;gung. Um einen Benutzer in der Datenbank zu speichern ist folgender Code notwendig:
<gen:highlight type="php">
// Fabric instanziieren
$ormf = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$orm = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Benutzer befuellen
$user = new GenericDomainObject('User');
$user->setProperty('FirstName','Christian');
$user->setProperty('LastName','Achatz');

// Benutzer speichern
$orm->saveObject($user);
</gen:highlight>
<div class="hint">
   Ab dem Release 1.11 kann das Objekt (in diesem Fall <em>$user</em>) direkt weiter verwendet werden.
   Der Mapper injiziert diesem bereits die aktuelle Mapper-Instanz und die ID des Objektes in der
   Datenbank. Details zum Feature-Request k&ouml;nnen dem Foren-Eintrag
   <a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=10&t=154" title="Erweiterung GORM (Release 1.11)" linkrewrite="false">Erweiterung GORM (Release 1.11)</a>
   entnommen werden.
</div>

<h4 id="Chapter-4-4-Speichern-von-Objektbaeumen"><a href="#Chapter-4-4-Speichern-von-Objektbaeumen">4.4. Speichern von Objekt-B&auml;umen</a></h4>
Wie bereits in der Einleitung angemerkt, kann der O/R-Mapper nicht nur einzelne Objekte, sondern auch
Objektb&auml;ume speichern. Dieses Feature kann in der Datenschicht der Applikation insbesondere dazu
genutzt werden, um f&uuml;r die Applikation notwendige Beziehungen aufzubauen.
<br />
<br />
<strong>Aufgabenstellung:</strong> Beim Erstellen eines Benutzers, soll dieser unterhalb einer Applikation
komponiert werden. Diese Komposition kann sp&auml;ter dazu genutzt werden um das Usermanagement
mandantenf&auml;hig zu gestalten.
<br />
<br />
<strong>Umsetzung:</strong> Um eine Beziehung zwischen einem <em>Application</em>- und einem
<em>User</em>-Objekt herzustellen und diese Beziehung auch zu speichern, kann die Methode
<strong>addRelatedObject()</strong> der Klasse <strong>GenericDomainObject</strong> verwendet werden.
Die folgende Codebox zeigt die Implementierung:
<gen:highlight type="php">
// Fabric instanziieren
$ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Applikation laden
$App = $ORM->loadObjectByID('Application',1);

// Benutzer befuellen
$User = new GenericDomainObject('User');
$User->setProperty('FirstName','Christian');
$User->setProperty('LastName','Achatz');

// Beziehung herstellen
$App->addRelatedObject('Application2User',$User);

// Objektbaum speichern
$ORM->saveObject($App);
</gen:highlight>
M&ouml;chte der Entwickler im gleichen Zug dem Benutzer noch eine Gruppe und eine Rolle zuordnen,
muss der oben gezeigte Quellcode zwischen dem Bef&uuml;llen des Benutzer-Objekts und der Herstellung
der Beziehung zum Application-Objekt entsprechend erweitert werden:
<gen:highlight type="php">
...

// Applikation laden
$App = $ORM->loadObjectByID('Application',1);

// Benutzer befuellen
$User = new GenericDomainObject('User');
$User->setProperty('FirstName','Christian');
$User->setProperty('LastName','Achatz');

// Gruppe laden
$Group = $ORM->loadObjectByID('Group',1);

// Rolle laden
$Role = $ORM->loadObjectByID('Role',1);

// Gruppe und Rolle zuweisen
$User->addRelatedObject('Group2User',$Group);
$User->addRelatedObject('Role2User',$Role);

// Beziehung herstellen
$App->addRelatedObject('Application2User',$User);

// Objektbaum speichern
$ORM->saveObject($App);
</gen:highlight>
<br />
<h3 id="Chapter-5-GenericCriterionObject"><a href="#Chapter-5-GenericCriterionObject">5. &Uuml;bersicht zum <em>GenericCriterionObject</em></a></h3>
Das vorliegende Kapitel m&ouml;chte einen zusammenfassenden &Uuml;berblick &uuml;ber die Nutzung des
<strong>GenericCriterionObject</strong> geben. Wie in den vorherigen Kapiteln angedeutet, kann das
Kriterium-Objekt dazu genutzt werden, Abfragen ohne Schreiben von SQL-Statements f&uuml;r den
Anwendungsfall zu konfigurieren. Das Objekt kann bei den <strong>load*ByCriterion()</strong>-Methoden
und beim Nachladen von in Beziehung stehenden Objekten und Objektlisten genutzt werden.
<br />
<br />
Die folgende Code-Box zeigt einen &Uuml;berblick &uuml;ber die Einsatzm&ouml;glichkeiten des
<strong>GenericCriterionObject</strong>s am Beispiel einer Benutzer-Liste, deren Benutzer zu einer
Applikation geh&ouml;ren und eine definierte Gruppe zugeordnet haben:
<gen:highlight type="php">
class usermanagementManager extends APFObject {

   ...

   function getUserList(){

      // Fabric instanziieren
      $ORMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

      // Mapper mit Basis-Konfiguration laden
      $ORM = &$ORMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

      // Erzeugen des Kriterien-Objekts
      $Crit = new GenericCriterionObject();

      // Hinzufuegen einer Beziehung zum Objekt "Application" (Komposition)
      $Application = new GenericDomainObject('Application');
      $Application->setProperty('ApplicationID',1);
      $Crit->addRelationIndicator('Application2User',$Application);

      // Hinzufuegen einer Beziehung zum Objekt "Group" (Assoziation)
      $Group = new GenericDomainObject('Group');
      $Group->setProperty('GroupID',1);
      $Crit->addRelationIndicator('Group2User',$Group);

      // Hinzufuegen einer Begrenzung der Anzahl mit definiertem Startpunkt
      $Crit->addCountIndicator(0,3);

      // Hinzufuegen einer Bedingung auf Ebene der Eigenschaften des zu ladenden Objekts
      $Crit->addPropertyIndicator('LastName','Achatz');

      // Hinzufuegen einer Sortierreihenfolge
      $Crit->addOrderIndicator('FirstName','ASC');
      $Crit->addOrderIndicator('LastName','DESC');

      // Definition der zu ladenden Attribute eines Objekts
      $Crit->addLoadedProperty('FirstName');
      $Crit->addLoadedProperty('LastName');

      // Laden einer Objektliste mit Hilfe des Kriterium-Objekts
      return $ORM->loadObjectListByCriterion('User',$Crit);

      // Laden eines Objekts mit Hilfe des Kriterium-Objekts
      return $ORM->loadObjectByCriterion('User',$Crit);

   }

   ...

}
</gen:highlight>
<strong>Hinweise zum Quelltext:</strong>
<ul>
  <li>
    <strong>Beziehungen</strong>:
    <br />
    Das Hinzuf&uuml;gen von Beziehungen zum Kriterien-Objekt beschreiben, dass das zu ladende Objekt
    oder jedes Objekt der zu ladenden Liste in Beziehung zum Objekt des Kriteriums stehen muss. Wird
    wie im Beispiel eine Beziehung zum Objekt <em>Application</em> (Komposition) und zum Objekt
    <em>Group</em> (Assoziation) aufgebaut, ist das Ergebnis eine Liste von Objekten innerhalb einer
    Applikation, die in einer bestimmten Gruppe sind.
    <br />
    M&ouml;chte der Entwickler alle Benutzer selektieren, die in einer Applikation enthalten sind,
    einer definierten Gruppe angeh&ouml;ren und eine bestimmte Rolle zugewiesen haben, m&uuml;ssen
    drei Beziehungen gem&auml;&szlig; der Beziehungskonfiguration zum Kriterium hinzugef&uuml;gt
    werden.
    <br />
    <br />
  </li>
  <li>
     <strong>Sortierreihenfolge</strong>:
     <br />
     Die Reihenfolge der Aufrufe entscheidet die Sortierung. Soll die Sortierung in einer anderen
     Reihenfolge vorgenommen werden, m&uuml;ssen die Sortierkriterien in der entsprechend anderen
     Abfolge hinzugef&uuml;gt werden. Der Wert <strong>ASC</strong> steht f&uuml;r aufsteigende
     Sortierung, <strong>DESC</strong> f&uuml;r absteigende.
     <br />
     <br />
  </li>
</ul>
<h3 id="Chapter-6-Erweiterung-Mapping-und-Relation-Table"><a href="#Chapter-6-Erweiterung-Mapping-und-Relation-Table">6. Erweiterung des Mapping- und Relation-Table</a></h3>
Wenn der <em>GenericORRelationMapper</em> &uuml;ber mehrere Anwendungen und mehrere Anwendungsf&auml;lle
hinweg eingesetzt wird, ergibt sich die Schwierigkeit, dass unterschiedliche Applikationen unterschiedliche
Bereiche der vom O/R-Mapper verwalteten Datenbank nutzen. Hierzu kann entweder f&uuml;r den entsprechenden
Anwendungsfall jeweils eine passende Konfiguration angelegt werden oder der Entwickler definiert
eine f&uuml;r alle verwendbare Basis-Konfiguration (z.B. alle Objekte des Moduls <em>usermanagement</em>)
und nutzt die Methoden
<ul>
  <li><strong>addMappingConfiguration()</strong></li>
  <li><strong>addRelationConfiguration()</strong></li>
</ul>
um die allgemeing&uuml;ltige Konfiguration f&uuml;r den aktuellen Anwendungsfall zu erweitern. Mit
den genannten Funktionen k&ouml;nnen beliebige weitere Objektdefinitions- und Beziehungs-Konfigurationen
hinzugeladen werden. Das folgende Beispiel zeigt, wie die aufgef&uuml;hrten Methoden genutzt werden
k&ouml;nnen um den Wirkungsbereich des Mappers zu erweitern:
<gen:highlight type="php">
// Fabric instanziieren
$oRMF = &$this->__getServiceObject('modules::genericormapper::data','GenericORMapperFactory');

// Mapper mit Basis-Konfiguration laden
$oRM = &$oRMF->getGenericORMapper('modules::usermanagement','umgt_1','umgt');

// Zusaetzliche Objekt-Definitionen hinzuladen
$oRM->addMappingConfiguration('modules::usermanagement','umgt_2');

// Zusaetzliche Beziehungs-Definitionen hinzuladen
$oRM->addRelationConfiguration('modules::usermanagement','umgt_2');
</gen:highlight>
Die Syntax der Objektdefinitions- und Beziehungs-Konfigurationen ist dabei identisch zu den
Standard-Konfiguration, wie sie im Kapitel
<a href="#2-3-Objekt-und-Beziehungsdefinition" title="2.3. Objekt- und-Beziehungsdefinition">2.3. Objekt- und-Beziehungsdefinition</a>
diskutiert wurden. Die zus&auml;tzliche Objekt-Definition beinhaltete dabei die folgenden Objekte:
<gen:highlight type="ini">
[Project]
DisplayName = "VARCHAR(100)"
Description = "TEXT"

[News]
DisplayName = "VARCHAR(100)"
Title = "VARCHAR(100)"
Content = "TEXT"
</gen:highlight>
und die neu hinzugekommenen Beziehungen waren
<gen:highlight type="ini">
[Application2Project]
Type = "COMPOSITION"
SourceObject = "Application"
TargetObject = "Project"

[Project2News]
Type = "COMPOSITION"
SourceObject = "Project"
TargetObject = "News"
</gen:highlight>
<br />
<h3 id="Chapter-7-Anmerkungen"><a href="#Chapter-7-Anmerkungen">7. Anmerkungen</a></h3>
Hinweise zur Performance k&ouml;nnen unter
<a href="./?Seite=065-Generischer-OR-Mapper-Performance-Hacks" title="Generischer O/R-Mapper - Performance-Hacks">Performance-Hacks</a>
nachgelesen werden, das manuelle Setup der Datenbank ist unter
<a href="./?Seite=064-Generischer-OR-Mapper-Manuelles-Setup-der-Datenbank" title="Generischer O/R-Mapper - Manuelles Setup der Datenbank">Manuelles Setup der Datenbank</a>
erkl&auml;rt. Die Quellcode-Dateien des
<a href="./?Seite=095-Module-Usermanagement" title="Usermanagement-Modul">usermanagement-Moduls</a>
k&ouml;nnen als weiterf&uuml;hrende Beispiele herangezogen werden.
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_063" />