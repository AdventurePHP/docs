<doku:title parent="119" tags="service,object,dependency,injection,di,framework,factory,service manager,manager,business services" title="Services" urlname="Services">
   The present chapter describes the object creation mechanisms contained in the framework. In particular, it details
   the dependency injection container that brings the ability to easily provide pre-configured objects.
</doku:title>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   Encapsulation of certain functionality into separate components is a well-known pattern in object oriented development.
   The advantages are described as <em>Multi-tier Architecture Pattern</em>. This means that each layer takes responsibility
   of dedicated parts of the application.
</p>
<p>
   Typically, <em>layers</em> or <em>services</em> are represented by one ore more classes what drives the need to create
   those classes. Moreover, it's your challenge to design and create reusable layers - <em>services</em> - that expose an
   easy-to-use and self-explantory API. An application's  data layer for instance requires a connection to an external
   data source whereas a business component has to know about the environment the application is used. In addition,
   layers define dependencies amongst each other.
</p>
<p>
   In order to ensure proper encapsulation and thus exchangeability of layers within an application an upper layer should
   not know about the internal structure and functionality of low layer components. To achieve this creation methods and
   configuration should be separated from the calling layer.
</p>
<p>
   The following chapters explain mechanisms and tools for <int:link pageid="030" /> that allow encapsulation of
   functionality and creating clear structures within your application.
</p>

<h3 id="Chapter-2-Creation-of-objects"><a href="#Chapter-2-Creation-of-objects">2. Creation of objects</a></h3>
<p>
   The Adventure PHP Framework uses different paradigms to create objects within the <int:link pageid="012" /> and
   <int:link pageid="098" />. Especially <em>Front-Controller-Actions</em> and <em>Tags</em> containing UI
   functionality have to be provided with their runtime environment. This is about injecting the parent component and
   applying the current <em>context</em> and <em>language</em> in order to access <int:link pageid="134" /> depending on
   those values. Therefor, the APF uses both <em>Factory pattern</em> and <em>Dependency Injection Pattern</em>.
</p>
<div class="hint">
   Creating objects APF components hand on
   <ul>
      <li>Context and</li>
      <li>Language</li>
   </ul>
   These are essential information that are applied to each and every object to for instance load
   <int:link pageid="134" /> items or realize language-dependent functionality (e.g.
   <int:link pageid="046" anchor="Chapter-2-2-Getstring" />).
</div>
<p>
   The framework lays it's clear focus on creating UI along with mechanisms and functionality required for that. This
   means, that you as a developer are responsible for creating objects outside of the UI area. For this reason, the APF
   contains two tools to support this at best: <a href="#Chapter-3-ServiceManager">ServiceManager</a> and the
   <a href="#Chapter-4-DIServiceManager">DIServiceManager</a>.
</p>
<div class="warn">
   Please ensure that all objects having access to configurations or create further objects that make use of the current
   context or language of your application are created by either <em>ServiceManager</em> or <em>DIServiceManager</em>.
   Otherwise, there will be errors loading configurations or create context- or language-dependent objects.
</div>
<div class="hint">
   <p>
      For the benefit of a generic facility to create any kind of class as <em>Singleton</em>, <em>SessionSingleton</em>,
      or <em>ApplicationSingleton</em> the APF does not support constructor arguments. Initialization is only done using
      <em>method injection</em> or <em>setter injection</em> respectively. Dependencies in terms of configuration and
      other services are thus applied after construction of the respective object.
   </p>
   <p>
      <a href="#Chapter-4-3-1-Configuration-scheme">Chapter 4.3.1</a> depicts mechanisms to do further initialization
      (see: <em>setupmethod</em>).
   </p>
</div>

<h3 id="Chapter-3-ServiceManager"><a href="#Chapter-3-ServiceManager">3. ServiceManager</a></h3>
<p>
   The <em>ServiceManager</em> is an extension to the existing <em>Singleton</em>-, <em>SessionSingleton</em>-, and
   <em>ApplicationSingleton</em> implementations described under <int:link pageid="030" />. Compared to these implementations,
   the <em>ServiceManager</em> is better integrated into the framework and <em>APFObject</em> offers a
   <em>convenience method</em> <em>APFObject::getServiceObject()</em> that can be used to easily create objects.
</p>
<p>
   The current <em>context</em> and <em>language</em> are automatically applied to the created instance by the
   <em>ServiceManager</em> and is thus returned fully initialized.
</p>

<h4 id="Chapter-3-1-Service-definition"><a href="#Chapter-3-1-Service-definition">3.1. Service definition</a></h4>
<p>
   To create objects with the <em>ServiceManager</em> the class definition must comply with the <em>APFService</em>
   interface. This interface allows to inject context and language and is used to mark services classes.
</p>
<p>
   The interface is as follows:
</p>
<gen:highlight type="php">
interface APFService {

   const SERVICE_TYPE_NORMAL = 'NORMAL';
   const SERVICE_TYPE_CACHED = 'CACHED';
   const SERVICE_TYPE_SINGLETON = 'SINGLETON';
   const SERVICE_TYPE_SESSION_SINGLETON = 'SESSIONSINGLETON';
   const SERVICE_TYPE_APPLICATION_SINGLETON = 'APPLICATIONSINGLETON';

   public function setContext($context);

   public function getContext();

   public function setLanguage($lang);

   public function getLanguage();

   public function setServiceType($serviceType);

   public function getServiceType();

}
</gen:highlight>
<p>
   The constants listed above define the list of possible creation patterns of services. The subsequently listed
   methods allow injection of context and language.
</p>
<div class="warn">
   In case the object to create does not implement the <em>APFService</em> interface and exception is thrown.
</div>

<h4 id="Chapter-3-2-Creation-of-services"><a href="#Chapter-3-2-Creation-of-services">3.2. Creation of services</a></h4>
<p>
   Within your application you can use the <em>ServiceManager</em> either directly (see
   <a href="#Chapter-3-2-1-Native-usage">3.2.1. Native usage</a>) or via <em>APFObject::getServiceObject()</em> (she
   <a href="#Chapter-3-2-2-Using-the-wrapper">3.2.2. Using the wrapper</a>). The following chapters discuss the pros and
   cons.
</p>

<h5 id="Chapter-3-2-1-Native-usage"><a href="#Chapter-3-2-1-Native-usage">3.2.1. Native usage</a></h5>
<p>
   The <em>ServiceManager</em> can be used allover the code invoking it's static method <em>getServiceObject()</em>. Here
   is an example:
</p>
<gen:highlight type="php">
use APF\core\service\ServiceManager;
$instance = &ServiceManager::getServiceObject('VENDOR\..\Class', $context, $language);
</gen:highlight>
<p>
   As you can take from the code snippet you need to know about the context and the current language retrieving an
   object instance. In general you always have these pieces of information present within an APF-created object since the
   framework takes care to distribute all relevant information.
</p>
<p>
   In case you create objects on your own or you are out of the area of validity of an object - e.g. within your
   <em>index.php</em> - you may want to use the <int:link pageid="012" /> instance as source. Usually, the instance is
   created within your bootstrap file using setting the current context and language. The relevant code is as follows:
</p>
<gen:highlight type="php">
use APF\core\frontcontroller\Frontcontroller;
use APF\core\singleton\Singleton;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');

$context = $fC->getContext();
$language = $fC->getLanguage();

use APF\core\service\ServiceManager;
$instance = &ServiceManager::getServiceObject('VENDOR\..\Class', $context, $language);
</gen:highlight>
<div class="warn">
   Please note, that within the DOM tree of the <int:link pageid="098" /> context and language can be re-defined for
   certain child structures within the tree. For this reason and to avoid issues with propagation of context and language
   it is recommended to use the wrapper method (see
   <a href="#Chapter-3-2-2-Using-the-wrapper">chapter 3.2.2</a>).
</div>

<h5 id="Chapter-3-2-2-Using-the-wrapper"><a href="#Chapter-3-2-2-Using-the-wrapper">3.2.2. Using the wrapper</a></h5>
<p>
   <em>APFObject</em> contains the <em>getServiceObject()</em> method that encapsulates a <em>ServiceManager</em> call.
   It also takes care of applying the correct context and language. You can create objects as follows using this approach:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\APFObject;

class GodObject extends APFObject {
   public function doSomething(){
      $service =
         &$this->getServiceObject(
            $serviceName,
            [$type = APFService::SERVICE_TYPE_SINGLETON],
            [$instanceId = null]
         );
      $service->doSomethingElse();
   }
}
</gen:highlight>
<p>
   <em>APFObject::getServiceObject()</em> offers the following parameters:
</p>
<ul>
   <li>
      <strong>$serviceName</strong>:
      Defines the fully-qualified name of the service implementation (e.g. <em>VENDOR\..\MyServiceName</em>).
   </li>
   <li>
      <strong>$type</strong>:
      The <em>$type</em> parameter defines the object creation flavor and thus the area of validity of the instance.
      Available values:
      <ul>
         <li><em>APFService::SERVICE_TYPE_NORMAL</em></li>
         <li><em>APFService::SERVICE_TYPE_SINGLETON</em></li>
         <li><em>APFService::SERVICE_TYPE_SESSION_SINGLETON</em></li>
         <li><em>APFService::SERVICE_TYPE_APPLICATION_SINGLETON</em></li>
      </ul>
      This parameter is optional. Default value is <em>APFService::SERVICE_TYPE_SINGLETON</em>. Details on the listed
      areas of validity can be taken from <int:link pageid="030" />.
   </li>
   <li>
      <strong>$instanceId</strong>:
      All implementations described in chapter <int:link pageid="030" /> have the ability to define unique identifiers
      for object instances. This can be used to create several instances of the same implementation e.g. for several
      database connections based on the same implementation. This feature can also be used with the
      <em>ServiceManager</em>.
   </li>
</ul>
<div class="hint">
   To ease implementation of services you may want to derive your class from <em>APFObject</em> instead of implementing
   the <em>APFService</em> interface. <em>APFObject</em> already includes all relevant basics to start from.
</div>

<h3 id="Chapter-4-DIServiceManager"><a href="#Chapter-4-DIServiceManager">4. DIServiceManager</a></h3>
<p>
   The <em>DIServiceManager</em> is a <em>Dependency Injection</em> and <em>Inversion of Control</em> container creating
   and configuring services (see
   <a href="http://www.martinfowler.com/articles/injection.html">Inversion of Control Containers and the Dependency Injection pattern</a>
   by Martin Fowler). The definition of Services is based on configuration files (paradigm: <em>wire by configuration</em>),
   that both define the service implementation as well as dependencies and configuration parameters.
</p>
<p>
   Creating the service instanced the <em>DIServiceManager</em> uses the capabilities of the
   <a href="#Chapter-3-ServiceManager">ServiceManager</a> and thus offers applicable areas of validity for all use cases
   (details can be taken from <int:link pageid="030" />).
</p>
<p>
   Compared to the <em>ServiceManager</em> the dependency injection container offers another abstraction layer creating
   and configuring services. Using the container you do not directly refer to an implementation but a configuration. This
   eases exchanging implementations or use MOCk implementations on-demand.
</p>
<p>
   Using the container you can either use the static method <em>DIServiceManager::getServiceObject()</em> or the
   <em>convenience method</em> <em>APFObject::getDIServiceObject()</em>.
</p>
<p>
   Using <em>APFObject::getDIServiceObject()</em> the current <em>context</em> and <em>language</em> are automatically
   applied to the <em>DIServiceManager</em> and thus the created object will be fully initialized.
</p>
<p>
   Services can be prepared for usage by both other services or static configuration parameters.
</p>

<h4 id="Chapter-4-1-Service-definition"><a href="#Chapter-4-1-Service-definition">4.1. Service definition</a></h4>
<p>
   In order to create objects with the <em>DIServiceManager</em> your implementation must comply with the <em>APFDIService</em>
   interface. This interfaces is based on <em>APFService</em> and provides the necessary structure to create and manage
   instances with the dependency injection container.
</p>
<p>
   The interface is as follows:
</p>
<gen:highlight type="php">
interface APFDIService extends APFService {

   public function markAsInitialized();

   public function markAsPending();

   public function isInitialized();

}
</gen:highlight>
<p>
   All methods listed above allow the container to query the status of the instance - e.g. the initialization state.
</p>
<div class="warn">
   Due to the fact that the object creation is delegated to the <em>ServiceManager</em> it is required that your
   implementation is t least an <em>APFService</em>. Otherwise, an exception is thrown.
</div>

<h4 id="Chapter-4-2-Creation-of-services"><a href="#Chapter-4-2-Creation-of-services">4.2. Creation of services</a></h4>
<p>
   Within your application you can use the <em>DIServiceManager</em> either directly (see
   <a href="#Chapter-4-2-1-Native-usage">4.2.1. Native usage</a>) or via <em>APFObject::getDIServiceObject()</em>
   (see <a href="#Chapter-4-2-2-Usage-of-the-wrapper">4.2.2. Usage of the wrapper</a>). The following chapters describe
   the pros and cons.
</p>

<h5 id="Chapter-4-2-1-Native-usage"><a href="#Chapter-4-2-1-Native-usage">4.2.1. Native usage</a></h5>
<p>
   The <em>DIServiceManager</em> can be used allover the code invoking it's static method <em>getServiceObject()</em>.
   Here is an example:
</p>
<gen:highlight type="php">
use APF\core\service\DIServiceManager;
$instance = &DIServiceManager::getServiceObject('VENDOR\..', 'Service-Name', $context, $language);
</gen:highlight>
<p>
   The first two parameters define the <em>namespace</em> and the <em>name</em> of the service definition. This effectively
   refers a configuration section that defines the services (details see
   <a href="#Chapter-4-3-Configuration">chapter 4.3</a>. Calling this method the current context and language must be
   present. In general you always have these pieces of information present within an APF-created object since the
   framework takes care to distribute all relevant information.
</p>
<p>
   In case you create objects on your own or you are out of the area of validity of an object - e.g. within your
   <em>index.php</em> - you may want to use the <int:link pageid="012" /> instance as source. Usually, the instance is
   created within your bootstrap file using setting the current context and language. The relevant code is as follows:
</p>
<gen:highlight type="php">
use APF\core\frontcontroller\Frontcontroller;
use APF\core\singleton\Singleton;

$fC = &Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');

$context = $fC->getContext();
$language = $fC->getLanguage();

use APF\core\service\DIServiceManager;
$instance = &DIServiceManager::getServiceObject('VENDOR\..', 'Service-Name', $context, $language);
</gen:highlight>
<div class="warn">
   Please note, that within the DOM tree of the <int:link pageid="098" /> context and language can be re-defined for
   certain child structures within the tree. For this reason and to avoid issues with propagation of context and language
   it is recommended to use the wrapper method (see <a href="#Chapter-4-2-2-Usage-of-the-wrapper">chapter 4.2.2</a>).
</div>

<h5 id="Chapter-4-2-2-Usage-of-the-wrapper"><a href="#Chapter-4-2-2-Usage-of-the-wrapper">4.2.2. Usage of the wrapper</a></h5>
<p>
   <em>APFObject</em> offers the <em>getDIServiceObject()</em> method that encapsulates the <em>DIServiceManager</em>.
   It takes care to distribute the current context and language. You can create objects as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\APFObject;

class GodObject extends APFObject {
   public function doSomething(){
      $service =
         &$this->getDIServiceObject(
            $serviceNamespace
            $serviceName
         );
      $service->doSomethingElse();
   }
}
</gen:highlight>
<p>
   <em>APFObject::getDIServiceObject()</em> has the following parameters defined:
</p>
<ul>
   <li>
      <strong>$serviceNamespace</strong>:
      Defines the namespace of the service configuration (e.g. <em>VENDOR\namespace\of\my\component</em>).
   </li>
   <li>
      <strong>$serviceName</strong>:
      Defines the reference name of the service configuration within the previously defined namespace (e.g. <em>open-weather-map-service</em>).
   </li>
</ul>
<div class="hint">
   To ease implementation of services you may want to derive your class from <em>APFObject</em> instead of implementing
   the <em>APFService</em> interface. <em>APFObject</em> already includes all relevant basics to start from.
</div>

<h4 id="Chapter-4-3-Configuration"><a href="#Chapter-4-3-Configuration">4.3. Configuration</a></h4>
<p>
   Creation and configuration of services with the <em>DIServiceManager</em> significantly differs from using the
   <a href="#Chapter-3-ServiceManager">ServiceManager</a>. Each service is described by a unique configuration. This is
   because one service is not only representing itself but can also be used to initialize other services. This allows you
   to define dependencies between different service with the <em>DIServiceManager</em>.
</p>
<p>
   Definition of a single service is done using a configuration section that is addressed by the namespace of the config
   file and the name of the section itself. The <em>DIServiceManager</em> uses the configuration mechanism of the APF to
   load <int:link pageid="134" /> files.
</p>
<p>
   Using the <em>ConfigurationManager</em> offers several possibilities - e.g. define services depending on namespace,
   context, and environment. This means:
</p>
<ul>
   <li>
      Services can be grouped into logical areas using <em>namespaces</em>. This eases naming and separation within your
      application.
   </li>
   <li>
      Services can be defined or configured according to their usage scenario (<em>context</em>). This for instance
      allows you to used two different services for weather forecasts within one application based on the same
      implementation.
   </li>
   <li>
      Using the <em>environment</em> services can be tailored to different physical platforms (e.g. development, staging
      production). The same implementation can e.g. be used within a development environment where the service runs in
      debug mode or on production servers where only dedicated information is written to log files.
   </li>
</ul>
<p>
   The subsequent chapters describe the details on configuration of services.
</p>

<h5 id="Chapter-4-3-1-Configuration-scheme"><a href="#Chapter-4-3-1-Configuration-scheme">4.3.1. Configuration scheme</a></h5>
<p>
   The definition of services is described by a configuration section within a configuration file with name
   <em>{ENVIRONMENT}_serviceobjects.ini</em> as mentioned above. The value for environment must be replaced by the
   value that your application defines (default: <em>DEFAULT</em>).
</p>
<p>
   Within this kind of file each section defines a unique and independently usable service definition. The content of
   one section is defined by the following scheme:
</p>
<gen:highlight type="ini">
[{service-name}]
class = ""
servicetype = ""

[conf.{CONF_KEY}.method = ""
conf.{CONF_KEY}.value = ""]

[init.{INIT_KEY}.method = ""
init.{INIT_KEY}.namespace = ""
init.{INIT_KEY}.name = ""]

[setupmethod = ""]
</gen:highlight>
<p>
   The meaning of the listed components are described below:
</p>
<ul>
   <li>
      <strong>service-name</strong>:
      The <em>service-name</em> forms the unique identifier of a service in conjunction with the namespace of the
      configuration file. It is used for requesting a service through <em>APFObject::getDIServiceObject()</em>
      or <em>DIServiceManager::getServiceObject()</em> as well as for initializing services with other services.
   </li>
   <li>
      <strong>class</strong>:
      The fully-qualified class name of the service implementation (e.g. <em>VENDOR\..\Class</em>). The content of
      this parameter is identical to the first parameter of an <em>ServiceManager::getServiceObject()</em> call.
   </li>
   <li>
      <strong>servicetype</strong>:
      This directive defines the way of creating the service. Please take the available modes from
      <a href="#Chapter-3-2-2-Using-the-wrapper">chapter 3.2.2</a>. In addition, you may want to use
      <em>APFService::SERVICE_TYPE_CACHED</em> or <em>CACHED</em>. This value means, that the service implementation is
      created again with each request to the container (see <em>APFService::SERVICE_TYPE_NORMAL</em>) but the configuration
      file is loaded only once.
   </li>
   <li>
      <strong>conf.*</strong>:
      The <em>conf</em> area is intended to initialize the service with static configuration.
      <div class="hint">
         This kind of initialization only allows to pass primitive data types. Thus, it is recommended for values like
         user names, passwords, and URLs etc. (also called <em>simple configuration</em>).
      </div>
      Each service may define any number or attributes. This can be done by using multiple <em>conf</em> blocks choosing
      an appropriate <em>{CONF_KEY}</em> place holder.
      <div class="warn">
         Please note that the <em>{CONF_KEY}</em> place holder must be the same within one group (for attributes
         <em>method</em> and <em>value</em>) but different between various groups (combination of one <em>method</em>
         and one <em>value</em> attribute). The following code block gives you an  example for initializing a service
         with a user, a password, and a URL:
<gen:highlight type="ini">
conf.user.method = "setUser"
conf.user.value = "John"

conf.pass.method = "setPassword"
conf.pass.value = "Doe"

conf.url.method = "setUr"
conf.url.value = "https://example.com/service/v1/soap"
</gen:highlight>
      </div>
      Initializing the user key <em>user</em> has been defined. The value of the <em>conf.user.method</em> attribute
      refers to the method that is called by the <em>DIServiceManager</em> on the service implementation defined with
      the <em>class</em> attribute to apply the value of the <em>conf.user.value</em> attribute. Same applies to
      other sections
   </li>
   <li>
      <strong>init.*</strong>:
      The <em>init</em> area is intended to initialize the service with dynamic or complex configuration using other
      services.
      <div class="hint">
         Using this section you are able to use complex data structures to initialize services. This means passing
         service instances as initialization parameter to the instance to be created (<em>dependency injection</em>) and
         thus configure it for the designed use case (e.g. inject database connection to be used).
      </div>
      Each service dan be configured using any number of further services. This can be done by using multiple <em>init</em>
      blocks choosing an appropriate <em>{INIT_KEY}</em> place holder.
      <div class="warn">
         Please note that the <em>{INIT_KEY}</em> place holder must be the same within one group (for attributes
         <em>method</em>, <em>namespace</em>, and <em>name</em>) but different between various groups (combination of
         one <em>method</em>-, one <em>value</em>, and one <em>name</em> attribute). The following code block gives you
         an example for initializing a service the database connection for a weather forecast service:
<gen:highlight type="ini">
init.weather.method = "setWeatherService"
init.weather.namespace = "VENDOR\namespace\of\service\definition"
init.weather.name = "open-weather-map-service"

init.db.method = "setDatabaseConnection"
init.db.namespace = "VENDOR\namespace\of\database\connection\definition"
init.db.name = "calendar-database-connection"
</gen:highlight>
      </div>
      Initializing the weather forecast service key <em>weather</em> has been defined. The value of the
      <em>init.weather.method</em> attribute refers to the method of the implementation defined with the <em>class</em>
      attribute that the <em>DIServiceManager</em> calls to inject the service that is described by attributes
      <em>init.weather.namespace</em> and <em>init.weather.name</em>. Same applies to other sections.
   </li>
   <li>
      <strong>setupmethod</strong>:
      Optional parameter <em>setupmethod</em> allows to call a method at the end of the configuration of an object using
      the dependencies that are defined with the <em>conf.*</em> and <em>init.*</em> areas.
      <div class="hint">
         <em>setupmethod</em> can be used to further initialize the object instance using the injected information. This
         is especially helpful for initialization of a service that needs all dependencies resolved previously (e.g.
         name of the database connection).
      </div>
      <div class="warn">
         In order to avoid multiple initialization calls your service may return <em>true</em> for method
         <em>isInitialized()</em> defined within the <em>APFDIService</em> interface as soon as the inituialization is
         done. This piece of information is used by the <em>DIServiceManager</em> to skip the <em>setupmethod</em>
         call in case the service has already been initialized.
      </div>
   </li>
</ul>

<h5 id="Chapter-4-3-2-Service-definition"><a href="#Chapter-4-3-2-Service-definition">4.3.2. Service definition</a></h5>
<p>
   One single service is defined by a configuration section described in
   <a href="#Chapter-4-3-1-Configuration-scheme">chapter 4.3.1</a> and references to other sections in case of
   dependencies. The sections are defined within a configuration file can be addressed by their <em>namespace</em> and
   the name of the file - <em>{ENVIRONMENT}_serviceobjects.ini</em>.
</p>
<p>
   The name of the configuration file is fixed and cannot be changed. This allows you to omit the file name while
   requesting services and thus eases the usage of the <em>DIServiceManager</em>. Within one file, you can define
   several services as long as the name of the service - which in turn is the name of the service - is unique.
</p>
<p>
   In case you try to query a service by
</p>
<gen:highlight type="php">
use APF\core\service\DIServiceManager;

$service = DIServiceManager::getServiceObject(
   'VENDOR\namespace\of\service\definition',
   'open-weather-map-service',
   $context,
   $language
);
</gen:highlight>
<p>
   the <em>DIServiceManager</em> expects a service definition - which in turn is represented by a configuration section
   - named <em>open-weather-map-service</em> located within
</p>
<gen:highlight type="code">
/path/to/VENDOR/config/namespace/of/service/definition/{CONTEXT}/{ENVIRONMENT}_serviceobjects.ini
</gen:highlight>
<p>
   The parameter <em>/path/to/VENDOR</em> - which is the base path of the application and configuration files for vendor
   <em>VENDOR</em> - as well as <em>{CONTEXT}</em> and <em>{ENVIRONMENT}</em> directly depend on the configuration of
   your application. Details on the usage of configuration files and their schema definition can be taken from
   <int:link pageid="134" /> and <int:link pageid="154" />.
</p>
<div class="hint">
   <p>
      Using namespace of configuration files and service names addressing services contained there developers are free
      to define and structure service definitions. You can either define dependent services within the same configuration
      file as well as on other ones.
   </p>
   <p>
      This opportunity may be used to separate basic services or services that are used multiple times (e.g. database
      connections) and place them into a basic namespace whereas dedicated services are located within a deeper section
      of the namespace tree.
   </p>
</div>

<h4 id="Chapter-4-4-Usage"><a href="#Chapter-4-4-Usage">4.4. Usage</a></h4>
<p>
   The subsequent features describe different use cases and the appropriate service implementation and configuration.
</p>
<h5 id="Chapter-4-4-1-Creation-of-a-simple-service"><a href="#Chapter-4-4-1-Creation-of-a-simple-service">4.4.1. Creation of a simple service</a></h5>
<p>
   The first use case is about creating a simple service that returns a shipment date based on the order date and time.
   In order to display a possible shipment date the service should be used within a <int:link pageid="006" />.
</p>

<h6 id="Chapter-4-4-1-1-Implementation"><a href="#Chapter-4-4-1-1-Implementation">4.4.1.1. Implementation</a></h6>
<p>
   At first we are defining the structure of the service. The interface is as follows:
</p>
<gen:highlight type="php">
namespace ACME\shop\order;

interface PreliminaryShipmentDateCalculator {
   /**
    * @param \DateTime $orderDate
    * @return \DateTime
    */
   public function getShipmentDate(\DateTime $orderDate);
}
</gen:highlight>
<p>
   The implementation should now calculate a shipment date based on the input:
</p>
<gen:highlight type="php">
namespace ACME\shop\order;

class SimpleShipmentDateCalculator extends APFObject implements PreliminaryShipmentDateCalculator {
   private $shipmentPeriodInDays = 10;

   public function getShipmentDate(DateTime $orderDate) {
      return $orderDate->add(\DateInterval::createFromDateString('+' . $this->shipmentPeriodInDays . 'd'));
   }
}
</gen:highlight>
<div class="hint">
   Please note, that <em>SimpleShipmentDateCalculator</em> extends <em>APFObject</em>. This means that it automatically
   complies with the <em>APFDIService</em> and it's requirements. Doing so, you can easily implement services without
   caring about the internals. In case you want to remove dependency to <em>APFObject</em> please follow the instructions
   noted in <a href="#Chapter-4-4-5-Implementation-of-APFDIService">chapter 4.4.5.</a>.
</div>
<p>
   In order to create a service within a document controller it is required to create the service configuration.
</p>
<div class="hint">
   Defining the namespace of the service definition it is recommended to use the same namespace of the implementation
   to express affiliation.
</div>

<h6 id="Chapter-4-4-1-2-Usage"><a href="#Chapter-4-4-1-2-Usage">4.4.1.2. Usage</a></h6>
<p>
   According to the hint within the last chapter the namespace of the service configuration should be defined as
   <em>ACME\shop\order</em> and the name of the service definition is <em>shipment-date-calculator</em>. The service
   can thus be used within a controller like this:
</p>
<gen:highlight type="php">
namespace ACME\shop\ui\checkout;

use ACME\shop\order\SimpleShipmentDateCalculator;
use APF\core\pagecontroller\BaseDocumentController;

class PreliminaryShipmentDateController extends BaseDocumentController {
   public function transformContent() {

      /* @var $service SimpleShipmentDateCalculator */
      $service = & $this->getDIServiceObject('ACME\shop\order', 'shipment-date-calculator');

      $this->setPlaceHolder(
         'shipment-date',
         $service->getShipmentDate(new \DateTime())->format('Y-m-d')
      );

   }

}
</gen:highlight>

<h6 id="Chapter-4-4-1-3-Configuration"><a href="#Chapter-4-4-1-3-Configuration">4.4.1.3. Configuration</a></h6>
<p>
   Configuration - or the configuration file - depends on several parameters. For this use case we assume the following
   facts:
</p>
<ul>
   <li>
      For vendor <em>ACME</em> a <em>StandardClassLoader</em> is registered according to the description under
      <int:link pageid="154" /> which defines <em>/path/to/ACME</em> as base path.
   </li>
   <li>
      <!-- hier weiter -->




      Als Kontext der Applikation wurde dem <int:link pageid="012" /> der Wert <em>customer-one</em> übergeben.
   </li>
   <li>
      Die konfigurierte Umgebung, in der die Applikation eingesetzt wird wurde nicht verändert und lautet damit
      <em>DEFAULT</em>.
   </li>
</ul>
<p>
   Unter den genannten Annahmen erwartet der <em>DIServiceManager</em> die Konfigurations-Datei
</p>
<gen:highlight type="code">
/path/to/ACME/config/shop/order/customer-one/DEFAULT_serviceobjects.ini
</gen:highlight>
<p>
   mit dem Inhalt
</p>
<gen:highlight type="ini">
[shipment-date-calculator]
class="ACME\shop\order\SimpleShipmentDateCalculator"
servicetype="SINGLETON"
</gen:highlight>

<h5 id="Chapter-4-4-2-Initialisierung-eines-einfachen-Services"><a href="#Chapter-4-4-2-Initialisierung-eines-einfachen-Services">4.4.2. Initialisierung eines einfachen Services</a></h5>
<p>
   In <a href="#Chapter-4-4-1-Creation-of-a-simple-service">Kapitel 4.4.1</a> wurde der <em>SimpleShipmentDateCalculator</em>
   statisch konfiguriert, sprich die Anzahl der durchschnittlich notwendigen Liefertage innerhalb des Codes der
   Klasse definiert. In diesem Kapitel erweitern wir die Definition des Interfaces und die Implementierung des Services
   so, dass eine konfigurierbare Anzahl von Tagen mitgegeben werden kann.
</p>

<h6 id="Chapter-4-4-2-1-Implementierung"><a href="#Chapter-4-4-2-1-Implementierung">4.4.2.1. Implementierung</a></h6>
<p>
   Das Interface <em>PreliminaryShipmentDateCalculator</em> erhält eine zusätzliche Methode <em>setShipmentPeriod()</em>
   um den Service konfigurieren zu können:
</p>
<gen:highlight type="php">
namespace ACME\shop\order;

interface PreliminaryShipmentDateCalculator {
   /**
    * @param int $shipmentPeriodInDays
    */
   public function setShipmentPeriodInDays($shipmentPeriodInDays);

   /**
    * @param \DateTime $orderDate
    * @return \DateTime
    */
   public function getShipmentDate(\DateTime $orderDate);
}
</gen:highlight>
<p>
   Die Implementierung des Service erweitert sich damit wie folgt:
</p>
<gen:highlight type="php">
namespace ACME\shop\order;

class SimpleShipmentDateCalculator implements PreliminaryShipmentDateCalculator {

   /**
    * @var int
    */
   private $shipmentPeriodInDays = 10;

   public function setShipmentPeriodInDays($shipmentPeriodInDays) {
      $this->shipmentPeriodInDays = $shipmentPeriodInDays;
   }

   public function getShipmentDate(\DateTime $orderDate) {
      return $orderDate->add(\DateInterval::createFromDateString('+' . $this->shipmentPeriodInDays . 'd'));
   }

}
</gen:highlight>

<h6 id="Chapter-4-4-2-2-Konfiguration"><a href="#Chapter-4-4-2-2-Konfiguration">4.4.2.2. Konfiguration</a></h6>
<p>
   Basierend auf den Annahmen in <a href="#Chapter-4-4-1-3-Configuration">Kapitel 4.4.1.3</a> kann die Konfigurations-Sektion
   <em>shipment-date-calculator</em> wie folgt erweitert werden:
</p>
<gen:highlight type="ini">
[shipment-date-calculator]
class="ACME\shop\order\SimpleShipmentDateCalculator"
servicetype="SINGLETON"

conf.shipment-days.method="setShipmentPeriodInDays"
conf.shipment-days.value="7"
</gen:highlight>
<p>
   Bei der Nutzung des Service wird nun gegenüber <a href="#Chapter-4-4-1-2-Usage">Kapitel 4.4.1.2</a> ein Datum von
   7 Tagen als Lieferungs-Datum ausgegeben.
</p>
<div class="hint">
   Da mit dieser Service-Definition eine saubere Trennung zwischen Code und Konfiguration eingeführt wurde, kann die
   Lieferzeit jederzeit und für unterschiedliche Applikationen und Umgebungen ohne Änderung von Quellcode angepasst
   werden.
</div>

<h5 id="Chapter-4-4-3-Nutzung-der-Initialisierungs-Methode"><a href="#Chapter-4-4-3-Nutzung-der-Initialisierungs-Methode">4.4.3. Nutzung der Initialisierungs-Methode</a></h5>
<p>
   Die Konstruktion bzw. die Konfiguration von Objekten und Services ist immer dann eine Herausforderung, wenn interne
   Zustände oder Ressourcen (z.B. Datenbank-Verbinungen) in Abhängigkeit zu mehreren Konfigurations-Parametern stehen.
   In diesem Fall ist es erforderlich, zunächst alle Abhängigkeiten aufzulösen, bzw. die benötigten Ressourcen zu
   injizieren und anschließend den &quot;Betriebs-Zustand&quot; der Instanz herzustellen.
</p>
<p>
   Eine denkbare Lösung ist, die Parameter in einer definierten, gleichbleibenden Reihenfolge in der Konfiguration zu
   definieren und im <em>Setter</em> des letzten Parameters den gewünschten Objektzustand herzustellen. Dies birgt
   allerdings die Gefahr, dass bei fehlerhafter Konfiguration oder bei Session-übergreifender Nutzung der Status des
   Objekts nicht garantiert werden kann.
</p>
<p>
   Um Fehler bei der Initialisierung zu vermeiden, bietet der <em>DIServiceManager</em> die Ausführung einer
   Initialisierungs-Methode an. Diese kann innerhalb der Konfiguration eines Service mit dem Attribut <em>setupmethod</em>
   definiert werden.
</p>
<div class="hint">
   Der <em>DIServiceManager</em> ruft die Methode am Ende der Konfiguration eines Objektes durch die in den
   <em>conf.*</em>- und <em>init.*</em>-Bereichen definierten Abhängigkeiten aus. Damit ist sichergestellt, dass alle
   notwendigen Informationen zur Initialisierung vorliegen.
</div>

<h6 id="Chapter-4-4-3-1-Implementierung"><a href="#Chapter-4-4-3-1-Implementierung">4.4.3.1. Implementierung</a></h6>
<p>
   Im folgenden Beispiel soll der <em>SimpleShipmentDateCalculator</em> aus <a href="#Chapter-4-4-2-Initialisierung-eines-einfachen-Services">Kapitel 4.4.2</a>
   um die Möglichkeit erweitert werden ein potentielles Liefer-Datum aus einem Basis-Wert und einem Uhrzeit-abhängigen
   Faktor zu berechnen. Der Faktor soll aus zwei Konfigurations-Parametern berechnet werden und gilt innerhalb der
   durch die beiden Parameter definierten Uhrzeiten.
</p>
<p>
   Die <em>setupmethod</em> dient nun dazu, die Berechnung des Faktors auszuführen, damit dieser bei der Berechnung des
   Liefer-Datums in der <em>getShipmentDate()</em>-Methode zur Verfügung steht. Hierzu erweitern wir zunächst das
   Interface <em>PreliminaryShipmentDateCalculator</em>, um die Start- und End-Uhrzeit zu definieren:
</p>
<gen:highlight type="php">
namespace ACME\shop\order;

interface PreliminaryShipmentDateCalculator {
   /**
    * @param int $shipmentPeriodInDays
    */
   public function setShipmentPeriodInDays($shipmentPeriodInDays);

   /**
    * @param string $start
    */
   public function setStartTime($start);

   /**
    * @param string $end
    */
   public function setEndTime($end);

   /**
    * @param \DateTime $orderDate
    * @return \DateTime
    */
   public function getShipmentDate(\DateTime $orderDate);
}
</gen:highlight>
<p>
   Die Implementierung des Service erweitert sich damit wie folgt:
</p>
<gen:highlight type="php">
namespace ACME\shop\order;

class SimpleShipmentDateCalculator implements PreliminaryShipmentDateCalculator {

   /**
    * @var int
    */
   private $shipmentPeriodInDays = 10;

   /**
    * @var \DateTime
    */
   private $start;

   /**
    * @var \DateTime
    */
   private $end;

   /**
    * @var int
    */
   private $dynamicFactor;

   public function setShipmentPeriodInDays($shipmentPeriodInDays) {
      $this->shipmentPeriodInDays = $shipmentPeriodInDays;
   }

   public function setStartTime($start) {
      $this->start = new \DateTime($start);
   }

   public function setEndTime($end) {
      $this->end = new \DateTime($end);
   }

   ...
}
</gen:highlight>
<p>
   Die Berechnung des <em>$dynamicFactor</em> soll nun in der Methode <em>initialize()</em> erfolgen. Die Implementierung
   der Klasse <em>SimpleShipmentDateCalculator</em> erweitert sich damit nochmals wie folgt:
</p>
<gen:highlight type="php">
class SimpleShipmentDateCalculator implements PreliminaryShipmentDateCalculator {

   /**
    * @var int
    */
   private $shipmentPeriodInDays = 10;

   /**
    * @var \DateTime
    */
   private $start;

   /**
    * @var \DateTime
    */
   private $end;

   /**
    * @var int
    */
   private $dynamicFactor;

   public function setShipmentPeriodInDays($shipmentPeriodInDays) {
      $this->shipmentPeriodInDays = $shipmentPeriodInDays;
   }

   public function setStartTime($start) {
      $this->start = new \DateTime($start);
   }

   public function setEndTime($end) {
      $this->end = new \DateTime($end);
   }

   public function initialize() {
      $difference = $this->end->diff($this->start)->h;
      $this->dynamicFactor = $difference > 1 ? $difference : 1;
   }

   public function getShipmentDate(\DateTime $orderDate) {
      $period = $this->shipmentPeriodInDays;
      if ($orderDate->diff($this->start)->h >= 0 && $this->end->diff($orderDate)->h <= 0) {
         $period = $this->shipmentPeriodInDays;
      }

      return $orderDate->add(
         \DateInterval::createFromDateString(
            '+' . ($period) . 'd'
         )
      );
   }

}
</gen:highlight>
<div class="hint">
   Die Methode <em>initialize()</em> wurde bewusst nicht zum Interface hinzugefügt, da diese aus Sicht des Anwendungs-Codes
   eine Besonderheit der Implementierung darstellt. Sofern Sie in jedem Fall beabsichtigen, die Instanz über den
   <em>DIServiceManager</em> zu erzeugen ist es sinnvoll das Interface um die Methode <em>initialize()</em> zu ergänzen.
</div>
<div class="warn">
   <p>
      Die Instanz der Klasse <em>SimpleShipmentDateCalculator </em> wird in der Methode <em>initialize()</em> nicht als
      initialisiert markiert. Dies führt dazu, dass der <em>DIServiceManager</em> die Methode <em>initialize()</em> bei
      einer erneuten Anfrage des Objekts nochmals ausführt.
   </p>
   <p>
      Ist der Zustand des Objektes nach der Initialisierung über einen längeren Zeitraum (z.B. die gesamte Lebensdauer
      des Objektes) gültig, kann dieses als initialisiert markiert werden. Der <em>DIServiceManager</em> ruft die
      <em>setupmethod</em> danach nicht mehr auf. Dies wird insbesonders für aufwendige Initialisierungsvorgänge
      empfohlen.
   </p>
   <p>
      Die Implementierung der Methode <em>initialize()</em> ändert sich dafür wie folgt:
   </p>
<gen:highlight type="php">
class SimpleShipmentDateCalculator implements PreliminaryShipmentDateCalculator {

   ...

   public function initialize() {
      $difference = $this->end->diff($this->start)->h;
      $this->dynamicFactor = $difference > 1 ? $difference : 1;
      $this->markAsInitialized();
   }

   ...

}
</gen:highlight>
</div>
<p>
   Nun sind alle Vorarbeiten erledigt um den Service initialisieren zu können. Das folgende Kapitel zeigt Ihnen, wie
   Sie den Service zur Nutzung konfigurieren.
</p>

<h6 id="Chapter-4-4-3-2-Konfiguration"><a href="#Chapter-4-4-3-2-Konfiguration">4.4.3.2. Konfiguration</a></h6>
<p>
   Die Implementierung des <em>SimpleShipmentDateCalculator</em> wurde im vorangegangenen Kapitel so angepasst, dass
   dieser mit den relevanten Konfigurations-Parametern ausgestattet und initialisiert werden kann.
</p>
<p>
   Um die erweiterte Service-Implementierung nutzen zu können, ist folgende Konfiguration erforderlich:
</p>
<gen:highlight type="ini">
[shipment-date-calculator]
class="ACME\shop\order\SimpleShipmentDateCalculator"
servicetype="SINGLETON"

setupmethod="initialize"

conf.shipment-days.method="setShipmentPeriodInDays"
conf.shipment-days.value="7"

conf.from.method="setStartTime"
conf.from.value="18:00:00"

conf.to.method="setEndTime"
conf.to.value="23:59:59"
</gen:highlight>
<p>
   Bei der Nutzung des <em>shipment-date-calculator</em> wird nun zwischen 18Uhr und 0Uhr ein dynamischer Faktor
   zur Auslieferungsdauer hinzugefügt.
</p>

<h5 id="Chapter-4-4-4-Initialisierung-eines-komplexen-Service"><a href="#Chapter-4-4-4-Initialisierung-eines-komplexen-Service">4.4.4. Initialisierung eines komplexen Service</a></h5>
<p>
   In diesem Kapitel widmen wir uns der Initialisierung eines Services mit einem anderen. Dies wird immer dann der Fall
   sein, wenn einfache Datentypen in <em>conf.*</em>-Sektionen für die Repräsentation der Konfigurations-Daten nicht mehr
   ausreichend sind, oder ein Service einen anderen vollwertigen Service (beispielsweise eine Datenbank-Verbindung) für
   seine Arbeit benötigt.
</p>
<p>
   Zur Initialierung eines Services lassen sich die <em>init.*</em>-Sektionen nutzen. Diese ermöglichen mit Hilfe einer
   Methode einen definierten Service an einen anderen Service zu übergeben. In diesem Kapitel entwerfen wir den
   <em>DatabaseConfiguredShipmentDateCalculator</em>, der die Lieferzeiten an Hand einer Datenbank-Tabelle evaluiert.
</p>

<h6 id="Chapter-4-4-4-1-Implementierung"><a href="#Chapter-4-4-4-1-Implementierung">4.4.4.1. Implementierung</a></h6>
<p>
   Zur Implementierung des <em>DatabaseConfiguredShipmentDateCalculator</em> nutzen wir die Interface-Definition
   <em>PreliminaryShipmentDateCalculator</em> aus <a href="#Chapter-4-4-1-1-Implementation">Kapitel 4.4.1.1</a>, die
   Implementierung der Methode <em>getShipmentDate()</em> vorschreibt.
</p>
<p>
   Für den Aufbau der Datenbank-Verbindung nutzen wir den <int:link pageid="031" /> bzw. die konkreten
   Treiber-Implementierungen - in unserem Fall den <em>MySQLiHandler</em>. Diese gestaltet sich wie folgt:
</p>
<gen:highlight type="php">
namespace ACME\shop\ui\checkout;

use APF\core\database\MySQLiHandler;

class DatabaseConfiguredShipmentDateCalculator implements PreliminaryShipmentDateCalculator {

   /**
    * @var MySQLiHandler
    */
   private $databaseConnection;

   /**
    * @param MySQLiHandler $databaseConnection
    */
   public function setDatabaseConnection(MySQLiHandler $databaseConnection) {
      $this->databaseConnection = $databaseConnection;
   }

   public function getShipmentDate(\DateTime $orderDate) {
      $select = 'SELECT `shipment_days` FROM ... WHERE ... ' . $orderDate->format('Y-m-d H:i:s') . ';';
      $result = $this->databaseConnection->executeTextStatement($select);
      $data = $this->databaseConnection->fetchData($result);
      return $data['shipment_days'];
   }

}
</gen:highlight>
<p>
   Ähnlich wie in <a href="#Chapter-4-4-3-Nutzung-der-Initialisierungs-Methode">Kapitel 4.4.3</a> definiert der
   <em>DatabaseConfiguredShipmentDateCalculator</em> die Methode <em>setDatabaseConnection()</em> mit der die Konfiguration
   des Services vorgenommen werden kann. In diesem Fall nimmt die Methode keinen skalaren Wert, sondern eine Instanz
   der Klasse <em>MySQLiHandler</em> entgegen.
</p>
<p>
   Innerhalb der Methode <em>getShipmentDate()</em> wird die Datenbank-Verbindung dann zur Evaluierung des Lieferzeitraums
   genutzt und erwartet, dass die Datenbank-Verbindung zu diesem Zeitpunkt aufgebaut ist.
</p>

<h6 id="Chapter-4-4-4-2-Konfiguration"><a href="#Chapter-4-4-4-2-Konfiguration">4.4.4.2. Konfiguration</a></h6>
<p>
   Um den Service <em>DatabaseConfiguredShipmentDateCalculator</em> nutzen können ist eine entsprechende Konfiguration
   notwendig. Diese definiert Service selbst und die abhängigen Strukturen (Datenbank-Verbindung über den <em>MySQLiHandler</em>)
   und dessen Konfiguration.
</p>
<p>
   Die Definition des Service lautet wie folgt:
</p>
<gen:highlight type="ini">
[shipment-date-calculator]
class="ACME\shop\order\DatabaseConfiguredShipmentDateCalculator"
servicetype="SINGLETON"
</gen:highlight>
<p>
   Zur Konfiguration der Datenbank-Verbindung - in diesem Fall ebenfalls eine Service-Definition, die später zur
   Initialisierung eingesetzt wird - kann die folgende Sektion verwendet werden:
</p>
<gen:highlight type="ini">
[shipment-database]
class="APF\core\database\MySQLiHandler"
servicetype="SINGLETON"

setupmethod = "setup"

conf.host.method = "setHost"
conf.host.value = "localhost"

conf.name.method = "setDatabaseName"
conf.name.value = "..."

conf.user.method = "setUser"
conf.user.value = "root"

conf.pass.method = "setPass"
conf.pass.value = "..."

conf.charset.method = "setCharset"
conf.charset.value = "utf8"

conf.collation.method = "setCollation"
conf.collation.value = "utf8_general_ci"
</gen:highlight>
<p>
   Die Sektion <em>shipment-database</em> definiert zunächst die Service-Implementierung, die in diesem Fall eine
   mit dem APF mitgelieferte Komponente ist - die Klasse <em>MySQLiHandler</em>. Da diese das
   <em>DatabaseConnection</em>-Interface implementiert ist es möglich, eine Instanz mit Hilfe des <em>DIServiceManager</em>
   zu erzeugen.
</p>
<p>
   Nach der Konfiguration mit unterschiedlichen <em>conf.*</em>-Sektionen wird die Instanz mit der in
   <a href="#Chapter-4-4-3-Nutzung-der-Initialisierungs-Methode">Kapitel 4.4.3.</a> beschriebenen <em>setupmethod</em>
   initialisiert und ist damit für die Verwendung bereit.
</p>
<p>
   Um die Datenbank-Verbindung im <em>DatabaseConfiguredShipmentDateCalculator</em> nutzen zu können, muss diese noch
   in den Service injiziert werden. Dies lässt sich mit der folgenden Erweiterung der Konfigurations-Sektion
   <em>shipment-date-calculator</em> erreichen:
</p>
<gen:highlight type="ini">
[shipment-date-calculator]
class="ACME\shop\order\DatabaseConfiguredShipmentDateCalculator"
servicetype="SINGLETON"

init.db.method = "setConnection"
init.db.namespace = "ACME\shop\order"
init.db.name = "shipment-database"
</gen:highlight>
<div class="hint">
   Das in diesem Kapitel beschriebene Beispiel geht davon aus, dass die beiden Services in einer Konfigurations-Datei
   definiert sind. Trifft dies für Ihre Applikation nicht zu, muss der Namespace im Attribut <em>init.db.namespace</em>
   entsprechend ausgetauscht werden.
</div>
<p>
   Bei der Nutzung des Service <em>shipment-date-calculator</em> steht Ihnen in der Methode <em>getShipmentDate()</em>
   nun der Zugriff auf eine initialisierte Datenbank-Verbindung zur Verfügung.
</p>
<div class="hint">
   Ein weiteres Beispiel findest sich auf der Wiki-Seite
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/Erzeugen_des_GORM_mit_dem_DIServiceManager" title="Erzeugen des GORM mit dem DIServiceManager">Erzeugen des GORM mit dem DIServiceManager</a>.
</div>

<h5 id="Chapter-4-4-5-Implementation-of-APFDIService"><a href="#Chapter-4-4-5-Implementation-of-APFDIService">4.4.5. Implementierung von APFDIService</a></h5>
<p>
   Die Klasse <em>APFObject</em> implementiert das <em>APFDIService</em>-Interface und stellt damit alle notwendigen
   Voraussetzungen zur Verfügung um Objekte dieses Typs mit dem <em>DIServiceManager</em> zu erzeugen. Ist dies nicht
   gewünscht - etwa um die von der Klasse <em>APFObject</em> ausgehenden Abhängigkeiten zu lösen -, so können Sie
   jederzeit die Abhängigkeit durch eine eigene Implementierung des <em>APFDIService</em>-Interface unterbrechen.
</p>
<p>
   Für Ihre eigene Implementierung des <em>APFDIService</em>-Interface gilt es folgende Punkte zu beachten:
</p>
<ul>
   <li>
      Die Verwaltung der Attribute <em>Kontext</em>, <em>Sprache</em> und <em>Service-Typ</em> muss von der
      Implementierung selbst übernommen werden. Konkret muss die Implementierung des Interfaces dafür sorgen, dass
      die Werte innerhalb einer Instanz gespeichert und bei Aufruf der entsprechenden Interface-Methoden (z.B.
      <em>getContext()</em>) zurückgegeben werden.
   </li>
   <li>
      Die Initialisierung und Markierung des Services erfolgt mit Hilfe der Methoden <em>markAsInitialized()</em> und
      <em>markAsPending()</em>, die Abfrage nimmt der <em>DIServiceManager</em> mit Hilfe der Methode <em>isInitialized()</em>
      vor. Die Speicherung des Initialisierungszustandes und die entsprechende Rückgabe obliegt Ihrer Implementierung.
   </li>
</ul>
<div class="hint">
   Bei der Implementierung von eigenen Services, die mit einer speziellen <em>setupmethod</em> initialisiert werden
   lässt sich die Markierung des Services als bereits initialisiert auch in der <em>isInitialized()</em>-Methode vornehmen.
   Nutzen Sie das <em>APFObject</em> als Basis, können Sie die Initialisierung lediglich in der <em>setupmethod</em>
   über die Methode <em>markAsInitialized()</em> abbilden.
</div>

<h5 id="Chapter-4-4-6-Nutzung-von-Services"><a href="#Chapter-4-4-6-Nutzung-von-Services">4.4.6. Nutzung von Services</a></h5>
<p>
   Die Nutzung von Services, die mit dem <em>DIServiceManager</em> erzeugt wurden kann auf unterschiedliche Arten erfolgen.
   Einige davon wurden bereits in den letzten Kapitel besprochen. Die folgende Tabelle fasst alle Möglichkeiten zusammen
   und gibt Ihnen weitere Hinweise und Tipps:
</p>
<table>
   <thead>
      <tr>
         <td>Beschreibung</td>
         <td>Einsatzgebiet</td>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>
            Die in den Kapiteln <a href="#Chapter-4-4-1-Creation-of-a-simple-service">4.4.1</a> bis
            <a href="#Chapter-4-4-4-Initialisierung-eines-komplexen-Service">4.4.4</a> beschriebene Art der Nutzung sieht
            den direkten Bezug der gewünschten Instanzen vom <em>DIServiceManager</em> vor. Ihnen steht es dabei frei,
            die Convenience-Methode <em>APFObject::getDIserviceObject()</em> zu nutzen oder direkt auf
            <em>DIServieceManager::getServiceObject()</em> zuzugreifen.
         </td>
         <td>
            Diese Art der Anwendung wird für <int:link pageid="006" /> und die <int:link pageid="147"/> empfohlen.
         </td>
      </tr>
      <tr>
         <td>
            <p>
               <a href="#Chapter-4-4-4-Initialisierung-eines-komplexen-Service">Kapitel 4.4.4</a> beschreibt die Initialisierung
               und Konfiguration von Services mit einfachen Werten und wiederum anderen Services. Der z.B. von einem Controller
               angefragte Service ist bei Bezug bereits fertig konfiguriert und der Anwender muss keine weiteren Code
               investieren (<em>inversion of control</em>).
            </p>
            <p>
               Innerhalb eines Services kann ein über den DI-Container injizierter Service direkt genutzt werden ohne
               diesen aktiv vom <em>DIServiceManager</em> zu beziehen. Dies erleichtert die Implementierung und entfernt
               explizite Abhängigkeiten um Transparenz und Testbarkeit zu verbessern.
            </p>
            <p>
               Diese Möglichkeit steht auch für Document-Controller zur Verfügung.
               Kapitel 4 der
               <int:link pageid="006" anchor="Chapter-4-Erzeugung-eines-Controllers-ueber-den-DI-Container" />-Dokumentation
               beschreibt die notwendigen Maßnahmen um einen Controller über den <em>DIServiceManager</em> zu erzeugen.
            </p>
         </td>
         <td>
            Diese Art der Anwendung wird für <int:link pageid="006" /> empfohlen, die komplexe Services bezieht bzw. auf
            mehr als einen Service zurückgreift. Ferner ist diese Vorgehensweise nützlich um Code innerhalb von
            Controllern besser testbar zu gestalten.
         </td>
      </tr>
      <tr>
         <td>
            <p>
               Analog zur Erzeugung von Document-Controllern ist es ebenfalls möglich, <em>Front-Controller-Actions</em>
               über den DI-Container zu erzeugen. Dies erleichtert ebenfalls die Implementierung und entfernt explizite
               Abhängigkeiten im Code um Transparenz und Testbarkeit zu verbessern.
            </p>
            <p>
               Kapitel 3.3 der
               <int:link pageid="012" anchor="Chapter-3-3-Erzeugung-einer-Action-ueber-den-DI-Container" />-Dokumentation
               beschreibt die notwendigen Maßnahmen um eine Action über den <em>DIServiceManager</em> zu erzeugen.
            </p>
         </td>
         <td>
            Diese Art der Anwendung wird für <int:link pageid="012" />-Actions empfohlen, die komplexe Services bezieht
            bzw. auf mehr als einen Service zurückgreift. Ferner ist diese Vorgehensweise nützlich um Code innerhalb von
            Actions besser testbar zu gestalten.
         </td>
      </tr>
   </tbody>
</table>

<h4 id="Chapter-4-5-Gueltigkeitsbereiche"><a href="#Chapter-4-5-Gueltigkeitsbereiche">4.5. Gültigkeitsbereiche</a></h4>
<p>
   Das Adventure PHP Framework stellt mehrere Möglichkeiten zur <int:link pageid="030" /> zur Verfügung. Mit diesen lassen
   sich Instanzen mit unterschiedlichen Gültigkeitsbereichen erstellen und innerhalb der Applikation verwenden. Erstellen
   Sie Services mit dem <em>ServiceManager</em> oder <em>DIServiceManager</em> stehen Ihnen diese Möglichkeiten ebenfalls
   zur Verfügung. Bei der Nutzung der Methode <em>APFObject::getServiceObject()</em> in
   <a href="#Chapter-3-2-2-Using-the-wrapper">Kapitel 3.2.2</a> und der Konfiguration von Services in
   <a href="#Chapter-4-3-Configuration">Kapitel 4.3</a> lassen sich die Gültigkeitsbereiche jeweils programmatisch bzw.
   konfigurativ pro Instanz definieren.
</p>
<p>
   Die folgende Tabelle führt die vorhandenen Gültigkeitsbereiche und deren empfohlenen Einsatz auf:
</p>
<table>
   <thead>
      <tr>
         <td>Gültigkeitsbereich</td>
         <td>Beschreibung</td>
         <td>Einsatzgebiete</td>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>
            <em>NORMAL</em>
         </td>
         <td>
            Objekt wird bei jeder Anfrage an den <em>ServiceManager</em> bzw. <em>DIServiceManager</em> neu erzeugt und
            ggf. initiaisiert.
         </td>
         <td>
            Soll ein neu erzeugtes Objekt mit <em>Kontext</em> und <em>Sprache</em> ausgestattet werden, jedoch
            bei jedem Anwendungsfall unterschiedlich sein, kann dieser Gültigkeitsbereich genutzt werden. Für
            Services wird i.d.R. jedoch der Gültigkeitsbereich <em>SINGLETON</em> empfohlen.
         </td>
      </tr>
      <tr>
         <td>
            <em>SINGLETON</em>
         </td>
         <td>
            Objekt wird lediglich bei der ersten Anfrage an den <em>ServiceManager</em> bzw. <em>DIServiceManager</em>
            neu erzeugt und ggf. initialisiert und ist innerhalb einer HTTP-Anfrage gültig.
         </td>
         <td>
            Objekte mit diesem Gültigkeitsbereich können zum Austausch von Informationen zwischen unterschiedlichen
            HMVC-Elementen innerhalb einer Anfrage verwendet werden.
            <br />
            <br />
            Ein weiterer Anwendungsfall ist die mehrfache Verwendung eines Service an unterschiedlichen Stellen innerhalb
            einer HTTP-Anfrage, dessen Initialisierung aufwendig ist und daher nur einmal durchgeführt werden soll.
         </td>
      </tr>
      <tr>
         <td>
            <em>SESSION_SINGLETON</em>
         </td>
         <td>
            Objekt wird lediglich bei der ersten Anfrage an den <em>ServiceManager</em> bzw. <em>DIServiceManager</em>
            neu erzeugt und ggf. initialisiert und ist innerhalb einer HTTP-Session gültig.
         </td>
         <td>
            Objekte mit diesem Gültigkeitsbereich können als View-Model für z.B. mehrseitige Workflows genutzt werden.
            Darin lassen sich über mehrere HTTP-Anfragen innerhalb eines Besuchs die Daten zwischenspeichern und am
            Ende konsolidiert verarbeiten.
            <br />
            <br />
            Ein weiterer Anwendungsfall ist die mehrfache Verwendung eines Service an unterschiedlichen Stellen innerhalb
            eines Besuchs, dessen Initialisierung aufwendig ist und daher nur einmal durchgeführt werden soll.
         </td>
      </tr>
      <tr>
         <td>
            <em>APPLICATION_SINGLETON</em>
         </td>
         <td>
            Objekt wird lediglich bei der ersten Anfrage an den <em>ServiceManager</em> bzw. <em>DIServiceManager</em>
            neu erzeugt und ggf. initialisiert und ist für die Laufzeit des Web-Servers gültig.
         </td>
         <td>
            Objekte mit diesem Gültigkeitsbereich können zum Austausch von Daten einer Anwendung unabhängig von einer
            Anfrage oder einem Besuch genutzt werden.
            <br />
            <br />
            Ein weiterer Anwendungsfall ist die mehrfache Verwendung eines Service an unterschiedlichen Stellen innerhalb
            einer Applikation, dessen Initialisierung aufwendig ist und daher nur einmal durchgeführt werden soll.
         </td>
      </tr>
   </tbody>
</table>
<div class="warn">
   <p>
      Bitte beachten Sie, dass bei Nutzung des Gültigkeitsbereichs <em>SESSION_SINGLETON</em> und <em>APPLICATION_SINGLETON</em>
      die Inhalte eines Objekts zwischen zwei Anfragen serialisiert werden. Da Resourcen (File-Pointer,
      Datenbank-Verbindungen) nicht searialisiert werden können müssen diese ggf. in der nächsten Anfrage neu
      initialisiert werden müssen.
   </p>
   <p>
      Um in einer Klasse <em>DataMapper</em>, die als Service über den <em>ServiceManager</em> oder <em>DIServiceManager</em>
      bezogen wird, eine Datenbank-Verbindung zu verwalten können Sie folgenden Code nutzen:
   </p>
<gen:highlight type="php">
class DataMapper extends APFObject {

   /**
    * @var MySQLiHandler
    */
   private $connection;

   ...

   public function __wakeup() {
      $this->connection = ...;
   }

}
</gen:highlight>
   <p>
      Sobald Sie den Service in einer weiteren Anfrage erneut beziehen, wird die Methode <em>__wakeup()</em> aufgerufen
      und die Verbindung wieder hergestellt.
   </p>
   <p>
      Nutzen Sie den <em>DIServiceManager</em> und ist für Ihren Service eine <em>setupmethod</em> konfiguriert, können
      Sie bei der Serialisierung den Initialisierugstatus des Objekts zurück zu setzen. Dies sorgt ebenfalls dafür, dass
      das Objekt beim nächsten Bezug über die <em>setupmethod</em> neu initialisiert wird. Hierzu lässt sich folgender
      Code nutzen:
   </p>
<gen:highlight type="php">
class DataMapper extends APFObject {

   /**
    * @var MySQLiHandler
    */
   private $connection;

   ...

   public function __sleep() {
      $this->markAsPending();
   }

   public function initialize() {
      $this->connection = ...;
   }

}
</gen:highlight>
   <p>
      Diese Möglichkeit ist jedoch an den <em>DIServiceManager</em> gebunden und setzt voraus, dass Sie Ihren Service
      mit einer <em>setupmethod</em> initialisieren.
   </p>
</div>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="en_107" />