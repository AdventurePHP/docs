<doku:title parent="119" tags="form,taglib,validatoren,validator,filter,auto,ausfuellen,presetting,1.11" title="Formulare" urlname="Formulare">
   Das APF bietet auf Basis von Taglibs eine komplette Abstraktion von Formularen und
   Formular-Elementen. Diese beherrschen out-of-the-box Presetting (Auto-Ausfüllen), Validierung
   und Filterung. Im Document-Controller steht ein Formular als eigenständiges Objekt mit diversen
   Funktionen zur Verfügung.
</doku:title>
<h3 id="Chapter-1-Einleitung"><a href="#Chapter-1-Einleitung">1. Einleitung</a></h3>
<p>
   Auf Grund der Tatsache, dass der <int:link pageid="098" /> des APF einen
   generischen Rahmen für das Verarbeiten von beliebigen Taglibs bereitstellt, ist es auf dieser
   Basis möglich, Formulare mit verschiedenen Taglibs - wie z.B. Text-Felder - zu abstrahieren.
</p>
<p>
   Das Release des Adventure PHP Framework beinhaltet daher einen Satz von Taglibs, mit denen
   HTML-Formulare vollständig abstrahiert sind und die gleichzeitig Features, wie Filterung,
   Validierung und Presetting out-of-the box beherrschen. Mit den in der Version 1.11 überarbeiteten
   Taglibs können Formular-Felder mit beliebigen Filter und Validatoren belegt und eigene Taglibs
   integriert werden.
</p>
<p>
   Die folgenden Kapitel beschreiben den grundsätzlichen Aufbau und die Verarbeitung von Formularen,
   sowie die vorhandenen Tags und deren Bedeutung und Funktion. Parallel dazu ist es ratsam, die
   <int:link pageid="002" /> bei der Implementierung zu Hilfe nehmen. Diese zeigt - insbesondere bei der Klasse
   <strong>HtmlFormTag</strong> - auf, welche Möglichkeiten die APF-Formulare bieten.
</p>
<div class="hint">
   Das Kapitel <int:link pageid="114" /> beinhaltet ausführliche Beispiele für die
   Verwendung und Erweiterung von Formularen.
</div>

<h3 id="Chapter-2-Aufbau"><a href="#Chapter-2-Aufbau">2. Aufbau von Formularen</a></h3>
<p>
   Wie in der Einleitung kurz beschrieben, werden Formulare im APF durch Taglibs abgebildet. Die
   Basis-Taglib bildet dabei <strong>&lt;html:form /&gt;</strong>, die alle weiteren Tags kapselt
   und so ein Formular in einem Document-Controller als <em>ein</em> Objekt zur Verfügung stellt.
   Dieses kann weitere Tags beinhalten, die entweder konkrete Elemente wie ein Text-Feld oder einen
   Button repräsentieren, oder funktionale Tags wie Platzhalter, Listener oder Tags, die eigene
   Formular-Elemente hinzufügen.
</p>
<p>
   Formulare werden - wie auch andere Elemente der GUI - in Template-Dateien definiert. Ein einfaches
   Formular für eine Suche mit einem Eingabe-Feld und einem Button hat folgende Gestalt:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="tools::form::taglib"
   class="HtmlFormTag"
   prefix="html"
   name="form"
/&gt;
&lt;html:form name="Search"&gt;
   &lt;form:text name="searchterm" /&gt; &lt;form:button name="search" value="GO" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Um das Formular anzuzeigen, muss ein Document-Controller für das betreffende Template vorhanden
   sein. Dies hat den Grund, dass ein Formular - im Gegensatz zu anderen Taglibs - immer an eine
   Verarbeitung durch den Entwickler gebunden ist. Sei es das Auslesen des Suchwort und Ausführen
   der Suche oder das Speichern von Nutzerdaten.
</p>
<p>
   Zur Anzeige des Formulars ist folgender Code im Controller erforderlich:
</p>
<gen:highlight type="php">
class search_controller extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('Search');
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>Die folgenden Kapitel beschreiben nun die vorhandenen Formular-Elemente und deren Einsatzgebiet.</p>

<h3 id="Chapter-3-Mitgelieferte-Tags"><a href="#Chapter-3-Mitgelieferte-Tags">3. Mitgelieferte Tags</a></h3>
<p>
   Das APF beinhaltet bereits einen umfangreichen Satz and Formular-Elementen, die nach Bedarf
   konfiguriert werden können. Sollten diese nicht ausreichen, können jederzeit eigene
   Formular-Elemente hinzugefügt werden. Siehe hierzu Kapitel <int:link pageid="114" />.
</p>
<p>
   Da das APF einen generischen Tag-Parser beinhaltet, können Formular-Tags mit beliebigen
   Attributen ausgestattet werden. Zu diesen zählen insbesondere
</p>
<ul>
   <li><strong>id="..."</strong></li>
   <li><strong>class="..."</strong></li>
   <li><strong>style="..."</strong></li>
</ul>
<p>
   zur Formatierung der Elemente. Aus diesem Grund werden diese in den Beschreibungen der Taglibs
   nicht weiter erwähnt, sondern es wird lediglich auf die für die Funktion des Tags
   relevanten Attribute eingegangen.
</p>
<div class="hint">
   Ein weiteres generische Attribute ist <em>optional</em>, das zur Kennzeichnung von optionalen
   Feldern hinsichtlich der Validierung genutzt wird. Details können im Kapitel
   <int:link pageid="113" anchor="Chapter-4-1-Verfuegbare-Validatoren">Verfügbare Validatoren</int:link>
   nachgelesen werden.
</div>
<div class="hint">
   Attribute, die mit "[" und "]" geklammert dargestellt sind, haben optionalen Charakter, die
   übrigen müssen verpflichtend angegeben werden.
</div>
<p>
   Das Formular-Tag selbst besitzt drei funktionale Attribute, die zur Definition und Konfiguration
   dienen:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="" [method=""] [action=""]&gt;
  ...
&lt;/html:form&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Formulars. Über den Namen kann auf das Element zugegriffen
    werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>method</strong>: Versand-Methode des Formulars. Standardmäßig wird 
    <strong>post</strong> verwendet.
    (<strong>Zeichen</strong>: <code>[get|post]</code>)
  </li>
  <li>
    <strong>action</strong>: URL, die bei Klick auf den Button aufgerufen werden soll.
  </li>
</ul>
<div class="hint">
   Seit dem Release 1.13 ist es möglich, einen globalen Standard-Wert für das Attribut <em>action</em>
   über die Registry zu definieren. Dies ist in der Bootstrap-Datei durch den Aufruf von
   <gen:highlight type="php">Registry::register('apf::tools', 'FormDefaultMethod','...')</gen:highlight>
   möglich. Damit erhalten alle Formulare - sofern das Attribut in der Tag-Definition nicht gesetzt ist -
   den dort definierten Standard-Wert. Sofern auch dieser nicht gesetzt ist, wird &quot;post&quot;
   verwendet.
</div>
<div class="hint">
   Bitte beachten Sie, dass Text-Felder keine Array-Notation für Namen unterstützen (Beispiel:
   <em>text[de]</em>). Grund dafür ist, dass Text-Felder skalare Werte enthalten sollen. Dieser
   Vereinbarung gemäß lesen die Validatoren auch nur skalare Werte aus und können nicht mit Arrays
   umgehen.
</div>

<h4 id="Chapter-3-1-Button"><a href="#Chapter-3-1-Button">3.1. Button</a></h4>
Diese Taglib repräsentiert einen Submit-Button. APF-Formular-Elemente werden Event-basiert
validiert und gefiltert. Dazu muss zwingend ein Button oder ein Image-Button definiert sein, da
diese das <em>Click-Event</em> auslösen.
<gen:highlight type="apf-xml">
&lt;form:button name="" value="" /&gt;

&lt;form:button name=""&gt;
   &lt;button:getstring
      [name=""]
      namespace=""
      config=""
      entry="" /&gt;
&lt;/form:button&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Buttons. Über den Namen kann auf das Element zugegriffen 
    werden. Dies ist insbesondere für die Validatoren und Filter notwendig.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Buttons. Dieser dient der Beschriftung.
  </li>
</ul>
<div class="hint">
   Seit Release 1.14 kann zur Beschriftung des Buttons der <em>&lt;button:getstring /&gt;</em>-Tag
   eingesetzt werden. Details zur Definition der Konfigurations-Dateien können der Definition des Tags
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>
   entnommen werden.
</div>

<h4 id="Chapter-3-2-Image-Button"><a href="#Chapter-3-2-Image-Button">3.2. Image-Button</a></h4>
<p>
   Der Image-Button erzeugt einen Button, der als Beschriftung ein Bild nutzt. Die Funktion ist
   identisch zum einfachen Button.
</p>
<gen:highlight type="apf-xml">
&lt;form:imagebutton name="" src="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Buttons. Über den Namen kann auf das Element zugegriffen
    werden.  Dies ist insbesondere für die Validatoren und Filter notwendig.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>src</strong>: Bild-Quelle des Buttons.
  </li>
</ul>
<br />
<h4 id="Chapter-3-3-Reset"><a href="#Chapter-3-3-Reset">3.3. Reset-Button</a></h4>
Seit dem Release 1.10 beinhalten die Formular-TagLibs einen Tag für Reset-Buttons. Diese
repräsentieren einen HTML-Reset-Button und können wie "normale" Buttons im
Document-Controller adressiert und konfiguriert werden.
<br />
<br />
<div class="hint">Mit einem Reset-Button ist keine Validierung bzwl. Filterung möglich!</div>
<gen:highlight type="apf-xml">
&lt;form:reset name="" value="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>value</strong>: Wert (Beschriftung) des Reset-Buttons.
  </li>
</ul>
<br />
<h4 id="Chapter-3-4-Hidden"><a href="#Chapter-3-4-Hidden">3.4. Hidden-Feld</a></h4>
<gen:highlight type="apf-xml">
&lt;form:hidden name="" value="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Hidden-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Hidden-Feldes.
  </li>
</ul>
<br />
<h4 id="Chapter-3-5-Text"><a href="#Chapter-3-5-Text">3.5. Text-Feld</a></h4>
<gen:highlight type="apf-xml">
&lt;form:text name="" [value=""] /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Text-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Text-Feldes.
  </li>
</ul>
<br />
<h4 id="Chapter-3-6-Textarea"><a href="#Chapter-3-6-Textarea">3.6. Textarea</a></h4>
Eine APF-Text-Area existiert in zwei Ausprägungen: ohne Inhalt als selbstschließender Tag oder mit
Inhalt, der im Template definiert wurde.
<gen:highlight type="apf-xml">
&lt;form:area name="" /&gt;
&lt;form:area name=""&gt;...&lt;/form:area&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Textarea. Über den Namen kann auf das Element zugegriffen
    werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
<br />
<h4 id="Chapter-3-7-Passwort"><a href="#Chapter-3-7-Passwort">3.7. Passwort-Feld</a></h4>
<gen:highlight type="apf-xml">
&lt;form:password name="" [value=""]/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Passwort-Felds. Über den Namen kann auf das Element 
    zugegriffen werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Passwort-Feldes.
  </li>
</ul>
<br />
<h4 id="Chapter-3-8-Dateiupload"><a href="#Chapter-3-8-Dateiupload">3.8. Dateiupload-Feld</a></h4>
<p>
   Das Dateiupload-Feld besitzt folgende Signatur:
</p>
<gen:highlight type="apf-xml">
&lt;form:file name="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Dateiupload-Felds. Über den Namen kann auf das Element
    zugegriffen werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
<p>
   Mit dem Release 1.12 des APF wurde eine Erweiterung des Dateiupload-Feldes eingeführt, mit
   dem es auf sehr einfache Art uns Weise möglich ist, einen Datei-Upload zu realisieren. Dazu
   besitzt die Taglib folgende Methoden, die in einem Document-Controller genutzt werden können:
</p>
<ul>
   <li>
      <em>hasUploadedFile():boolean</em>: gibt <em>true</em> zurück, sofern eine Datei 
      hochgeladen wurden; ansonsten <em>false</em>.
   </li>
   <li>
      <em>getFile():FileModel</em>: gibt eine Instanz der Klasse <em>FileModel</em> zurück,
      die eine hochgeladene Datei repräsentiert. Wenn keine Datei hochleladen wurden, wird
      <em>null</em> zurückgegeben.
   </li>
</ul>
<p>
   Der Wiki-Eintrag 
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/File-Upload_mit_Form-Taglibs" title="File-Upload mit Form-Taglibs">File-Upload mit Form-Taglibs</a>
   beschreibt, wie ein Datei-Upload auf einfache Weise realisiert werden kann. Bitte beachten Sie
   auch die in 1.12 neu hinzugekommenen 
   <a href="#Chapter-4-1-12-MimeTypeValidator">MimeTypeValidator</a> und
   <a href="#Chapter-4-1-13-FileSizeValidator">FileSizeValidator</a>, die zur
   Validierung der hochgeladenen Dateien genutzt werden können.
</p>
<div class="hint">
   Seit Release 1.16 wird seitens des APF auch ein weiteres Tool zum Erzeugen von Datei-Uploads
   mit Vorschau-Funktion sowie prozentualer Fortschrittanzeige angeboten: der MultiFileUpload.
   Ausführliche Informationen dazu entnehmen Sie bitte der Dokumentation im Wiki:
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/MultiFileUpload" title="MultiFileUpload im Wiki">MultiFileUpload im Wiki</a>
</div>

<h4 id="Chapter-3-9-Checkbox"><a href="#Chapter-3-9-Checkbox">3.9. Checkbox</a></h4>
Die Checkbox-Taglib implementierung nicht nur einen Wrapper für eine HTML-Checkbox, sondern
inkludiert auch die Logik, die zum anhaken und abhaken einer Checkbox notwendig ist. Hierbei wird
die Schwäche ausgebügelt, dass nicht angehakte Checkboxen speziell geprüft werden müssen.
<gen:highlight type="apf-xml">
&lt;form:checkbox name="" value="" [checked="checked"] /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name der Checkbox. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert der Checkbox.
  </li>
  <li>
    <strong>checked</strong>: Definiert, ob die Checkbox vorselektiert ist.
  </li>
</ul>
<br />
<h4 id="Chapter-3-10-Radio-Button"><a href="#Chapter-3-10-Radio-Button">3.10. Radio-Button</a></h4>
Die Radio-Button-Taglib implementierung nicht nur einen Wrapper für einen HTML-Radio-Button,
sondern inkludiert auch die Logik, die zum anhaken und abhaken eines Radio-Buttons notwendig ist.
Hierbei wird die Schwäche ausgebügelt, dass nicht selektierte Radio-Buttons speziell geprüft werden
müssen.
<gen:highlight type="apf-xml">
&lt;form:radio name="" value="" [checked="checked"]/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Radio-Buttons. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Radio-Buttons bzw. der aktuellen Option.
  </li>
  <li>
    <strong>checked</strong>: Zeigt an, ob der Radio-Button vorselektiert ist.
  </li>
</ul>

<h4 id="Chapter-3-11-Select"><a href="#Chapter-3-11-Select">3.11. Select-Feld</a></h4>
<p>
   Ein Select-Feld kann auf unterschiedliche Arten definiert werden: mit statischen oder dynamisch
   hinzugef&uml;gten Optionen oder Gruppen oder einer Mischung aus den genannten Möglichkeiten.
   Dynamische Optionen und Gruppen können in einem <int:link pageid="006" /> hinzugefügt
   und verarbeitet werden.
</p>
<p>
   Seit dem Release 1.12 sind auch Options-Gruppen verfügbar.
</p>
<gen:highlight type="apf-xml">
&lt;form:select name="" /&gt;

&lt;form:select name=""&gt;
  &lt;select:option value="" [selected="selected"]&gt;...&lt;/select:option&gt;
  [&lt;select:group label=""&gt;
     &lt;group:option value="" [selected="selected"]&gt;...&lt;/group:option&gt;
  &lt;/select:group&gt;]
&lt;/form:select&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Select-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert der Optionen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>  
  <li>
    <strong>selected</strong>: Soll eine Option vorausgewählt dargestellt werden, so muss das
    Attribut <em>selected</em> mit dem gleichnamigen Wert gefüllt sein.
  </li>
  <li>
    <strong>label</strong>: Beinhaltet die Beschriftung einer Gruppe von Optionen.
  </li>
</ul>

<h4 id="Chapter-3-12-Multiselect"><a href="#Chapter-3-12-Multiselect">3.12. Multiselect-Feld</a></h4>
<p>
   Wie auch das einfache Select-Feld, so ist es auch beim Multiselect-Feld möglich, dieses auf
   zwei Arten zu definieren: ohne und mit statische Optionen und Gruppen.
</p>
<gen:highlight type="apf-xml">
&lt;form:multiselect name="" /&gt;

&lt;form:multiselect name=""&gt;
  &lt;select:option value="" [selected="selected"]&gt;&lt;/select:option&gt;
  [&lt;select:group label=""&gt;
     &lt;group:option value="" [selected="selected"]&gt;...&lt;/group:option&gt;
  &lt;select:group&gt;]
&lt;/form:multiselect&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Multiselect-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert der Optionen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>selected</strong>: Soll eine Option vorausgewählt dargestellt werden, so muss das
    Attribut <em>selected</em> mit dem gleichnamigen Wert gefüllt sein.
  </li>
  <li>
    <strong>label</strong>: Beinhaltet die Beschriftung einer Gruppe von Optionen.
  </li>  
</ul>
<div class="hint">
   Der Name des Formular-Feldes darf am Schluss kein "[]" enthalten, da es sonst zu Fehlern bei der
   Übertragung der Optionen kommt.
</div>

<h4 id="Chapter-3-13-Platzhalter"><a href="#Chapter-3-13-Platzhalter">3.13. Platzhalter</a></h4>
Der Platzhalter dieht dazu, dynamische Inhalte in das Formular einzubringen.
<gen:highlight type="apf-xml">
&lt;form:placeholder name="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Platzhalters. Über den Namen kann auf das Element
    zugegriffen werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
Um einen Platzhalter eines Formulars zu füllen, besitzt die Klasse <strong>HtmlFormTag</strong>
die Methode <strong>setPlaceHolder()</strong>:
<gen:highlight type="php">
$form = &$this->getForm('MyForm');
$form->setPlaceHolder('NameOfThePlaceHolder','...Value...');
</gen:highlight>

<h4 id="Chapter-3-14-Datum-Control"><a href="#Chapter-3-14-Datum-Control">3.14. Datums-Control</a></h4>
<p>
   Um die Erstellung von Datum-Auswahl-Menüs zu erleichtern, enthält das APF ein Date-Control. Dieses
   kann entsprechend den Anforderungen konfiguriert werden.
</p>
<gen:highlight type="apf-xml">
&lt;form:date
   name=""
   [yearrange=""]
   [offsetnames=""]
   [tab-indexes=""]
   [prepend-empty-options="true|false"]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>name</strong>: Name des Datum-Controls. Über den Namen kann auf das Element
      zugegriffen werden.
      (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
   </li>
   <li>
      <strong>yearrange</strong>: Range des Jahres-Feldes. Beispiel: <code>1990-2007</code>.
      (<strong>Zeichen</strong>: <code>[0-9-]</code>)
   </li>
   <li>
      <strong>offsetnames</strong>: Namen der Felder für Tag, Monat und Jahr. Einzelne Felder
      müssen durch ";" getrennt werden. Beispiel: <code>Tag;Monat;Jahr</code>.
      (<strong>Zeichen</strong>: <code>[A-Za-z;]</code>)
   </li>
   <li>
      <strong>tab-indexes</strong>: Das Datums-Control besteht aus drei Auswahl-Feldern. Mit diesem Attribut lassen
      sich die <em>tabindex</em>-Attribute der einzelnen Felder individuell festlegen. Beispiel: <code>1;2;3</code>.
      (<strong>Zeichen</strong>: <code>[0-9;]</code>)
   </li>
   <li>
      <strong>prepend-empty-options</strong>: Wird das Attribut mit dem Wert <em>true</em> gefüllt, wird das Control
      beim ersten Aufrufen mit leeren Optionen dargestellt. Sofern das Feld mit einem Validator belegt wird, zwingt dies
      den Benutzer zu einer aktiven Auswahl.
      (<strong>Zeichen</strong>: <code>true|false</code>)
   </li>
</ul>

<h4 id="Chapter-3-15-Marker"><a href="#Chapter-3-15-Marker">3.15. Marker</a></h4>
Wie im Kapitel <int:link pageid="114" anchor="Chapter-6-Dynamische-Formulare">Dynamische Formulare</int:link>
beschrieben, kann der Tag <em>&lt;form:marker /&gt;</em>-Tag zur Positionierung von
dynamischen Formular-Elementen genutzt werden. Der Tag selbst erzeugt dabei keine Ausgabe.
<gen:highlight type="apf-xml">
&lt;form:marker name="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Markers. Dieser dient zur Adressierung desselben.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
</ul>
<br />
<h4 id="Chapter-3-16-Addtaglib"><a href="#Chapter-3-16-Addtaglib">3.16. Addtaglib</a></h4>
Die Taglib <em>&lt;form:addtaglib /&gt;</em> bildet das Pendant zur Taglib
<em>&lt;core:addtaglib /&gt;</em> und bietet die Möglichkeit, die bestehende
Funktionalität der Formular-Tags zu erweitern. Die Implementierung des Tags erlaubt es
beliebige weitere Formular-Tags einzubinden und zu verwenden.
<gen:highlight type="apf-xml">
&lt;form:addtaglib namespace="" class="" prefix="" name="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Ein mit "::" getrennter Namespace-Pfad.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-:]</code>)
  </li>
  <li>
    <strong>prefix</strong>: XML-Prefix
    (<strong>Zeichen</strong>: <code>[a-z]</code>)
  </li>
  <li>
    <strong>class</strong>: XML-Klasse
    (<strong>Zeichen</strong>: <code>[a-z]</code>)
  </li>
</ul>
<div class="hint">
   Die mit der Taglib hinzugefügten Tags müssen von der Klasse <strong>AbstractFormControl</strong>
   erben, damit sichergestellt ist, dass diese den Status isSent() und isValid() korrekt an das
   Formular zurückmelden.
</div>
<br />
<h4 id="Chapter-3-17-Getstring"><a href="#Chapter-3-17-Getstring">3.17. Getstring</a></h4>
Der Tag <em>&lt;form:getstring/gt;</em> dient dazu einen Konfigurations-String aus einer sprachabhängigen
Konfigurations-Datei auszulesen und anzuzeigen. So können auf einfache Weise mehrsprachige
Formulare aufgebaut werden. Details zur Definition der Konfigurations-Dateien können der Definition
des Tags <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>
entnommen werden.
<gen:highlight type="apf-xml">
&lt;form:getstring [name=""] namespace="" config="" entry="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>name</strong>: Name des Platzhalters zur Referenz in der <em>getLabel()</em>-Methode
      (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
   </li>
  <li>
    <strong>namespace</strong>: Namespace der Konfiguration des Attributes.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-:]</code>)
  </li>
  <li>
    <strong>config</strong>: Name der Konfiguration.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>entry</strong>: Name des Konfigurations-Offsets.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_.]</code>)
  </li>
</ul>

<h4 id="Chapter-3-18-Listener"><a href="#Chapter-3-18-Listener">3.18. Listener</a></h4>
Der Listener-Tag ist Teil des Validierungs-Konzeptes. Er hört auf das Event eines Validators und
zeigt seinen Inhalt an, sofern das referenzierte Formular-Element nicht erfolgreich validiert werden
kann. Im Tag selbst können beliebiger Text und weitere Tags definiert werden, die zur
Ausgabe-Formatierung heran gezogen werden können. Details zur Validierung, können dem Kapitel 4
entnommen werden.
<gen:highlight type="apf-xml">
&lt;form:listener [name=""] control="..." [validator="..." ]&gt;
  ...
  [&lt;listener:getstring namespace="" config="" entry="" /&gt;]
  [&lt;listener:placeholder name="" /&gt;]
  [&lt;listener:addtaglib namespace="" class="" prefix="" name=""/&gt;]
  ...
&lt;/form:listener&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>control</strong>: Name des Formular-Elements auf dessen fehlgeschlagene Validierung 
    der Inhalt angezeigt werden soll.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
  <li>
    <strong>name</strong>: Name des Listeners. Dient zur Adressierung des Elements innerhalb des
    Formulars.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
  <li>
     <strong>validator</strong>: Name des Validators, der den Listener bei fehlgeschlagener
     Validierung aktivieren darf.
  </li>
</ul>
<p>
   Der Platzhalter-Tag <em>&lt;listener:placeholder /&gt;</em> gleicht in seiner Funktion
   dem <int:link pageid="046" anchor="Chapter-2-1-Placeholder">&lt;html:placeholder /&gt;</int:link>,
   der <em>&lt;listener:getstring /&gt;</em>-Tag
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>
   und der <em>&lt;listener:addtaglib /&gt;</em>-Tag dem
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link>-Tag.
</p>
<p>
   Zur Befüllung eines Platzhalters in einem Document-Controller kann folgender Code verwendet werden:
</p>
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="name_form" method="post"&gt;
   &lt;form:listener name="name-listener" control="name"&gt;
      Please fill in the &lt;listener:placeholder name="field-name" /&gt; field!
   &lt;/form:listener&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:addvalidator 
      class="TextLengthValidator"
      control="name"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
class form_controller extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('name-form');
      $listener = &$form->getFormElementByName('name-listener');
      $listener->setPlaceHolder('field-name','name');
   }
}
</gen:highlight>
<p>
   Das Attribut <em>validator</em> kann dann verwendet werden, wenn für das relevante
   Formular-Feld <a href="#">spezielle Validator-Listener</a>
   definitiert sind. Ein Anwendungs-Beispiel ist die Prüfung eines E-Mail-Feldes, für das
   jeweils eine eigene Meldung für eine fehlende E-Mail-Adresse und eine syntaktisch nicht
   korrekte Eingabe ausgegeben werden soll. Hierzu kann folgendes Template genutzt werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="email_form" method="post"&gt;
   &lt;form:listener control="email" validator="TextLengthValidator"&gt;
      Please fill in the email field!
   &lt;/form:listener&gt;
   &lt;form:listener control="email" validator="EMailValidator"&gt;
      Please fill in the email field with a correct email address!
   &lt;/form:listener&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="name"
      button="send"
      type="special"
   /&gt;
   &lt;form:addvalidator
      class="EMailValidator"
      control="email"
      button="send"
      type="special"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<div class="warn">
   Bitte beachten Sie, dass Validatoren, die für das Attribut <em>type</em> den Wert
   <em>special</em> enthalten nur spezielle Validator-Listener benachrichtigen. Sofern die oben
   ausgegebenen Validator-Meldungen noch mit einer Markierung versehen werden sollen, bietet sich an,
   einen <em>EMailValidator</em> zu definieren, deren Listener als Rahmen-gebende Elemente fungieren:
<gen:highlight type="apf-xml">
&lt;html:form name="email_form" method="post"&gt;
   &lt;form:listener control="email"&gt;
      &lt;div class="error-container"&gt;
   &lt;/form:listener&gt;
   &lt;form:listener control="email" validator="TextLengthValidator"&gt;
      Please fill in the email field!
   &lt;/form:listener&gt;
   &lt;form:listener control="email" validator="EMailValidator"&gt;
      Please fill in the email field with a correct email address!
   &lt;/form:listener&gt;
   &lt;form:listener control="email"&gt;
      &lt;/div&gt;
   &lt;/form:listener&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="name"
      button="send"
      type="special"
   /&gt;
   &lt;form:addvalidator
      class="EMailValidator"
      control="email"
      button="send"
      type="special"
   /&gt;
   &lt;form:addvalidator
      class="EMailValidator"
      control="email"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
</div>

<h4 id="Chapter-3-19-Error"><a href="#Chapter-3-19-Error">3.19. Anzeige von Formular-Fehlern</a></h4>
Der in Kapitel 3.18 beschriebene Tag kann dazu benutzt werden, automatisiert Fehlermeldungen eines
definierten Formular-Feldes zu erzeugen. Der <nobr><strong>&lt;form:error /&gt;</strong></nobr>-Tag
ist für Fehlermeldungen vorbehalten, die das gesamte Formular betreffen. Wird eines der Felder als
nicht valide markiert, so wird der Inhalt des Tags - sofern in der Formular-Definition vorhanden -
ausgegeben.
<gen:highlight type="apf-xml">
&lt;form:error [name=""]&gt;
  ...
  [&lt;error:getstring namespace="" config="" entry="" /&gt;]
  [&lt;error:placeholder name="" /&gt;]
  [&lt;error:addtaglib namespace="" class="" prefix="" name="" /&gt;]
  ...
&lt;/form:error&gt;
</gen:highlight>
<p>
   Der Platzhalter-Tag <strong>&lt;error:placeholder /&gt;</strong> gleicht in seiner Funktion
   dem <int:link pageid="046" anchor="Chapter-2-1-Placeholder">&lt;html:placeholder /&gt;</int:link>
   der <em>&lt;error:getstring /&gt;</em>-Tag
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>
   und der <em>&lt;error:addtaglib /&gt;</em>-Tag dem
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link>-Tag.
   Die Befüllung des Platzhalters kann identisch zur Vorgehensweise des vorangegangenen Kapitels
   erledigt werden.
</p>

<h4 id="Chapter-3-20-Success"><a href="#Chapter-3-20-Success">3.20. Anzeige von Formular-Erfolgsmeldungen</a></h4>
Der in Kapitel 3.19 beschriebene Tag kann dazu benutzt werden, automatisiert Fehlermeldungen
bezogen auf ein komplettes Formular anzugeigen. Oft ist es jedoch notwendig, auch im Erfolgsfall eine
Meldung auszugeben. Der <nobr><strong>&lt;form:success /&gt;</strong></nobr>-Tag stellt einen Inhalt
dar, wenn alle Felder des Formulars als valide gekennzeichnet werden. Die Definition gestaltet sich
wie folgt:
<gen:highlight type="apf-xml">
&lt;form:success [name=""]&gt;
  ...
  [&lt;success:getstring namespace="" config="" entry="" /&gt;]
  [&lt;success:placeholder name="" /&gt;]
  [&lt;success:addtaglib namespace="" class="" prefix="" name="" /&gt;]
  ...
&lt;/form:success&gt;
</gen:highlight>
<p>
   Der Platzhalter-Tag <strong>&lt;success:placeholder /&gt;</strong> gleicht in seiner Funktion
   dem <int:link pageid="046" anchor="Chapter-2-1-Placeholder">&lt;html:placeholder /&gt;</int:link>,
   der <em>&lt;success:getstring /&gt;</em>-Tag
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link> und der
   <em>&lt;success:addtaglib /&gt;</em>-Tag dem
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link>-Tag.
   Die Befüllung des Platzhalters kann identisch zur Vorgehensweise des vorangegangenen Kapitels
   erledigt werden.
</p>
      
<h4 id="Chapter-3-21-TimeCaptcha"><a href="#Chapter-3-21-TimeCaptcha">3.21. TimeCaptcha</a></h4>
<p>
   Mit dem <strong>TimeCaptcha</strong> kann ein Formular in Kombination mit dem 
   <a href="#Chapter-4-1-15-TimeCaptchaValidator">TimeCaptchaValidator</a> vor (Spam-)Bots
   geschützt werden. Hierzu speichert die Taglib den Zeitpunkt der Erstellung in der Session
   und macht diesen für den genannten Validator zur Auswertung verfügbar.
</p>
<p>
   Die minimale Zeitspanne, die Benutzer zum Ausfüllen des Formulars brauchen sollte, kann
   durch Angabe des optionalen Attributs <em>seconds</em> beeinflusst werden. Der Wert muss eine
   ganzzahlige Angabe des Zeitraums beinhalten.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   <form:timecaptcha name="timecaptcha" [seconds="3"]/>
   ...
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-3-22-CSRF-Schutz"><a href="#Chapter-3-22-CSRF-Schutz">3.22. CSRF-Schutz</a></h4>
<p>
   Diese Taglib erzeugt ein verstecktes Feld, das einen generierten Hash enthält. Das Formular wird
   als ungültig gekennzeichnet, wenn sich der im Request enthaltene Hash von einem neu generiertem
   unterscheidet. Damit ist es möglich, ein Formular vor CSRF-Attacken zu schützen.
</p>
<div class="hint">
   Der mitgelieferte <em>CSRFHashValidator</em> muss nicht manuell hinzugefügt werden, da dies
   bereits in der Taglib geschieht.
</div>
<p>
   Zur Generierung des Hashs wird das Provider Pattern genutzt, wodurch der Algoritgmus leicht
   ausgetauscht werden kann. Die Provider-Klasse muss dafür das <em>CSRFHashProvider</em>-Interface
   implementieren, welches die Methode <em>generateHash()</em> vorsieht.
</p>
<p>
   Die folgende Code-Box zeigt den mit dem Release mitgelieferten Provider:
</p>
<gen:highlight type="php">
class EncryptedSIDHashProvider extends APFObject implements CSRFHashProvider {
   public function generateHash($salt) {
      if(!defined('SID')) {
         session_start();
      }

      return md5($salt.SID);
   }
}   
</gen:highlight>
<p>
   Der zu verwendende Provider wird mittels den Attributen <em>namespace</em> und <em>class</em>
   angegeben. Werden die Attribute nicht gesetzt, wird der Standardprovider genutzt, welcher
   einen MD5 Hash von der SID und dem angegebenem Salt liefert.
</p>
<gen:highlight type="apf-xml">
&lt;form:csrfhash
   salt=""
   name=""
   [namespace=""
   class=""]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>salt</strong>: Der Salt, der zur sicheren Berechnung des Hash eingesetzt wird.
  </li>
  <li>
     <strong>name</strong>: Der Name des Feldes (<strong>Zeichen</strong>: [A-Za-z0-9_]).
  </li>
  <li>
     <strong>namespace</strong>: Der Namespace des Hash-Providers.
  </li>
  <li>
     <strong>class</strong>: Der Klassen-Name des Hash-Providers.
  </li>
</ul>

<h4 id="Chapter-3-23-Zeit-Control"><a href="#Chapter-3-23-Zeit-Control">3.23. Zeit-Control</a></h4>
<p>
   Um die Erstellung von Zeit-Auswahl-Menüs zu erleichtern, enthält das APF ein Time-Control.
   Dieses kann entsprechend den Anforderungen konfiguriert werden:
</p>
<gen:highlight type="apf-xml">
&lt;form:time
   name=""
   [hoursrange=""]
   [offsetnames=""]
   [showseconds="true|false"]
   [minutesinterval=""]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Time-Controls. Über den Namen kann auf das Element zugegriffen
    werden.
    (<strong>Zeichen</strong>: [A-Za-z0-9-_])
  </li>
  <li>
     <strong>hoursrange</strong>: Range des Stunden-Feldes. Beispiel: <em>08-21</em>.
     (<strong>Zeichen</strong>: [0-9-])
  </li>
  <li>
     <strong>offsetnames</strong>: Namen der Felder für Stunden, Minuten und Sekunden. Einzelne
     Felder müssen durch ";" getrennt werden. Beispiel: <em>Stunde;Minute;Sekunde</em>.
     (<strong>Zeichen</strong>: [A-Za-z;])
  </li>
  <li>
     <strong>showseconds</strong>: Hier kann festgelegt werden ob bei der Ausgabe auch ein 
     Sekunden-Feld angezeigt werden soll.
  </li>
  <li>
     <strong>minutesinterval</strong>: Mit diesem Attribut kann definiert werden in welchem Abstand
     die auswählbaren Minuten vorhanden sind. Man sollte aber darauf achten, dass 60 durch den Wert
     sinnvoll teilbar ist. Beispiel: 5, 10 oder 15.
  </li>
</ul>

<h4 id="Chapter-3-24-MultiFileUpload"><a href="#Chapter-3-24-MultiFileUpload">3.24. MultiFileUpload</a></h4>
<p>
   Seit dem Release des APF in der Version 1.16 gibt es ein weitere nützliches Tool: den MultiFileUpload. Alle
   wichtigen Informationen diesbezüglich entnehmen Sie bitte dem Wiki-Beitrag:
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/MultiFileUpload" title="MultiFileUpload im Wiki">MultiFileUpload im Wiki</a>
</p>

<h4 id="Chapter-3-25-Label"><a href="#Chapter-3-25-Label">3.25. Label</a></h4>
<p>
   Seit Version 1.17 ist es möglich, die Beschriftung eines Formular-Elements als APF-Tag zu definieren.
</p>
<p>
   Der Label-Tag hat folgende Signatur:
</p>
<gen:highlight type="apf-xml">
&lt;form:label for=""&gt;
   [...]
   [&lt;label:getstring [name=""] namespace="" config="" entry="" /&gt;]
&lt;/form:label&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>for</strong>: HTML-Id des Formular-Elements auf das sich die Beschriftung bezieht.
      (<strong>Zeichen</strong>: [A-Za-z0-9-_])
   </li>
   <li>
      <strong>Inhalt</strong>: Der Inhalt des Tags kann entweder durch einen statischen Text oder mit Hilfe eines
      <em>&lt;label:getstring /&gt;</em>-Tags definiert werden.
   </li>
</ul>
<div class="hint">
   Details zur Definition der für den <em>&lt;button:getstring /&gt;</em>-Tag notwendigen Konfigurations-Dateien
   können der Dokumentation des Tags <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>
   entnommen werden.
</div>

<h3 id="Chapter-4-Validierung"><a href="#Chapter-4-Validierung">4. Validierung</a></h3>
<p>
   In den bisherigen Versionen des APF wurde die Validierung direkt mit einem Formular-Element
   verknüpft und diese auch im <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Lifecycle einer Taglib</int:link>
   ausgeführt. Das hat zum Nachteil, dass ein Element mit nur einem Validator belegt werden kann und
   sich häufig redundanter Code durch Definition der Validatoren pro Feld ergibt. Weiterhin war es
   nicht ohne Weiteres möglich eigene Validatoren einzuhängen.
</p>
<p>
   Ab Version 1.11 wurden diese Umstände berücksichtigt und die Formular-Taglibs auf eine neue
   Variante der Validierung umgestellt. Ab dieser Version werden Validatoren über ein eigenes
   Tag, das nach dem
   <a class="external" href="http://de.wikipedia.org/wiki/Observer_%28Entwurfsmuster%29" title="Observer-Pattern ">Observer-Pattern</a>
   implementiert ist, an das einzelne Element gebunden. So ist es möglich, mehrere Validatoren auf ein
   Feld anzusetzen, eigene Validatoren zu schreiben und mit einer Observer-Definition mehrere Felder
   zu gleichermaßen zu validieren.
</p>
<p>Die Definition einer Validierung eines Formular-Feldes gestaltet sich dabei wie folgt:</p>
<gen:highlight type="apf-xml">
&lt;form:addvalidator
   namespace=""
   class=""
   button=""
   control=""
   [type="special"]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Namespace der Validator-Implementierung.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>class</strong>: Name der Validator-Implementierung (Name = Klassen-Name!)
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>button</strong>: Name des Buttons, der die Validierung auslösen soll. Die Validierung
    ist immer an das Event <em>isSent</em> eines Buttons oder Image-Buttons gebunden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>control</strong>: Name des Formular-Controls auf das die Validierung Anwendung finden
    soll. Sollen mehrere Controls mit der im Tag definierten Validierung belegt werden, so enthält
    das Attribut alle mit Pipe getrennte Feld-Namen (z.B. <em>sender|recipient|subject</em>).
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_|]</code>)
  </li>
  <li>
     <strong>type</strong>: Sofern das optionale Attribut vorhanden und auf den Wert <em>special</em>
     gesetzt ist, werden nur noch Listener informiert, die im Attribut <em>validator</em> den Namen
     (=Klassen-Namen) des mit dem Tag definierten Validators enthalten. 
     (<strong>Zeichen</strong>: <code>special</code>)
  </li>
</ul>
<div class="hint">
   Für mitgelieferte Validatoren muss das Attribut <strong>namespace</strong> nicht definiert
   werden. Hier verwendet die Taglib automatisch <strong>tools::form::validator</strong> als Wert.
   Unter diesem Namespace finden sich alle enthaltenen Validatoren, die im Kapitel 4.1. aufgeführt
   sind.
</div>
<div class="hint">
   Hinweise zu speziellen Validator-Listenern findet sich auch im Wiki-Artikel
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/Spezielle_Validator-Listener" title="Spezielle Validator-Listener">Spezielle Validator-Listener</a>.
</div>
<p>
   In der Version 1.12 wurde die Markierung von invaliden Formular-Elementen auf CSS-Klassen
   umgestellt. Dies ermöglicht flexiblere Formatierung pro Formular oder Anwendungsfall. Das Proposal
   zur Implementierung kann unter
   <a class="wiki" href="http://wiki.adventure-php-framework.org/de/Weiterentwicklung_Formular-Validierung" title="Weiterentwicklung Formular-Validierung">Weiterentwicklung Formular-Validierung</a>
   nachgelesen werden.
</p>
<p>
   Im Standard-Fall werden von Validatoren als fehlerhaft markierte Felder mit der CSS-Klasse
   <em>apf-form-error</em> ausgestattet. Ist dies nicht erwünscht, kann diese Klasse durch Setzen
   des Attributs <em>valmarkerclass</em> beim jeweiligen Formular-Element beeinflusst werden:
</p>
<gen:highlight type="apf-xml">
<form:text
   name="age"
   valmarkerclass="special-val-marker"
/>
</gen:highlight>
<p>
   Um alle fehlerhaften Formular-Elemente innerhalb eines Web-Projekts mit einem roten Rahmen zu
   versehen, muss das CSS folgende Klassen-Definition enthalten:
</p>
<gen:highlight type="css">
.apf-form-error {
   border: 2px solid red;
}
</gen:highlight>
<p>
   Die speziellen Klassen-Definitionen müssen ebenfalls im CSS abgebildet werden. Andernfalls wird
   ein als invalid gekennzeichnetes Feld u.U. optisch nicht als solches hervorgehoben.
</p>

<h4 id="Chapter-4-1-Verfuegbare-Validatoren"><a href="#Chapter-4-1-Verfuegbare-Validatoren">4.1. Verfügbare Validatoren</a></h4>
<p>
   Wie auch in den Releases < 1.11 werden eine Reihe von Validatoren mitgeliefert. Diese decken
   üblicherweise den Großteil der Anforderungen ab. Sollten diese nicht genügen, können eigene
   Validatoren implementiert werden. Dies ist im nächsten Kapitel beschrieben.
</p>
<div class="hint">
   Ab dem Release 1.13 können Validatoren auch als optional deklariert werden. Dazu muss das
   optional zu validierende Formular-Feld das Attribut <em>optional</em> mit dem Wert <em>true</em>
   besitzten:
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="age" optional="true"/&gt;
   &lt;form:addvalidator
      class="IntegerValidator"
      button="send"
      control="age"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
   Bitte beachten Sie, dass optionale Validatoren aktuell nur für Text-Felder implementiert sind,
   da Select- und Checkbox-Felder hinsichtlich ihrer Verwendung nach Meinung der APF-Entwickler
   keine optionale Validierung benötigen.
</div>

<p>Aktuell sind folgende Validatoren im Release verfügbar:</p>

<h5 id="Chapter-4-1-1-TextLengthValidator"><a href="#Chapter-4-1-1-TextLengthValidator">4.1.1. TextLengthValidator</a></h5>
<p>
   Der <strong>TextLengthValidator</strong> überprüft ein Text-Formular-Feld (Text-Feld,
   Passwort-Feld, Text-Area), ob der enthaltene Text eine Mindestlänge aufweist. Standardmäßig
   wird von einer Länge von mindestens 3 Zeichen ausgegangen, die vom Benutzer eingegeben werden
   müssen, ehe das Feld als gültig markiert wird. Sofern eine andere Text-Länge als
   valide Eingabe erwünscht ist, kann dies im referenzierten Text-Feld mit den Attributen
   <strong>minlength</strong> und <strong>maxlength</strong> angegeben werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="firstname" /&gt;
   &lt;form:text name="lastname" minlength="5" /&gt;
   &lt;form:password name="pass" /&gt;
   &lt;form:area name="comment" minlength="20" maxlength="200"/&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      button="send"
      control="firstname|lastname|pass|comment"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Im abgebildeten Code-Block wird das Formular-Control <strong>firstname</strong> auf einen Text
   mit einer Zeichenlänge &gt;=3 validiert, im Feld <strong>lastname</strong> müssen
   mindestens 5 aber höchstens 200 Zeichen enthalten sein.
</p>
<p>
   Seit dem Release 1.12 ist es möglich, eine strikte Validierung der Textlänge zu
   aktivieren. Hierzu kann im referenzierten Text-Feld das Attribut <strong>mode</strong> mit dem
   Wert <em>strict</em> versehen werden. Ab diesem Zeitpunkt wendet der Validator die Funktion
   <em>trim()</em> auf die Eingabe an und erkennt nur Inhalte an, die nicht lediglich aus Leerzeichen
   bestehen.
</p>

<h5 id="Chapter-4-1-2-NumberValidator"><a href="#Chapter-4-1-2-NumberValidator">4.1.2. NumberValidator</a></h5>
Der <strong>NumberValidator</strong> prüft, ob ein Text-Feld eine gültige Nummer enthält. Hierzu
wird die PHP-Funktion <em>is_numeric()</em> genutzt.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="number" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="NumberValidator"
      button="send"
      control="number"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-3-EMailValidator"><a href="#Chapter-4-1-3-EMailValidator">4.1.3. EMailValidator</a></h5>
Der <strong>EMailValidator</strong> prüft, ob im referenzierten ein Form-Control eine gültige
E-Mail-Addresse steht. Hierzu wird der Inhalt des Text-Feldes gegen einen regulären Ausdruck
geprüft.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="EMailValidator"
      button="send"
      control="email"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-4-PhoneAndFaxValidator"><a href="#Chapter-4-1-4-PhoneAndFaxValidator">4.1.4. PhoneAndFaxValidator</a></h5>
Der <strong>PhoneAndFaxValidator</strong> prüft, ob ein Formular-Feld eine gültige Telefon-
oder Fax-Nummer enthält. Hierzu wird der Inhalt des Text-Feldes gegen einen regulären Ausdruck
geprüft.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="phone" /&gt;
   &lt;form:text name="fax" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="PhoneAndFaxValidator"
      button="send"
      control="phone|fax"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-5-FieldCompareValidator"><a href="#Chapter-4-1-5-FieldCompareValidator">4.1.5. FieldCompareValidator</a></h5>
Mit dem <strong>FieldCompareValidator</strong> ist es möglich, den Inhalt zweiter Felder mit
einander zu vergleichen. Stimmen sie nicht überein, werden die beiden Felder auf <em>invalid</em>
gesetzt.
<br />
<br />
Da ein Validator immer auf ein konkretes Control gesetzt wird, muss das Haupt-Feld definieren,
welches Formular-Element als Referenz-Feld genutzt wird. Hierzu definiert dieses das Attribut
<strong>ref</strong>, das den Namen des Referenz-Feldes enthält.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:password name="pass" ref="pass2" /&gt;
   &lt;form:password name="pass2" /&gt;
   &lt;form:addvalidator
      class="FieldCompareValidator"
      control="pass"
      button="login"
   /&gt;
   &lt;form:button name="login" value="login" /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-6-SimpleBirthdayValidator"><a href="#Chapter-4-1-6-SimpleBirthdayValidator">4.1.6. SimpleBirthdayValidator</a></h5>
Der <strong>SimpleBirthdayValidator</strong> prüft ein Text-Feld auf ein korrektes Datum der Form
<strong>dd.MM.YYYY</strong>.
<div class="hint">
   Der Validator kann nur mit &quot;normalen&quot; Text-Feldern verwendet werden. Sofern ein
   Date-Control validiert werden soll, muss der
   <a href="#Chapter-4-1-11-SimpleDateControlValidator" title="4.1.11. SimpleDateControlValidator">SimpleDateControlValidator</a>
   genutzt oder ein eigener Validator implementiert werden.
</div>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="birthday" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleBirthdayValidator"
      button="send"
      control="birthday"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-7-DefaultSelectFieldValidator"><a href="#Chapter-4-1-7-DefaultSelectFieldValidator">4.1.7. DefaultSelectFieldValidator</a></h5>
<div class="warn">
   Der <strong>DefaultSelectFieldValidator</strong> wurde mit dem Release 1.13 entfernt. Bitte nutzen
   Sie statt dessen den <a href="#Chapter-4-1-8-SimpleSelectControlValidator">SimpleSelectControlValidator</a>.
   Dieser kann sowohl im Fall von statisch als auch dynamisch gefüllten Select-Feldern eingesetzt
   werden.
</div>

<h5 id="Chapter-4-1-8-SimpleSelectControlValidator"><a href="#Chapter-4-1-8-SimpleSelectControlValidator">4.1.8. SimpleSelectControlValidator</a></h5>
Der <strong>SimpleSelectControlValidator</strong> ist für die Prüfung von statischen und
dynamischen Select-Formular-Feldern geeignet. Er prüft ein Select-Feld, ob der ausgewählte Inhalt
nicht leer ist.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:select name="color"&gt;
      &lt;select:option value=""&gt;&lt;/select:option&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:select&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleSelectControlValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-9-MultiSelectFieldValidator"><a href="#Chapter-4-1-9-MultiSelectFieldValidator">4.1.9. MultiSelectFieldValidator</a></h5>
Der <strong>MultiSelectFieldValidator</strong> ist das Pendant zum
<strong>SimpleSelectControlValidator</strong>. Er prüft Multi-Select-Felder auf eine nicht leere
Auswahl.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:multiselect name="colors"&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:multiselect&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="MultiSelectFieldValidator"
      button="send"
      control="colors"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-10-SimpleRadioControlValidator"><a href="#Chapter-4-1-10-SimpleRadioControlValidator">4.1.10. SimpleRadioControlValidator</a></h5>
Mit dem <strong>SimpleRadioControlValidator</strong> kann ein Radio-Button, bzw. eine ganze Gruppe
validiert werden. Anforderung des Validators ist, das eine Option der Gruppe ausgewählt ist. Der
Validator ist sowohl für dynamische als auch für statische Formular-Definitionen geeignet.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:radio id="red" name="color" /&gt; Red color
   &lt;form:radio id="green" name="color" /&gt; Green color
   &lt;form:radio id="blue" name="color" /&gt; Blue color
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleRadioControlValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-11-SimpleDateControlValidator"><a href="#Chapter-4-1-11-SimpleDateControlValidator">4.1.11. SimpleDateControlValidator</a></h5>
Der <strong>SimpleDateControlValidator</strong> validiert ein Date-Control (siehe Kapitel 3.14.).
Er erwartet, dass das dort ausgewählte Datum größer als das heutige ist.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:date name="birthday" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="SimpleDateControlValidator"
      button="send"
      control="birthday"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-12-MimeTypeValidator"><a href="#Chapter-4-1-12-MimeTypeValidator">4.1.12. MimeTypeValidator</a></h5>
<p>
   Der <strong>MimeTypeValidator</strong> prüft, ob der MIME-Typ der hochgeladenen Datei in
   der Liste der akzeptierten Typen zu finden ist. Die Liste der zugelassenen Datei-Typen wird als
   Pipe-separierte Liste im Attribut <em>accepts</em> des zu validierenden Formular-Elements
   erwartet. 
</p>
<p>
   Die Evaluierung der Datei-Typen wird <strong>ab PHP 5.3</strong> mit Hilfe der 
   <em>finfo</em>-Funktionen durchgeführt, für alle früheren Versionen wird die
   Information genutzt, die von PHP im Offset <em>type</em> des <em>$_FILES</em>-Array zur
   Verfügung gestellt wird (siehe auch 
   <a class="external" href="http://de.php.net/manual/en/reserved.variables.files.php" title="$_FILES">$_FILES</a>
   im PHP-Manual).
</p>
<div class="warn">
   Aus der Bestimmung der Inhalts-Typen kann sich eine Änderung der Definition der akzeptierten
   Medien ergeben. Ab der PHP Version 5.3 können die akzeptierten Typen in der
   MIME-Typen-Schreibweise (z.B. <em>application/pdf</em>) definiert werden, in PHP Versionen < 5.3
   lediglich über die Endung (z.B. <em>pdf</em>).
</div>
<p>
   Im folgenden Formular akzeptiert ein Dateiupload-Feld lediglich PDF-Dateien. Das Formular wird
   solange als invalid gekennzeichnet, bis der Benutzer das richtige Datei-Format gewählt hat:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="upload" method="post"&gt;
   <fieldset>
      <label for="pdf">PDF file:</label>
      <form:file name="pdf" id="pdf" accepts="pdf|application/pdf" />
      <form:addvalidator
         class="MimeTypeValidator"
         control="pdf"
         button="send"
      />
      <form:button name="send" value="GO" />
   </fieldset>
&lt;/html:form&gt;
</gen:highlight>
<p>
   Wie dem Attribut <em>accepts</em> zu entnehmen ist, wurden hier aus Gründen der
   Kompatibilität beide Schreibweisen der Type-Definitionen eingefügt um bei einem
   Version-Upgrade weiter die gewünschte Funktion zu erhalten.
</p>

<h5 id="Chapter-4-1-13-FileSizeValidator"><a href="#Chapter-4-1-13-FileSizeValidator">4.1.13. FileSizeValidator</a></h5>
<p>
   Der <strong>FileSizeValidator</strong> prüft die hochgeladene Datei auf ihre
   Datei-Größe. Hierzu werden die optionalen Attribute <em>minsize</em> und <em>maxsize</em>
   genutzt um den Bereich der erlaubten Datei-Größe <strong>in Bytes</strong> zu definieren.
</p>
<p>
   Ist das Attribut <em>minsize</em> im zu validierenden Formular-Element nicht definiert, wird ein
   Wert von <em>0</em> angenommen. Es ist damit möglich, 0-Byte-Dateien hochzuladen. Ist das
   Attribut <em>maxsize</em> nicht definiert, wird eine maximale Größe von <em>1024000</em>
   (=1 MB) zugelassen.
</p>
<p>
   Im folgenden Formular werden nur Dateien zugelassen, die eine Mindest-Größe von
   <em>20kB</em> und eine maximale Größe von <em>500kB</em> haben:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="upload" method="post"&gt;
   <fieldset>
      <label for="image">Image:</label>
      <form:file name="image" id="image" minsize="20480" maxsize="512000" />
      <form:addvalidator
         class="FileSizeValidator"
         control="image"
         button="send"
      />
      <form:button name="send" value="GO" />
   </fieldset>
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-14-CheckboxValidator"><a href="#Chapter-4-1-14-CheckboxValidator">4.1.14. CheckboxValidator</a></h5>
<p>
   Der <strong>CheckboxValidator</strong> prüft, ob eine Checkbox aktiviert wurde. Ist diese
   nicht der Fall, wird das Feld als invalid markiert.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="upload" method="post"&gt;
   <fieldset>
      ...
      <form:checkbox name="agb" value="agb" /> Akzeptiere die AGBs.
      <form:addvalidator
         class="CheckboxValidator"
         button="send"
         control="agb"
      />
      <form:button name="send" value="GO" />
   </fieldset>
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-15-TimeCaptchaValidator"><a href="#Chapter-4-1-15-TimeCaptchaValidator">4.1.15. TimeCaptchaValidator</a></h5>
<p>
   Mit dem <strong>TimeCaptchaValidator</strong> kann ein Formular in Kombination mit dem
   <a href="#Chapter-3-21-TimeCaptcha">&lt;form:timecaptcha /&gt;</a> vor (Spam-)Bots geschützt
   werden. Der Validator prüft die Zeit, welche zum Ausfüllen des Formulars gebraucht wurde.
   Da Bots Formulare meistens binnen Sekundenbruchteilen ausfüllen, genügt es
   standartmäßig alle Formulare, welche in weniger als 2 Sekunden ebgeschickt wurden als
   invalid zu kennzeichnen. Dieser Wert kann durch Angabe des optionalen <em>seconds</em> Parameters
   in der Taglib-Definition beeinflusst werden.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   <form:timecaptcha name="timecaptcha"/>
   <form:addvalidator
      class="TimeCaptchaValidator"
      button="send"
      control="timecaptcha"
   />
   <form:button name="send" value="Send"/>
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-16-IntegerValidator"><a href="#Chapter-4-1-16-IntegerValidator">4.1.16. IntegerValidator</a></h5>
<p>
   Der <em>IntegerValidator</em> validiert, ob die Eingabe einen validen Integer-Wert enthält:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="age" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="IntegerValidator"
      button="send"
      control="age"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-4-2-Aufbau-von-Validatoren"><a href="#Chapter-4-2-Aufbau-von-Validatoren">4.2. Aufbau von Validatoren</a></h4>
Validatoren sind Klassen, die von <strong>AbstractFormValidator</strong> erben. Diese definiert das
Interface aller Formular-Validatoren. Das ist notwendig, damit diese als Observer an alle
Formular-Elemente geheftet werden können.
<br />
<br />
Das Interface eines Validators hat folgende gestalt:
<gen:highlight type="php">
abstract class AbstractFormValidator extends APFObject {

   protected $control;
   protected $button;

   public function AbstractFormValidator(AbstractFormControl &$control, AbstractFormControl &$button){
      $this->control = &$control;
      $this->button = &$button;
   }

   public abstract function validate($input);

   public abstract function notify();

   public function isActive(){
      return $this->button->isSent();
   }

}
</gen:highlight>
Über den Konstruktor werden das zu validierende Form-Control und der Button, der als Trigger
fungiert injiziert. Die Methode <strong>validate()</strong> wird vom Formular-Element mit dem zu
validierenden Inhalt versorgt und muss den Validierungs-Code enthalten. Als Rückgabe wird
<em>true</em> im Erfolgsfall und <em>false</em> im Fehlerfall erwartet.
<br />
<br />
Die Methode <strong>notify()</strong> wird aufgerufen, wenn ein Formular-Element nicht erfolgreich
validiert werden konnte. Dieses kann dazu dienen, die Formular-Elemente mit weiteren
CSS-Formatierungen zu versehen, Platzhalter zu füllen oder Änderungen am DOM-Baum vorzunehmen.
Die übliche Vorgehensweise ist, das Feld entsprechen zu markieren und die registrierten Listener
zu benachrichtigen.
<br />
<br />
Die Klassen-Variablen <strong>$control</strong> und <strong>$button</strong> enthalten jeweils
die Instanz des zu validieren Formular-Elements und den Button, der als Trigger verwendet wird.
<br />
<br />
Voraussetzung für die Funktion von Validatoren ist, dass ein Formular-Element die Validierung
unterstützt. Hierzu muss in jedem Formular-Control die Methode <strong>addValidator()</strong>
implementiert sein. Diese in der Klasse <strong>AbstractFormControl</strong> definierte Methode hat
folgende Signatur:
<gen:highlight type="php">
public function addValidator(AbstractFormValidator &$validator){
   if($validator->isActive()){
      if(!$validator->validate($this->getAttribute('value'))){
         $validator->notify();
      }
   }
}
</gen:highlight>
Wie im Code-Snippet zu sehen ist, nimmt die Methode eine Instanz eines Validators entgegen, führt
diesen - falls als aktiv gekennzeichnet - aus und involviert die <strong>notify()</strong>-Methode
bei nicht erfolgreicher Validierung.
<br />
<br />
Wie ebenfalls zu erkennen ist, wird dem Validator <em>by default</em> das Tag-Attribut
<strong>value</strong> übergeben, was nur für Text-Felder gültig ist. Aus diesem Grund
überschreiben Nicht-Text-Felder diese Methode und übergeben dem Validator den relevanten
Inhalt.
<br />
<br />
<br />
<h4 id="Chapter-4-3-Implementierung-von-Validatoren"><a href="#Chapter-4-3-Implementierung-von-Validatoren">4.3. Implementierung von Validatoren</a></h4>
Wie bereits im letzten Kapitel angesprochen, muss ein Validator von der Klasse
<strong>AbstractFormValidator</strong> erben. Das APF enthält daneben noch einige weitere
Basis-Klassen, die für die Implementierung von Validatoren verwendet werden können. Diese sind:
<ul>
   <li><strong>TextFieldValidator:</strong> Basis für alle Text-Feld Validatoren</li>
   <li><strong>SelectFieldValidator:</strong> Basis für alle Select-Feld Validatoren</li>
</ul>
Diese sehen bereits vor, welche Änderungen am Formular-Element im Fehlerfall vorgenommen werden
und welche Listener zu benachrichtigen sind.
<br />
<br />
Für die Implementierung eines eigenen Validators muss folgendes beachtet werden:
<ul>
   <li>Der Validator muss von von der Klasse <strong>AbstractFormValidator</strong> erben.</li>
   <li>
      Mit Hilfe der Methode <strong>markAsInvalid()</strong> kann ein Formular-Element als
      invalide gekennzeichnet werden.
   </li>
   <li>
      Mit Hilfe der Methode <strong>notifyValidationListeners()</strong> können die Listener 
      eines übergebenen Elements benachrichtigt werden.
   </li>
   <li>
      Über den Button (Methode: <strong>isSent()</strong>)kann der Entwickler abfragen, ob das
      Formular mit Klick auf diesen abgesendet wurde.
   </li>
</ul>
<br />
<h3 id="Chapter-5-Filter"><a href="#Chapter-5-Filter">5. Filter</a></h3>
In den bisherigen Versionen des APF wurde die Filterung von Formular-Element-Werten ebenfalls direkt
mit einem Formular-Element verknüpft und im <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Lifecycle einer Taglib</int:link>
ausgeführt. Hieraus ergeben sich ähnliche Nachteile wie es bei der Validierung der Fall ist.
Deshalb wurde auch die Filterung in der Version 1.11 nach dem Konzept der Validierung angepasst.
Ab Version 1.11 können Filter gleichermaßen als Observer auf ein Formular-Element angewendet
werden.
<br />
<br />
<div class="hint">
   Die Filterung von Formular-Felder wird <strong>vor</strong> der Validierung ausgeführt um zu
   verhindern, dass Eingaben, die durch einen Filter entfernt werden, eine positive Validierung
   erzeugen. Dies ist insbesondere beim <strong>TextLengthValidator</strong> relevant.
</div>
<br />
Die Definition der Filterung eines Formular-Feldes gestaltet sich dabei wie folgt:
<gen:highlight type="apf-xml">
&lt;form:addfilter
   namespace=""
   class=""
   button=""
   control=""
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>namespace</strong>: Namespace der Filter-Implementierung.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>class</strong>: Name der Filter-Implementierung (Name = Klassen-Name!)
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>button</strong>: Name des Buttons, der die Filterung auslösen soll. Die Filterung
    ist immer an das Event <em>isSent</em> eines Buttons oder Image-Buttons gebunden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>control</strong>: Name des Formular-Controls auf das die Filterung Anwendung finden
    soll. Sollen mehrere Controls mit der im Tag definierten Filterung belegt werden, so enthält
    das Attribut alle mit Pipe getrennte Feld-Namen (z.B. <em>sender|recipient|subject</em>).
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_|]</code>)
  </li>
</ul>
<div class="hint">
   Für mitgelieferte Filter muss das Attribut <strong>namespace</strong> nicht definiert
   werden. Hier verwendet die Taglib automatisch <strong>tools::form::filter</strong> als Wert.
   Unter diesem Namespace finden sich alle enthaltenen Filter, die im Kapitel 5.1. aufgeführt
   sind.
</div>
<div class="warn">
   Bitte beachten Sie, dass die Filterung von Werten lediglich innerhalb der Formular-Elemente greift. Die Werte in den
   Superglobals <em>$_GET</em>, <em>$_POST</em> und <em>$_REQUEST</em> bleiben davon unberührt. Es empfiehlt sich daher
   dringend, Inhalte direkt aus den Formular-Komponenten zu beziehen.
</div>

<h4 id="Chapter-5-1-Verfuegbare-Filter"><a href="#Chapter-5-1-Verfuegbare-Filter">5.1. Verfügbare Filter</a></h4>
<p>
   Wie auch in den Releases vor Version 1.11 werden eine Reihe von Filter mitgeliefert. Diese decken
   üblicherweise den Großteil der Anforderungen ab. Sollten diese nicht genügen, können
   eigene Filter implementiert werden. Dies ist im nächsten Kapitel beschrieben.
</p>
<div class="hint">
   <p>
      Ab Version 1.14 lassen sich die regulären Ausdrücke zahlreicher Filter über das Tag-Attribut 
      <em>filter-expr</em> des zu filternden Formular-Elements steuern. Dies hilft beispielsweise
      Zeichensatz-Probleme wie im 
      <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=10&amp;t=643#p6275">Forum</a>
      diskutiert vermeiden. 
   </p>
   <p>
      Folgende Filter unterstützen das Überschreiben des Filter-Ausdrucks:
   </p>
   <ul>
      <li>SpecialCharacterFilter</li>
      <li>OnlyNumbersFilter</li>
      <li>OnlyLettersFilter</li>
      <li>OnlyIntegersFilter</li>
      <li>NoSpecialCharactersFilter</li>
      <li>EMailFilter</li>
   </ul>
   <p>
      Darüber hinaus verwenden Zeichensatz-sensitive Funktions-Aufrufe der Filter nun den per
      <int:link pageid="067" /> global konfigurierten Zeichensatz. 
   </p>
</div>
<p>
   Aktuell sind folgende Filter im Release verfügbar:
</p>

<h5 id="Chapter-5-1-1-EMailFilter"><a href="#Chapter-5-1-1-EMailFilter">5.1.1. EMailFilter</a></h5>
Der <strong>EMailFilter</strong> entfernt alle Zeichen, die für eine E-Mail-Adresse nicht relevant
sind.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="EMailFilter"
      button="send"
      control="email"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-2-NoSpecialCharactersFilter"><a href="#Chapter-5-1-2-NoSpecialCharactersFilter">5.1.2. NoSpecialCharactersFilter</a></h5>
Der <strong>NoSpecialCharactersFilter</strong> filtert alle Zeichen, die nicht dem regulären
Ausdruck <strong>[^0-9A-Za-z-_\.& ]</strong> genügen.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="simplechars" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="NoSpecialCharactersFilter"
      button="send"
      control="simplechars"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-3-OnlyHTMLEntitiesFilter"><a href="#Chapter-5-1-3-OnlyHTMLEntitiesFilter">5.1.3. OnlyHTMLEntitiesFilter</a></h5>
Mit dem <strong>OnlyHTMLEntitiesFilter</strong> kann erreicht werden, dass Sonderzeichen in ihre
HTML Entity Entsprechungen umgewandelt werden. Hierbei muss jedoch beachtet werden, dass bei
mehrmaligem Abschicken, Mehrfach-Codierungen möglich sind.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="htmlentitiestext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyHTMLEntitiesFilter"
      button="send"
      control="htmlentitiestext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-4-OnlyIntegersFilter"><a href="#Chapter-5-1-4-OnlyIntegersFilter">5.1.4. OnlyIntegersFilter</a></h5>
Der <strong>OnlyIntegersFilter</strong> lässt nur Ziffern zu und filtert alle anderen Zeichen.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="zipcode" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyIntegersFilter"
      button="send"
      control="zipcode"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-5-OnlyLettersFilter"><a href="#Chapter-5-1-5-OnlyLettersFilter">5.1.5. OnlyLettersFilter</a></h5>
Mit dem <strong>OnlyLettersFilter</strong> werden nur Standard-Zeichen des Alphabets zugelassen.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="productcode" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyLettersFilter"
      button="send"
      control="productcode"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-6-OnlyNumbersFilter"><a href="#Chapter-5-1-6-OnlyNumbersFilter">5.1.6. OnlyNumbersFilter</a></h5>
Der <strong>OnlyNumbersFilter</strong> lässt nur Ziffern und Interpunktionen zu, die für die
Trennung von 1000er Blöcken und Nachkommastellen notwendig sind.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="productprice" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="OnlyNumbersFilter"
      button="send"
      control="productprice"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-7-SpecialCharacterFilter"><a href="#Chapter-5-1-7-SpecialCharacterFilter">5.1.7. SpecialCharacterFilter</a></h5>
Mit dem <strong>SpecialCharacterFilter</strong> werden nur Zeichen zugelassen, die im normalen
Satzbau notwendig sind.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="simpletext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="SpecialCharacterFilter"
      button="send"
      control="simpletext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-8-String2LowerFilter"><a href="#Chapter-5-1-8-String2LowerFilter">5.1.8. String2LowerFilter</a></h5>
Der <strong>String2LowerFilter</strong> wandelt alle Buchstaben in Klein-Buchstaben um.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="lowertext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="String2LowerFilter"
      button="send"
      control="lowertext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-9-String2UpperFilter"><a href="#Chapter-5-1-9-String2UpperFilter">5.1.9. String2UpperFilter</a></h5>
Der <strong>String2UpperFilter</strong> wandelt alle Buchstaben in Groß-Buchstaben um.
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="uppertext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="String2LowerFilter"
      button="send"
      control="uppertext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h5 id="Chapter-5-1-10-StripTagsFilter"><a href="#Chapter-5-1-10-StripTagsFilter">5.1.10. StripTagsFilter</a></h5>
<p>
   Mit dem <strong>StripTagsFilter</strong> werden alle HTML- und PHP-Code-Fragmente aus dem Text
   entfernt. Dieser eignet sich gut für Felder, in denen viel Freitext eingegeben werden kann.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="notagstext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="StripTagsFilter"
      button="send"
      control="notagstext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-11-FloatFilter"><a href="#Chapter-5-1-11-FloatFilter">5.1.11. FloatFilter</a></h5>
<p>
   Der <strong>FloatFilter</strong> kann dazu genutzt werden, um Inhalte eines Text-Feldes in eine
   Fließkomma-Zahl umzuwandeln.
</p>
<div class="hint">
   Dieser Filter ist vor Allem dann interessant, wenn Text-Felder zur Eingabe von Fließkomma-Zahlen
   angeboten werden. Damit entfällt bei der Verarbeitung die Konvertierung und erleichtert die
   Validierung.
</div>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="length" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="FloatFilter"
      button="send"
      control="length"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-5-2-Aufbau-von-Filtern"><a href="#Chapter-5-2-Aufbau-von-Filtern">5.2. Aufbau von Filtern</a></h4>
<p>
   Formular-Filter sind eine Spezialisierung der APF-Filter-API. Als Interface steht die abstrakte
   Klasse <strong>AbstractFormFilter</strong> zur Verfügung, die alle konkreten Formular-Filter
   implementieren müssen.
</p>
<p>
   Ähnlich den im Kapitel 4.2 beschrieben Formular-Validatoren, müssen Formular-Validatoren einige
   Formular-spezifische Methoden implementieren. Die Klasse <strong>AbstractFormFilter</strong> hat
   folgenden Aufbau:
</p>
<gen:highlight type="php">
abstract class AbstractFormFilter extends AbstractFilter {

   protected $control;
   protected $button;

   public function AbstractFormFilter(AbstractFormControl &$control, AbstractFormControl &$button){
      $this->control = &$control;
      $this->button = &$button;
   }

   public function isActive(){
      return $this->button->isSent();
   }

}
</gen:highlight>
Über den Konstruktor werden das zu filternde Form-Control und der Button, der als Trigger
fungiert injiziert. Die Methode <strong>filter()</strong> wird vom Formular-Element mit dem zu
filternden Inhalt versorgt und muss den Filter-Code enthalten. Als Rückgabe wird der gefilterte
Wert erwartet.
<br />
<br />
Die Methode <strong>isActive()</strong> dienen dazu, dem Filter zu fragen, ob er ausgeführt werden
darf.
<br />
<br />
Die Klassen-Variablen <strong>$control</strong> und <strong>$button</strong> enthalten jeweils
die Instanz des zu validieren Formular-Elements und den Button, der als Trigger verwendet wird.
<br />
<br />
Voraussetzung für die Funktion von Filtern ist, dass ein Formular-Element dies unterstützt.
Hierzu muss in jedem Formular-Control die Methode <strong>addFilter()</strong>
implementiert sein. Diese in der Klasse <strong>AbstractFormControl</strong> definierte Methode hat
folgende Signatur:
<gen:highlight type="php">
public function addFilter(AbstractFormFilter &$filter){
   if($filter->isActive()){
      $value = $this->getAttribute('value');
      $filteredValue = $filter->filter($value);
      $this->setAttribute('value',$filteredValue);
   }
}
</gen:highlight>
Wie im Code-Snippet zu sehen ist, nimmt die Methode eine Instanz eines Filters entgegen, führt
diesen - falls als aktiv gekennzeichnet - aus.
<br />
<br />
Wie ebenfalls zu erkennen ist, wird dem Filter <em>by default</em> das Tag-Attribut
<strong>value</strong> übergeben, was nur für Text-Felder gültig ist. Aus diesem Grund
überschreiben Nicht-Text-Felder diese Methode und übergeben dem Filter den relevanten
Inhalt.
<br />
<br />
<div class="hint">
   Filter finden üblicherweise nur bei Text-Feldern Anwendung. Für Felder mit komplexeren
   Datenstrukturen kann es Sinn machen einen Filter zu schreiben, im Fall der Select-Felder ist es
   jedoch für die Sicherheit nicht von Bedeutung. Aus diesem Grund liefert das APF für Select-Felder
   keine Filter mit.
</div>

<h4 id="Chapter-5-3-Implementierung-von-Filtern"><a href="#Chapter-5-3-Implementierung-von-Filtern">5.3. Implementierung von Filtern</a></h4>
<p>
   Wie bereits im letzten Kapitel angesprochen, muss ein Filter von der Klasse
   <strong>AbstractFormFilter</strong> erben.
</p>
<p>
   Für die Implementierung eines eigenen Filters muss folgendes beachtet werden:
</p>
<ul>
   <li>Der Filter muss von von der Klasse <strong>AbstractFormFilter</strong> erben.</li>
   <li>
      Über den Button (Methode: <strong>isSent()</strong>) kann der Entwickler abfragen, ob das
      Formular mit Klick auf diesen abgesendet wurde.
   </li>
   <li>
      Die Methode <strong>isActive()</strong> kann üblicherweise von
      <strong>AbstractFormFilter</strong> übernommen werden.
   </li>
</ul>
<div class="hint">
   Auf Grund der Besonderheit, dass mit PHP >=5.2.10, bzw. >=5.3.0 die Signaturen von
   überschriebenen abstrakten Methoden Zeichen-identisch sein müssen, muss darauf geachtet werden,
   dass die Funktion <em>public function filter($input)</em> in der Filter-Implementierung exakt so
   definiert wurde!
</div>

<h3 id="Chapter-6-Verwendung-von-Formularen"><a href="#Chapter-6-Verwendung-von-Formularen">6. Verwendung von Formularen</a></h3>
<p>
   Die Verwendung von Formularen und die Verarbeitung mit Hilfe von Document Controllern ist im Kapitel
   <int:link pageid="114" /> näher beschrieben. Diese Seite soll lediglich als Referenz für die vorhandenen Taglibs
   und die Implementierung von Validatoren und Filtern dienen. Weiter wird auf die Erstellung von
   dynamischen Formularen eingegangen.
</p>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_113" />