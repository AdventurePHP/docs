<doku:title parent="119" tags="autoloader,class loader,classes,2.0" title="Class loading" urlname="Class-loading">
   This chapter describes the class loading mechanisms of the APF used to load classes, template files and configuration
   files.
</doku:title>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   As of version 2.0 the APF natively supports PHP namespaces. Following the namespace concept of prior versions all
   resources are addressed absolutely and including it's namespaces. This applies both to PHP classes, HTML templates,
   and configuration files as well as to SQL statement resources. Depending on the type direct and absolute addressing
   according to the PHP namespace pattern (e.g. <int:link pageid="006" />) or addressing separated by namespace and file
   (e.g. <int:link pageid="047" />) applies.
</p>
<p>
   The <em>ClassLoader</em> implementation is based on the
   <a class="external" href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a> PHP
   standard. The document describes the construction of namespaces of PHP classes that is also applied to templates and
   configurations within the Adventure PHP Framework.
</p>
<p>
   The following table shows the components of the APF and how they are defined concerning it's location:
</p>
<table>
   <thead>
      <tr>
         <td>Type</td>
         <td>Namespace</td>
         <td>Name</td>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>PHP classes (controller, tags, ...)</td>
         <td>\{Vendor name}\{Namespace}\</td>
         <td>{Class name}</td>
      </tr>
      <tr>
         <td>HTML template</td>
         <td>\{Vendor name}\{Namespace}\</td>
         <td>{Template name}</td>
      </tr>
      <tr>
         <td>Configuration files</td>
         <td>\{Vendor name}\{Namespace}\</td>
         <td>{Configuration file name}</td>
      </tr>
   </tbody>
</table>
<div class="warn">
   <p>
      The APF implementation of the <em>PSR-0</em> requires all application components to be addressed in absolute mode.
      Using this rule, you are able to load PHP classes, templates and configuration files from different base folders
      according to their vendor name.
   </p>
   <p>
      For this reason, PHP classes must always be stated fully-qualified (e.g. <em>APF\core\loader\StandardClassLoader</em>)
      and other components such as templates at least require to have a fully-qualified namespace
      (e.g. <em>APF\modules\usermanagement\pres\templates</em>).
   </p>
</div>
<p>
   The following chapters describe the components that are delivered with the APF.
</p>

<h3 id="Chapter-2-RootClassLoader"><a href="#Chapter-2-RootClassLoader">2. RootClassLoader</a></h3>
<p>
   The <em>RootClassLoader</em> is the central component of the APF that manages the <em>ClassLoader</em> implementations.
   It's static interface offers the capability to register different <em>ClassLoader</em> with different
   <em>vendor names</em> and thus load PHP classes, templates and configuration files from different base folders. Due
   to this mechanism you are enabled to separate framework and application code as well as productive code from test
   artefacts <strong>by vendor name</strong>.
</p>
<p>
   A <em>ClassLoader</em> is defined by the follwing interface:
</p>
<gen:highlight type="php">
interface ClassLoader {

   public function load($class);

   public function getVendorName();

   public function getRootPath();

}
</gen:highlight>
<p>
   As you can take from the interface every <em>ClassLoader</em> knows about it's vendor name. The vendor name is the
   first section of the namespace or the fully-qualified name of a PHP class. This allows to determine which template,
   configuration file, or PHP class is loaded by which <em>ClassLoader</em>.
</p>
<p>
   <strong>Loading classes</strong> is done by the respective <em>ClassLoader</em> directly using the <em>vendor name</em>.
   The standard implementation of the APF - the <em>StandardClassLoader</em> - exclusively loads classes that refer to
   the <em>vendor name</em> it is registered with. This enables you to easily register multiple <em>ClassLoader</em>
   instances for different vendors and with different base folders.
</p>
<p>
   Für das <strong>Laden von Templates und Konfigurations-Dateien</strong> werden ebenfalls die registrierten
   <em>ClassLoader</em> genutzt, jedoch stellen Sie in diesem Fall lediglich den Basis-Pfad zur Verfügung. Dieser wird
   dann genutzt um den vollständigen Datei-Pfad zu erzeugen. Damit können auch Templates und Konfigurations-Dateien aus
   unterschiedlichen Basis-Pfaden geladen werden.
</p>
<div class="hint">
   Der im APF enthaltene Mechnismus zum Laden von Klassen ist voll kompatibel zu anderen Frameworks/Tools, da der
   <em>RootClassLoader</em> über die Funktion <em>spl_autoload_register()</em> registriert wird und sich damit des
   PHP-Standards bedient.
</div>

<h3 id="Chapter-3-StandardClassLoader"><a href="#Chapter-3-StandardClassLoader">3. StandardClassLoader</a></h3>
<p>
   Der <em>StandardClassLoader</em> ist die Standard-Implementierung des <em>ClassLoader</em>-Interfaces. Er kümmert
   sich um das Laden von Klassen, für die er mit einem definierten Hersteller-Namen registriert wurde.
</p>
<p>
   Hierzu wird er im Konstruktor mit dem gewünschten Hersteller-Namen und dem Basis-Pfad initialisiert. Beispiel:
</p>
<gen:highlight type="php">
use APF\core\loader\RootClassLoader;
use APF\core\loader\StandardClassLoader;

$classLoader = new StandardClassLoader('ACME', '/acme/src');
RootClassLoader::addLoader($classLoader);
</gen:highlight>
<p>
   Beabsichtigen Sie Code und Konfiguration von unterschiedlichen Herstellern zu trennen, so können Sie dies mit Hilfe
   des <em>StandardClassLoader</em> unter Nutzung eines eigenen Hersteller-Namens und Basis-Pfades wie im Code gezeigt
   konfigurieren.

</p>
<div class="hint">
   Der Basis-Pfad des <em>StandardClassLoader</em>, der für den Hersteller <em>APF</em> in der Datei
   <em>APF/core/bootstrap.php</em> registriert wird, kann in der Bootstrap-Datei Ihrer Applikation mit Hilfe der
   Variable <em>$apfClassLoaderRootPath</em> an Ihre Umgebung angepasst werden. Details hierzu entnehmen Sie bitte dem
   <a href="#Chapter-4-Konfiguration">Kapitel 4</a>.
</div>
<p>
   Das Mapping von Hersteller-Name bzw. Namespace und Typ (z.B. PHP-Klasse) auf einen konkreten Datei-Namen übernimmt
   jeweils die Implementierung des <em>ClassLoader</em>. Das Standard-Setup des APF verhält sich wie folgt:
</p>
<table>
   <thead>
      <tr>
         <td>Namespace/voll-qualifizierter Name</td>
         <td>Name</td>
         <td>Datei-Pfad</td>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>ACME\application\pres\controller\DoSomethingController</td>
         <td>-</td>
         <td>/acme/src/application/pres/controller/DoSomethingController.php</td>
      </tr>
      <tr>
         <td>ACME\application\pres\templates\</td>
         <td>something.html</td>
         <td>/acme/src/application/pres/templates/something.html</td>
      </tr>
      <tr>
         <td>ACME\biz\factory</td>
         <td>goods.ini</td>
         <td>/acme/src/config/biz/factory/{CONTEXT}/{ENVIRONMENT}_goods.ini</td>
      </tr>
   </tbody>
</table>
<p>
   Bitte beachten Sie, dass das Mapping der Namen von Konfigurations-Dateien maßgeblich von der Implementierung
   des <em>ConfigurationProvider</em> abhängt. Details dazu finden Sie in Kapitel <int:link pageid="134" />.
</p>

<h3 id="Chapter-4-Anwendung"><a href="#Chapter-4-Anwendung">4. Anwendung</a></h3>
<p>
   Die folgenden Kapitel zeigen Ihnen, wie die Sie das Laden von Klassen, Templates und Konfigurations-Dateien anpassen
   und den <em>ClassLoader</em>-Mechanismus in Ihren Anwendungen einsetzen können.
</p>

<h4 id="Chapter-4-1-Anpassung-des-Basis-Pfads"><a href="#Chapter-4-1-Anpassung-des-Basis-Pfads">4.1. Anpassung des Basis-Pfads</a></h4>
<p>
   Jeder <em>ClassLoader</em> wird mit einem Basis-Pfad initialisiert, der für das Laden von Klassen, Templates und
   Konfigurations-Dateien des jeweiligen Herstellers genutzt wird. Den <em>StandardClassLoader</em> für den Hersteller
   <em>APF</em> initialisiert die Datei <em>APF/core/bootstrap.php</em>, die in der Bootstrap-Datei Ihrer Anwendung
   eingebunden wird. Eine typische <em>index.php</em> hat folgenden Inhalt:
</p>
<gen:highlight type="php">
include('./APF/core/bootstrap.php');

use APF\core\frontcontroller\Frontcontroller;

/* @var $fC Frontcontroller */
$fC = Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');
echo $fC->start('...', '...');
</gen:highlight>
<p>
   Ohne weitere Konfiguration evaluiert das Framework den Pfad zur Datei <em>bootstrap.php</em> und nutzt den
   darüber liegenden Ordner - also denjenigen Ordner, in dem sich <em>core</em>, <em>extensions</em>, <em>modules</em>
   und <em>tools</em> befinden - als Basis-Pfad für die Initialisierung des <em>StandardClassLoader</em>. Als
   Hersteller-Name wird <em>APF</em> verwendet.
</p>
<p>
   Nutzen Sie Symlinks oder wird Ihre Code-Basis für die Auslieferung von mehreren Projekten verwendet, können Sie den
   Basis-Pfad über die Variable <em>$apfClassLoaderRootPath</em> vor der Einbindung der Datei <em>bootstrap.php</em>
   selbst definieren. Ihre <em>index.php</em> ändert sich damit wie folgt:
</p>
<gen:highlight type="php">
$apfClassLoaderRootPath = '/path/to/apf/src';
include('./APF/core/bootstrap.php');

use APF\core\frontcontroller\Frontcontroller;

/* @var $fC Frontcontroller */
$fC = Singleton::getInstance('APF\core\frontcontroller\Frontcontroller');
echo $fC->start('...', '...');
</gen:highlight>
<p>
   PHP-Klassen, Templates und Konfigurations-Dateien für den Hersteller <em>APF</em> werden in Ihrer Applikation
   anschließend aus dem Pfad <em>/path/to/apf/src</em> geladen.
</p>

<h4 id="Chapter-4-2-Registrieren-von-weiteren-ClassLoadern"><a href="#Chapter-4-2-Registrieren-von-weiteren-ClassLoadern">4.2. Registrieren von weiteren ClassLoadern</a></h4>
<p>
   Um weitere <em>ClassLoader</em> nutzen zu können, müssen diese zunächst in der Bootstrap-Datei Ihrer Anwendung
   registriert werden. Hierzu können Sie die Methode <em>RootClassLoader::addLoader()</em> nutzen. Die genannte Methode
   erwartet eine Instanz vom Typ <em>ClassLoader</em>. Sie können daher sowohl auf eine Implementierung des APF zurück
   greifen (<em>StandardClassLoader</em>) als auch eigene Implementierung nutzen.
</p>
<p>
   Der folgende Code-Block registriert einen <em>StandardClassLoader</em> für einen eigenständigen Hersteller-Namen:
</p>
<gen:highlight type="php">
include('./APF/core/bootstrap.php');

use APF\core\loader\RootClassLoader;
use APF\core\loader\StandardClassLoader;

RootClassLoader::addLoader(new StandardClassLoader('ACME', '/acme/src'));
</gen:highlight>
<p>
   Reicht der Lieferumfang des APF für Ihren Anwendungsfall nicht aus, können Sie jederzeit eigene
   <em>ClassLoader</em>-Implementierungen zum Einsatz bringen. Das folgende Beispiel zeigt eine Implementierung, die
   Klassen mit explititer Angabe von <em>Hersteller</em>, <em>Namespace</em> und <em>Klassen-Namen</em> in der Form
   <em>ACME_Name_Space_ClassName</em> läd:
</p>
<gen:highlight type="php">
namespace ACME\loader;

use APF\core\loader\ClassLoader;

class ExplicitClassNameClassLoader implements ClassLoader {

   private $vendorName;
   private $rootPath;

   public function __construct($vendorName, $rootPath) {
      $this->vendorName = $vendorName;
      $this->rootPath = $rootPath;
   }

   public function load($class) {
      // loads classes that are including vendor, namespace, and name within
      // the class name directly, e.g. ACME_Foo_Bar_ClassName.
      if (strpos($class, $this->vendorName . '_') !== false) {
         $file = $this->rootPath . '/'
                    . str_replace(
                                  $this->vendorName . '_',
                                  '',
                                  str_replace('_', '/', $class)
                      );
         include($file);
      }
   }

   public function getVendorName() {
      return $this->vendorName;
   }

   public function getRootPath() {
      return $this->rootPath;
   }

}
</gen:highlight>
<p>
   Die Nutzung gestaltet sich wie folgt:
</p>
<gen:highlight type="php">
include('./APF/core/bootstrap.php');

use APF\core\loader\RootClassLoader;
use ACME\loader\ExplicitClassNameClassLoader;
RootClassLoader::addLoader(new ExplicitClassNameClassLoader('ACME', '/acme/src'));
</gen:highlight>

<h4 id="Chapter-4-3-Laden-von-Anwendungskomponenten"><a href="#Chapter-4-3-Laden-von-Anwendungskomponenten">4.3. Laden von Anwendungskomponenten</a></h4>
<p>
   Das Laden von Klassen wird direkt vom <em>RootClassLoader</em> übernommen. Möchten Sie Komponenten wie z.B.
   Schrift-Dateien direkt im Verzeichnisbaum Ihrer Anwendung ablegen und einbinden, können Sie auf die Funktonalitäten
   des <em>RootClassLoader</em> zurückgreifen.
</p>
<p>
   Das folgende Code-Beispiel zeigt Ihnen, wie Sie eine Schrift-Datei, die parallel zur Klasse <em>ImageHeadlineGenerator</em>
   abgelegt ist, zur Erzeugung einer grafischen Überschrift nutzen können:
</p>
<gen:highlight type="php">
namespace ACME\components\pres;

use APF\core\loader\RootClassLoader;

class ImageHeadlineGenerator {

   private $fontName;
   private $fontSize;

   public function __construct($fontName, $fontSize) {
      $this->fontName = $fontName;
      $this->fontSize = $fontSize;
   }

   public function generateHeadline($text) {

      $img = imagecreate($this->getWidth($text), $this->getHeight($text));

      // The RootClassLoader is able to determine the respective class loader for the
      // current namespace. The class loader instance then delivers the root path.
      // Der RootClassLoader kann an Hand des aktuellen Namespace den zuständigen
      // ClassLoader bestimmen. Dieser wiederum liefert den Basis-Pfad.
      $loader = RootClassLoader::getLoaderByNamespace(__NAMESPACE__);
      $rootPath = $loader->getRootPath();

      $currentNamespace = RootClassLoader::getNamespace(__NAMESPACE__);

      // Assuming that the fonts reside side-by-side with this class,
      // this is the path of the font to load:
      // Unter der Annahme, dass die Schrift-Dateien parallel zur aktuellen
      // Klasse liegen, kann der Pfad der Datei wie folgt definiert werden:
      $font = $rootPath . '/'
                  . str_replace('\\', '/', $currentNamespace) . '/'
                  . $this->fontName . '.ttf';

      imagettftext($img, $this->fontSize, 0, 10, 10, 0, $font, $text);

      imagepng($img);

   }

   private function getWidth($text) {

   }

   private function getHeight($text) {

   }

}
</gen:highlight>
<p>
   Im Code-Beispiel wird die Methode <em>getLoaderByNamespace()</em> dazu genutzt den für den aktuellen Hersteller
   zuständigen <em>ClassLoader</em> zu beziehen. Dieser wird dann dazu verwendet, den aktuellen Basis-Pfad des
   Herstellers für PHP-Klassen, Templates, Konfigurations-Dateien und andere Dateien zu beziehen.
</p>
<p>
   Des Weiteren wird der <em>RootClassLoader</em> in den folgenden Zeilen dazu eingesetzt um aus dem voll-qualifizierten
   Namespace den relevanten Teil ohne Hersteller-Name zu extrahieren. Die beiden Teile - Basis-Pfad und Namespace-Pfad -
   ergeben dann den Datei-Pfad der Schrift-Datei.
</p>

<h4 id="Chapter-4-4-Anwendung-des-RootClassLoader"><a href="#Chapter-4-4-Anwendung-des-RootClassLoader">4.4. Anwendung des RootClassLoader</a></h4>
<p>
   Neben den in <a href="#Chapter-4-3-Laden-von-Anwendungskomponenten">Kapitel 4.3.</a> vorgestellten Methoden verfügt
   der <em>RootClassLoader</em> über weitere Funktionen, die Sie für das Erzeugen von Datei-Pfaden bzw. zum Laden von
   Applikations-Inhalten nutzen können.
</p>
<p>
   Die folgende Liste zeigt die vorhandenen Methoden und ihre Anwendungsfälle:
</p>
<table>
   <thead>
      <tr>
         <td>Methode</td>
         <td>Anwendung</td>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>getLoaderByVendor()</td>
         <td>
            Gibt die <em>ClassLoader</em>-Instanz zurück, die mit dem übergebenen Hersteller-Namen registriert wurde.
         </td>
      </tr>
      <tr>
         <td>getLoaderByNamespace()</td>
         <td>
            Gibt die <em>ClassLoader</em>-Instanz zurück, die zum übergebenen Namespace passt.
         </td>
      </tr>
      <tr>
         <td>getLoaderByClass()</td>
         <td>
            Gibt die <em>ClassLoader</em>-Instanz zurück, die zum übergebenen, voll-qualifizierten PHP-Klasse passt.
         </td>
      </tr>
      <tr>
         <td>getClassName()</td>
         <td>
            Gibt den Klassen-Namen einer voll-qualifizierten Klasse (z.B. <em>APF\core\loader\RootClassLoader</em>)
            zurück (z.B. <em>RootClassLoader</em>).
         </td>
      </tr>
      <tr>
         <td>getNamespace()</td>
         <td>
            Gibt den Namespace einer voll-qualifizierten Klasse (z.B. <em>APF\core\loader\RootClassLoader</em>)
            zurück (z.B. <em>APF\core\loader</em>).
         </td>
      </tr>
      <tr>
         <td>getVendor()</td>
         <td>
            Gibt den Hersteller-Namen einer voll-qualifizierten Klasse (z.B. <em>APF\core\loader\RootClassLoader</em>)
            zurück (z.B. <em>APF</em>).
         </td>
      </tr>
   </tbody>
</table>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_154" />