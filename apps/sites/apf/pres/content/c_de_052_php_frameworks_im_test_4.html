<doku:title parent="100" tags="php,frameworks,test,cakephp,codeigniter,zend framework,adventure php framework,bewertung" title="PHP-Frameworks im Test (4)" urlname="PHP-Frameworks-im-Test-4">
  Der Artikel PHP-Frameworks im Test vergleicht unterschiedliche Frameworks. Basis der Bewertung ist
  ein Anforderungskatalog, der darauf Wert legt, dass der Entwickler einen möglichst
  vollständigen Werkzeugkasten an die Hand bekommt um effektiv Webseiten und Web-Applikationen
  entwickeln zu können.
</doku:title>
<h4 id="Chapter-3-2-CodeIgniter"><a href="#Chapter-3-2-CodeIgniter">3.2. CodeIgniter</a></h4>
<br />
<h5 id="Chapter-3-2-1-Allgemeines"><a href="#Chapter-3-2-1-Allgemeines">3.2.1. Allgemeines</a></h5>
<br />
<h6 id="Chapter-Roadmap-des-Projekts"><a href="#Chapter-Roadmap-des-Projekts">Roadmap des Projekts</a></h6>
Auf der Seite <doku:link>http://codeigniter.com/</doku:link> und den angeschlossenene Seiten findet
sich leider keine Roadmap, die über den weiteren Verlauf der Entwicklungen Aufschluss geben
könnte. Einzig das Bug-Tracking-System oder das Forum lassen vermuten, welche Features im
nächsten Release eingeführt werden.
<br />
<br />
<br />
<h6 id="Chapter-Aktualitaet-der-Version"><a href="#Chapter-Aktualitaet-der-Version">Aktualität der Version</a></h6>
Die unter <doku:link>http://codeigniter.com/download.php</doku:link> (Download startet sofort)
verfügbare Version stammt vom 12.07.2007. Das Release-Datum und die Aktivitäten im
Bug-Tracking-System stellen sicher, dass der Code aktuell ist und das Projekt regelmäßig
gepflegt wird.
<br />
<br />
<br />
<h6 id="Chapter-Release-Packages-in-verschiedenen-Formaten"><a href="#Chapter-Release-Packages-in-verschiedenen-Formaten">Release-Packages in verschiedenen Formaten</a></h6>
Das Release von CodeIgniter ist nur in einer ZIP-Version verfügbar. Somit ist nicht sichergestellt,
dass die Pakete auch auf Nicht-Windows-Betriebssystemen einfach verwendet werden können.
<br />
<br />
<br />
<h6 id="Chapter-CVS-SVN-Repositories"><a href="#Chapter-CVS-SVN-Repositories">CVS/SVN-Repositories</a></h6>
Für CodeIgniter ist kein öffentliches CVS- oder SVN-Repository zugänglich, über
das z.B. "nightly builds" bezogen werden können.
<br />
<br />
<br />
<h6 id="Chapter-Bug-Tracking-Ticketing"><a href="#Chapter-Bug-Tracking-Ticketing">Bug-Tracking / Ticketing</a></h6>
Unter <doku:link>http://codeigniter.com/bug_tracker/</doku:link> können Bugs berichtet werden.
Zudem existiert mit <doku:link>http://codeigniter.com/forums/viewforum/51/</doku:link> ein Bug-Report-
Forum, das sowohl zum Reporting als auch zur Diskussion mit den Entwicklern genutzt wird.
<br />
<br />
<br />
<h6 id="Chapter-Version-fuer-PHP-4"><a href="#Chapter-Version-fuer-PHP-4">Version für PHP 4</a></h6>
Die installierte Version ist zu PHP 4 (im Test: Version 4.4.6) kompatibel.
<br />
<br />
<br />
<h6 id="Chapter-Version-fuer-PHP-5"><a href="#Chapter-Version-fuer-PHP-5">Version für PHP 5</a></h6>
Die installierte Version ist zu PHP 5 (im Test: Version 5.2.1) kompatibel.
<br />
<br />
<br />
<h5 id="Chapter-3-2-2-Installation"><a href="#Chapter-3-2-2-Installation">3.2.2. Installation</a></h5>
<br />
<h6 id="Chapter-Extract-Go"><a href="#Chapter-Extract-Go">Extract & Go</a></h6>
Auch bei CodeIgniter ist keine aufwändige Vorbereitung notwendig. Nach dem Entpacken des Paketes
in den Document-Root des zu Test-Zwecken erstellten VHOSTs ist die Demo-Applikation verfügbar.
Positiv auffällig ist der grafisch übersichtlich und inhaltlich gut strukturierte
User-Guide, der dem Benutzer den Einstieg erleichtert.
<br />
<br />
<h6 id="Chapter-Konfiguration"><a href="#Chapter-Konfiguration">Konfiguration</a></h6>
Die notwendigen Konfigurationsarbeiten sind im User-Guide auf der Seite
<doku:link>http://codeigniter.com/user_guide/installation/index.html</doku:link> beschrieben.
Hauptsächlich geht es dabei um das Setup des absoluten Pfads, in dem CodeIgniter ausgeführt
wird und die Datenbank Zugangsdaten. Um das URL-Layout von CodeIgniter nutzen zu können, sind
manuelle Anpassungen notwendig. Hierzu wurde eine Apache RewriteRule erstellt, die alle Anfragen der
Form
<gen:highlight type="apf-xml">
  http://codeigniter.de/{Controlle}/{Action}[/{Param}]/../{ParamN}]
</gen:highlight>
an die zentrale Datei <em>index.php</em> weiterleitet. Die erstellte <em>.htaccess</em>-Datei hat
folgenden Inhalt:
<gen:highlight type="apf-xml">
  RewriteEngine On
  RewriteRule !(index.php|css|jpe?g|png|gif)$ /index.php?%{REQUEST_URI} [NC,L]
</gen:highlight>
(<em>Quelle: <doku:link>http://codeigniter.com/user_guide/general/urls.html</doku:link></em>)
<br />
<br />
<br />
<h5 id="Chapter-3-2-3-Erste-Schritte"><a href="#Chapter-3-2-3-Erste-Schritte">3.2.3. Erste Schritte</a></h5>
<br />
<h6 id="Chapter-Demo-Software"><a href="#Chapter-Demo-Software">Demo-Software</a></h6>
Das PHP-Framework CodeIgniter bringt, ähnlich wie CakePHP, eine Demo-Seite sowie einen
Offline-User-Guide mit. Die Einstiegsseite gibt dem Anwender Informationen darüber, wo in das
System eingegriffen werden muss um Änderungen an der angezeigten Seite durchzuführen, bzw.
wo das Manual zu finden ist. Die Seite bringt jedoch keine Demo-Applikation bzw. -Module mit, die
dem Entwickler ein Gefühl für die Funktionsweise geben.
<br />
<br />
<h6 id="Chapter-Einfuehrung-Quickstart"><a href="#Chapter-Einfuehrung-Quickstart">Einführung / Quickstart</a></h6>
Das Manual enthält einige ausführliche Kapitel, über die ersten Schritte. An dieser
Stelle sie nochmals auf <doku:link>http://codeigniter.com/user_guide/installation/index.html</doku:link>
hingewiesen. Die Seite dient dem CodeIgniter-Anfänger als Einstiegsseite.<br />
Etwas negativ fällt auf, dass der Benutzer direkt nach der Installations-Seite  an die Referenz
verwiesen wird ohne etwa eine "Hallo Welt!"-Applikation oder ähnliches zwischen zu lagern.
Eine "Hallo Welt!"-Applikation findet sich in Form eines Video Tutorials unter
<doku:link>http://codeigniter.com/tutorials/watch/intro/</doku:link> allerdings wird im Manual nicht
darauf verwiesen.
<br />
<br />
<br />
<h5 id="Chapter-3-2-4-Erstellung-einer-Webseite"><a href="#Chapter-3-2-4-Erstellung-einer-Webseite">3.2.4. Erstellung einer Webseite</a></h5>
<br />
<h6 id="Chapter-Template-Bau-Layoutgestaltung"><a href="#Chapter-Template-Bau-Layoutgestaltung">Template-Bau / Layoutgestaltung</a></h6>
Die Standard-Seite, die mit dem Release mitgeliefert wird beschreibt bereits, welche Dateien bearbeitet
werden müssen um auf die Ausgabe Einfluss nehmen zu können. Nagativ fällt sofort
ins Auge, dass CodeIgniter standardmäßig keine Layouts unterstützt, wie dies z.B.
CakePHP tut. Um ein zentrales Seiten-Layout einsetzen zu können ist eine Erweiterung der eingesetzten
Klassen notwendig. Eine Anleitung dazu kann unter <doku:link>http://codeigniter.com/wiki/layout_library/</doku:link>
gefunden werden. Nach einer erneuten Recherche konnte eine weitere Lösung für das Layout-
Thema gefunden werden: YATS, ein erweitertes Template-System für CodeIgniter. Dieses gehört
jedoch ebenso wie der Quick-Hack im Wiki nicht zum Standard-Release. YATS kann unter
<doku:link>http://codeigniter.com/wiki/Yet_Another_Template_System/</doku:link> heruntergeladen
und installiert werden. Postitiv ist zu vermerken, dass das AddOn ein eigenes Support-Forum mitbringt.
YATS ersetzt bei der Installation einige der Standard-Bibliotheken von CodeIgniter, was zur Folge hat,
dass einige der bisher erstellten Applikationen unter Umständen nicht mehr korrekt ausgeführt
werden können.
<br />
<br />
Für die Untersuchung des Frameworks wurde beim Template-Bau die erweiterte Layout-Library des WIKIs
genutzt. Das Erstellen von Templates erfolgt damit einer ähnlichen Vorgehensweise, die bei CakePHP
state-of-the-art ist. View-Templates (<em>Endung: .php</em>) werden als PHP-Skripte eingebunden und
können beliebigen PHP-Code enthalten. Zunächst wurde unter
<strong>/system/application/views/demosite</strong> eine Layout-Datei mit dem Namen
<strong>basic_layout.php</strong> angelegt um das gemeinsame Layout abbilden zu können. Diese
enthält, ebenso wie beim Test des vorangegangenen Probanden die Bereiche für Menü,
Top-Menü, News und Content.
<br />
<br />
Da CodeIgniter auch mit der erweiterten Layout-Library das Handeln von mehr als einem View-Bereich im
Layout-Template nicht unterstützt, wurde die Layout-Library wie folgt erweitert:
<gen:highlight type="php">
   class Layout
   {

       var $obj;
       var $layout;

       public function Layout($layout)
       {
           $this->obj =& get_instance();
           $this->layout = $layout;
       }

       public function view($view, $layoutvar = 'content_for_layout',$data=null, $return=true)
       {
           $data[$layoutvar] = $this->obj->load->view($view,$data,true);

           if($return)
           {
               $output = $this->obj->load->view($this->layout,$data, true);
               return $output;
           }
           else
           {
               $this->obj->load->view($this->layout,$data, false);
           }
       }
   }
</gen:highlight>
Damit ist es dem Entwickler möglich mehrere Bereiche im zentralen Layout zu definieren und den
Inhalt unterschiedlicher Views dynamisch dort zu platzieren. Im Beispiel konnte damit sowohl ein
<gen:highlight type="apf-xml">
  &lt;td width="180" height="400" valign="top" class="menu"&gt;
    &lt;?php echo $content_for_menu; ?&gt;
  &lt;/td&gt;
</gen:highlight>
als auch ein
<gen:highlight type="apf-xml">
  &lt;td height="20" class="topmenu"&gt;
    &lt;?php echo $content_for_topmenu; ?&gt;
  &lt;/td>
</gen:highlight>
im Template definiert und im zugehörigen Controller gefüllt werden.
<br />
<br />
<br />
<h6 id="Chapter-Handling-von-Controllern"><a href="#Chapter-Handling-von-Controllern">Handling von Controllern</a></h6>
Um ein einheitliches URL-Bild erstellen zu können muss auch hier das Routing angepasst werden.
Dies erfolgt in der Datei <strong>/system/application/config/routes.php</strong>. Dort werden u.a.
die Default-Route und Benutzer-eigene Routen definiert. Für den Test muss lediglich die
Default-Route angepasst und ein Mapping auf den Seite-Controller eingetragen werden:
<gen:highlight type="php">
   $route['default_controller'] = 'Seite';
   $route['Seite'] = 'Seite/Startseite';
</gen:highlight>
Der bereits angesprochene Action-Controller implementiert die mitgelieferte Controller-Klasse und
steuert die Befüllung der einzelnen Views. Der Konstruktor der Klasse wir dazu genutzt um die
o.g. Layout-Library zu laden und die allgemeinen Views (Menü, Top-Menü) mit Daten zu
füllen.
<gen:highlight type="php">
 class Seite extends Controller {

    public function Seite(){
       parent::Controller();
       $this->load->library('layout','demosite/basic_layout');
       $this->layout->view('demosite/menu','content_for_menu');
       $this->layout->view('demosite/topmenu','content_for_topmenu');
    }

    public function index(){
       $this->Startseite();
    }

   public function Startseite(){
       echo $this->layout->view('demosite/content/startseite');
    }

   public function Benchmark(){
       echo $this->layout->view('demosite/content/benchmark');
    }

}
</gen:highlight>
Die Methode <strong>index()</strong> wird immer dann vom Dispatcher aufgerufen, wenn keine Methode in
der URL angegeben ist. Wird eine Methode in der URL angegeben, die nicht im Controller existert wird
die etwas unverständliche Meldung angezeigt, dass die aufgerufene Seite nicht auf dem Server
existiert (Fehler 404). Die Ursache konnte erst nach einer Zeit der Nachforschung herausgefunden werden.
Es ist bei CodeIgniter tatsächlich so, dass jede "virtuelle" Methode der URL auch eine konkrete
Implementierung im Controller benötigt. Interessant wäre an dieser Stelle eine Bootstrap-Methode,
die alle Aufrufe, in denen lediglich Inhalte per URL-Parameter geladen werden müssen, abfängt.
Auf Grund der URL-Struktur kann dies beispielsweise über den URL-Helper in der Methode
<strong>index()</strong> realisiert werden:
<gen:highlight type="php">
   public function index(){

      // Action-Parameter holen
      $Action = $this->uri->segment(2);

      if(!method_exists($this,$Action)){

         // Action-Methode ausführen
         $this->{$Action}();

      }
      else{

         if(file_exists('system/application/views/demosite/content/'.strtolower($Action).'.php')){

            // View rendern
            $this->_output($this->layout->view('views/demosite/content/'.strtolower($Action));

         }
         else{

            // Zur Startseite leiten
            redirect('Seite');

         }

      }

  }
</gen:highlight>
Um den Test zu komplettieren, wurden - wie bereits im Code des Controllers zu sehen ist - die Seiten
Startseite, Benchmark und Formulare mit Inhalten gefüllt.
<br />
<br />
<br />
<h6 id="Chapter-Erweiterbarkeit-der-GUI-Komponenten"><a href="#Chapter-Erweiterbarkeit-der-GUI-Komponenten">Erweiterbarkeit der GUI-Komponenten</a></h6>
Im Quellcode der Datei <em>benchmark.php</em> befinden sich neben "normalen" HTML-Tags auch XML-Tags,
zwischen den PHP-Codes eingeschlossen sind, der formatiert auf der Seite dargestellt werden sollen.
CakePHP und das Adventure PHP Framework bieten dazu generische Tag-Parser bzw. TagLibs, die diese
Ausgaben erzeugen. CodeIgniter verfügt zwar ebenso wie CakePHP über Helper-Funktionen, die
allerdings nativ keine XML-Tags parsen können. Um dieses Verhalten nachstellen zu können
wird die interne Controller-Methode <strong>_output()</strong> für die Aufgabe des XML-Tag-Parsings
modifiziert. Es wurde jedoch davon abgesehen eine generische Implementierung für diese Aufgabe
zu wählen, da dies sonst den Rahmen der Evaluierung sprengen würde. Die Bereiche Navigation
innerhalb des Dokumentationsbereich wurde nicht als Tag, sondern als zusätzlicher View realisiert,
damit die Codierung nicht zu stark vom CodeIgniter-Standard abweicht:
<gen:highlight type="php">
public function _output($output){

   // load helper
   $this->load->helper('highlight');

   // Include Tag parsing
   // We could go so far to include a generic tag-parser, that can be configured in any
   // configuration file, but i refrain from doing that. this is just a non generic parser
   echo highlight($output);

}
</gen:highlight>
Um die Funktion des Parsens auszulagern wurde ein Helper programmiert, der das Tag-Parsen über
Ersetzung regulärer Such-Strings realisiert. Die Datei
<strong>/system/application/helpers/highlight_helper.php</strong> hat demnach folgenden Inhalt:
<gen:highlight type="php">
public function highlight($content){

   // Quelltext parsen
   return preg_replace_callback('=\<php\:highlight\>(.*?)\<\/php\:highlight\>=si','highlight_it',$content);

}

public function highlight_it($content){

   $HighlightedContent = highlight_string(trim('<?php'.ltrim(rtrim($content[1]),"\x0A..\x0D").' ?>'),true);

   // PHP-Anfangstag ersetzen
   $HighlightedContent = str_replace('< font color="#007700">&lt;?< /font>',
                                     '',
                                     $HighlightedContent);
   $HighlightedContent = str_replace('< font color="#0000BB">&lt;?php&nbsp;',
                                     '< font color="#0000BB">',
                                     $HighlightedContent);
   $HighlightedContent = str_replace('< font color="#0000BB">php',
                                     '< font color="#0000BB">',
                                     $HighlightedContent);
   $HighlightedContent = str_replace('< font color="#0000BB">&nbsp;< /font>',
                                     '',
                                     $HighlightedContent);

   // PHP-Endtag ersetzen
   $HighlightedContent = str_replace('< font color="#0000BB">?&gt;< /font>','',$HighlightedContent);

   // Code im DIV zurückgeben
   return '< div class="phpcode">'.$HighlightedContent.'< /div>';

}
</gen:highlight>
<br />
<br />
<h6 id="Chapter-Komplexe-Layouts"><a href="#Chapter-Komplexe-Layouts">Komplexe Layouts</a></h6>
Da bereits die Gestaltung einer einfachen Webseite nicht ohne einige Hindernisse möglich ist,
sieht der Autor auch bei diesem Framework Schwierigkeiten beim Aufsetzen von komplexen Layouts und
verschachtelten Funktionen. Auch bei CodeIgniter konnten Menü und Top-Menü nur als statische
Views eingebunden werden. Eine Art "Controller für Views", mit dem weiterer dynamischer
HTML-Code generiert werden kann - um beispielsweise ein Menü aus einem Model-Objekt darzustellen -
ist nicht vorgesehen.
<br />
<br />
Auch hier wurde keine weitere Prüfung unternommen, da keine Beschreibungen für eine
offizielle Lösung unter den CodeIgniter-Seiten gefunden werden konnte. Ansätze waren unter
<ul>
  <li><doku:link>http://codeigniter.com/wiki/Multiple_Applications_via_Symlinks/</doku:link> (Smarty)</li>
</ul>
zu finden. Diese waren jedoch nicht auf das Problem zugeschnitten und eine Evaluierung von Smarty im
Zusammenspiel mit CodeIgniter ist nicht Teil der Betrachtungen.
<br />
<br />
<br />
<h6 id="Chapter-FormularDesign"><a href="#Chapter-FormularDesign">FormularDesign</a></h6>
Zur Erstellung eines Formulars bietet CodeIgniter den FormHelper (<doku:link>http://codeigniter.com/user_guide/helpers/form_helper.html</doku:link>).
Um die Vergleichbarkeit zu wahren wird auch hier das bereits unter 3.1.4. beschriebene Formular
erstellt. Da das Formular in die bereits bestehende Seite eingebunden werden soll, wird neues
View-Template mit dem Namen <em>kontakt.php</em> unter <em>/system/application/views/demosite/content</em>
angelegt. Dieses hat den folgenden Inhalt:
<gen:highlight type="apf-xml">
&lt;font style="font-size: 26px; font-weight: bold;"&gt;Kontakt-Formular&lt;/font&gt;
&lt;br /&gt;
&lt;br /&gt;
Wenn Sie mit mir in Kontakt treten möchten, dann benutzen Sie einfach dieses Formular. Geben Sie Ihre
Nachricht ein und schon kann es los gehen. Ich werden mich dann umgehend mit Ihnen in Verbindung
setzten. &lt;strong&gt;Bitte füllen Sie das Formular vollständig aus!&lt;/strong&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;?php echo $this-&gt;validation-&gt;error_string; ?&gt;
&lt;?php echo form_open('/Seite/Kontakt'); ?&gt;
 &lt;span style="width: 47px; border: 0px solid black; margin-right: 69px;"&gt;Person:&lt;/span&gt;
 &lt;?php
  echo form_dropdown('person',
                     array(
                              '' =&gt; '',
                              '1' =&gt; 'Max Mustermann',
                              '2' =&gt; 'Bianka Mustermann'
                              ),
                     null,
                     'class="eingabe_feld"'
                    );
 ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;span style="width: 56x; border: 0px solid black; margin-right: 64px;"&gt;Ihr Name:&lt;/span&gt;
 &lt;?php
    echo form_input(array(
                          'name' =&gt; 'name',
                          'value' =&gt; $this-&gt;validation-&gt;name,
                          'class' =&gt; 'eingabe_feld',
                          'style' =&gt; 'width: 280px;'.$ContactNameStyle
                         )
                    );
 ?&gt;
 &lt;?php echo $ContactNameErrorMessage; ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;span style="width: 108px; border: 0px solid black; margin-right: 10px;"&gt;Ihre eMail-Adresse:&lt;/span&gt;
 &lt;?php
    echo form_input(array(
                          'name' =&gt; 'email',
                          'value' =&gt; $this-&gt;validation-&gt;email,
                          'class' =&gt; 'eingabe_feld',
                          'style' =&gt; 'width: 280px;'.$ContactEMailStyle
                         )
                    );
 ?&gt;
 &lt;?php echo $ContactEMailErrorMessage; ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;span style="width: 57px; border: 0px solid black; margin-right: 61px;"&gt;Ihr Betreff:&lt;/span&gt;
 &lt;?php
    echo form_input(array(
                          'name' =&gt; 'subject',
                          'value' =&gt; $this-&gt;validation-&gt;subject,
                          'class' =&gt; 'eingabe_feld',
                          'style' =&gt; 'width: 280px;'.$ContactSubjectStyle
                         )
                    );
 ?&gt;
 &lt;?php echo $ContactSubjectErrorMessage; ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 Ihre Nachricht:
 &lt;br /&gt;
 &lt;?php
    echo form_textarea(array(
                             'name' =&gt; 'note',
                             'value' =&gt; $this-&gt;validation-&gt;note,
                             'class' =&gt; 'eingabe_feld',
                             'style' =&gt; 'height: 200px; width: 400px; overflow: auto;'.$ContactNoteStyle
                            )
                      );
 ?&gt;
 &lt;br /&gt;
 &lt;br /&gt;
 &lt;?php echo form_submit('Absenden','Absenden','class="eingabe_feld"'); ?&gt;
&lt;?php echo form_close(); ?&gt;
</gen:highlight>
Das Template zeigt, dass der Entwickler und Template-Bauer mit dem Form-Helper die Möglichkeit
hat Formular-Felder per Helper-Funktionen generieren zu lassen. Hier stehen ihm beispielsweise die
Funktionen <strong>form_input()</strong> oder <strong>form_textarea()</strong> zur Verfügung.
Auch Formular-Tags können automatisch generiert werden.<br />
Im Gegensatz zu CakePHP verfügt das Framework CodeIgniter über eine eingebaute Formular-
Validierung mit sehr vielseitigen Einstellungsmöglichkeiten. Der Quellcode der zugehörigen
Controller-Methode zeigt die Anwendung:
<gen:highlight type="php">
public function Kontakt(){

   // Libraries und Helper laden
   $this->load->helper('form');
   $this->load->helper('url');
   $this->load->library('validation');

   // View-Daten vorbereiten
   $data['ContactNameStyle'] = '';
   $data['ContactEMailStyle'] = '';
   $data['ContactSubjectStyle'] = '';
   $data['ContactNoteStyle'] = '';

   // Validierung konfigurieren
   $rules['person'] = 'required|empty';
   $rules['name']	= 'required|min_length[3]';
   $rules['email'] = 'required|valid_email';
   $rules['subject']	= 'required|min_length[3]';
   $rules['note'] = 'required|min_length[5]';
   $this->validation->set_rules($rules);

   // Feldernamen für Validierung bezeichnen
   $fields['person'] = 'Person';
   $fields['name'] = 'Name';
   $fields['email'] = 'E-Mail';
   $fields['subject'] = 'Betreff';
   $fields['note'] = 'Notiz';
   $this->validation->set_fields($fields);

   // Validierung starten
   if($this->validation->run() == FALSE){

      // Falls die Error-Member-Variable gesetzt ist, roten Rahmen zeichnen
      if($this->validation->name_error){
         $data['ContactNameStyle'] = 'border: 2px solid red;';
      }
      if($this->validation->email_error){
         $data['ContactEMailStyle'] = 'border: 2px solid red;';
      }
      if($this->validation->subject_error){
         $data['ContactSubjectStyle'] = 'border: 2px solid red;';
      }
      if($this->validation->note_error){
         $data['ContactNoteStyle'] = 'border: 2px solid red;';
      }

      // View rendern
      $this->_output($this->layout->view('demosite/content/kontakt','content_for_layout',$data));

   }
   else{
      $this->_output($this->layout->view('demosite/content/kontakt_success','content_for_layout',$data));
   }

}
</gen:highlight>
Im ersten Anweisungsblock werden die Helper und Libraries geladen, die zur Validierung benötigt
werden. Der zweite Block definiert einen Satz von Daten, die an den Formular-View übergeben
werden sollen um die Formatierung der Felder bei Bedarf um ein weiteres Style-Attribut zu ergänzen.
Anschließend wird die Validierung konfiguriert. Wie unter <doku:link>http://codeigniter.com/user_guide/libraries/validation.html</doku:link>
nachzulesen ist, können beliebig viele Validierungsmethoden kaskadiert und neue vom Anwender
programmiert werden. Damit die Ausgabe der Fehlermeldungen zum aktuellen Anwendungsfall passt, wird
der Validator-Library im nächsten Schritt bekannt gemacht, wie die Felder-Namen heißen.
Diese Definition ist vor allem deshalb wichtig, damit später mit
<gen:highlight type="php">
   if($this->validation->name_error){
      $data['ContactNameStyle'] = 'border: 2px solid red;';
   }
</gen:highlight>
der zusätzliche CSS-Tag ergänz werden kann um die Felder mit roten Rahmen zu markieren.
<br />
<br />
Nachteilig an der aufgezeigten Vorgehensweise ist, dass CodeIgniter das Füllen von POST-Werten
nicht selbständig bei Verwendung der Form-Helper-Funktionen erledigt, sondern dies zu Fuß
über die Validate-Library programmiert werden muss. Auch problematisch sieht der Autor, dass
das Presetting von POST-Werten in Select-Feldern nur dann funktioniert, wenn das Select-Feld manuell
angelegt wird. Bei Verwendung der Helper-Funktion <strong>form_dropdown()</strong> gibt es keine
generische Möglichkeit dies zu realisieren. Darüber hinaus ist die Validierung von
Formular-Feldern zwar unterstützt, jedoch recht umständlich in der Anwendung.
<br />
<br />
Fazit: Das Formular-Handling ist im Bereich der Validierung dem von CakePHP überlegen, jedoch fehlen
in CodeIgniter wiederum einige Features, die in CakePHP Standard sind (Presetting). Vergleicht man nur
diese beiden Frameworks, so wäre eine Mischung wünschenswert.
<br />
<br />
<br />
<br />
<h5 id="Chapter-3-2-5-URL-Handling"><a href="#Chapter-3-2-5-URL-Handling">3.2.5. URL-Handling</a></h5>
<br />
<h6 id="Chapter-Unterstuetzung-von-URL-Rewriting"><a href="#Chapter-Unterstuetzung-von-URL-Rewriting">Unterstützung von URL-Rewriting</a></h6>
URL-Rewriting wird von CodeIgniter nativ unterstützt. Hierzu müssen zwar entsprechende
RewriteRules angelegt werden und diese leiten die Anfragen alle an die zentrale Bootstrap-Datei
<em>index.php</em> zur Verarbeitung weiter. Ein Betrieb ohne URL-Rewriting ist aber ebenso möglich.
Dazu müssen einige Konfigurationseinstellungen in der <em>config.php</em>, die unter
<doku:link>http://codeigniter.com/user_guide/general/urls.html</doku:link> beschrieben sind,
geändert werden.
<br />
<br />
<h6 id="Chapter-Generik-des-URL-Layouts"><a href="#Chapter-Generik-des-URL-Layouts">Generik des URL-Layouts</a></h6>
Das URL-Layout hat zur Zeit der Auslieferung das Format
<gen:highlight type="apf-xml">
 http://www.example.com/{Controller}/{Action}[/{Param1}/.../{ParamN}]
</gen:highlight>
Über die Routing-Einträge können unterschiedliche URL-Teile als Kenner für
bestimmte Aktionen verwendet werden. Das Aufbrechenen des URL-Layouts hinsichtlich der Ausführung
mehrerer Controller zur Laufzeit ist jedoch nicht möglich. Die Übergabe von beliebig vielen
und beliebig gearteten GET-Parametern ist nur im Non-Rewrite-URL-Moduls möglich und auch nur dann,
wenn das globale Zurücksetzen des <strong>$_GET</strong>-Arrays im Code verhindert wird.
<br />
<br />
<br />
<h6 id="Chapter-URL-Manipulations-Tools-Linkgenerierung"><a href="#Chapter-URL-Manipulations-Tools-Linkgenerierung">URL-Manipulations-Tools / Linkgenerierung</a></h6>
Zur Generierung von URLs steht der URL-Helper zur Verfügung. Dieser besitzt die unter
<doku:link>http://codeigniter.com/user_guide/helpers/url_helper.html</doku:link> beschriebenen
Funktionen. Es ist sowohl möglich eine URL mit <strong>site_url()</strong> oder <strong>base_url()</strong>
zu generieren, als auch mit <strong>anchor()</strong> einen Anker-Link zu erstellen. Darüber
hinaus bietet die URL-Library(<em><doku:link>http://codeigniter.com/user_guide/libraries/uri.html</doku:link></em>)
diverse Manipulations-Möglichkeiten einer URL. Herausgegriffen sei an dieser Stelle die Methoden
<strong>uri_to_assoc</strong> und <strong>assoc_to_uri()</strong>, die zur Manipulation einer URL
an Hand eines Array möglich macht. Dies könnte in etwa so aussehen:
<gen:highlight type="php">
  $this->load->library('uri');

  $ParamArray = array(
                      'MyParam1' => 'value1',
                      'MyParam2' => 'value2'
                      );
  $URLParams = $this->uri->uri_to_assoc(10);
  $URLParams = array_merge($ParamArray,$URL);

  $URL = $this->uri->assoc_to_uri($URLParams);
</gen:highlight>
<br />
<br />
<h5 id="Chapter-3-2-6-Design-des-Frameworks"><a href="#Chapter-3-2-6-Design-des-Frameworks">3.2.6. Design des Frameworks</a></h5>
<br />
<h6 id="Chapter-Umfang-der-mitgelieferten-Komponenten"><a href="#Chapter-Umfang-der-mitgelieferten-Komponenten">Umfang der mitgelieferten Komponenten</a></h6>
CodeIgniter liefert einen großen Umfang an Bibliotheken mit dem Release aus. Hierzu gehören
alle Komponenten rund um die MVC-Implementierung und deren Helper, sowie Klassen, die als Basis
für GUI-Module dienen wie die Kalender- oder die File-Upload-Klasse. Einzusehen sind die
Dokumentationen im User-Guide / Sektion "Class Reference" unter <doku:link>http://codeigniter.com/user_guide</doku:link>.
Die Seite <doku:link>http://codeigniter.com/projects/</doku:link> und das Wiki
(<doku:link>http://codeigniter.com/wiki/</doku:link>) sind eine gute Ressource für fertige
Applikationen und Artikel mit Code-Beispielen rund um CodeIgniter. Ein netter Ansatz ist der
Quick-Reference-Table, der alle Methoden im Überblick zeigt. So hat der Entwickler eine weitere
Möglichkeit, sich schnell einen Überblick über die Komponenten und deren
Möglichkeiten zu verschaffen. Die Quick-Reference kann auf
<doku:link>http://codeigniter.com/user_guide/general/quick_reference.html</doku:link> im Manual
nachgeschlagen werden.<br />
Ein weiterer positiver Punkt ist, dass CodeIgniter eine direkte Unterstützung von Unit-Tests
mitbringt. Die Komponente <em>CI_Unit_test</em> kann dazu verwendet werden automatisierte Unit-Tests
von CodeIgniter-Applikationen ablaufen zu lassen.
<br />
<br />
<br />
<h6 id="Chapter-Einsatz-von-Design-Pattern"><a href="#Chapter-Einsatz-von-Design-Pattern">Einsatz von Design-Pattern</a></h6>
Um während der Evaluierung ein besseres Verständnis des Designs des Frameworks zu bekommen
wurde mit Hilfe von Doxygen und Dot eine API-Dokumentation generiert. Auffällig ist, dass kein
einheitliches Klassen-Modell existiert. Gegenüber CakePHP und dem Adventure PHP Framework
basiert nicht jede Klasse auf einer gemeinsamen Basis-Klasse, sondern jede Klasse jedes Unter-Namespaces
hat ihre eigene Basis-Klasse. Das Singleton-Pattern wird zudem für einige Klassen jeweils neu
implementiert. Ein abstrakter Ansatz wird nicht verfolgt, was dazu führt, dass der Anwender
darauf beschränkt ist, nur diejenigen Klassen singleton instanziieren zu können, die das
Feature auch unterstützen. Positiv zu bewerten ist jedoch hier, dass ein generischer
Benchmarker im Lieferumfang enthalten ist, mit dem beliebige Code-Stellen gemessen werden können.
Das Handling des Benchmarkers ist jedoch hinsichtlich der <strong>mark()</strong>-Methode etwas
gewöhnungsbedürftig. Die Ausgabe hingegen ist sehr übersichtlich und erleichtert
die Performance-Optimierung.
<br />
<br />
<br />
<h6 id="Chapter-Struktur-des-Quellcodes-Design-der-Klassen"><a href="#Chapter-Struktur-des-Quellcodes-Design-der-Klassen">Struktur des Quellcodes / Design der Klassen</a></h6>
Der Aufbau des Packages ist sehr übersichtlich gestaltet. Die Benennung der Klassen kann jedoch
bei der Komponente "Controller" nicht ganz nachvollzogen werden, da es sich offensichtlich um eine
Core-Komponente handelt, die jedoch nicht mit "CI_" gepräfixt ist. Die Klassen an sich sind gut
dokumentiert, die Klassen-Variablen wurden in die Dokumentation leider nicht einbezogen.
<br />
<br />
<br />
<h6 id="Chapter-Einsetzbarkeit-fuer-mehrere-Applikationen"><a href="#Chapter-Einsetzbarkeit-fuer-mehrere-Applikationen">Einsetzbarkeit für mehrere Applikationen</a></h6>
CodeIgniter bringt für die generische Implementierung von Applikationen und Modulen mehrere
Komponenten mit: <em>CI_Language</em> und <em>CI_Config</em>. Diese beiden Bibliotheken, und insbesondere
<strong>CI_Config</strong> bringen jedoch keine weitere Abstraktionsebene mit, die unterscheidet,
in welchem Umfeld und in welche Applikation ein Modul eingesetzt ist.
<br />
<br />
<br />
<h6 id="Chapter-Erweiterbarkeit"><a href="#Chapter-Erweiterbarkeit">Erweiterbarkeit</a></h6>
Der modulare Design-Ansatz ermöglicht es dem engagierten Entwickler die Funktionalitäten
des Frameworks beliebig zu erweitern. Durch das nicht durchgängige Klassen-Modell sind Erweiterungen
jedoch nicht durch ein Interface definiert und es besteht die Gefahr, dass CodeIgniter durch zu viele
Erweiterungen zu einer monolithischen Klassensammlung wie PEAR mutieren könnte. Auch im GUI-Bereich
von CodeIgniter stoßen die Entwickler schnell an die Grenzen und müssen auf Erweiterungen
oder den Einsatz von Drittprodukten ausweichen.
<br />
<br />
<br />
<h6 id="Chapter-Scaffolding"><a href="#Chapter-Scaffolding">Scaffolding</a></h6>
Genau wie CakePHP bringt CodeIgniter ein Rapid Development Feature mit, das wie CakePHP Benutzern
hilft, Applikationen schnell zu entwickeln. CodeIgniter weißt im Manual jedoch extra darauf hin,
dass Scaffolding-Applikationen nicht im Live-Betrieb eingesetzt werden sollten, was die Intension des
Rapid Development ein Stück weit relativiert. Das hier betrachtete Beispiel ist ein auf
einem auf CodeIgniter aufsetzenden "Framework" basiertes Beispiel. Rapyd besitzt eine eigene Webseite,
die die gew&uumlählten Beispiele näher erläutert. Auf
<doku:link>http://www.rapyd.com/samples.php/rapyd/samples</doku:link> kann dieses bei Bedarf noch einmal
nachvollzogen werden. Die CodeIgniter-Seite selbst geizt mit Anwendungsbeispielen des Scaffolding-Features.
Wirklich ausführliche Beispiele finden sich nur auf externen Seiten.
<br />
<br />
<br />
<h5 id="Chapter-3-2-7-Dokumentation"><a href="#Chapter-3-2-7-Dokumentation">3.2.7. Dokumentation</a></h5>
<br />
<h6 id="Chapter-Dokumentation-des-Quellcodes"><a href="#Chapter-Dokumentation-des-Quellcodes">Dokumentation des Quellcodes</a></h6>
Wie bereits erwähnt ist der Quellcode gut dokumentiert, bei den Klassen-Variablen findet sich
jedoch wenig bis keine Dokumentation zur Bedeutung und Verwendung derselben. Durch die übersichtliche
Strukturierung des Paketes findet sich der Anwender aber schnell im Quellcode zurecht, sollte der
Blick in das Manual nicht ausreichen.
<br />
<br />
<br />
<h6 id="Chapter-API-Dokumentation"><a href="#Chapter-API-Dokumentation">API-Dokumentation</a></h6>
Für CodeIgniter ist weder online noch offline eine API-Dokumentation verfügbar. Zu
Evaluationszwecken wurde diese manuell mit Doxygen generiert, ersetzt jedoch nicht die Notwendigkeit,
dass diese vom Entwicklungsteam zur Verfügung gestellt wird.
<br />
<br />
<br />
<h6 id="Chapter-Einfuehrungen,-Tutorials-und-Anwendungs-Beispiele">Einführungen, Tutorials und Anwendungs-Beispiele</h6>
Die Seiten <doku:link>http://codeigniter.com/user_guide/</doku:link> und
<doku:link>http://codeigniter.com/wiki</doku:link> dienen dem Anwender als Ressourcen für
Einführungen, Tutorials und Anwendungsbeispiele. Unter <doku:link>http://codeigniter.com/tutorials/</doku:link>
finden sich 2 Video Tutorials, die ebenfalls den Einstieg erleichtern sollen. Ein Link, der auf eine
externe Seite führt, zeigt die Erstellung einer Applikation mit AJAX Features
(<doku:link>http://video.derekallard.com/</doku:link>).<br />
Im Vergleich zu den Hinweisen auf Projekte, die bereits auf CodeIgniter aufgesetzt wurden
(<doku:link>http://codeigniter.com/projects/</doku:link>) wartet das User-Manual mit relativ wenigen
Einführungsbeispielen auf und versteht sich eher als Referenz. Im Wiki finden sich unter
<doku:link>http://codeigniter.com/wiki/Special:Categories</doku:link> jedoch viele Kategorien, in
denen der Entwickler Anwendungsbeispiele beziehen kann. Abgesehen von der etwas unglücklichen
Strukturierung und den nicht ganz als solche zu verstehende Hinweisen auf das Wiki kann von einer
guten Auswahl an Dokumentationselementen gesprochen werden.
<br />
<br />
<br />
<h6 id="Chapter-ChangeLogs-Migrations-Hinweise-für-API-Aenderungen">ChangeLogs / Migrations-Hinweise für API-Änderungen</h6>
Eine öffentlich zugängliche Release-Planung scheint kein Feature der CodeIgniter-Webseite
zu sein, denn auch in den News ist keine weitere Planung für das Feature-Set des Frameworks zu
sehen. ChangeLogs zu den einzelnen Releases finden sich dagegen in den Newseinträgen der
jeweiligen Anlkündigungen der neuen Features. Alte Releases sind jedoch nach einem neuen Release
nicht mehr zugänglich.
<br />
<br />
<br />
<br />
<h5 id="Chapter-3-2-8-Support"><a href="#Chapter-3-2-8-Support">3.2.8. Support</a></h5>
Support erfährt der Entwickler im direkt angeschlossenen Forum (<doku:link>http://codeigniter.com/forums/</doku:link>),
per Suche im Wiki, oder in diversen anderen Foren, die sich mit dem Thema PHP-Entwicklung beschäftigen.
Das eigene Forum ist gut strukturiert und gliedert sich auf in Foren für Feature-Requests und
Support. Bugfixes finden sich zudem auch im WIKI, was schnelle Hilfe verspricht. Eine Newsgroup zu
CodeIgniter findet sich unter <doku:link>http://groups.google.de/group/codeigniter?lnk=gschg</doku:link>,
ein IRC-Channel wurde unter <doku:link>http://codeigniter.com/forums/viewthread/57381/</doku:link>
bekannt gegeben.
<br />
<br />
<br />
<br />
<h5 id="Chapter-3-2-9-Benchmark"><a href="#Chapter-3-2-9-Benchmark">3.2.9. Benchmark</a></h5>
Im Benchmark-Test konnte mit den CodeIgniter-eigenen Mitteln eine Rendering-Zeit von durchschnittlich
<strong>0.12434 s</strong> gemessen werden. Die Rendering-Zeit ist hier die komplette
Ausführungszeit ohne Rendering-Zeit für eine Sub-Navigation. Diese wurde aus genannten
Gründen nicht implementiert.
<br />
<br />
<br />
&raquo; Weiter auf <int:link pageid="053" title="PHP-Frameworks im Test (5)">Seite 5</int:link> (Bewertung Zend Framework).
<br />
<br />
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_052" />