<doku:title parent="119" tags="forumlare,form,aufbau,validierung,manipulation,befuellung,auslesen,dynamische formulare,controller" title="Verwendung von Formularen" urlname="Verwendung-von-Formularen">
  Diese Dokumentationsseite beschreibt den Aufbau und die Verwendung von Formularen so wie die
  M√∂glichkeiten, die sich aus dem APF-Formular-Modell ergeben. Dazu z√§hlen die Validierung 
  und das Vorausf√ºllen, sowie die M√∂glichkeit, Formular-Elemente (=Objekte) im Controller
  zu manipulieren, zu bef√ºllen oder diese auszulesen. Weiterhin wird die dynamische
  Formular-Erstellung beschrieben.
</doku:title>
Das Adventure PHP Framework beinhaltet eine sehr umfangreiche Formular-Unterst√ºtzung die auf dem
Taglibs-Konzept basiert. Die Grundlagen und vorhandenen Taglibs sind im Abschnitt
<a href="./?Seite=113-Formulare" title="Formulare">Formulare</a> beschrieben. Dieses Kapitel
besch√§ftigt sich nun mit der Verwendung von Formularen, der dynamischen Formular-Generierung
und der Erweiterung der Formular-Taglibs.
<br />
<br />
<br />
<h3 id="Chapter-1-Formulare-und-Controller"><a href="#Chapter-1-Formulare-und-Controller">1. Formulare &amp; Controller</a></h3>
Formulare sind - genau wie Template-Fragmente - Elemente, die im DOM-Baum existieren, jedoch bei der
Transformation nicht automatisch ausgegeben werden. Hierzu bedarf es eines Document-Controller. Der
Grund daf√ºr ist simple: nahezu jedes Formular ist an Aktionen gekn√ºpft, die mit dem Absenden
des Formulars ausgef√ºhrt werden sollen (z.B. Speichern der Daten).
<br />
<br />
Um ein Formular mit Hilfe eines Document-Controller auszugeben, ist folgender Code notwendig:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('Search');
      $form->transformOnPlace();
   }
}
</gen:highlight>
In der Variable <strong>$form</strong> steht dabei eine Instanz der Klasse
<strong>html_taglib_form</strong> zur Verf√ºgung, die ein APF-Formular mit all seinen Elementen und
Funktionen kapselt. Mit Hilfe dieser Referenz auf das Formular-Objekt im DOM-Baum kann das Formular
ausgegeben, manipuliert, bef√ºllt und angepasst werden. Details dazu k√∂nnen den folgenden Kapiteln
entnommen werden.
<br />
<br />
<br />
<h3 id="Chapter-2-API-der-Formular-Taglibs"><a href="#Chapter-2-API-der-Formular-Taglibs">2. API der Formular-Taglibs</a></h3>
Im vorangegangenen Abschnitt wurde beschrieben, wie ein Formular in einem Document-Controller
referenziert werden kann. In diesem Kapitel besch√§ftigen wir uns nun mit der API der
Formular-Taglibs, die Aufschluss dar√ºber gibt, welche M√∂glichkeiten die Formular-Integration des
APF bietet.
<br />
<br />
<div class="hint">
   F√ºr die Entwicklung ist es stets ratsam, die <int:link pageid="002"/>
   der eingesetzten Version parallel zur Entwicklungsumgebung ge√∂ffnet zu haben. Dies erleichtert
   die Arbeit, da jede Taglib ihre eigene API mitbringt, die in der API-DOkumentation genau
   beschrieben ist.
</div>
<p>
   Grundlage f√ºr alle Formular-Elemente ist die Klasse <strong>form_control</strong>. Diese
   implementiert Basis-Funktionalit√§ten f√ºr alle konkreten Formular-Elemente und definiert die
   Struktur eines Formular-Elements. Da die Formular-Elemente als Taglibs ausgef√ºhrt sind, unterliegen
   sie dem <int:link pageid="098" chapter="Chapter-2-1-Ablaufdiagramm">Lifecycle des Page-Controllers</int:link>.
   Das bedeutet, dass sie dar√ºber hinaus alle Methoden einer &quot;normalen&quot; Taglib
   implementieren m√ºssen.
</p>
<div class="hint">
   Im Gegensatz zu den Formular-Taglibs <strong>bis Version 1.10</strong>, kennen die
   Formular-Elemente <strong>ab Version 1.11</strong> ihren Validit√§ts-Status selbst. Damit kann
   jedes Element nach seinem Status gefragt werden. F√ºr das Formular selbst bedeutet das, dass die
   Methode <strong>isValid()</strong> den Status von jedem Element abfragt und daraus einen
   kumulierten Wert erzeugt.
</div>
<br />
Die Klasse <strong>form_control</strong> implementierten folgende Methoden:
<ul>
   <li>
      <strong>isValid():</strong> Die Funktion erm√∂glicht es, den Validit√§ts-Status der
      Formular-Elements abzufragen. Intern oder auch von aussen.
   </li>
   <li>
      <strong>markAsInvalid():</strong> Markiert ein Element als invalid.
   </li>
   <li>
      <strong>markAsSent():</strong> Markiert ein Element als abgesendet (relevant f√ºr Formulare
      und Buttons).
   </li>
   <li>
      <strong>isSent():</strong> Pr√ºft, ob ein Formular abgesendet wurde.
   </li>
   <li>
      <strong>isChecked():</strong> Gibt zur√ºck, ob eine Checkbox angehakt wurde oder nicht.
   </li>
   <li>
      <strong>check():</strong> Hakt eine Checkbox an.
   </li>
   <li>
      <strong>uncheck():</strong> Deaktiviert eine Checkbox.
   </li>
   <li>
      <strong>getValue():</strong> Gibt den Inhalt eines Elements zur√ºck. Normalerweise ist dies der Inhalt des
	  "value"-Attribut, au√üer bei Sonderf√§llen wie z.B. Textareas, bei denen Usereingaben im Inhaltsbereich
	  des Tags stehen. (Seit 1.14)
   </li>
   <li>
      <strong>setValue():</strong> Setzt den Inhalt eines Elements. Normalerweise ist dies der Inhalt des
	  "value"-Attribut, au√üer bei Sonderf√§llen wie z.B. Textareas, bei denen Usereingaben im Inhaltsbereich
	  des Tags stehen. (Seit 1.14)
   </li>
   <li>
      <strong>isFilled():</strong> Gibt bei ausgef¸lltem Textfeld oder ausgef¸llter Textarea <em>true</em> zur¸ck,
          andernfalls <em>false</em>. Dies funktioniert nur bei Textfeldern und Textareas (form:test und form:area).
          (Seit 1.15)
   </li>
   <li>
      <strong>isSelected():</strong> Gibt bei einer Auswahl in einem Single- oder Multiselect <em>true</em> zur¸ck,
          andernfalls <em>false</em>. Es muss dazu eine Option, welche einen Wert enth‰lt, selektiert werden. Wird ein
          Wert selektiert, welcher ledigiglich <em>""</em> liefert, wird ebenfalls <em>false</em> von dieser
          Methode zur¸ck gegeben. Dies funktioniert bei einfachen sowie mehrfachen Auswahlfeldern (form:select und
          form:multiselect). (Seit 1.15)
   </li>
   <li>
      <strong>addFilter():</strong> F√ºgt einen Filter zu einem Element hinzu.
   </li>
   <li>
      <strong>addValidator():</strong> F√ºgt einen Validator zu einem Element hinzu.
   </li>
   <li>
      <strong>addAttribute():</strong> Kann genutzt werden, um zu einem Attribut eines Tags weiteren
      Inhalt hinzuzuf√ºgen. Dies wird beim Benachrichtigen eines Formular-Elements innerhalb der
      Validierung genutzt.
   </li>
   <li>
      <strong>notifyValidationListeners():</strong> Benachrichtigt alle Listener eines
      Formular-Elements, dass dieses invalid ist.
   </li>
   <li>
      <strong>__presetValue():</strong> Die Methode stellt Presetting von Formular-Elementen f√ºr
      einfache Text-Felder zur Verf√ºgung. Diese kann bei der Erweiterung von Formular-Elementen
      entweder mit einer eigenen Logik √ºberschrieben oder direkt genutzt werden.
   </li>
   <li>
      <strong>setPlaceHolder():</strong> Die Methode implementiert eine generische Funktion zum
      setzen eines Platzhalters in einem Formular-Element. Wichtig hierbei ist, dass das Kind-Tag
      <strong>*:placeholder</strong> hei√üt.
   </li>
   <li>
      <strong>addAttributeToWhitelist():</strong> F√ºgt das √ºbergebene Attribut zur Whitelist des
      aktuellen Formular-Elements hinzu. Damit wird dieses auch in den HTML-Quelltext geschrieben.
   </li>
</ul>
<p>
   Mit Hilfe dieser Funktionen wird der Entwickler darin untrst√ºtzt, eigene Formular-Elemente zu
   erstellen. Mehr dazu in Kapitel 7.
</p>
<div class="hint">
   <p>
      Mit dem Release 1.12 wurde im Zusammenhang mit der Einf√ºhrung der Client-Validierung ein
      Attribut-Whitelisting f√ºr Formular-Taglibs eingef√ºhrt. Dieses sorgt daf√ºr, dass
      nur XHTML-kompatible Attribute in den Quelltext geschrieben werden. Propriet√§re Attribute -
      etwa zur Steuerung der Validierung - werden nicht beachtet.
   <p>
   <p>
      Bei der Erstellung einer eigenen Formular-Taglib muss da daher darauf geachtet werden, dass
      zus√§tzlich notwendige Attribute in die Whitelist aufgenommen werden. Hierzu empiehlt es
      sich, den Konstruktor der Taglib zu nutzen:
   </p>
<gen:highlight type="php">
class form_taglib_myspecial extends form_control {
   public function form_taglib_myspecial(){
      $this->attributeWhiteList[] = 'name';
      $this->attributeWhiteList[] = 'accesskey';
   }
}
</gen:highlight>
</div>

<h3 id="Chapter-3-Validierung"><a href="#Chapter-3-Validierung">3. Validierung</a></h3>
Die Validierung von Formular-Elementen wird √ºber die Taglib <strong>form:addvalidator</strong>
und die Implementierung der Validatoren auf das Klick-Event eines Buttons ausgef√ºhrt. Zeitlich
gesehen erfolgt die Validierung bei der Ausf√ºhrung der <strong>onAfterAppend()</strong>-Methode.
Das ist nach der Analyse-Phase (hier wird die Methode <strong>onParseTime()</strong> jeder Taglib
ausgef√ºhrt) und damit steht der DOM-Baum der Formular-Elemente vollst√§ndig zur Verf√ºgung.
<br />
<br />
In der <strong>onAfterAppend()</strong>-Methode des <strong>form:addvalidator</strong>-Tags wird
dann der Validator erzeugt, mit den notwendigen Informationen (Button und Formular-Control)
ausgestattet und dem Element √ºbergeben. Das Element f√ºhrt den Validator dann bei aktivem Status
aus und pr√ºft das Ergebnis. Im Negativfall wird die <strong>notify()</strong>-Methode des
Validators aufgerufen.
<br />
<br />
<br />
<h4 id="Chapter-3-1-Abfragen-des-Validierungs-Status"><a href="#Chapter-3-1-Abfragen-des-Validierungs-Status">3.1. Abfragen des Validierungs-Status</a></h4>
Da die einzelnen Formular-Elemente ab der neuen Implementierung selbst kennen, muss die Methode
<em>isValid()</em> des Formulars den Status jedes einzelnen Elements erfragen. In einem
Document-Controller kann der Zustand eines Formulars damit wie folgt abgefragt werden:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('MyForm');
      if($form->isSent()){
         echo 'Form was send');
      }
      if($form->isValid()){
         echo 'Form is valid';
      }
   }
}
</gen:highlight>
Ebenso ist es m√∂glich, den Status eines definierten Elements zu erfragen:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('MyForm');
      $searchField = &$form->getFormElementByName('searchterm');
      if($searchField->isValid()){
         echo 'Search field is valid';
      }
   }
}
</gen:highlight>
Um den Klick-Status eines Buttons abzufragen, kann folgender Code genutzt werden:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('MyForm');
      $button = &$form->getFormElementByID('button');
      if($button->isSent()){
         echo 'Search button was clicked';
      }
   }
}
</gen:highlight>
<div class="hint">
   Weitere Methoden der Formular-Elemente finden sich in der
   <a href="./?Seite=002-API-Dokumentation" title="API-Dokumentation">API-Dokumentation</a>
   der Klassen <strong>html_taglib_form</strong>, <strong>form_control</strong> und den Taglibs
   der jeweiligen Formular-Elemente (z.B. <strong>form_taglib_text</strong>).
</div>
<br />
<br />
<h4 id="Chapter-3-2-Ausgabe-von-Validator-Fehlermeldungen"><a href="#Chapter-3-2-Ausgabe-von-Validator-Fehlermeldungen">3.2. Ausgabe von Validator-Fehlermeldungen</a></h4>
Bei der Validierung von Formularen werden monierte Felder √ºblicherweise farblich markiert und der
Benutzer mit einem Hinweistext benachrichtigt. F√ºr diese Aufgaben k√∂nnen die Tags
<strong>&lt;form:error /&gt;</strong> (globale Formular-Fehlermeldungen) und
<strong>&lt;form:listener /&gt;</strong> verwendet werden. Alternativ dazu ist ein Platzhalter-Tag
verf√ºgbar, das im Controller mit einem entsprechenden Wert belegt werden kann.
<br />
<br />
<br />
<h5 id="Chapter-3-2-1-Form-Error"><a href="#Chapter-3-2-1-Form-Error">3.2.1. Form-Error</a></h5>
Der <strong>&lt;form:error /&gt;</strong> gibt immer dann seinen Inhalt aus, wenn das Formular nicht
valide ist. Dazu fragt er das Formular bei der Transformation nach seinem Status:
<br />
<br />
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:error&gt;Please fill in the mandatory fields!&lt;/form:error&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('product-form');
      $form->transformOnPlace();
   }
}
</gen:highlight>
Innerhalb des <strong>&lt;form:error /&gt;</strong>-Tags k√∂nnen gem√§√ü
<a href="./?Seite=113-Formulare#Chapter-3-19-Error" title="Anzeige von Formular-Fehlern">Anzeige von Formular-Fehlern</a>
noch weitere Tags zur Definition der Inhalte verwendet werden.
<br />
<br />
<br />
<h5 id="Chapter-3-2-2-Listener"><a href="#Chapter-3-2-2-Listener">3.2.2. Listener</a></h5>
Der <strong>&lt;form:listener /&gt;</strong>-Tag dient dazu Feld-speziefische Fehler anzuzeigen. Wie
in der Einleitung zum Kapitel 3 angesprochen, wird bei fehlgeschlagener Validierung die Methode
<strong>notify()</strong> aufgerufen. Diese benachrichtigt alle Listener, die sich auf das
entsprechende Control registriert haben und diese geben dann bei der Transformation den definierten
Inhalt aus.
<br />
<br />
Im folgenden Beispiel wird bei fehgeschlagener Validierung jeweils eine Feld-spezifische Meldung
angezeigt:
<br />
<br />
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:listener control="code"&gt;Please fill in a five letter product code!&lt;/form:listener&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:listener control="title"&gt;Please fill in a title with at least 20 characters!&lt;/form:listener&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:listener control="description"&gt;Please provide a verbose product description!&lt;/form:listener&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('product-form');
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Innerhalb des <strong>&lt;form:listener /&gt;</strong>-Tags k√∂nnen gem√§√ü
   <a href="./?Seite=113-Formulare#Chapter-3-18-Listener" title="Listener">Listener</a> noch weitere Tags zur
   Definition der Inhalte verwendet werden.
</p>

<h4 id="Chapter-3-3-Nachtraegliche-Validierung"><a href="#Chapter-3-3-Nachtraegliche-Validierung">3.3. Nachtr√§gliche Validierung im Controller</a></h4>
<p>
   In einigen Situationen kann es einfacher bzw. schneller sein, eine Formular-Validierung im
   Controller durchzuf√ºhren anstatt einen eigenen Validator zu schreiben. Um auch in diesen F√§llen
   eine Markierung der Formular-Felder zu erm√∂glichen wurde in <strong>Version 1.14</strong> eine
   neue Methode f√ºr Formular-Felder eingef√ºhrt.
</p>
<p>
   Als Beispiel soll im folgenden Formular das Feld <em>searchterm</em> nach einer eigenen Regel
   im Controller validiert werden:
</p>
<gen:highlight type="apf-xml">
<html:form name="search">
   <label for="searchterm">Suchbegriff:</label>
   <form:text id="searchterm" name="searchterm" value="" />
   <form:button name="search" value="GO" />
</html:form>
</gen:highlight>
<p>
   Der passende Controller beinhaltet folgenden Code zur Pr√ºfung, dass das Suchfeld den Buchstaben
   <em>e</em> nicht enth√§lt:
</p>
<gen:highlight type="php">
class search_controller extends base_controller {

   public function transformContent() {

      $form = &$this->getForm('search');
      $searchTerm = &$form->getFormElementById('searchterm')

      if(stripos($searchTerm->getValue(), 'e') !== false) {
         $searchTerm->markAsInvalid();
         $searchTerm->appendCssClass(AbstractFormValidator::$DEFAULT_MARKER_CLASS);
      }

      $form->transformOnPlace();

   }

}
</gen:highlight>
<p>
   Beim Abschicken des Formulars mit einem Wort, das den Buchstaben <em>e</em> beinhaltet, wird das
   Feld <em>searchterm</em> technisch als invalid markiert und erh√§lt die Standard-CSS-Klasse, die 
   zur optischen Markierung eingesetzt wird. Sofern eine eigene Klasse genutzt werden soll, kann
   diese entweder im Controller fest definiert werden oder aus einem Attribut des Formular-Feldes
   bezogen werden (z.B. <em>valmarkerclass</em>).
</p>

<h3 id="Chapter-4-Auslesen-von-Formularen"><a href="#Chapter-4-Auslesen-von-Formularen">4. Auslesen von Formularen</a></h3>
<p>
   Eine h√§ufige Aufgabe beim Handling von Formularen stellt das Auslesen von Werte dar. Hierzu
   k√∂nnen im Document-Controller folgende Methoden genutzt werden:
</p>
<ul>
   <li>
      <strong>getFormElementByID():</strong> Liefert ein Formular-Element an Hand seiner ID
      (Attribut: <em>id</em>).
   </li>
   <li>
      <strong>getFormElementByName():</strong> Liefert ein Formular-Element an Hand seines Namens
      (Attribut: <em>name</em>).
   </li>
   <li>
      <strong>getFormElementsByTagName():</strong> Liefert eine Liste von Formular-Elementen an
      Hand des Tag-Namens (z.B. <em>form:text</em>).
   </li>
   <li>
      <strong>getFormElementsByObjectID():</strong> Liefert ein Formular-Element an Hand seiner
      internen ObjektID. Diese Vorgehensweise kann bei der Generierung von dynamischen Formularen
      angewendet werden.
   </li>
</ul>
<br />
<h4 id="Chapter-4-1-Auswahl-per-Name"><a href="#Chapter-4-1-Auswahl-per-Name">4.1. Auswahl per Name</a></h4>
Sollen die im Formular des Kapitels 3.2.2. beschriebenen Felder zum Abspeichern des Formulars
ausgelesen werden, kann dies mit Hilfe des folgenden Controller-Codes erreicht werden:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('product-form');

      if($form->isSent() && $form->isValid()){

         $code = &$form->getFormElementByName('code');
         echo 'product code: '.$code->getValue();

         $title = &$form->getFormElementByName('title');
         echo 'product title: '.$title->getValue();

         $description = &$form->getFormElementByName('description');
         echo 'product desc: '.$description->getValue();
      }
      
   }
}
</gen:highlight>
<div class="hint">
   Bei Textareas wird der Inhalt nicht im Attribut <strong>value</strong> gespeichert, sondern
   im Inhalt des Tags. Dies entspriche exakt der Vorgehensweise der Tag-Definition in HTML.
</div>
<br />
Da das Formular nichts anderes darstellt als einen DOM-Baum von Formular-Elementen, kann ein
Platzhalter in einem Error-Tag √ºber zwei Stufen adressiert werden. Zu erst wird die Instanz des
Error-Tags bezogen und von dort der Platzhalter. Als Beispiel nutzen wir folgendes Formular:
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:error name="error"&gt;
      &lt;error:placeholder name="ph1" /&gt;
   &lt;/form:error&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>
Um nun den Platzhalter innerhalb des <strong>&lt;form:error /&gt;</strong>-Tags zu f√ºllen, kann
folgender Controller-Code genutzt werden:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('product-form');
      $error = &$form->getFormElementByName('error');

      // simple way:
      $error->setPlaceHolder('ph1','My placeholder value');

      // alternative way:
      $placeHolder = $error->getFormElementByName('ph1');
      $placeHolder->setContent('My placeholder value');
   }
}
</gen:highlight>
<div class="hint">
   Um ein Formular-Element per ID auszuw√§hlen, kann die gleiche Vorgehensweise wie bei der Auswahl
   nach Name verwendet werden.
</div>
<br />
<br />
<h4 id="Chapter-4-2-Auswahl-per-Tag"><a href="#Chapter-4-2-Auswahl-per-Tag">4.2. Auswahl per Tag</a></h4>
In manchen F√§llen kann es n√ºtzlich sein, die gew√ºnschten Formular-Elemente per Tag-Namen zu
selektieren. Hierzu steht die Methode <strong>getFormElementsByTagName()</strong> zur Verf√ºgung.
Diese liefert eine Liste mit Referenzen auf Formular-Elemente des √ºbergebenen Tag-Namens.
<br />
<br />
Im Zusammenspiel mit dem
<a href="./?Seite=063-Generischer-OR-Mapper#Chapter-4-3-Speichern-von-Objekten" title="GenericORMapper - Speichern von Objekten">GenericORMapper</a>
kann die Methode genutzt werden um Formular-Felder auszulesen und direkt in ein
<strong>GenericDomainObject</strong> zu speichern. Hierzu kann folgender Code genutzt werden:
<gen:highlight type="php">
class edit_controller extends base_controller {
   public function transformContent(){
      $form = &$this->getForm('...');
      $textFields = &$form->getFormElementsByTagName('form:text');
      $user = new GenericDomainObject('User');
      $count = count($textFields);
      for($i = 0; $i < $count; $i++){
         $user->setProperty(
            $textFields[$i]->getAttribute('name'),
            $textFields[$i]->getValue()
         );
      }
   }
}
</gen:highlight>
Bei der Anwendung ist zu beachten, dass die Methode jeweils nur diejenigen Elemente zur√ºckliefert,
die ausgehend vom verwendeten Element, als direkte Kind-Knoten vorhanden sind.
<br />
<br />
<br />
<h3 id="Chapter-5-Manipulation-von-Formularen"><a href="#Chapter-5-Manipulation-von-Formularen">5. Manipulation von Formularen</a></h3>
Die Implementierung der Formular-TagLibs des Frameworks bringt einige M√∂glichkeiten zur
Manipulation von Formularelementen oder deren Werte mit. Die folgenden Kapitel zeigen h√§ufig
auftretende Anwendungsbeispiele.
<br />
<br />
<br />
<h4 id="Chapter-5-1-Vorbefuellung"><a href="#Chapter-5-1-Vorbefuellung">5.1. Vorbef√ºllung von Formularen</a></h4>
Zur Vorbef√ºllung von Formularen (z.B. in einem Bearbeiten-Dialog) k√∂nnen Methoden
<ul>
   <li><strong>getFormElementByName()</strong>,</li>
   <li><strong>getFormElementByTagName()</strong>,</li>
   <li><strong>getFormElementByID()</strong> oder</li>
   <li><strong>getFormElementByObjectID()</strong></li>
</ul>
eingesetzt werden um eine Referenz auf ein Formular-Element zu beziehen. Anschlie√üend stehen
die Standard-Methode
<ul>
   <li><strong>getAttribute()</strong></li>
</ul>
bzw.
<ul>
   <li><strong>setAttribute()</strong></li>
</ul>
zur Verf√ºgung.
<br />
<br />
Die folgenden Codebox definiert ein Beispiel-Formular, das im anschlie√üend abgedruckten
PHP-Code bef√ºllt wird:
<br />
<br />
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="UserEdit" method="post"&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
$form = &$this->getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
$userID->setAttribute('value','...');

$firstName = &$form->getFormElementByName('FirstName');
$fFirstName->setAttribute('value','...');

$lastName = &$form->getFormElementByName('LastName');
$lastName->setAttribute('value','...');
</gen:highlight>
<br />
<h4 id="Chapter-5-2-Befuellen-von-Select-Feldern"><a href="#Chapter-5-2-Befuellen-von-Select-Feldern">5.2. Bef√ºllen von Select-Feldern</a></h4>
Die Behandlung Select- und Multiselect-Feldern unterscheidet sich ein wenig von einfachen
Formular-Elementen. Das Framework stellt jedoch auch hier Methoden zur Verf√ºgung, mit denen das
Bef√ºllen von Feldern vereinfacht wird. Im nachfolgend aufgef√ºhrten Code wird ein Formular
vorausgef√ºllt, das zus√§tzlich zu den Standard-Text-Felder auch Auswahlfelder beinhaltet:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="UserCreate" method="post"&gt;
   &lt;strong&gt;Salutation&lt;/strong&gt;:
   &lt;form:select name="Salutation" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;strong&gt;Groups&lt;/strong&gt;:
   &lt;br /&gt;
   &lt;form:multiselect name="Group" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</gen:highlight>
Der folgende PHP-Code bef√ºllt das Formular:
<gen:highlight type="php">
$form = &$this->getForm('UserCreate');
$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['DisplayName'], $salutations[$i]['Value']);
}
$goups = array(...);
$group = &$form->getFormElementByName('Groups');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['DisplayName'], $groups[$i]['Value']);
}
</gen:highlight>
<div class="hint">
   Sollen beim Bef√ºllen eines Multiselect-Feldes bestimmte Optionen bereits vorausgew√§hlt
   sein, so kann die Methode <strong>setOption2Selected()</strong> verwendet werden.
</div>
<br />
Der folgende Code zeigt, wie ein Multiselect-Feld zun√§chst mit Berechtigungen gef√ºllt und
anschlie√üend gem√§√ü den Applikationsinformationen vorselektiert wird. Das Beispiel
ist aus dem im Release mitgelieferten
<a href="./?Seite=095-Module-Usermanagement" title="Usermanagement-Modul">Usermanagement-Modul</a>
entnommen.
<gen:highlight type="php">
$form = &$this->getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</gen:highlight>
<br />
<h4 id="Chapter-5-3-Auslesen-von-Formular-Elementen"><a href="#Chapter-5-3-Auslesen-von-Formular-Elementen">5.3. Auslesen von Formular-Elementen</a></h4>
Das Auslesen von Formular-Elementen gestaltet sich √§hnlich wie das Bef√ºllen. Eine
Besonderheit stellen auch hier die Einfach- und Mehrfachselektionsfelder dar. Das folgende Code-Beispiel
zeigt, wie die Werte des unter 3.1 dargestellten Formulars im Document-Controller ausgelesen werden
k√∂nnen:
<gen:highlight type="php">
$form = &$this->getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
echo $userID->getValue();

$firstName = &$form->getFormElementByName('FirstName');
echo $firstName->getValue();

$lastName = &$form->getFormElementByName('LastName');
echo $lastName->getValue();
</gen:highlight>
<p>
   Um die selektierten Optionen eines Einfach- oder Mehrfachselektionsfeldes auszulesen, stehen die
   Methoden <strong>getSelectedOption()</strong> und <strong>getSelectedOptions()</strong> zur
   Verf√ºgung. Die folgende Codebox zeigt den Anwendungsfall:
</p>
<gen:highlight type="php">
$form = &$this->getForm('UserCreate');

$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['Value'],$salutations[$i]['DisplayName']);
}

$option = &$salutation->getSelectedOption();
echo $option->getAttribute('value').', '.$option->getContent();

$groups = array(...);
$group = &$form->getFormElementByName('Groups[]');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['Value'],$groups[$i]['DisplayName']);
}

$selectedGroups = &$group->getSelectedOptions();
for($i = 0; $i < count($selectedGroups); $i++){
   echo $selectedGroups[$i]->getAttribute('value').', '.$selectedGroups[$i]->getContent();
}
</gen:highlight>

<div class="warn">
   Die Auswertung von dynamisch bef√ºllten Select-Feldern funktioniert nur dann, wenn diese in allen Anwendungsf√§llen
   zuerst mit den gew√ºnschten Optionen versehen werden. Ist dies nicht der Falls, so liefern die Methoden
   <em>getSelectedOption()</em> bzw. <em>getSelectedOptions()</em> kein Ergebnis. Dies ist insbesondere dann wichtig,
   wenn eine Auswertung bei Absenden des Formulars stattfindet. In diesem Fall muss die Bef√ºllung unabh√§ngig vom
   Zustand des Formulars vorgenommen werden.
</div>

<h3 id="Chapter-6-Dynamische-Formulare"><a href="#Chapter-6-Dynamische-Formulare">6. Dynamische Formulare</a></h3>
<p>
   In einigen Anwendungsf√§llen ist es notwenig, Formulare dynamisch nach Anforderung zu erstellen.
   Hierzu besitzt die Implementierung der Formular-TagLib (<em>html_taglib_form</em>) die Methoden
</p>
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
und seit dem Release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
Die ersten beiden Funktionen lassen sich dazu nutzen, Inhalte oder konkrete Formular-Elemente
an das Ende des Formulars anzuh√§ngen. Die zu letzt genannten Methoden sind dazu gedacht, Inhalte
oder Formular-Elemente an konkreten Stellen zu platzieren. Zur Positionierung steht das
<strong>&lt;form:marker /&gt;</strong>-Tag zur Verf√ºgung. Das Tag selbst generiert keine Ausgabe,
sondern dient lediglich als Positionierungshilfe.
<br />
<br />
Die folgenden Kapitel sollen zeigen, wie ein dynamisches Formular zur Eingabe von Form-Koordinaten
(Dreieck, Quadrat, ...) realisiert werden kann. Je nach Auswahl des Typs sollen die jeweils notwenigen
Felder angezeigt werden. Bei Auswahl des Typs "square" werden vier Felder angezeigt ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs square" />
<br />
<br />
... und bei Auswahl von "triangle" drei:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - Dynamische Formular-Generierung; Auswahl des Typs triangle" />
<br />
<br />
<br />
<h4 id="Chapter-6-1-Formular-Definition"><a href="#Chapter-6-1-Formular-Definition">6.1. Formular-Definition</a></h4>
Bei der Definition des Formulars sollte bereits bedacht werden, welche Art der Formular-Generierung
angestrebt wird. Kommen die Methoden <em>addFormElement()</em> und/oder <em>addFormContent()</em>
zum Einsatz, ist keinen Marker erforderlich. In diesem Beispiel wird jedoch ein Marker eingesetzt, da
das Formular bereits Inhalte besitzt, die nach den dynamisch erzeugten Elementen angezeigt werden
sollen.
<br />
<br />
Die folgende Code-Box zeigt das notwenige Formular mit einem Auswahlfeld. Bei der Implementierung
wurde auf CSS-Formatierung verzichtet um die wesentlichen Elemente besser hervorheben zu k√∂nnen.
Das Formular besteht dabei aus einem statisch definierten Auswahlfeld, das den Typ der geometrischen
Form vorgibt und aus einem Marker-Tag, der als Positionierungshilfe f√ºr die dynamisch erzeugten
Felder dient. Weiterhin wird ein Document-Controller definiert, der die gew√ºnschten Felder
dynamisch an der Stelle des Markers hinzuf√ºgt:
<gen:highlight type="apf-xml">
&lt;@controller namespace="..." [file="..."] class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h4 id="Chapter-6-2-Controller"><a href="#Chapter-6-2-Controller">6.2. Controller</a></h4>
Der Document-Controller √ºbernimmt im beschriebenen Beispiel die Generierung der abh√§ngigen
Formularfelder, die je nach Auswahl angezeigt werden sollen. Hierzu wird im Controller zun√§chst
definiert, welche Formular-Felder f√ºr welchen Typ angezeigt werden. Anschlie√üend wird
das Typ-Feld ausgewertet und das Formular mit Inhalten und Text-Feldern gem√§√ü Typ
erg√§nzt. Die folgende Code-Box zeigt die Implementierung des Document-Controllers:
<gen:highlight type="php">
class select_controller extends base_controller {

   // specify form element container
   private $__FormElements = array();

   public function __construct(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

   }

   public function transformContent(){

      // get form reference
      $form = &$this->getForm('type');

      // get current decision
      $Select = &$form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
      }
      else{
         $CurrentType = $Option->getAttribute('value');
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $currentElementID = $form->addFormElementBeforeMarker(
                                'fields',
                                'form:text',
                                array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                             );

         // configure further form element attributes
         $currentElement = &$form->getFormElementByObjectID($currentElementID);
         $currentElement->setAttribute('style','width: 200px;');

         // add a line break
         $form->addFormContentBeforeMarker('fields','<br />');

      }

      // display form
      $form->transformOnPlace();

   }

}
</gen:highlight>

<h4 id="Chapter-6-3-Dynamische-Filter-und-Validatoren"><a href="#Chapter-6-3-Dynamische-Filter-und-Validatoren">6.3. Dynamische Filter und Validatoren</a></h4>
<p>
   Mit dem <strong>Release 1.11</strong> wurde das Konzept der Filter und Validatoren √ºberarbeitet.
   Dies wirkt sich auch auf die Definition von dynamischen Formular-Elementen mit Filtern und
   Validatoren aus.
</p>
<p>
   Wie im Kapitel
   <a href="./?Seite=113-Formulare#Chapter-4-2-Aufbau-von-Validatoren" title="Aufbau von Validatoren">Aufbau von Validatoren</a>
   und
   <a href="./?Seite=113-Formulare#Chapter-5-2-Aufbau-von-Filtern" title="Aufbau von Filtern">Aufbau von Filtern</a>
   besprochen wurde, werden Validatoren und Filter als <strong>Observer</strong> an Formular-Elemente
   geheftet. Bei dynamischen Formularen kann durch &quot;Simulation&quot; der
   <strong>&lt;form:addvalidator /&gt;</strong>- und <strong>&lt;form:addfilter /&gt;</strong>-Tags
   ebenso verfahren werden. F√ºr die konkrete Anwendung bedeutet das, dass nach der Definition eines
   dynamischen Formular-Feldes der gew√ºnschte Validator oder Filter √ºber die Methoden
   <strong>addValidator()</strong> bzw. <strong>addFilter()</strong> angeheftet werden kann. Dies gestaltet sich in
   Code ausgedr√ºckt im Kontext des in den letzten Kapiteln besprochenen Beispiels wie folgt:
</p>
<gen:highlight type="php">
// gather button instance of the form
$button = &$form->getFormElementByName('submit');

// create dynamic form elements
for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

   // add label
   $form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

   // add text field (name attribute is present to enable validation and presetting!)
   $currentElementID = $form->addFormElementBeforeMarker(
                           'fields',
                           'form:text',
                           array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                       );

   // configure further form element attributes
   $currentElement = &$form->getFormElementByObjectID($currentElementID);
   $currentElement->setAttribute('style','width: 200px;');

   // add filter to the current element
   $filter = new NoSpecialCharactersFilter($currentElement,$button);
   $currentElement->addFilter($filter);

   // add validator to the current element
   $validator = new TextLengthValidator($currentElement,$button);
   $currentElement->addValidator($validator);

   // add a line break
   $form->addFormContentBeforeMarker('fields','<br />');

}
</gen:highlight>
<div class="hint">
   Bei der Definition von dynamischen Validatoren und Filtern muss die Reihenfolge beachtet werden.
   Damit keine unerw√ºnschten Validierungs-Ergebnisse auftreten, m√ºssen Filter stets 
   <em>vor</em> Validatoren ausgef√ºhrt werden.
</div>
<div class="warn">
   Bitte beachten Sie, dass Pr√ºfungen eines Formulars per
   <gen:highlight type="php">$form->isValid()</gen:highlight>
   erst nach dem Hinzuf√ºgen von dynamischen Validatoren und Filtern erfolgen d√ºrfen. Andernfalls werden fehlerhafte
   Inhalte nicht erkannt.
</div>

<h4 id="Chapter-6-4-Weitere-Hinweise"><a href="#Chapter-6-4-Weitere-Hinweise">6.4. Weitere Hinweise</a></h4>
Ein APF-Formular-Element ben√∂tigt bereits bei der Erstellung des Objekts die Information √ºber
den Namen des Feldes. Ist dieser nicht bekannt, kann es nicht vorausgef√ºllt oder validiert werden.
Um die Presetting und Validierung von Formular-Elementen nutzen zu k√∂nnen besitzen die Methoden
<em>addFormElement()</em>, <em>addFormElementBeforeMarker()</em> und <em>addFormElementBeforeMarker()</em>
einen optionalen, dritten Parameter. Dieser erwartet eine assoziative Liste von Tag-Attributen, die
dem Formular-Tag bei der Erstellung mitgegeben werden. Es daher sinnvoll, der Methode mindestens
den Namen des Feldes in der Form
<gen:highlight type="apf-xml">
array(
      'name' => 'current_name'
     )
</gen:highlight>
als drittes Argument mitzugeben. Dies kann unter Umst√§nden auch f√ºr die sp√§tere
Adressierung der Objekte √ºber die Methoden <em>getFormElementByName()</em> und
<em>getFormElementByID()</em> von Interesse sein.
<br />
<br />
<br />
<h3 id="Chapter-7-Erweiterung-von-Formular-Elementen"><a href="#Chapter-7-Erweiterung-von-Formular-Elementen">7. Erweiterung von Formular-Elementen</a></h3>
Das APF-Konzept des Page-Controllers erlaubt es, eigene Taglibs zu schreiben um wiederverwendbare
Elemente zu schaffen. Dies setzt sich auch bei den Formularen fort. Eigene Formular-Elemente
k√∂nnen bequem mit dem <strong>&lt;form:addtaglib /&gt;</strong>-Tag, dessen Funktion identisch
zum <strong>&lt;core:addtaglib /&gt;</strong> ist, in ein bestehendes Formular eingebunden werden.
<br />
<br />
Die Besonderheit der Formular-Taglibs bzw. Formular-Elemente ist, dass diese die abstrakte Klasse
<strong>form_control</strong> implementieren. Sie gen√ºgen damit einem erweiterten Tag-Interface,
das vom <strong>&lt;html:form /&gt;</strong>-Tag behandelt werden kann. Die Erweiterung des
Funktions-Umfangs besteht insbesondere in der Validierung und Filterung.
<br />
<br />
Die folgenden drei Kapitel beschreiben die Erstellung von eigenen Formular-Elementen, Validatoren
und Filter und geben Beispiele f√ºr die Implementierung.
<br />
<br />
<br />
<h4 id="Chapter-7-1-Formular-Felder"><a href="#Chapter-7-1-Formular-Felder">7.1. Formular-Felder</a></h4>
Wie bereits angedeutet, ist eine Formular-Element im APF durch die abstrakten Basis-Klasse
<strong>form_control</strong> definiert. Um ein neues Formular-Element zu implementieren, muss diese
nun um die gew√ºnschten Funktionen erweitert werden.
<br />
<br />
Als Beispiel soll im Folgenden ein Formular-Element besprochen werden, das zum Schutz eines
Formulars ein verstecktes Text-Feld erzeugt und das im darauffolgenden Kapitel mit einem speziellen
Validator belegt werden kann. Ist das Feld gef√ºllt, ist davon auszugehen, dass es sich um eine
automatisierte Anfrage handelt. Ist das Feld nicht gef√ºllt, wird das Formular als valide
betrachtet, sofern alle anderen Felder ebenfalls valide sind. In diversen Blog-Eintr√§gen werden
diese Art von Felder auch als
<a class="external" href="http://nedbatchelder.com/text/stopbots.html" title="Stopping spambots with hashes and honeypots">honeypot fields</a>
bezeichnet.
<br />
<br />
Beginnen wir zun√§chst mit dem Rumpf des Elements. Wie zuvor beschrieben soll ein Text-Feld
ausgeben werden, das via CSS versteckt wird. Um diese Funktion zu gew√§hrleisten, muss das neue
Formular-Element bei der Transformation die entsprechende HTML-Ausgabe zur√ºckliefern:
<gen:highlight type="php">
class form_taglib_honeypot extends form_control {
   public function transform(){
      $htmlCode  = (string)'&lt;input ';
      $htmlCode .= $this->getAttributesAsString($this->__Attributes);
      $htmlCode .= 'type="text" ';
      $htmlCode .= 'style="margin: 0px; padding: 0px; display: none; height: 0px; width: 0px;"';
      $htmlCode .= ' /&gt;';
      return $htmlCode;
   }
}
</gen:highlight>
<div class="hint">
   Vor der Version 1.14 muss die Zeile
   <gen:highlight type="php">$htmlCode .= $this->getAttributesAsString($this->__Attributes);</gen:highlight>
   auf Grund von API-√Ñnderungen durch
   <gen:highlight type="php">$htmlCode .= $this->__getAttributesAsString($this->__Attributes);</gen:highlight>
   ersetzt werden.
</div>
<p>
   Da die R√ºckgabe des Validit√§ts-Status, die M√∂glichkeit Validatoren und Filter
   anzuheften und Presetting der eingegebenen Werte beim Absenden bereits in der Klasse
   <strong>form_control</strong> enthalten ist, stellt die oben gezeigte Klasse bereits den
   vollst√§ndig Funktionsumfang dar.
</p>
<p>
   Um das neue Element in einem Formular verwenden zu k√∂nnen, muss dieses mit Hilfe des
   <strong>&lt;form:addtaglib /&gt;</strong>-Tags im Formular bekannt gemacht werden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="CheckedForm"&gt;
   ...
   &lt;form:addtaglib namespace="..." prefix="form" class="honeypot" /&gt;
   &lt;form:honeypot name="check" /&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>
Die eigentliche Funktionalit√§t des <strong>honepot field</strong> steckt in der Validierung.
Diese wird im n√§chsten Kapitel besprochen.
<br />
<br />
<br />
<h4 id="Chapter-7-2-Validatoren"><a href="#Chapter-7-2-Validatoren">7.2. Validatoren</a></h4>
Validatoren werden ab dem Release <strong>1.11</strong> von Formular-Elementen getrennt
definiert und diesen als Observer mitgegeben. Um diesen Mechanismus zu unterst√ºtzen, muss das
Formular-Element jedoch darauf vorbereitet sein. Im Fall des im vorangegangenen Kapitels
beschriebenen Honeypot-Feldes ist die Validierungs-Funktionalit√§t bereits durch die
Basis-Klasse <strong>form_control</strong> definiert. Bei der Validierung wird dem Validator der
Inhalt des Attributs <strong>value</strong> √ºbergeben und dieser kann entsprechend darauf
reagieren.
<br />
<br />
Der zu erstellende <strong>HoneypotValidator</strong> ist im Wesentlichen ein Text-Feld-Validator,
daher kann die im APF-Release enthaltene Klasse <strong>TextFieldValidator</strong> als Basis
f√ºr die Implementierung verwendet werden. Diese leitet von
<strong>AbstractFormValidator</strong> ab, der Basis-Klasse f√ºr alle Formular-Validatoren.
<br />
<br />
Jeder Validator implementiert die Methode <strong>validate()</strong>, die den zu validierenden
Inhalt entgegen nimmt. In unserem Fall erh√§lt die Funktion den Inhalt des Honeypot-Feldes.
Dieses muss im Positiv-Fall leer sein, sofern dort Zeichen enthalten ist, muss das Feld als invalid
gekennzeichnet werden. Hierzu kann folgender Code verwendet werden:
<gen:highlight type="php">
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }
   ...
}
</gen:highlight>
Da die Klasse <strong>TextFieldValidator</strong> bereits die Benachrichtigung eines &quot;echten&quot;
Text-Feldes √ºbernimmt wird das Feld im Fehlerfall mit einer CSS-Klasse versehen, die zur
optischen Markierung genutzt werden kann. Dies ist im aktuellen Anwendungsfall nicht erforderlich
und muss daher unterdr√ºckt werden. Hierzu √ºberschreiben wir die Methode
<strong>notify()</strong> der Klasse <strong>TextFieldValidator</strong>, die aufgerufen wird,
sofern ein Feld nicht erfolgreich validiert werden konnte:
<gen:highlight type="php">
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }

   public function notify(){
      $this->__Control->markAsInvalid();
      $this->notifyValidationListeners($this->__Control);
   }
}
</gen:highlight>
Die Methode enth√§lt im Gegensatz zur Implementierung in der Klasse
<strong>TextFieldValidator</strong> die Zeile
<gen:highlight type="php">
$this->markControl($this->__Control);
</gen:highlight>
nicht. Damit haben wir das optische Markieren des fehlerhaften Formular-Feldes ausgeschaltet.
<br />
<br />
Die Anwendung des Validators gestaltet sich dann im Zusammenhang mit dem Honeypot-Textfeld wie folgt:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="CheckedForm"&gt;
   &lt;form:addtaglib namespace="..." prefix="form" class="honeypot" /&gt;
   &lt;form:honeypot name="check" /&gt;
   &lt;form:addvalidator
      namespace="..."
      class="HoneypotValidator"
      control="check"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
Der Validator kann durch die eigentst√§ndige Definition auch auf andere Text-Felder angewendet
werden, die Text-Validierung unterst√ºtzen. Hierzu z√§hlen alle im Release mitgelieferten
Text- und Text-Area-Taglibs.
<br />
<br />
<br />
<h4 id="Chapter-7-3-Filter"><a href="#Chapter-7-3-Filter">7.3. Filter</a></h4>
F√ºr das Honeypot-Feld wird kein Validator ben√∂tigt. Aus diesem Grund soll in diesem
Kapitel ein Filter implementiert werden, mit dem deutsche Umlaute durch die Laut-Entsprechungen
(z.B. √§ -> ae) ersetzt werden.
<br />
<br />
Der <strong>GermanUmlautsFilter</strong> implementiert dabei die Klasse
<strong>AbstractFormFilter</strong> - die wie der <strong>AbstractFormValidator</strong> bei den
Validatoren - das Interface eines Formular-Filters beschreibt.
<br />
<br />
Jeder Filter implementiert dabei die Methode <strong>filter()</strong>. Diese nimmt den zu
filternden Inhalt entgegen, f√ºhrt die gew√ºnschte Funktion aus und gibt den gefilterten 
Inhalt wieder zur√ºck.
<br />
<br />
Das Grundger√ºst des Filters kann damit durch folgenden Code beschrieben werden:
<gen:highlight type="php">
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return $input;
   }
}
</gen:highlight>
Die Funktionalit√§t des Filters besteht aus einem einfachen Aufruf der Funktion
<strong>str_replace()</strong>:
<gen:highlight type="php">
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return str_replace(
         array('√§','√∂','√º','√Ñ','√ñ','√ú','√ü'),
         array('ae','oe','ue','Ae','Oe','Ue','ss'),
         $input
      );
   }
}
</gen:highlight>
Die Anwendung des Filters gestaltet sich dann im Zusammenhang mit einem Text-Feld oder einer
Text-Area wie folgt:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="UmlautsForm"&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:area name="comment" /&gt;
   &lt;form:addfilter
      namespace="..."
      class="GermanUmlautsFilter"
      control="name|comment"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_114" />