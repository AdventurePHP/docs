<doku:title parent="100" tags="taglib,taglibs,tag,parser" title="Implementierung von Tags" urlname="Implementierung von Tags">
   Dieses Kapitel beschreibt die Bedeutung und die Implementierung von eigenen Tags/Taglibs.
</doku:title>
<h3 id="Chapter-1-Einfuehrung"><a href="#Chapter-1-Einfuehrung">1. Einführung</a></h3>
<p>
   Dieses Kapitel widmet sich den APF-Tags (a.k.a. Taglibs), deren Bedeutung und Implementierung.
</p>
<p>
   Der <int:link pageid="098"/> basiert auf dem gleichnamigen Software-Entwurfsmuster und ist ein zentraler Bestandteil
   des APF. Er ermöglicht dem Entwickler über das Tag-Konzept, eigene Funktionalitäten zur Erzeugung und Transformation
   des HMVC-DOM-Baumes zu injizieren. Tags bilden damit nicht nur die Basis des APF-HMVC-Konzepts, sondern können auch
   zur Erweiterung desselben genutzt werden.
</p>
<p>
   Des Weiteren können Tags dazu verwendet werden um darin enthaltene Funktionalitäten in unterschiedlichen Projekten
   wiederzuverwenden. APF-Templates verarbeiten - als Schutz vor unkontrollierter Verteilung von Logik - lediglich Tags
   und keinen PHP-Code. Damit ist der Entwickler gezwungen, View-Logik in Tags oder Controller zu verpacken.
</p>

<h4 id="Chapter-1-1-Page-Controller"><a href="#Chapter-1-1-Page-Controller">1.1. Page-Controller</a></h4>
<p>
   Aufgabe des <int:link pageid="098"/> ist der Aufbau und die Transformation der internen Template-Struktur.
   Hierzu bietet er ein Tag-API, die einem definierten Timing-Modell folgend Tags einliest, daraus Dokumente im Baum
   erzeugt und aus dem Baum anschließend eine HTML-Ausgabe erzeugt. Andere Formate wie beispielsweise XML sind ebenfalls
   möglich. Der Parser ist kein &quot;echter&quot; XML-Parser, beherrscht jedoch die Auflösung von explizit- und
   selbst-schließenden Tags sowie die Schachtelung von Tags in beliebig tiefen Hierarchien.
</p>
<div class="warn">
   Bitte beachten Sie die Hinweise im Kapitel <a href="#Chapter-6-Tag-Hierarchie">Tag-Hierarchie</a> zu den Restriktionen
   des Parsers.
</div>
<p>
   Die mit dem APF ausgelieferten <int:link pageid="046"/> bieten bereits eine Reihe an Standard-Funktionalitäten wie
   das Einbinden einer weiteren Template-Datei, die Definition von wiederverwendbaren Template-Fragmenten und das
   Bekanntgeben von eigenen Tags an.
</p>

<h4 id="Chapter-1-2-XML-Parser"><a href="#Chapter-1-2-XML-Parser">1.2. XML-Parser</a></h4>
<p>
   Der <em>XMLParser</em> dient dem Page-Controller zur Analyse einer Tag-Definition im Template und wird bei der
   Erstellung von <em>Document</em>-Instanzen genutzt.
</p>
<div class="warn">
   Der <em>XMLParser</em> verarbeitet aus Performance-Gründen nur durch Leerzeichen getrennte Attribute. Die Werte von
   Attributen müssen mit doppelten Anführungszeichen umschlossen sein.
</div>

<h3 id="Chapter-2-Definition-eines-Tags"><a href="#Chapter-2-Definition-eines-Tags">2. Definition eines Tags</a></h3>
<p>
   Ein APF-Tag definiert sich durch folgende Bestandteile:
</p>
<ul>
   <li>
      <strong>Prefix</strong>: das <em>Prefix</em> des Tags dient im Allgemeinen zur Strukturierung der Tags in Gruppen
      (z.B. <em>core</em> für Tags, die mit dem APF mitgeliefert werden). Dieser Teil ist mit XML-Namespaces vergleichbar.
   </li>
   <li>
      <strong>Name</strong>: der <em>Name</em> des Tags bezeichnet den Tag selbst. Dieser Teil ist mit XML-Tag-Namen
      vergleichbar.
   </li>
   <li>
      <strong>Attribute</strong>: die Attribute des Tags können zur Konfiguration des Tags genutzt werden. Sie dürfen
      keine weiteren Tags enthalten.
   </li>
   <li>
      <strong>Inhalt</strong>: der Inhaltsbereich des Tags kann weitere Tags oder Text enthalten. Der APF-Parser löst
      dort enthaltene Tags entsprechend auf und hängt diese als Kinder in die aktuelle Hierarchie ein. Einfacher Text
      ist später ebenfalls in der Tag-Instanz verfügbar.
   </li>
</ul>
<p>
   Folgende Tag-Definition könnte zur Ausgabe des aktuellen Datums in einem Template genutzt werden:
</p>
<gen:highlight type="apf-xml">
<current:date format="H:i" />
</gen:highlight>
<p>
   Dabei ist <em>current</em> das Prefix des Tags, <em>date</em> der Name und das Attribut <em>date</em> beinhaltet das
   Ausgabe-Format. Der Tag definiert keinen Inhalt.
</p>
<p>
   Zur Darstellung einer Bildergalerie könnte folgendes Tag genutzt werden:
</p>
<gen:highlight type="apf-xml">
<img:gallery>
   <h3>Mein Urlaub 2012</h3>
   <p>
      Diese Bilder stammen aus meinem Urlaub im Jahr 2012:
   </p>
   <gallery:datasource
      namspace="..."
      class="..."
   />
</img:gallery>
</gen:highlight>
<p>
   In diesem Beispiel beinhaltet der <em>&lt;img:gallery /&gt;</em>-Tag statisches HTML, was später zur Formatierung der
   Ausgabe genutzt werden kann und einen weiteren Tag zur Angabe der Datenquelle (z.B. aus einer Datenbank). Zur
   Verwendung des Tags muss auch dieses zunächst dem APF-Parser bekannt gegeben werden.
</p>

<h3 id="Chapter-3-DOM-Struktur"><a href="#Chapter-3-DOM-Struktur">3. DOM-Struktur</a></h3>
<p>
   Wie im Kapitel <a href="#Chapter-1-1-Page-Controller">Kapitel 2</a> angesprochen erzeugt der <int:link pageid="098"/>
   aus der Tag-Struktur in den Template-Dateien einen DOM-Baum. Dieser ähnelt dem eines Browsers, der aus den HTML-Tags
   ebenfalls eine Speicherstruktur erzeugt.
</p>
<p>
   Der Unterschied zur DOM-Struktur eines Browsers besteht darin, dass die einzelnen Knoten jeweils eigene Funktionalität
   zur Transformation bzw. Darstellung beinhalten, die der Page-Controller während der Transformationsphase nutze. Details
   zum Timing-Modell des Page-Controller finden Sie <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">hier</int:link>.
</p>
<p>
   Jeder Tag bzw. ab einem definierten Zeitpunkt seine Instanz durchläuft einen definierten Zyklus. Zunächst wird die
   Struktur des Tags analysiert, dann seine Substanz (Attribute und Inhalt). Anschließend wird gemäß der Tag-Definition
   eine Instanz des Tags erstellt und mit dem vom <em>XMLParser</em> analysierten Inhalt initialisiert.
</p>
<div class="hint">
   Der Page-Controller verarbeitet Tags nur dann, wenn sie im aktuellen Knoten bekannt sind. Aus diesem Grund müssen
   eigene Tags zunächst bekannt gegeben werden. Dies kann mit Hilfe des <em>&lt;core:addtaglib /&gt;</em>-Tag oder einem
<gen:highlight type="php">
$this->__TagLibs[] = new TagLib(...);
</gen:highlight>
   in einem eigenen Tag erreicht werden. Die Nutzung des <em>&lt;core:addtaglib /&gt;</em>-Tags ist immer dann notwendig,
   wenn Sie innerhalb eines Templates einen eigenen Tag bekannt geben wollen, das PHP-Code-Beispiel nutzen Sie, wenn Sie
   innerhalb eines eigenen Tags eine weitere Hierarchie-Stufe bekannt geben wollen.
</div>
<p>
   Zur Bekanntgabe eines Tags werden <em>Präfix</em> und <em>Name</em> sowie <em>Namespace</em> und
   <em>Klassen-Name</em> der Tag-Implementierung beschrieben. Dabei kann eine Implementierung über unterschiedliche
   <em>Präfix</em>- und <em>Namens</em>-Angaben mehrfach in unterschiedlichen Hierarchien oder Projekten genutzt werden.
   Die Klasse <em>TagLib</em> besitzt folgende Signatur (gekürzt):
</p>
<gen:highlight type="php">
final class TagLib {

   private $namespace;
   private $class;
   private $prefix;
   private $name;

   public function __construct($namespace, $class, $prefix, $name) {
   }

}
</gen:highlight>
<p>
   Details zu unterschiedlichen Ebenen von Tags können Sie im Kapitel <a href="#Chapter-6-Tag-Hierarchie">Tag-Hierarchie</a>
   nachlesen.
</p>

<h3 id="Chapter-4-Klassenstruktur-eines-Tags"><a href="#Chapter-4-Klassenstruktur-eines-Tags">4. Klassenstruktur eines Tags</a></h3>
<p>
   Die Struktur eines Tags beschreibt die Klasse <em>Document</em>. Diese ist die Mutter aller Tag-Implementierungen des
   APF und definiert eine Reihe von Methoden, die innerhalb des Timing-Modells des Page-Controllers zu unterschiedlichen
   Zwecken aufgerufen werden.
</p>
<p>
   Die Signatur de Klasse <em>Document</em> ist wie folgt (gekürzt):
</p>
<gen:highlight type="php">
class Document extends APFObject {

   protected $__ObjectID = null;
   protected $__ParentObject = null;
   protected $__Children = array();
   protected $__Content;
   protected $__TagLibs = array();

   public function __construct() {
   }

   public function onParseTime() {
   }

   public function onAfterAppend() {
   }

   public function transform() {
   }

}
</gen:highlight>
<p>
   Den aufgeführten Elementen kommt dabei folgende Bedeutung zu:
</p>
<ul>
   <li>
      Im Feld <em>__ObjectID</em> wird die eindeutige interne Objekt-Id gespeichert, die jeder Tag vom APF-Parser bei
      Erzeugen erhält. Diese wird u.a. bei der Vergabe von <int:link pageid="004"/>-Tags genutzt um jedes DOM-Element
      eindeutig zu referenzieren.
   </li>
   <li>
      <em>__ParentObject</em> referenziert auf das Vater-Objekt innerhalb des DOM-Baumes. Diese Referenz kann zur
      Traversierung des DOM-Baumes genutzt werden. Der Root-Knoten hat keinen Vater.
   </li>
   <li>
      In der Liste <em>__Children</em> finden sich alle Kind-Knoten des aktuellen DOM-Elements. Diese Liste kann zur
      Traversierung des DOM-Baumes genutzt werden. Hat ein DOM-Knoten keine Kinder, ist die Liste leer.
   </li>
   <li>
      Die Variable <em>__Content</em> beinhaltet den textuellen Inhalt eines Tags und die Platzhalter, die der
      Page-Controller bei der Erzeugung des DOM-Baumes hinterlässt um den exakten Zusammenbau des HTML-Quelltextes
      sicher zu stellen.
   </li>
   <li>
      In der Variable <em>__Attributes</em> - aus der Klasse <em>APFObject</em> vererbt - findet sich eine assoziative
      Liste der Tag-Attribute wieder. Besitzt das Tag keine Attribute, ist die Liste leer.
   </li>
   <li>
      Die <em>__TagLibs</em>-Liste beinhaltet die für den aktuellen Knoten bekannte Tags. Wie im vorangegangenen Kapitel
      angesprochen, verarbeitet der APF-Parser nur bekannte Tags innerhalb einer Hierarchie-Stufe bzw. innerhalb eines
      DOM-Elements. Welche Tags bekannt oder eben nicht bekannt sind, bestimmt demnach der Inhalt dieser Liste.
      <div class="hint">
         Die <em>__TagLibs</em>-Liste kann in eigenen Tag-Implementierungen dazu genutzt werden, neue Tags bekannt zu geben
         oder bereits bekannte Tags zu entfernen. Da die Manipulation der Liste in die eine oder die andere Richtung direkte
         Auswirkung auf die Verarbeitung von Tags hat, behalten Sie bitte die Bedeutung stets im Hinterkopf!
      </div>
   </li>
   <li>
      Der Konstruktor einer Tag-Klasse wird bei der Erzeugung der Tag-Instanz aufgerufen. Der Parser übergibt jedoch
      keine Argumente. Die Methode kann dazu genutzt werden, weitere Tags für die vorliegende Hierarchie bekannt zu
      geben oder Standard-Werte zu belegen.
      <div class="warn">
         Zum Zeitpunkt der Ausführung des Konstruktors sind weder die Attribute des Tags noch der Inhalt verfügbar.
         Ebenso sind der Kontext und die Sprache des Tags noch nicht initialisiert.
      </div>
   </li>
   <li>
      Nachdem der Tag geparst wurde wird die Methode <em>onParseTime()</em> aufgerufen. Zu diesem Zeitpunkt sind die
      Attribute des Tags und der Inhalt in der Instanz verfügbar. Auch Kontext und Sprache des Tags sind initialisiert.
      Diese Methode kann dazu genutzt werden, den Tag mit Hilfe der verfügbaren Informationen weiter zu initialsieren
      oder den Tag-Inhalt weitere zu analysieren (z.B. enthaltene Kind-Tags parsen.
   </li>
   <li>
      Ist der Knoten in den DOM-Baum eingehangen - sprich sind Vater und Kinder bekannt - wird die Methode
      <em>onAfterAppend()</em> aufgerufen. Innerhalb dieser Methode können Sie nun Logik platzieren, die auf Vater und
      Kinder Auswirkung hat.
   </li>
   <li>
      Soll der aktuelle DOM-Knoten transformiert werden, ruft der Page-Controller die Methode <em>transform()</em> Ihres
      Tags auf. Platzieren Sie hier bitte diejenige Logik, die zur Erzeugung von HTML-Quelltext benötigt wird. Tags, die
      innerhalb des DOM-Baumes lediglich zur Konfiguration oder Initialisierung dienen generieren oft keine Ausgabe (z.B.
      <em>&lt;core:addtaglib /&gt;</em>). Wie sich Ihr Tag letztlich verhält bleibt Ihrer Implementierung überlassen.
      <div class="hint">
         Sofern die Methode <em>transform()</em> in eigenen TagLibs überschrieben wird, muss
         sich der Entwickler selbst um die Transformation der Kind-Knoten kümmern. Dies kann im
         einfachsten Fall durch
<gen:highlight type="php">
foreach($this->__Children as $objectId => $DUMMY){
   $this->__Content = str_replace(
      '<'.$objectId.' />',
      $this->__Children[$objectId]->transform(),
      $this->__Content
   );
}
</gen:highlight>
         erreicht werden, wenn in den Methoden <em>onParseTime()</em> oder <em>onAfterAppend()</em> die
         Parser-Funktion <em>__extractTagLibTags()</em> aufgerufen wurde. Weitere Hinweise können dem
         Foren-Beitrag
         <a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a>
         entnommen werden.
      </div>
   </li>
</ul>

<h3 id="Chapter-5-Implementierung"><a href="#Chapter-5-Implementierung">5. Implementierung</a></h3>

<h4 id="Chapter-5-1-Einfacher-Tag"><a href="#Chapter-5-1-Einfacher-Tag">5.1. Einfacher Tag</a></h4>
<p>
   Dieses Kapitel beschäftigt sich mit einfachen Tags. &quot;Einfach&quot; meint in diesem Zusammenhang einen Tag, der
   eine bestimmte Aufgabe erledigt, jedoch keine weitere Hierarchie erzeugt - sprich keine Kind-Tags besitzt.
</p>
<p>
   Als Beispiel soll die Ausgabe der aktuellen Uhrzeit aus <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a>
   dienen. Hierzu muss der Tag lediglich zur Transformatinszeit die Uhrzeit im gewünschten Format zurückgeben.
   Abhängigkeiten zu anderen Tags im Baum und die Notwendigkeit der Initialisierung bestehen nicht. Der Quellcode des
   Tags gestaltet sich damit wie folgt (Namespace: <em>examples::tags::pres</em>):
</p>
<gen:highlight type="php">
class HourDisplayTag extends Document {

   public function transform() {
     return date($this->getAttribute('format'));
   }

}
</gen:highlight>
<p>
   Innerhalb eines Templates lässt er sich wie anschließend gezeigt verwenden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="examples::tags::pres"
   class="HourDisplayTag"
   prefix="current"
   name="date"
/>&gt;
<current:date format="H:i:s" />
</gen:highlight>
<div class="hint">
   Der Konstruktor der Klasse <em>Document</em> gibt mögliche Kind-Tags bekannt, die in der aktuellen Implementierung
   nicht benötit werden. Insofern könnte als mögliche Speicherverbrauchsoptimierung ebenso der Konstruktor überschrieben
   werden damit sichergestellt ist, dass der Tag keine weiteren Kinder verarbeiten kann.
</div>

<h4 id="Chapter-5-2-Komplexer-Tag"><a href="#Chapter-5-2-Komplexer-Tag">5.2. Komplexer Tag</a></h4>
<p>
   Als &quot;komplexer&quot; Tag versteht das APF einen Tag mit weiteren - in der Hierarchie nicht eingeschränkten -
   Kind-Knoten.
</p>
<p>
   Als Beispiel soll die Ausgabe einer Bildergalerie aus <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a> dienen.
   Dieser Tag definiert zunächst statischen Inhalt, der zur Ausgabe einer Überschrift und eines Einleitungstextes
   genutzt wird. Die Generierung der Ausgabe selbst wird vom <em>&lt;img:gallery /&gt;</em>-Tag mit Hilfe eines
   <em>Content-Providers</em>, der durch den <em>&lt;gallery:datasource /&gt;</em>-Tag definiert wird.
</p>
<div class="hint">
   Bitte beachten Sie, dass die Struktur des Beispiels willkürlich gewählt und nicht für Ihre Implementierungen bindend
   ist. Es wäre sowohl denk- als auch realisierbar den Content-Provider über Tag-Attribute zu definieren und die
   Formatierung der Galerie über weitere Elemente (siehe z.B. <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator</int:link>)
   zu realisieren.
</div>

<h5 id="Chapter-5-2-1-Basis"><a href="#Chapter-5-2-1-Basis">5.2.1. Basis</a></h5>
<p>
   Die Basis-Struktur des Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="php">
import('examples::tags::pres', 'GalleryDataSourceTag');

class GalleryTag extends Document {

   public function __construct() {
      $this->__TagLibs[] = new TagLib(
         'examples::tags::pres',
         'GalleryDataSourceTag',
         'gallery',
         'datasource'
      );
   }

   ...

}
</gen:highlight>
<p>
   Im Konstruktor des Tags wird dem Parser der <em>&lt;gallery:datasource /&gt;</em>-Tag bekannt gegeben. Damit der
   Parser die Klasse <em>GalleryDataSourceTag</em> findet, wird sie per <em>import()</em> eingebunden.
</p>

<h5 id="Chapter-5-2-2-Konfiguration-des-Content-Provider"><a href="#Chapter-5-2-2-Konfiguration-des-Content-Provider">5.2.2. Konfiguration des Content-Provider</a></h5>
<p>
   Widmen wir uns nun zunächst der Konfiguration des <em>Content-Providers</em>. Hierzu spendieren wir dem
   <em>&lt;img:gallery /&gt;</em>-Tag ein privates Feld und einen Setter, damit der <em>&lt;gallery:datasource /&gt;</em>-Tag
   die Instanz übergeben kann:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   private $contentProvider;

   ...

   public function setContentProvider(ImageGalleryContentProvider $provider) {
     $this->contentProvider = $provider;
   }

   ...

}
</gen:highlight>
<p>
   Der Provider selbst definiert sich durch folgendes Interface:
</p>
<gen:highlight type="php">
interface ImageGalleryContentProvider {
   /**
    * @return GalleryImage[]
    */
   public function getImages();
}

class GalleryImage {

   private $title;
   private $description;
   private $imageUrl;

   public function __construct($title, $description, $imageUrl) {
      $this->title = $title;
      $this->description = $description;
      $this->imageUrl = $imageUrl;
   }

   public function getDescription() {
      return $this->description;
   }

   public function getImageUrl() {
      return $this->imageUrl;
   }

   public function getTitle() {
     return $this->title;
   }

}
</gen:highlight>
<p>
   Gemäß unseres Beispieles ist der <em>&lt;gallery:datasource /&gt;</em>-Tag dafür zuständig den gewünschten Provider
   zu erzeugen und dem <em>GalleryTag</em> mitzugeben. Dies lässt sich innerhalb der <em>onAfterAppend()</em>-Methode
   erledigen, da zu diesem Zeitpunkt der Vater-Knoten bekannt ist:
</p>
<gen:highlight type="php">
class GalleryDataSourceTag extends Document {

   public function __construct() {
   }

   public function onAfterAppend() {
      $provider = &$this->getServiceObject(
         $this->getAttribute('namespace'),
         $this->getAttribute('class')
      );
      /* @var $parent GalleryTag */
      $parent = &$this->getParentObject();
      $parent->setContentProvider($provider);
   }

   public function transform() {
      return '';
   }

}
</gen:highlight>
<p>
   Da der <em>GalleryDataSourceTag</em> keine weiteren Kinder erwartet, wurde der Konstruktor von <em>Document</em> leer
   überschrieben. In der Methode <em>onAfterAppend()</em> erzeugt das Tag den gewünschten Provider mit Hilfe des
   <int:link pageid="107" anchor="Chapter-3-2-1-ServiceManager-Einfache-Services">ServiceManager</int:link> um der Instanz
   Kontext und Sprache des aktuellen Elements mitzugeben. Anschließend wird dem Vater-Element des DOM-Baumes - hier
   eine Instanz der Klasse <em>GalleryTag</em> wie mit dem Type-Hint angegeben wird - der Provider injiziert.
</p>
<p>
   Die leer überschriebene <em>transform()</em>-Methode sorgt dafür, dass keine weiteren Kind-Elemente transformiert oder
   eine Ausgabe erzeugt wird. Dies ist im aktuellen Beispiel nicht notwendig.
</p>

<h5 id="Chapter-5-2-4-Parsen-des-GalleryDataSourceTag"><a href="#Chapter-5-2-4-Parsen-des-GalleryDataSourceTag">5.2.4. Parsen des GalleryDataSourceTag</a></h5>
<p>
   Damit der <em>GalleryDataSourceTag</em> seine Arbeit verrichten kann muss der <em>GalleryTag</em> dafür sorgen, dass
   er auch vom Page-Controller erfasst und ausgeführt wird. Dazu bringt der Page-Controller bereits eine Parser-Methode
   mit, die in jeder von <em>Document</em> erbenden Klasse ausgeführt werden kann - <em>__extractTagLibTags()</em>.
</p>
<p>
   Zu welchem Zeitpunkt diese aufgerufen werden soll entscheiden zunächst Sie selbst. Beachten Sie dabei jedoch immer das
   <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Ablaufdiagramm des Page-Controller</int:link> um den für
   den Anwendungsfall richtigen Zeitpunkt zu wählen. In unserem Fall ist lediglich wichtig, dass der Provider <em>vor</em>
   der Erzeugung der Inhalte ausgeführt wird. Damit sind theoretisch drei Möglichkeiten denkbar:
</p>
<ul>
   <li>In einer eigenen <em>onParseTime()</em>-Methode.</li>
   <li>In einer eigenen <em>onAfterAppend()</em>-Methode.</li>
   <li>Zu Beginn der <em>transform()</em>-Methode.</li>
</ul>
<p>
   Üblicherweise schickt es sich für die Analyse von weiteren Kind-Strukturen die <em>onParseTime()</em>-Methode zu
   nutzen, da Sie damit sicherstellen, dass die weiteren Elemente im Baum ebenfalls die Möglichkeit haben, Kind-Knoten
   zeitlich korrekt zu erzeugen.
</p>
<p>
   Um den <em>GalleryDataSourceTag</em> zu erzeugen und auszuführen, reicht folgender Quellcode:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function onParseTime() {
      $this->__extractTagLibTags();
   }

   ...

}
</gen:highlight>
<p>
   Alles Weitere erledigt der APF-Parser für Sie gemäß den bekannten Tags.
</p>

<h5 id="Chapter-5-2-3-Erzeugen-der-Ausgabe"><a href="#Chapter-5-2-3-Erzeugen-der-Ausgabe">5.2.3. Erzeugen der Ausgabe</a></h5>
<p>
   Die Ausgabe der Bildergalerie erfolgt in der Methode <em>transform()</em>, die vom Page-Controller bei der Transformation
   des Baumes aufgerufen wird. Diese muss nun dafür sorgen, dass die Bilder, die vom Provider geliefert werden
   entsprechend ausgegeben werden.
</p>
<p>
   Unter der Annahme, dass alle Bilder als ungeordnete Liste mit entsprechendem Platz für Beschreibungen ausgegeben werden,
   gestaltet sich die Methode <em>transform()</em> wie folgt:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<' . 'ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<' . 'li>'
            . '<' . 'img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
            . '<' . 'p>' . $image->getDescription() . '<' . '/p>'
            . '<' . '/li>';
      }
      $buffer .= '<' . '/ul>';

      $this->setContent($this->getContent() . $buffer);
   }

}
</gen:highlight>
<p>
   Mit der aktuellen Implementierung werden alle Bilder als Listen-Elemente nach dem im <em>&lt;img:gallery /&gt;</em>-Tag
   vorhandenen statischen Inhalt angezeigt.
</p>
<div class="hint">
   Soll in einem Tag kein statischer Inhalt zugelassen werden, so kann dieser in der <em>transform()</em>-Methode durch
   <em>setContent()</em> durch einen dynamisch erzeugten überschrieben werden.
</div>
<div class="hint">
   Damit bei der Transformation die Inhalte eines Tags an der korrekten Stelle ausgegeben werden,
   erzeugt die Methode <em>__extractTagLibTags()</em> Platzhalter der Form
   <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Dabei entspricht <em>{OBJECT_ID}</em>
   dem Wert der Klassen-Variable <em>$this->__ObjectID</em> und dem Array-Offset, in dem die
   Kind-Tags gespeichert werden (<em>$this->__Children</em>). Dieser Wert kann dann bei der
   Implementierung von eigenen <em>transform()</em>-Methoden für die Ersetzung des Inhalts
   genutzt werden.
</div>
<p>
   Im Fall des <em>&lt;img:gallery /&gt;</em>-Tags sollen die Kind-Tags keine Ausgabe erzeugen, was prinzipiell mit der
   <em>GalleryDataSourceTag::transform()</em>-Methode sichergestellt. Da der APF-Parser jedoch zur Positionierung der
   Ausgabe Platzhalter erzeugt, müssen diese in unserem Beispiel dennoch ersetzt werden. Dies kann durch folgende
   Erweiterung passieren:
</p>
<gen:highlight type="php">
class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<' . 'ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<' . 'li>'
         . '<' . 'img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
         . '<' . 'p>' . $image->getDescription() . '<' . '/p>'
         . '<' . '/li>';
      }
      $buffer .= '<' . '/ul>';

      $this->setContent($this->getContent() . $buffer);

      foreach ($this->__Children as $objectId => $DUMMY) {
         $this->__Content = str_replace(
            '<' . $objectId . ' />',
            $this->__Children[$objectId]->transform(),
            $this->__Content
         );
      }
   }

}
</gen:highlight>

<h4 id="Chapter-5-3-Document-API"><a href="#Chapter-5-3-Document-API">5.3. Document-API</a></h4>
<p>
   Zur Implementierung von Tag-Logik stehen zahlreiche Methoden zur Verfügung. Diese umfassen das Parsen von Tag-Strukturen,
   das Traversieren des Baumes und das Manipulieren oder Auslesen von Tag-Informationen. Diese sind:
</p>
<ul>
   <li>
      <strong>__extractTagLibTags()</strong>:
      Analysiert die bekannten Kind-Tags und erstellen den DOM-Baum daraus.
   </li>
   <li>
      <strong>getParentObject()</strong>:
      Liefert die Instanz des Vater-Tags im DOM-Baum. Sofern kein Vater vorhanden ist, liefert die Methode <em>null</em>.
   </li>
   <li>
      <strong>setParentObject()</strong>:
      Injiziert eine Instanz als Vater-Tags des entsprechenden DOM-Knotens..
   </li>
   <li>
      <strong>getChildren()</strong>:
      Liefert die Liste aller Kinder des Tags. Sofern keine Kinder vorhanden sind, wird eine leere Liste zurückgegeben.
   </li>
   <li>
      <strong>getContent()</strong>:
      Liefert den Inhalt des befragten DOM-Elements.
   </li>
   <li>
      <strong>setContent()</strong>:
      Beschreibt den Inhalt des entsprechenden DOM-Elements.
   </li>
   <li>
      <strong>getChildNode()</strong>:
      Liefert einen Kind-Knoten, der einem definierten Selektor genügt.
   </li>
   <li>
      <strong>getAttribute()</strong>:
      Liefert den Wert eines Attributes.
   </li>
   <li>
      <strong>setAttribute()</strong>:
      Definiert den Wert eines Attributes.
   </li>
   <li>
      <strong>getAttributes()</strong>:
      Liefert die Liste der aktuellen Attribute.
   </li>
   <li>
      <strong>getAttributesAsString()</strong>:
      Generiert eine XML-Repräsentation der übergebenen Attribute an Hand einer optionalen Whitelist.
   </li>
</ul>
<p>
   Weitere Methoden der Klasse <em>Document</em> oder der Basis-Klasse ihres aktuellen Tags finden Sie in der
   <int:link pageid="002"/>.
</p>

<h3 id="Chapter-6-Tag-Hierarchie"><a href="#Chapter-6-Tag-Hierarchie">6. Tag-Hierarchie</a></h3>
<p>
   Der Tag-Parser des APF besitzt aus Performance- und Konsistenz-Gründen einigen Restriktionen gegenüber einem
   &quot;echten&quot; XML-Parser. Diese sind:
</p>
<ul>
   <li>Tag-Attribute können nur durch Leerzeichen getrennt werden. Tab-Zeichen nicht nicht möglich.</li>
   <li>Der Inhalt von Tag-Attribute wird nur in doppelten Anführungszeichen erkannt.</li>
   <li>
      Tag-Hierarchien werden nur dann richtig aufgelöst, wenn ein Tag - bestehend aus Präfix und Namen - nur in einer
      Ebene bekannt sind. Dies erfordert die Registrierung einer Tag-Implementierung in unterschiedlichen Ebenen mit
      einer anderen Präfix-Name-Kombination.
      <div class="warn">
         Möchten Sie einen Tag auf &quot;höchster&quot; Ebene in einer Template-Datei und gleichzitig in einer tiefer
         gelegenen Struktur verwenden, ordnet der Parser die Instanzen falsch zu. Beispiel:
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   namespace="..."
   class="FooBarTag"
   prefix="foo"
   name="tag"
/&gt;
&lt;foo:bar id="..."/&gt;
&lt;html:template name="..."&gt;
   &lt;template:addtaglib
      namespace="..."
      class="FooBarTag"
      prefix="foo"
      name="tag"
   /&gt;
&lt;foo:bar id="..."/&gt;
&lt;/html:template&gt;
</gen:highlight>
         In diesem Fall ordnet der Parser die Instanz des Tags <em>&lt;foo:bar /&gt;</em> der obersten Ebene zu. Im
         <em>&lt;html:template /&gt;</em>-Tag ist kein <em>&lt;foo:bar /&gt;</em> vorhanden, sondern lediglich ein
         Platzhalter und es kommt bei der Transformation zu einem Fehler bzw. einem nicht nachvollziehbaren.
      </div>
   </li>
   <li>
      Als verarbeitbare Tags werden nur APF-Tags erkannt. Einfache HTML-Tags können nicht erfasst werden und dies
      erfordert u.U. die Implementierung von Wrapper-Tags für die Abstraktion.
   </li>
</ul>

<h4 id="Chapter-6-1-Einfache-Hierarchien"><a href="#Chapter-6-1-Einfache-Hierarchien">6.1. Einfache Hierarchien</a></h4>
<p>
   Einfache Tag-Hierarchien sind solche, bei denen Tags in unterschiedlichen Ebenen nur einmal vorkommen. Die Einschränkung
   des Tag-Parsers wirkt sich dabei vor allem auf den aktuell verarbeiteten Knoten - in der Regel das aktuelle Template -
   aus.
</p>

<h4 id="Chapter-6-2-Komplexe-Hierarchien"><a href="#Chapter-6-2-Komplexe-Hierarchien">6.2. Komplexe Hierarchien</a></h4>
<p>

</p>

<a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=4&amp;t=38">Schachtelung TagLibs</a>

<h3 id="Chapter-7-Anwendungsbeispiele"><a href="#Chapter-7-Anwendungsbeispiele">7. Anwendungsbeispiele</a></h3>

* Wann Tag wann Controller?
==> Generell gilt als Daumenregel: schreibe eine Taglib, wenn du mit einem Template plus Controller nicht mehr weiter kommst. Das sollte an und für sich selten der Fall sein, aber es schadet z.B. nicht, eigene und immer wieder verwendete Elemente (z.B. die Anzeige, ob jemand neue Elemente im Posteingang hat oder nicht) als Taglib abzufassen. Dann kannst du sie bequem in beliebige Templates einbinden ohne den Code nochmals schreiben zu müssen.

<h3 id="Chapter-8-Weiterfuehrende-Links"><a href="#Chapter-8-Weiterfuehrende-Links">8. Weiterführende Links</a></h3>
<p>
   Sofern Sie weitere Informationen benötigen, können Sie folgende Threads aus dem Forum nutzen:
</p>
<ul>
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=1126">TagLib unterschiedliche Zustände</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=982">Taglib innerhalb eines Templates</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=827">Taglib der Template rundherum läd</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=540">Taglibs</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=505">Mehrere Checkboxes taglib aus DB holen und ausgeben</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=456">Taglib-Call innerhalb eines Taglib-Call</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=191">transform() von eigenem taglib nicht ausgeführt</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=177">Menü taglib-modul</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=122">Performance TagLibs</a></li> 
   <li><a class="forum" href="http://forum.adventure-php-framework.org/de/viewtopic.php?f=5&amp;t=37">Taglibs vs. Templates</a></li> 
</ul>
<p>
   Im Wiki finden sich folgende Seiten zu den APF-Tags:
</p>
<ul>
   <li><a class="wiki" href="http://wiki.adventure-php-framework.org/de/All-in-one_Include-Tag">All-in-one Include-Tag</a></li> 
   <li><a class="wiki" href="http://wiki.adventure-php-framework.org/de/Timing-Modell_des_Page-Controller">Timing-Modell des Page-Controller</a></li> 
   <li><a class="wiki" href="http://wiki.adventure-php-framework.org/de/WYSIWYG_%2B_APF-Formulare">WYSIWYG + APF-Formulare</a></li> 
</ul>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="de_147" />