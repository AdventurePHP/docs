<doku:title parent="119" tags="forms,validation,manipulation,initialization,construction,dynamic forms,controller" title="Usage of forms (as of revision 1.11)" urlname="Usage-of-forms">
  This documentation page describes the structure and usage of forms. Among these are validation,
  presetting as well as field manipulation within the document controller. Further dynamic form
  generation is described.
</doku:title>
The adventure PHP framework contains a comprehensive form support based on the taglib concept. The
basics of forms and the available taglibs are described in the
<a href="./?Page=113-Forms" title="Forms">forms</a> chapter. This section now discusses the usage of
forms, dynamic form generation, and implementation of custon form taglibs in detail.
<br />
<br />
<br />
<h3 id="Chapter-1-Forms-and-controller"><a href="#Chapter-1-Forms-and-controller">1. Forms &amp; controller</a></h3>
Forms are kind of template fragments, that exist within the APF DOM tree, but are not displayed at
transformation. To display a form, a document controller is needed. The reason for it is simple:
nearly every form is attached to operations which should be executed with sending the form (e.g.
save data).
<br />
<br />
In order to display a form, the following controller code can be used:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('Search');
      $form->transformOnPlace();
   }
}
</gen:highlight>
Teherby, the <strong>$form</strong> variable contains a reference on the
<strong>html_taglib_form</strong> instance, that encapsulates an APF form with all it's child
elements. Having this reference, the form can be manipulated, filled, displayed, or adapted. Details
can be taken from the subsequent chapters.
<br />
<br />
<br />
<h3 id="Chapter-2-API-of-the-form-taglibs"><a href="#Chapter-2-API-of-the-form-taglibs">2. API of the form taglibs</a></h3>
As described within the preceeding section, a form can be referenced within a document controller
easily. This section deals with the API of the form taglibs, that gives you an idea if the
functionality included.
<br />
<br />
<div class="hint">
   It is recommended to have the
   <a href="./?Page=002-API-documentation" title="API documentation">API documentation</a>
   opened during development times. This eases work much, because each taglib has it's own API,
   that is described within the API documentation in detail.
</div>
<br />
The basic form element is defined within the <strong>form_control</strong> class. There, the structure
is defined as well as the basic functionality is included. Due to the fact, that all taglibs underly
the
<a href="./?Page=098-Pagecontroller#Chapter-2-1-Activity-diagram" title="Page controller lifecycle">page controller lifecycle</a>
each form element must implement the methods, a &quot;normal&quot; taglib must implement, too.
<br />
<br />
<div class="hint">
   In contrast to form controls <strong>up to version 1.10</strong>, form elements <strong>since
   version 1.11</strong> know about their validation status. Hence, each element can be queried it's
   status. Concerning the implementation, this means, that a form collects the status of all
   controls and returns the cumulated value executing the <strong>isValid()</strong> method.
</div>
<br />
Class <strong>form_control</strong> implements the following methods:
<ul>
   <li>
      <strong>isValid():</strong> The function enables you to query the validity status from
      inside the form as well as from the outside.
   </li>
   <li>
      <strong>markAsInvalid():</strong> Marks a form element as invalid.
   </li>
   <li>
      <strong>markAsSent():</strong> Marks an element as sent (only relevant for forms and buttons).
   </li>
   <li>
      <strong>isSent():</strong> Checks, whether a form was sent or not.
   </li>
   <li>
      <strong>isChecked():</strong> Returns true, in case a checkbox is checked and false otherwise.
   </li>
   <li>
      <strong>check():</strong> Enables a checkbox.
   </li>
   <li>
      <strong>uncheck():</strong> Deaktivates a checkbox.
   </li>
   <li>
      <strong>addFilter():</strong> Adds a filter to the current form control.
   </li>
   <li>
      <strong>addValidator():</strong> Adds a validator to the current form control.
   </li>
   <li>
      <strong>addAttribute():</strong> Can be used to add content to an existing attribute. This is
      used when notifying invalid form elements.
   </li>
   <li>
      <strong>notifyValidationListeners():</strong> Notifies all listeners of a form element, that
      it is invalid.
   </li>
   <li>
      <strong>__presetValue():</strong> This method provides presetting for form text fields. It
      can be directly used or overwritten for custom form elements.
   </li>
   <li>
      <strong>setPlaceHolder():</strong> This method implements a generic method to set place holder
      tags within subtags of the form taglib. Please note, that place holder tags must be namedag
      <strong>*:placeholder</strong> to be able to use the method.
   </li>
   <li>
      <strong>addAttributeToWhitelist():</strong> Adds the attribute applied to the method to the
      whitelist of the current form control. This causes the attribute to be included into the HTML
      source code.
   </li>
</ul>
<p>
   Using this methods, the developer is supported to implement custom form taglibs as described in
   chapter 7.
</p>
<div class="hint">
   <p>
      Since release 1.12 attribute whitelisting was introduced along with the client side form
      validator extension. This mechanism is responsible to only render XHTML compatible attributes
      to the HTML source code. Not suitable attributes - e.g. used for validation control - are
      ignored.
   <p>
   <p>
      Creating custom form taglibs you must care about the attributes of your taglib. Hence, we
      recommend to add the desired attributes within the constructor of the taglib:
   </p>
<gen:highlight type="php">
class form_taglib_myspecial extends form_control {
   public function form_taglib_myspecial(){
      $this->attributeWhiteList[] = 'name';
      $this->attributeWhiteList[] = 'accesskey';
   }
}
</gen:highlight>
</div>

<h3 id="Chapter-3-Validation"><a href="#Chapter-3-Validation">3. Validation</a></h3>
Validation is executed via the <strong>form:addvalidator</strong>, that attaches a validator to the
desired form control. The validator is executed, when the click event of a form button is fired.
Having a look at the timing, validation is executed within the <strong>onAfterAppend()</strong>
method of each taglib. This is after the analysis phase (at this time, the <strong>onParseTime()</strong>
of each taglib is executed) and the DOM tree is fully created by the page controller.
<br />
<br />
Within the <strong>onAfterAppend()</strong> method of the <strong>form:addvalidator</strong> tag,
the validator is created and initialized with the necessary information (button and target form
control) and given to the target element. The element itself executes the validator in case it is
active and checks the result. In case of errors, the <strong>notify()</strong> method of the
validator is called.
<br />
<br />
<br />
<h4 id="Chapter-3-1-Validation-status-query"><a href="#Chapter-3-1-Validation-status-query">3.1. Validation status query</a></h4>
Since each form element knows about it's validation status within the new implementation, the 
form's <em>isValid()</em> method must query the status of each form element. Using a document
controller, you can get the form status as follows:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      if($form->isSent()){
         echo 'Form was send');
      }
      if($form->isValid()){
         echo 'Form is valid';
      }
   }
}
</gen:highlight>
Further, you can ask a single form element to return it's status using the subsequent PHP code:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      $searchField = &$form->getFormElementByName('searchterm');
      if($searchField->isValid()){
         echo 'Search field is valid';
      }
   }
}
</gen:highlight>
To decide, whether a button has been clicked, use the follwing code:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('MyForm');
      $button = &$form->getFormElementByID('button');
      if($button->isSent()){
         echo 'Search button was clicked';
      }
   }
}
</gen:highlight>
<div class="hint">
   To get an overview of the existent methods, please refer to the
   <a href="./?Page=002-API-documentation" title="API documentation">API documentation</a> of the
   classes <strong>html_taglib_form</strong>, <strong>form_control</strong> and the dedicated
   form taglibs (e.g. <strong>form_taglib_text</strong>).
</div>
<br />
<br />
<h4 id="Chapter-3-2-Display-of-validation-messages"><a href="#Chapter-3-2-Display-of-validation-messages">3.2. Display of validation messages</a></h4>
Introducin form validation, the fields containing wrong data are often marked with red borders and
the user is presented a validation message. To achieve this, the taglibs
<strong>&lt;form:error /&gt;</strong> (used for global error messages) and
<strong>&lt;form:listener /&gt;</strong> can be used. As an alternative, you may use place holders,
that are filled with the appropriate error messages within the controller code.
<br />
<br />
<br />
<h5 id="Chapter-3-2-1-Form-error"><a href="#Chapter-3-2-1-Form-error">3.2.1. Form error</a></h5>
The <strong>&lt;form:error /&gt;</strong> displays it's content, in case the form is not valid -
regardless which field is invalid. For this reason, the tag queries the form's status at transformation
time:
<br />
<br />
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:error&gt;Please fill in the mandatory fields!&lt;/form:error&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $form->transformOnPlace();
   }
}
</gen:highlight>
Within the <strong>&lt;form:error /&gt;</strong> tag, you may define further tags for formatting
or content generation purposes as described in chapter
<a href="./?Page=113-Forms#Chapter-3-19-Error" title="display of form errors">display of form errors</a>.
<br />
<br />
<br />
<h5 id="Chapter-3-2-2-Listener"><a href="#Chapter-3-2-2-Listener">3.2.2. Listener</a></h5>
The <strong>&lt;form:listener /&gt;</strong> tag is aimed to display field specific errors. As noted
in the introduction chapter, the <strong>notify()</strong> method is called, when a form control
is considered invalid. This method then notifies all listener tags, that have registered on this
event to display their content at transformation time.
<br />
<br />
In the below, field specific messages are displayed in case a desired field is marked invaluid:
<br />
<br />
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:listener control="code"&gt;Please fill in a five letter product code!&lt;/form:listener&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:listener control="title"&gt;Please fill in a title with at least 20 characters!&lt;/form:listener&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:listener control="description"&gt;Please provide a verbose product description!&lt;/form:listener&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:addvalidator
      class="TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Save" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $form->transformOnPlace();
   }
}
</gen:highlight>
Within the <strong>&lt;form:listener /&gt;</strong> tag, you may define further tags for formatting
or content generation purposes as described in chapter
<a href="./?Page=113-Forms#Chapter-3-18-Listener" title="Listener">Listener</a>.
<br />
<br />
<br />
<h3 id="Chapter-4-Handle-form-content"><a href="#Chapter-4-Handle-form-content">4. Handle form content</a></h3>
A frequent job with the handling of forms is the readout of values. To support this, the following
methods can be used in the document controller:
<ul>
   <li>
      <strong>getFormElementByID():</strong> Returns a form element selected by id
      (Attribut: <em>id</em>).
   </li>
   <li>
      <strong>getFormElementByName():</strong> Returns a form element selected by name
      (Attribut: <em>name</em>).
   </li>
   <li>
      <strong>getFormElementsByTagName():</strong> Returns a list of form elements selected by tag name
      (z.B. <em>form:text</em>).
   </li>
   <li>
      <strong>getFormElementsByObjectID():</strong> Returns a form element selected by the APF DOM
      id. This can be used generating dynamic forms.
   </li>
</ul>
<br />
<h4 id="Chapter-4-1-Select-by-name"><a href="#Chapter-4-1-Select-by-name">4.1. Select by name</a></h4>
Are you faced with the task to gather the values of the form described in chapter 3.2.2., you can
use the subsequent controller code:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('product-form');

      if($form->isSent() && $form->isValid()){

         $code = &$form->getFormElementByName('code');
         echo 'product code: '.$code->getAttribute('value');

         $title = &$form->getFormElementByName('title');
         echo 'product title: '.$title->getAttribute('value');

         $description = &$form->getFormElementByName('description');
         echo 'product desc: '.$description->getContent();
      }

   }
}
</gen:highlight>
<div class="hint">
   Using text ares, the content of the tag is not contained in the <strong>value</strong> attribute
   but within the content of the tag. This is identical to the HTML tag definition.
</div>
<br />
Due to the fact, that an APF form is a DOM subtree containing form taglibs, a place holder within
an error tag can be addressed with two steps. First, get the instance of the error tag, and second
get the place holder's instance from the error tag. To have a dedicated example, consider the
following form definition:
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:error name="error"&gt;
      &lt;error:placeholder name="ph1" /&gt;
   &lt;/form:error&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>
To fill the place holder within the <strong>&lt;form:error /&gt;</strong> tag use the following
controller code:
<gen:highlight type="php">
class form_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('product-form');
      $error = &$form->getFormElementByName('error');

      // simple way:
      $error->setPlaceHolder('ph1','My placeholder value');

      // alternative way:
      $placeHolder = $error->getFormElementByName('ph1');
      $placeHolder->setContent('My placeholder value');
   }
}
</gen:highlight>
<div class="hint">
   To select a form element by id, the same procedure can be used. Please ensure, to use the
   content of the id atttribute of the desired form element in combination with the
   <em>getFormElementByID()</em> method.
</div>
<br />
<br />
<h4 id="Chapter-4-2-Selection-by-tag"><a href="#Chapter-4-2-Selection-by-tag">4.2. Selection by tag</a></h4>
In some cases, it may be useful to select form elements by it's tag name. For this application case,
the <strong>getFormElementsByTagName()</strong> method is available. It returns a list of form controls
filtered by the given tag name.
<br />
<br />
In combination with the
<a href="./?Page=063-Generic-OR-mapper#Chapter-4-3-Saving-objects" title="GenericORMapper - savin objects">GenericORMapper</a>
the method can be used to read the content of the form elements and directly map them to a
<strong>GenericDomainObject</strong>. Achieving this, you can use the following code:
<gen:highlight type="php">
class edit_controller extends base_controller {
   public function transformContent(){
      $form = &$this->__getForm('...');
      $textFields = &$form->getFormElementsByTagName('form:text');
      $user = new GenericDomainObject('User');
      $count = count($textFields);
      for($i = 0; $i < $count; $i++){
         $user->setProperty(
            $textFields[$i]->getAttribute('name'),
            $textFields[$i]->getAttribute('value')
         );
      }
   }
}
</gen:highlight>
Please note, that the method returns only those elements which exist as direct child nodes in all
cases.
<br />
<br />
<br />
<h3 id="Chapter-5-Manipulation-of-forms"><a href="#Chapter-5-Manipulation-of-forms">5. Manipulation of forms</a></h3>
The implementation of the form taglibs of the framework included several opportunities to manipulate
form elements or their values. The next chapters thus describe solutions for the most frequent tasks.
<br />
<br />
<br />
<h4 id="Chapter-5-1-Presetting"><a href="#Chapter-5-1-Presetting">5.1. Form presetting</a></h4>
To preset form controls (e.g. within an edit dialog) the
<ul>
   <li><strong>getFormElementByName()</strong>,</li>
   <li><strong>getFormElementByTagName()</strong>,</li>
   <li><strong>getFormElementByID()</strong> oder</li>
   <li><strong>getFormElementByObjectID()</strong></li>
</ul>
methods can be used to gather an instance of the desired form control. After that, you can take one
of the standard methods
<ul>
   <li><strong>get()</strong> und</li>
   <li><strong>getAttribute()</strong></li>
</ul>
or
<ul>
   <li><strong>set()</strong> und </li>
   <li><strong>setAttribute()</strong></li>
</ul>
respectively to retrieve or fill the content.
<br />
<br />
The subsequent code box defines a form, that is filled using the php code below:
<br />
<br />
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="UserEdit" method="post"&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
$form = &$this->__getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
$userID->setAttribute('value','...');

$firstName = &$form->getFormElementByName('FirstName');
$fFirstName->setAttribute('value','...');

$lastName = &$form->getFormElementByName('LastName');
$lastName->setAttribute('value','...');
</gen:highlight>
<br />
<h4 id="Chapter-5-2-Prefilling-of-form-controls"><a href="#Chapter-5-2-Prefilling-of-form-controls">5.2. Prefilling of form controls</a></h4>
Treatment of select and multi select fields is a bit different to normal form controls. But, the
framework provides methods to ease prefilling of select fields. The subsequent code is used to
prefill a form, that contains select fields in addition to normal text fields:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="UserCreate" method="post"&gt;
   &lt;strong&gt;Salutation&lt;/strong&gt;:
   &lt;form:select name="Salutation" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;strong&gt;Salutation&lt;/strong&gt;:
   &lt;br /&gt;
   &lt;form:multiselect name="Group" validate="true" button="Edit" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</gen:highlight>
The below controller code prefills the form:
<gen:highlight type="php">
$form = &$this->__getForm('UserCreate');
$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['DisplayName'], $salutations[$i]['Value']);
}
$goups = array(...);
$group = &$form->getFormElementByName('Groups');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['DisplayName'], $groups[$i]['Value']);
}
</gen:highlight>
<div class="hint">
   In order to mark options as selected, please use the <strong>setOption2Selected()</strong> method.
</div>
<br />
The follwing code box gives presents an example taken from the
<a href="./?Page=095-Module-usermanagement" title="Usermanagement module">usermanagement module</a>.
The controller code first fills the select field and then preselects the desired option.
<gen:highlight type="php">
$form = &$this->__getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</gen:highlight>
<br />
<h4 id="Chapter-5-3-Readout-of-form-controls"><a href="#Chapter-5-3-Readout-of-form-controls">5.3. Readout of form controls</a></h4>
Readout of form controls is similar to prefilling. Please note, that simple and multi select fields
are handled a little bit different. The following code example shows how the values can be read out
from the form described in chapter 3.1:
<gen:highlight type="php">
$form = &$this->__getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
echo $userID->getAttribute('value');

$firstName = &$form->getFormElementByName('FirstName');
echo $firstName->getAttribute('value');

$lastName = &$form->getFormElementByName('LastName');
echo $lastName->getAttribute('value');
</gen:highlight>
In order to get the selected options of simple and multi select fields,
<strong>getSelectedOption()</strong> and <strong>getSelectedOptions()</strong> can be used. The
subsequent code box describes how:
<gen:highlight type="php">
$form = &$this->__getForm('UserCreate');

$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['Value'],$salutations[$i]['DisplayName']);
}

$option = &$salutation->getSelectedOption();
echo $option->getAttribute('value').', '.$option->getContent();

$groups = array(...);
$group = &$form->getFormElementByName('Groups[]');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['Value'],$groups[$i]['DisplayName']);
}

$selectedGroups = &$group->getSelectedOptions();
for($i = 0; $i < count($selectedGroups); $i++){
   echo $selectedGroups[$i]->getAttribute('value').', '.$selectedGroups[$i]->getContent();
}
</gen:highlight>
<br />
<h3 id="Chapter-6-Dynamic-forms"><a href="#Chapter-6-Dynamic-forms">6. Dynamic forms</a></h3>
In some cases it is necessary to generate forms dynamically. For this reason, the form taglib
(<em>html_taglib_form</em>) features the methods
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
</ul>
and as of release 1.7
<ul>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
The first two functions can be used to add content (i.e. plain text or html) or form elements at the
end of the form. The latter ones are intended to add content or form at certain positions. For this
reason, the <strong>&lt;form:marker /&gt;</strong> tag was introduced. The tag itself does not generate
any output, but can be used for positioning purposes along with the "<em>addForm*[Before|After]Marker()</em>"
methods.
<br />
<br />
The following chapters describe, how a dynamic form can be generated displaying form coordinate fields
(triangle, square, ...). Depending on the type, the corresponding fields are displayed. If the type
is set to "square", four fields are displayed ...
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_02.png" alt="APF - dynamische Form generation; selection of the 'square' type" />
<br />
<br />
... in case of "triangle" three fields are presented:
<br />
<br />
<img src="http://media.adventure-php-framework.org/content/dynamic_forms_01.png" alt="APF - dynamische Form generation; selection of the 'triangle' type" />
<br />
<br />
<br />
<h4 id="Chapter-6-1-Form-definition"><a href="#Chapter-6-1-Form-definition">6.1. Form definition</a></h4>
As already mentioned, the dynamic definition can be done in two flavours. While using
<em>addFormElement()</em> and/or <em>addFormContent()</em>, no marker is needed. Instead, the
following example uses marker, because the form already contains structural elements (e.g. table).
<br />
<br />
The following code box shows the form definition needed to display the form denoted above. To keep
things simple, no CSS was added. Taking a closer look at the definition, you can see, that the form
consists of a static select field, that defines the types available and a marker tag for positioning.
Further, a document controller is specified, to add the desired form elements in front of the marker:
<gen:highlight type="apf-xml">
&lt;@controller namespace="..." file="..." class="select_controller" @&gt;
&lt;core:addtaglib namespace="tools::form::taglib" prefix="html" class="form" /&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<h4 id="Chapter-6-2-Controller"><a href="#Chapter-6-2-Controller">6.2. Controller</a></h4>
The document controller is responsible for generating the form field, that depends on the type of
the geometrical shape. For this reason, the constructor contains a definition of the form fields
that should be displayed for a concrete type. Afterwards, the typ is read from the select field and
the form is enhanced with additional content and fields. The following code box presents the
implementation of the document controller needed for this functionality:
<gen:highlight type="php">
class select_controller extends base_controller {

   // specify form element container
   private $__FormElements = array();

   public function __construct(){

      // define form elements for the triangle
      $this->__FormElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->__FormElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->__FormElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->__FormElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->__FormElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

   }

   pubic function transformContent(){

      // get form reference
      $form = &$this->__getForm('type');

      // get current decision
      $Select = &$form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
      }
      else{
         $CurrentType = $Option->getAttribute('value');
      }

      // add form elements
      for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

         // add label
         $form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $currentElementID = $form->addFormElementBeforeMarker(
                                'fields',
                                'form:text',
                                array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                             );

         // configure further form element attributes
         $currentElement = &$form->getFormElementByObjectID($currentElementID);
         $currentElement->setAttribute('style','width: 200px;');

         // add a line break
         $form->addFormContentBeforeMarker('fields','<br />');

      }

      // display form
      $form->transformOnPlace();

   }

}
</gen:highlight>
<br />
<h4 id="Chapter-6-3-Dynamic-filters-and-validators"><a href="#Chapter-6-3-Dynamic-filters-and-validators">6.3. Dynamic filters and validators</a></h4>
As of release <strong>Release 1.11</strong> the filter and validation comcept was completely
redesigned. This does also effect the dynamic form filters and validators.
<br />
<br />
As described in chapter
<a href="./?Page=113-Forms#Chapter-4-2-Construction-of-validators" title="Construction of validators">construction of validators</a>
and
<a href="./?Page=113-Forms#Chapter-5-2-Construction-of-filters" title="Construction of filters">construction of filters</a>
validators and filters are attached to a form control as an <strong>Observer</strong>. Using dynamic
forms, this can be simulated by imitateing the <strong>&lt;form:addvalidator /&gt;</strong> and
<strong>&lt;form:addfilter /&gt;</strong> tags. This means, that you can add a filter or validator
using the <strong>addValidator()</strong> and <strong>addFilter()</strong> method respectively. The
follwing code sample descibes this approach in detail:
<gen:highlight type="php">
// gather button instance of the form
$button = &$form->getFormElementByName('submit');

// create dynamic form elements
for($i = 0; $i < count($this->__FormElements[$CurrentType]); $i++){

   // add label
   $form->addFormContentBeforeMarker('fields',$this->__FormElements[$CurrentType][$i]['label'].': ');

   // add text field (name attribute is present to enable validation and presetting!)
   $currentElementID = $form->addFormElementBeforeMarker(
                           'fields',
                           'form:text',
                           array('name' => $this->__FormElements[$CurrentType][$i]['name'])
                       );

   // configure further form element attributes
   $currentElement = &$form->getFormElementByObjectID($currentElementID);
   $currentElement->setAttribute('style','width: 200px;');

   // add filter to the current element
   $filter = new NoSpecialCharactersFilter($currentElement,$button);
   $currentElement->addFilter($filter);

   // add validator to the current element
   $validator = new TextLengthValidator($currentElement,$button);
   $currentElement->addValidator($validator);

   // add a line break
   $form->addFormContentBeforeMarker('fields','<br />');

}
</gen:highlight>
<div class="hint">
   Please respect the order of filters and validators defining dynamic forms. If you do not, 
   undesirable validation effects may occure, because filters are executed after validators.
</div>
<br />
<br />
<h4 id="Chapter-6-4-Notes"><a href="#Chapter-6-4-Notes">6.4. Notes</a></h4>
A APF form element does need information about the name of itself already at creation time. If the
element doesn't know it's own name, presetting and validation cannot be enabled. In order to use
presetting and validation in combination with dynamic form elements, the <em>addFormElement()</em>,
<em>addFormElementBeforeMarker()</em> and <em>addFormElementBeforeMarker()</em> functions possess a
third parameter. This parameter expects an associative list of tag attributes, that are applied to
the form object on creation time. Creating dynamic form elements, it is thus recommended to at least
apply the name of the tag to the third argument:
<gen:highlight type="apf-xml">
array(
      'name' => 'currentname'
     )
</gen:highlight>
Please note, that the tag attributes are also interesting for addressing the form objects after
appending them to the form via the <em>getFormElementByName()</em> or <em>getFormElementByID()</em>
methods.
<br />
<br />
<br />
<h3 id="Chapter-7-Enhancement-of-form-controls"><a href="#Chapter-7-Enhancement-of-form-controls">7. Enhancement of form controls</a></h3>
The concept of the APF's page controller allows you to write own taglibs to create reusable elements.
This also continues with forms. Custom form controls can be added using the <strong>&lt;form:addtaglib /&gt;</strong>
tag. This tag acts similar to the <strong>&lt;core:addtaglib /&gt;</strong>, but is restricted to
forms.
<br />
<br />
The difference between a normal taglib and a form taglib is the fact, that each form taglib implements
the abstract <strong>form_control</strong> class. Hence, the form control inherits an advanced tag
definition and some more functionality to enable the <strong>&lt;html:form /&gt;</strong> tag to
handle the control. The extra functionality mentioned in the last sentence merely consists of
validation and filter handling code.
<br />
<br />
The next three chapters describe the creation of custom form controls, validators and filters.
Besiders, implementation examples are presented.
<br />
<br />
<br />
<h4 id="Chapter-7-1-Form-controls"><a href="#Chapter-7-1-Form-controls">7.1. Form controls</a></h4>
As mentioned above, an APF form control is defined by the abstract class <strong>form_control</strong>.
In order to implement a custom form element, the class' functionality must be enhanced.
<br />
<br />
As an example, a form element should be discussed that generates a hidden input field in order to
protect a form. In the next chapter, we are going to implement the appropriate validator. In case,
the control is filled, we consider the field invalid and assume, that it was filled by automated
scripts. Otherwise, the field is defined to be valid. In various blog entries this kind of fields
are also as called
<a class="external" href="http://nedbatchelder.com/text/stopbots.html" title="Stopping spambots with hashes and honeypots">honeypot fields</a>.
<br />
<br />
Let's start with the basics of the element. As described in the last sentence, the tag should
generate a hidden text input field. To achieve this, the taglib must return the desired source
code:
<gen:highlight type="php">
class form_taglib_honeypot extends form_control {
   public function transform(){
      $htmlCode  = (string)'&lt;input ';
      $htmlCode .= $this->__getAttributesAsString($this->__Attributes);
      $htmlCode .= 'type="text" ';
      $htmlCode .= 'style="margin: 0px; padding: 0px; display: none; height: 0px; width: 0px;"';
      $htmlCode .= ' /&gt;';
      return $htmlCode;
   }
}
</gen:highlight>
Due to the fact, that validation and filter attachment as well as the method returning the validity
status of the tag is already included in the <strong>form_control</strong> class, the code printed
above is all that you need by now.
<br />
<br />
In order to use the newly created form control, the <strong>&lt;form:addtaglib /&gt;</strong> tag
can be used to announce the tag to the form:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="CheckedForm"&gt;
   ...
   &lt;form:addtaglib namespace="..." prefix="form" class="honeypot" /&gt;
   &lt;form:honeypot name="check" /&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>
The real functionality is now included in the <strong>honepot field</strong> validator. See the
next chapter for details.
<br />
<br />
<br />
<h4 id="Chapter-7-2-Validators"><a href="#Chapter-7-2-Validators">7.2. Validators</a></h4>
Validators are defined separately and are attached as observer since release <strong>1.11</strong>.
In order to support this mechanism, a form control must be aware of validators. In case of the honey
pot field, the functionality is already included in the tag, because it extends the base class
<strong>form_control</strong>. Thus, the validator is applied the content of the <strong>value</strong>
attribute and is thus able to act as descibed in the introduction.
<br />
<br />
For convenience, we call the validator <strong>HoneypotValidator</strong>. In common sense, it is a
text field validator and can thus use the <strong>TextFieldValidator</strong> class as a basis. This
class derives from <strong>AbstractFormValidator</strong>, what is the bas class for all validators.
<br />
<br />
Each validator must implement the <strong>validate()</strong> method, that is applied the content to
validate. In case of the <em>HoneypotValidator</em> the content of the text field must be empty to
consider the control valid. If not, the field is marked as invalid. The following code can be used
to implement the descibed functionality:
<gen:highlight type="php">
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }
   ...
}
</gen:highlight>
Due to the fact, that <strong>TextFieldValidator</strong> already contains the functionality that
is necessary to notify a &quot;real&quot; text field and mark it with a red border in case of errors.
As of this application case, we do not need this functionality and though we have to suppress it.
For this reason, we are going to overwrite the <strong>notify()</strong> method (defined within
<strong>TextFieldValidator</strong>), that is called when a field failed validation:
<gen:highlight type="php">
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }

   public function notify(){
      $this->__Control->markAsInvalid();
      $this->notifyValidationListeners($this->__Control);
   }
}
</gen:highlight>
In contrast to the implementation of the <strong>TextFieldValidator</strong> class, the line
<strong>TextFieldValidator</strong> die Zeile
<gen:highlight type="php">
$this->__Control->addAttribute('style','; border: 2px solid red;');
</gen:highlight>
is not included. This disables the marking of the form element using a red CSS border.
<br />
<br />
The following code box describes the application of the validator together with the above honeypot
field:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="CheckedForm"&gt;
   &lt;form:addtaglib namespace="..." prefix="form" class="honeypot" /&gt;
   &lt;form:honeypot name="check" /&gt;
   &lt;form:addvalidator
      namespace="..."
      class="HoneypotValidator"
      control="check"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
Thanks to the independent definition and implementation of the validator, it can also be applied to
other text fields. These are all text fields and text areas shipped with the APF release.
<br />
<br />
<br />
<h4 id="Chapter-7-3-Filter"><a href="#Chapter-7-3-Filter">7.3. Filter</a></h4>
Applying the honeypot field no filter is needed. Hence, this chapter describes a filter, that
substitutes German umlauts with their phoneme equivalents (e.g. &auml; -> ae).
<br />
<br />
The <strong>GermanUmlautsFilter</strong> thus implements the <strong>AbstractFormFilter</strong> class
that is the base class for all form filters just as the <strong>AbstractFormValidator</strong> is
for validators. The abstract form filter class defines the interface for all concrete form filter
implementations.
<br />
<br />
Further, each form filter implements <strong>filter()</strong> method described in the APF
<a href="./?Page=087-Filter#Chapter-4-Design-and-function" title="Design and function of filters">filter api</a>.
The function takes the content to filter as an argument and returns the filtered content.
<br />
<br />
The skeleton of the filter is as follows:
<gen:highlight type="php">
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return $input;
   }
}
</gen:highlight>
The functionality of the filter is a simple string replace call using the PHP standard function
<strong>str_replace()</strong>:
<gen:highlight type="php">
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return str_replace(
         array('&auml;','&ouml;','&uuml;','&Auml;','&Ouml;','&Uuml;','&szlig;'),
         array('ae','oe','ue','Ae','Oe','Ue','ss'),
         $input
      );
   }
}
</gen:highlight>
The application of the filter using a text field or a text area can be taken from the below code box:
<gen:highlight type="apf-xml">
&lt;core:addtaglib namespace="tools::html::form" prefix="html" class="form" /&gt;
&lt;html:form name="UmlautsForm"&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:area name="comment" /&gt;
   &lt;form:addfilter
      namespace="..."
      class="GermanUmlautsFilter"
      control="name|comment"
      button="send"
   /&gt;
   &lt;form:button name="send" value="Send" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<br />
<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_114" />