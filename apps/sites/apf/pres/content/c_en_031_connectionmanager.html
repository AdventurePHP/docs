<doku:title parent="119" tags="documentation,class reference,classes,reference,singleton,connectionmanager" title="ConnectionManager" urlname="ConnectionManager">
  The conceptual goal of the connection manager is, to define conventions like the configuration and
  the addressing of the database access layer. In best case, the database layer of an application
  can be replaced with another wothout changing any line of code.
</doku:title>
<p>
   The notion of the ConnectionManager is to define the configuration and implementation of a database
   abstraction and access layer. Ideally, this approach eases switching from one database driver to
   another.
</p>
<p>
   Despite the fact, that this procedure is described a little bit too idealistic - different databases
   often have different features - the ConnectionManager itself gives a common understanding of how an
   application's data layer should communicate with the database abstraction layer.
</p>

<h3 id="Chapter-1-Configuration"><a href="#Chapter-1-Configuration">1. Configuration</a></h3>
<p>
   The <strong>ConnectionManager</strong> is a kind of factory to concrete implementations of database
   driver classes. To load the desired driver the abstraction layer must be configured using the config
   file
</p>
<gen:highlight type="code">/config/core/database/{CONTEXT}/{ENVIRONMENT}_connections.ini</gen:highlight>
<p>
   Details on configuration files can be found in the
   <a href="./?Page=033-Configuration" title="Configuration">configuration</a> chapter. The configuration
   file mentioned above must contain one section for each driver layer:
</p>
<gen:highlight type="ini">
[sectionname]
DB.Host = ""
DB.User = ""
DB.Pass = ""
DB.Name = ""
[DB.DebugMode = "true|false"]
</gen:highlight>
<p>
   The <strong>sectionsname</strong> is used to create the driver instance, <strong>DB.Host</strong>
   contains the hostname of the database server, <strong>DB.User</strong> and <strong>DB.Pass</strong>
   define the logon credentials and <strong>DB.Name</strong> defines the name of the database to use.
   <strong>DB.Type</strong> is aimed to switch the debug mode on of off.
</p>
<div class="hint">
   The debug mode can be used to display the executed statement directly on screen. If you like to
   monitor the statements executes, you may use the optional parameter <em>$logStatement</em> applied
   to the <em>executeStatement()</em> and <em>executeTextStatement()</em> method. If set to
   <em>true</em>, the currently executed statement is appended to a log file. Details on the function
   can be obtained from the <int:link pageid="002" />.
</div>

<h3 id="Chapter-2-Practice"><a href="#Chapter-2-Practice">2. Practice</a></h3>
To be able to use the <strong>ConnectionManager</strong> the component must be imported by
<gen:highlight type="php">
import('core::database','ConnectionManager');
</gen:highlight>
prior to use. Further, you can create a database driver instance using the following code snippet:
<gen:highlight type="php">
$cM = &$this->__getServiceObject('core::database','ConnectionManager');
$db_driver = &$cM->getConnection('sectionname');
</gen:highlight>

<h3 id="Chapter-3-Extending-database-drivers"><a href="#Chapter-3-Extending-database-drivers">3. Extending the database drivers</a></h3>
<p>
   The class <strong>AbstractDatabaseHandler</strong> describes the interface of a database driver that
   can be created using the <strong>ConnectionManager</strong>. In order to implement another
   abstraction layer any other driver must inherit from <strong>AbstractDatabaseHandler</strong> and
   reside in the <strong>core::database</strong> namespace.
</p>

<h3 id="Chapter-4-Existing-abstraction-layers"><a href="#Chapter-4-Existing-abstraction-layers">4. Existing abstraction layers</a></h3>
The adventure php framework comes with two different abstraction layers:
<ul>
  <li>MySQLx: MySQL driver. Based on the mysql_* functions.</li>
  <li>SQLite: SQLite driver. Based on the sqlite_* functions. Needs PHP > 5.0.0!</li>
  <li>MySQLi: MySQLi driver. Based on the mysqli_* functions. Needs PHP > 5.0.0!</li>
</ul>

<h4 id="Chapter-4-1-MySQL-driver"><a href="#Chapter-4-1-MySQL-driver">4.1. MySQL driver</a></h4>
<p>
   In order to create an instance of the MySQL abstraction class the following configuration has to
   be included in the config file mentioned above:
</p>
<gen:highlight type="ini">
[MySQL]
DB.Host = "host"
DB.User = "user"
DB.Pass = "pass"
DB.Name = "name"
DB.Type = "MySQLx"
[DB.DebugMode = "true|false"]
[DB.Charset = ""]
[DB.Collation = ""]
</gen:highlight>
<p>
   The two parameters <strong>DB.Charset</strong> and <strong>DB.Collation</strong> are used to
   configure the <em>character set</em> and the <em>collation</em> of the MySQL connection. The
   directive <strong>DB.Charset</strong> sets the MySQL variables
</p>
<ul>
   <li>character_set_client</li>
   <li>character_set_connection</li>
   <li>character_set_results</li>
</ul>
and the value of <strong>DB.Collation</strong> is applied to the variables
<ul>
   <li>collation_connection</li>
   <li>collation_database</li>
</ul>
Both params are optional and can be defined alternately. There is no need to specify both params at
the same time.
<div class="hint">
   Details on the configuration param values can be taken from the MySQL documentation within
   chapter
   <a class="external" href="http://dev.mysql.com/doc/refman/5.0/en/charset-connection.html" title="Connection Character Sets and Collations (MySQL 5.0)">Connection Character Sets and Collations (MySQL 5.0)</a>.
</div>
Afterwards, the instance of the abstraction layer can be created using the following lines of code:
<gen:highlight type="php">
$cM = &$this->__getServiceObject('core::database','ConnectionManager');
$MySQL = &$cM->getConnection('MySQL');
</gen:highlight>
<p>
   Due to performance issues, the connection manager only creates singleton drivers.
</p>

<h4 id="Chapter-4-2-SQLite-driver"><a href="#Chapter-4-2-SQLite-driver">4.2. SQLite driver</a></h4>
Any SQLite abstraction layer instance can be configured by
<gen:highlight type="ini">
[SQLite]
DB.Name = "/path/to/my/database.sqlite"
DB.Type = "SQLite"
DB.DebugMode = "true|false"
</gen:highlight>
Please note, that host, user and password don't have to be configured, due to the fact, that SQLite
is an integrated database engine. Creating an instance of the driver class looks like this:
<gen:highlight type="php">
$cM = &$this->__getServiceObject('core::database','ConnectionManager');
$SQLite = &$cM->getConnection('SQLite');
</gen:highlight>

<h4 id="Chapter-4-3-MySQLi-driver"><a href="#Chapter-4-3-MySQLi-driver">4.3. MySQLi driver</a></h4>
<p>
   Der <em>MySQLi</em>-Treiber ist weitestgehend identisch mit der Implementierung des
   <em>MySQLx</em>-Treibers. Er unterst&uuml;tzt das Ausf&uuml;hren von dynamisch zusammengesetzten
   Statements und Statements, die in SQL-Dateien abgelegt sind.
</p>
<p>
   Um eine Instanz des MySQL-Treibers erstellen zu k&ouml;nnen, ist folgende Konfiguration notwendig:
</p>
<gen:highlight type="ini">
[MySQLi]
DB.Host = "host"
DB.User = "user"
DB.Pass = "pass"
DB.Name = "name"
DB.Type = "MySQLi"
[DB.DebugMode = "true|false"]
[DB.Charset = ""]
[DB.Collation = ""]
</gen:highlight>
<p>
   F&uuml;r die Konfiguration des Zeichensatz und der Collation gelten die selben Bedingungen wie
   f&uuml;r eine <a href="#Chapter-4-1-MySQL-Treiberschicht">MySQLx</a>-Connection.
</p>
<p>
   &Uuml;ber die Funktion des <em>MySQLx</em>-Treibers hinaus implementiert er Methoden, die es
   erlauben, Statements mit Bind-Parametern gegen die Datenbank auszuf&uuml;hren. Diese sind:
</p>
<ul>
   <li>executeTextBindStatement()</li>
   <li>executeBindStatement()</li>
</ul>
<p>
   Mit <em>executeTextBindStatement()</em> kann ein Statement, das - analog zu <em>executeTextStatement()</em>
   - als String &uuml;bergeben wurde gegen die Datenbank ausgef&uuml;hrt werden. Als zweiten Parameter
   erwartet es die Werte der Bind-Parameter.
</p>
<p>
   Die Methode <em>executeBindStatement()</em> f&uuml;hrt ein Statement aus, das in einer SQL-Datei
   abgelegt wurde und reichert dieses mit den im Aufruf &uuml;bergebenen Parametern an. Da die
   Implementierung der Bind-Parameter f&uuml;r MySQL-Datenbanken eine genaue Beachtung der Reihenfolge
   der Bind-Parameter voraussetzt, wurde in der Implementierung eine automatische Re-Sortierung
   eingef&uuml;hrt, die daf&uuml;r sort, dass die Zuordnung der Parameter des Methoden-Aufrufs zur
   Definition der Parameter in der SQL-Datei passt.
</p>
<p>
   F&uuml;r die Nutzung der Methode <em>executeTextBindStatement()</em> steht die Funktion
   <em>fetchBindResult()</em> zur Verf&uuml;gung. Diese holt analog zu <em>fetchData()</em> die
   gew&uuml;nschte Ergebnismenge ab.
</p>
<p>
   Die folgende Code-Box zweigt Anwendungsbeispiele f&uuml;r den Umgang mit Bind-Statements:
</p>
<gen:highlight type="php">
// retrieve db connection
$cm = &$this->__getServiceObject('core::database','ConnectionManager');
$conn = $cm->getConnection('MySQLi');

// execute textual statement with bind params
$data = $conn->executeTextBindStatement(
   'SELECT * FROM ent_user_2 WHERE FirstName LIKE ?',
   array('Christian')
);

// execute statement within an sql file with bind params
$data = $conn->executeBindStatement(
   'my::module',
   'notepad_entries',
   array('date_from' => '2009-03-20 00:00:00','date_until' => '2010-04-10 00:00:00')
);
</gen:highlight>
<p>
   Die Ausf&uuml;hrung der letzten Methode setzt voraus, dass eine SQL-Datei unter
</p>
<gen:highlight type="code">/apps/config/my/module/{CONTEXT}/{ENVIRONMENT}_notepad_entries.sql</gen:highlight>
<p>
   die &uuml;bergebenen Parameter in der Form
</p>
<gen:highlight type="sql">
SELECT *
FROM notepad
WHERE
   save_date BETWEEN [date_from] AND [date_until]
</gen:highlight>
<p>
   enth&auml;lt.
</p>

<core:importdesign namespace="modules::comments::pres::templates" template="comment" categorykey="en_031" />