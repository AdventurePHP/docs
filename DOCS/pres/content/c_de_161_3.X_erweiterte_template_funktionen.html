<doku:title parent="119" tags="templates,platzhalter,objekt zugriff" title="Erweiterte Template-Funktionen" urlname="Erweiterte-Template-Funktionen">
   Das vorliegende Kapitel beschreibt die erweiterten Templating-Funktionalitäten wie verkürzte Platzhalter-Syntax
   und der Zugriff auf Objekte in Data-Attributen. Desweiteren wird die Erweiterung von Template-Ausdrücken beschrieben.
</doku:title>
<h3 id="Chapter-1-Einleitung"><a href="#Chapter-1-Einleitung">1. Einleitung</a></h3>
<p>
   Aufbauend auf <int:link pageid="047" /> verfügt das APF über eine erweiterte Syntax für einfacheres Templating.
</p>
<p>
   Im Auslieferungszustand stehen die in <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a> beschriebenen
   Möglichkeiten zur Verfügung, in <a href="#Chapter-3-Erweiterung-der-Syntax">Kapitel 3</a> erfahren Sie, wie die
   Syntax erweitert werden kann.
</p>
<div class="hint">
   In Kapitel <int:link pageid="164" lang="en" /> (Englisch) finden Sie einen ausführlichen Artikel zur Nutzung von
   <em>View-Models</em> um Ihre Controller schlank und einfach testbar zu gestalten. Der Artikel nutzt die hier
   beschriebenen Möglichkeiten um die View-Templates einfach und übersichtlich zu gestalten.
</div>

<h3 id="Chapter-2-Verfuegbare-Funktionen"><a href="#Chapter-2-Verfuegbare-Funktionen">2. Verfügbare Funktionen</a></h3>
<p>
   Zusätzlich zu den im Kapitel <int:link pageid="047" anchor="Chapter-2-Aufbau-von-Templates"/> beschriebenen
   Funktionen lassen sich innerhalb von APF-Templates auch dynamische Template-Ausdrücke nutzen. Diese bieten Ihnen eine
   Kurzschreibweise für Platzhalter wie z.B. <em>&lt;html:placeholder /&gt;</em> sowie eine Pseudo-Sprache für den Zugriff
   auf Data-Attribute von APF-DOM-Knoten. Darüber hinaus lassen sich auch Methoden-Aufrufe und Listen-Zugriffe auf
   Data-Attribute realisieren.
</p>
<p>
   Die folgenden Kapitel zeigen Ihnen die Nutzung der beiden Funktionen und geben Ihnen Anwendungsbeispiele.
</p>

<h4 id="Chapter-2-1-Platzhalter"><a href="#Chapter-2-1-Platzhalter">2.1. Platzhalter</a></h4>
<p>
   Neben den bekannten APF-Tags für Platzhalter wie beispielsweise
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="foo" /&gt;
</gen:highlight>
<p>
   lässt sich auch die Kurzformen
</p>
<gen:highlight type="apf-xml">
&#36;{foo}
</gen:highlight>
<p>
   nutzen. Dies hilft die Größe Ihres Template-Codes zu reduzieren und gegebenfalls Probleme mit der IDE-Unterstützung
   für HTML-Dateien zu vermeiden.
</p>
<div class="hint">
   Die Kurzschreibweise von Platzhaltern setzt sich aus <em>&#36;{</em>, einem eindeutigen Bezeichner und einer schließenden
   Klammer - <em>}</em> - zusammen. Der Bezeichner darf keine weiteren Klammern enthalten. Erlaubt sind große und kleine
   Buchstaben sowie Binde- und Unterstriche.
</div>
<p>
   Der Zugriff auf Platzhalter in der Kurzform unterscheidet sich nicht von der herkömmlichen Notation. Möchten Sie die
   Platzhalter des Templates
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="&#36;{css-class}">
   <p>
      &#36;{intro-text}
   </p>
   <p>
      &#36;{detail-text}
   </p>
   <p>
      <a href="&#36;{link-target}">&#36;{link-label}</a>
   </p>
</div>
</gen:highlight>
<p>
   füllen, so können Sie dazu den folgenen Controller-Code nutzen:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      $this->setPlaceHolder('css-class', $model->getCssClass());
      $this->setPlaceHolder('intro-text', $model->getIntroText());
      $this->setPlaceHolder('detail-text', $model->getDetailText());
      $this->setPlaceHolder('link-target', $model->getMoreLink()->getTarget());
      $this->setPlaceHolder('link-label', $model->getMoreLink()->getLabel());

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>

<h4 id="Chapter-2-2-Objekt-Zugriff"><a href="#Chapter-2-2-Objekt-Zugriff">2.2. Objekt-Zugriff</a></h4>
<p>
   Die <em>Pseudo-Template-Sprache</em> des APF ermöglicht Ihnen, mit einem dynamischen Ausdruck auf Data-Attribute von
   APF-DOM-Knoten zuzugreifen und die dort abgelegten Inhalte innerhalb von Templates auszugeben.
</p>
<p>
   Das in <a href="#Chapter-2-1-Platzhalter">Kapitel 2.1</a> beschriebene Template-Beispiel lässt sich mit Hilfe der
   <em>Pseudo-Sprache</em> wie folgt vereinfachen:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="&#36;{news->getCssClass()}">
   <p>
      &#36;{news->getIntroText()}
   </p>
   <p>
      &#36;{news->getDetailText()}
   </p>
   <p>
      <a href="&#36;{news->getMoreLink()->getLinkTarget()}">
         &#36;{news->getMoreLink()->getLinkLabel()}
      </a>
   </p>
</div>
</gen:highlight>
<p>
   Der Controller verkürzt sich ebenfalls:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<p>
   Auf diese Weise lässt sich wiederholender Code aus Controllern entfernen und damit die Übersichtlichkeit erhöhen.
</p>
<p>
   Grundlage für die <em>Pseudo-Template-Sprache</em> ist das APF-DOM-Modell. Dieses ermöglicht - analog zu HTML-Knoten
   - Data-Attribute zu definieren. Die Klasse <em>Document</em> stellt hierzu die Methoden <em>setData()</em> und
   <em>getData()</em> zur Verfügung. Innerhalb des <em>BaseDocumentController</em> können Sie mit den gleichnamigen
   Methoden ebenfalls auf die Data-Attribute des aktuellen Knotens zuzugreifen.
</p>
<p>
   Die folgenden Kapitel stellen Ihnen die Funktionalitäten der Template-Sprache genauer vor.
</p>

<h5 id="Chapter-2-2-1-Listen-Zugriff"><a href="#Chapter-2-2-1-Listen-Zugriff">2.2.1. Listen-Zugriff</a></h5>
<p>
   Mit der <em>Pseudo-Template-Sprache</em> des APF lassen sich Listen-Zugriffe für Data-Attribute analog zur PHP-Syntax
   realisieren. Dabei werden einfach, sowie mehrfach verschachtelte Arrays mit nummerischen und alphanummerischen
   Adressen unterstützt.
</p>
<p>
   Sie können im Template auf einfache und verschachtelte Listen mit einfachen Inhalten, aber auch auf Listen mit
   komplexen Inhalten (Objekte) zugreifen. Der Zugriff auf komplexe Inhalte erfordert gegebenenfalls weitere Schritte.
   Beachten Sie hierzu bitte <a href="#Chapter-2-2-2-Objekt-Zugriff">Kapitel 2.2.2</a> und
   <a href="#Chapter-2-2-3-Kombinierter-Zugriff">Kapitel 2.2.3</a>.
</p>
<p>
   Die folgende Code-Box zeigt Ihnen den Zugriff auf Listen im Template:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Zugriff auf das erste, nummerische Offset --&gt;
&#36;{news[0]}

&lt;!-- Zugriff auf das Offset xyz --&gt;
&#36;{news['xyz']}

&lt;!-- Zugriff auf das nummerische Offset 1 und darin auf das nummerische Offset 2 --&gt;
&#36;{news[1][2]}

&lt;!-- Zugriff auf das nummerische Offset 1 und darin auf das alphanummerische Offset xyz --&gt;
&#36;{news[1]['xyz']}

&lt;!-- Zugriff mit Mischformen --&gt;
&#36;{news[1][2][3][4]}
&#36;{news[1]['two'][3]['four']}
</gen:highlight>
<p>
   Um mit den beschriebenen Ausdrücken auf Inhalte zugreifen zu können sind die Data-Attribute im Controller wie
   folgt zu befüllen:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      // Zugriff auf das erste, nummerische Offset
      $this->setData(
         'news',
         array(
            0 => $model
         )
      );

      // Zugriff auf das Offset xyz
      $this->setData(
         'news',
         array(
            'xyz' => $model
         )
      );

      // Zugriff auf das nummerische Offset 1 und darin auf das nummerische Offset 2
      $this->setData(
         'news',
         array(
            1 => array(
               2 => $model
            )
         )
      );

      // Zugriff auf das nummerische Offset 1 und darin auf das alphanummerische Offset xyz
      $this->setData(
         'news',
         array(
            1 => array(
               'xyz' => $model
            )
         )
      );

      // Zugriff mit Mischformen
      $this->setData(
         'news',
         array(
            1 => array(
               2 => array(
                  3 => array(
                     4 => $model
                  )
               )
            )
         )
      );
      $this->setData(
         'news',
         array(
            1 => array(
               'two' => array(
                  3 => array(
                     'four' => $model
                  )
               )
            )
         )
      );

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<div class="hint">
   Implementieren die in der Liste befindlichen Objekte die <em>__toString()</em>-Methode, so können Sie die Ausgabe
   der Objekte durch einen Listen-Zugriff erzeugen ohne weitere Methoden-Aufrufe zu definieren.
</div>

<h5 id="Chapter-2-2-2-Objekt-Zugriff"><a href="#Chapter-2-2-2-Objekt-Zugriff">2.2.2. Objekt-Zugriff</a></h5>
<p>
   Neben dem Zugriff auf Listen, bietet die <em>Pseudo-Template-Sprache</em> des APF auch den Zugriff auf Objekte in
   Data-Attributen. Die Syntax folgt auch hier der PHP-Syntax.
</p>
<p>
   Methoden-Aufrufe lassen sich in beliebiger Anzahl und Abfolge definieren und können auch in Verbindung mit Listen
   genutzt werden. Beachten Sie hierzu bitte die Dokumentation in
   <a href="#Chapter-2-2-3-Kombinierter-Zugriff">Kapitel 2.2.3</a>.
</p>
<p>
   Die folgende Code-Box zeigt Ihnen Beispiele für Methoden-Aufrufe:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Zugriff auf die Methode getCssClass() der Klasse ContentModel --&gt;
&#36;{news->getCssClass()}

&lt;!--
   Zugriff auf die Methode getLinkLabel() der Klasse LinkModel, das von der
   Methode getMoreLink() der Klasse ContentModel zurückgegeben wird
--&gt;
&#36;{news->getMoreLink()->getLinkLabel()}
</gen:highlight>
<p>
   Um mit den beschriebenen Ausdrücken auf Inhalte zugreifen zu können muss das Data-Attribute <em>news</em> im
   Controller wie folgt zu befüllt werden:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

}
</gen:highlight>
<div class="hint">
   Neben dem Zugriff auf Data-Attribute ist es auch möglich auf die Instanz desjenigen Tags zuzugreifen, in dem der
   Ausdruck definiert ist und ausgeführt wird. Hier steht Ihnen das Schlüsselwort <em>this</em> zur Verfügung. Möchten
   Sie beispielsweise den Namen des Templates ausgeben, in dem ein Ausdruck definiert ist, so können Sie dies wie folgt
   tun:
<gen:highlight type="apf-xml">
&lt;html:template name="foo"&gt;
   Template-Name: &#36;{this-&gt;getAttribute('name')}
&lt;/html:template&gt;
</gen:highlight>
</div>

<h5 id="Chapter-2-2-3-Kombinierter-Zugriff"><a href="#Chapter-2-2-3-Kombinierter-Zugriff">2.2.3. Kombinierter-Zugriff</a></h5>
<p>
   Die in <a href="#Chapter-2-2-1-Listen-Zugriff">Kapitel 2.2.1</a> und
   <a href="#Chapter-2-2-2-Objekt-Zugriff">Kapitel 2.2.2</a> beschriebenen Listen- und Methoden-Zugriffe lassen sich
   auch zu komplexeren Abfragen kombinieren. So kann durch eine Kombination eines Listen- und ein oder mehrerer
   Methoden-Aufrufe der Zugriff auf eine Liste von Einträgen und deren Eigenschaften realisieren.
</p>
<div class="hint">
   Bitte beachten Sie, dass mehrere Methoden-Aufrufe bzw. Listen-Zugriffe jeweils durch <em>-&gt;</em> getrennt sind.
</div>
<p>
   Beabsichtigen Sie in einem Template die ersten drei News-Einträge auszugeben, so lässt sich dies mit dem folgenden
   Template realisieren:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<ul class="news-list">
   <li>&#36;{news[0]->getIntroText()}</li>
   <li>&#36;{news[1]->getIntroText()}</li>
   <li>&#36;{news[2]->getIntroText()}</li>
</ul>
</gen:highlight>
<p>
   Zur Erzeugung der Ausgabe ist folgender Controller-Code notwendig:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getNews());
   }

   /**
    * @return ContentModel[]
    */
   private function getNews() {
      ...
   }

}
</gen:highlight>
<p>
   Die Methode <em>getNews()</em> liefert dabei eine Liste von <em>ContentModel</em>-Objekten zurück.
</p>
<p>
   Die Implementierung der <em>Pseudo-Template-Sprache</em> ermöglicht darüber hinaus weitere Kombinationen von Ausdrücken:
</p>
<gen:highlight type="apf-xml">
&lt;!-- Aufruf von getBar() auf das dritte von getFoo() zurückgegebene Element --&gt;
&#36;{news->getFoo()->[3]->getBar()}

&lt;!--
   Aufruf von getBaz() auf das Ergebnis von getBar(), das im Offset foo des
   5.ten Elements im Data-Attribut news steht
--&gt;
&#36;{news[5]['foo']->getBar()->getBaz()}
</gen:highlight>
<div class="warn">
   Bitte beachten Sie, dass die im letzen Code-Block aufgeführten Beispiele jeweils eine entsprechende Daten-Struktur
   voraussetzen! Fehlerhafte Ausdrücke führen zu Fehlern und damit zum Abbruch der Applikation.
</div>

<h3 id="Chapter-3-Erweiterung-der-Syntax"><a href="#Chapter-3-Erweiterung-der-Syntax">3. Erweiterung der Syntax</a></h3>
<p>
   Die erweiterte Templating-Syntax basiert auf einer Funktion des APF-Parsers zur Verarbeitung von logischen Ausdrücken.
   Dabei leitet <em>&#36;{</em> einen Ausdruck ein und <em>}</em> schließt diesen. Der Teil zwischen diesen beiden Elementen
   formuliert die eigentliche Anweisung. Auf diese Weise lassen sich Platzhalter und der Zugriff auf Data-Attribute
   sehr einfach und mit einer im Vergleich zu XML-Tags kürzeren Schreibweise realisieren.
</p>
<p>
   Die während des Verarbeitens eines Templates oder einer Tag-Struktur gefundenen Ausdrücke werden in APF-DOM-Knoten
   übersetzt und an die entsprechende Stelle im Baum eingehangen. Damit können Sie auf diese innerhalb der Applikation
   mit den gewohnten Mechanismen zugreifen.
</p>
<p>
   Zur Erweiterung der in <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a> beschriebenen
   Templating-Syntax lassen sich mit Hilfe der Methode <em>Document::addTemplateExpression()</em> - analog zu
   <em>Document::addTagLib()</em> - eigene Ausdrücke registrieren.
</p>
<p>
   Die folgenden Kapitel beschreiben nun den Aufbau und den Einsatz von eigenen Ausdrücken.
</p>

<h4 id="Chapter-3-1-Definition"><a href="#Chapter-3-1-Definition">3.1. Definition</a></h4>
<p>
   Ein Template-Ausdruck definiert sich über das Interface <em>TemplateExpression</em>. Dieses dient dem APF-Parser zu
   erkennen, ob der Ausdruck für die Verarbeitung des Inhalts zwischen <em>&#36;{</em> und <em>}</em> zuständig ist.
   Falls dies zutrifft, erzeugt er einen DOM-Knoten, der die Funktionalität des Ausdrucks repräsentiert.
</p>
<p>
   Das Interface definiert folgende Methoden:
</p>
<gen:highlight type="php">
namespace APF\core\pagecontroller;

interface TemplateExpression {

   public static function applies($token);

   public static function getDocument($token);

}
</gen:highlight>
<p>
   Die Methode <em>applies()</em> nutzt der Parser um an Hand der registrierten Ausdrücke den jeweils zuständige
   Implementierung zu evaluieren. Hierzu übergibt der APF-Parser den zu verarbeitenden Ausdruck und erwartet die Rückgabe
   von <em>true</em> sofern die Implementierung zuständig ist. Ist dies nicht der Fall, ist der Rückgabewert <em>false</em>.
</p>
<p>
   Wird in einem Template der Ausdruck
</p>
<gen:highlight type="apf-xml">
&#36;{getString(APF\modules\comments, language.ini, header.title)}
</gen:highlight>
<p>
   definiert, so übergibt der Parser <em>getString(APF\modules\comments, language.ini, header.title)</em> an die Methode
   <em>applies()</em>.
</p>
<p>
   Die Methode <em>getDocument()</em> übernimmt die Erzeugung eines DOM-Knotens zur Verarbeitung des Ausdrucks.
   Damit folgt das APF konsequent dem HMVC-Ansatz beim Aufbau von GUI-Komponenten und kapselt die Funktionalität in einem
   Tag.
</p>

<h4 id="Chapter-3-2-Implementierung"><a href="#Chapter-3-2-Implementierung">3.2. Implementierung</a></h4>
<p>
   Die Implementierung eines Template-Ausdrucks umfasst die Implementierung des <em>TemplateExpression</em>-Interfaces,
   die wiederum eine Tag-Implementierung als Rückgabe der <em>getDocument()</em>-Methode verwendet. Die
   <em>TemplateExpression</em>-Implementierung beschreibt dabei den Ausdruck, der Tag implementiert die konkrete
   Funktionalität des Ausdrucks.
</p>
<p>
   Als Beispiel für dieses Kapitel soll die verkürzte Syntax für den
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>-Tag dienen. Dieser gibt je
   nach Sprache der Anwendung einen lokalisierten Inhalt aus einer Sprach-Datei aus.
</p>
<p>
   Die folgende Code-Box beinhaltet eine Implementierung für die verkürzte <em>&lt;html:getstring /&gt;</em>-Syntax:
</p>
<gen:highlight type="php">
namespace VENDOR\..\expression;

class GetStringTemplateExpression implements TemplateExpression {

   const START_TOKEN = 'getString(';
   const END_TOKEN = ')';

   public static function applies($token) {
      return strpos($token, self::START_TOKEN) !== false && strpos($token, self::END_TOKEN) !== false;
   }

   public static function getDocument($token) {

      $startTokenPos = strpos($token, self::START_TOKEN);
      $endTokenPos = strpos($token, self::END_TOKEN, $startTokenPos + 1);

      $arguments = explode(',', substr($token, $startTokenPos + 10, $endTokenPos - $startTokenPos - 10));

      $object = new LanguageLabelTag();
      $object->setAttribute('namespace', trim($arguments[0]));
      $object->setAttribute('config', trim($arguments[1]));
      $object->setAttribute('entry', trim($arguments[2]));

      return $object;

   }

}
</gen:highlight>
<p>
   Innerhalb der <em>applies()</em>-Methode wird zunächst festgestellt, ob die vorliegende Implementierung für die
   Verarbeitung zuständig ist. Dies geschieht an Hand des erwarteten öffnenden und schließenden Token.
</p>
<div class="warn">
   Bitte beachten Sie, dass die Verarbeitung von Template-Ausdrücken an Hand von Zeichenketten und nicht an Hand von
   XML-Strukturen erfolgt. Bitte stellen Sie daher bei der Implementierung von eigenen Ausdrücken sicher, dass diese
   innerhalb eines Projektes eindeutig zu erkennen sind.
</div>
<p>
   Die <em>getDocument()</em>-Methode erzeugt im Anschluss den einen Tag, der die Verarbeitung des Ausdrucks übernimmt.
   Im Fall des <em>getString()</em>-Ausdrucks basiert die Implementierung auf dem im APF vorhandenen <em>LanguageLabelTag</em>-Tag
   der an Hand der Attribute <em>namespace</em>, <em>config</em> und <em>entry</em> eine Sprach-abhängige Ausgabe erzeugt.
</p>
<p>
   Hinweise zur Implementierung von eigenen Tags finden Sie unter <int:link pageid="147" />.
</p>

<h4 id="Chapter-3-3-Konfiguration"><a href="#Chapter-3-3-Konfiguration">3.3. Konfiguration</a></h4>
<p>
   Möchten Sie den im vorangegangenen Kapitel erstellten Template-Ausdruck nutzen, so muss dieser in der Bootstrap-Datei
   registriert werden. Hierzu können Sie folgenden Code nutzen:
</p>
<gen:highlight type="php">
Document::addTemplateExpression('VENDOR\..\expression\GetStringTemplateExpression');
</gen:highlight>
<p>
   Anschließend lässt sich der Ausdruck in einem Template wie folgt nutzen:
</p>
<gen:highlight type="apf-xml">
<h2>Beispiel</h2>
<p>
   &#36;{getString(APF\modules\comments, language.ini, header.title)}
</p>
</gen:highlight>
<p>
   Möchten Sie die im Auslieferungszustand des APF konfigurierten Template-Ausdrücke (teilweise/vollständig) ersetzen,
   so eignet sich dazu folgende Vorgehensweise:
</p>
<gen:highlight type="php">
Document::clearTemplateExpressions();

// Neue Expression
Document::addTemplateExpression('VENDOR\..\expression\GetStringTemplateExpression');

// Standard-Expression aus der bootstrap.php
Document::addTemplateExpression(DynamicTemplateExpression::class);
</gen:highlight>
<p>
   Mit dem abgebildeten Code-Block wird zunächst die Liste der registrierten Ausdrücke zurück gesetzt und anschließend
   werden die gewünschten Ausdrücke registriert.
</p>
<div class="warn">
   Bitte beachten Sie, dass der abgedruckte Code-Block lediglich der Demonstration der Vorgehensweise dient. Bitte
   registrieren Sie nach dem Zurücksetzen alle für Ihre Applikation notwendigen Ausdrücke (z.B.
   <em>PlaceHolderTemplateExpression</em> für Standard-Platzhalter) um die korrekte Funktionalität sicher zu stellen.
</div>

<h3 id="Chapter-4-Bedingte-Ausgabe"><a href="#Chapter-4-Bedingte-Ausgabe">4. Bedingte Ausgabe</a></h3>
<p>
   Ein häufiger Anwendungsfall in Web-Anwendungen ist die bedingte Ausgabe von Inhalten. Als Lösung bietet das APF zwei
   Tag-Implementierungen, die einfache sowie komplexe Anwendungsszenarien abdecken.
</p>
<p>
   Der <em>&lt;cond:placeholder /&gt;</em>-Tag erlaubt die Ausgabe von Inhalten sofern eine definierte
   Bedingung erfüllt wurde. Der <em>&lt;cond:template /&gt;</em>-Tag ist für komplexere Ausgaben wie die bedingte
   Ausgabe von komplexen Inhalten gedacht.
</p>
<div class="hint">
   <em>&lt;cond:placeholder /&gt;</em> und <em>&lt;cond:template /&gt;</em> kombinieren die Definition der Ausgabe mit
   der Ausgabe-Bedingung direkt im Template. Dadurch erhöht sich nicht nur die Übersichtlichkeit, sondern hilft auch
   den Controller-Code einfach zu gestalten.
</div>
<p>
   Die folgenden Kapitel bringen Ihnen die Verwendung der beiden Tags an Hand von ausführlichen Beispielen näher.
</p>

<h4 id="Chapter-4-1-Platzhalter"><a href="#Chapter-4-1-Platzhalter">4.1. Platzhalter</a></h4>
<p>
   Die Signatur des <em>&lt;cond:placeholder /&gt;</em>-Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;cond:placeholder name="" [condition=""]&gt;
   ... ${content} ...
&lt;/cond:placeholder&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>name</strong>:
      Name des Platzhalters. Über den Namen kann auf das Element zugegriffen werden - z.B. im Controller.
      (<strong>Zeichen:</strong> [A-Za-z0-9-_])
   </li>
   <li>
      <strong>condition</strong> (optional):
      Definition der Bedingung, die über die Ausgabe des Inhalts entscheidet (<strong>Standard:</strong>
      <em>notEmpty()</em>). Details zu den verfügbaren Bedingungen entnehmen Sie bitte
      <a href="#Chapter-4-3-Verfuegbare-Bedingungen">Kapitel 4.3</a>.
   </li>
   <li>
      <strong>&#36;{content}</strong>:
      Mit Hilfe des inneren Platzhalters <em>content</em> lässt sich der im Controller gesetzte Inhalt innerhalb der
      bedingten Ausgabe platzieren.
   </li>
</ul>
<p>
   Das folgende Beispiel zeigt die Ausgabe eines Teasers, der eine optionale Zwischen-Überschrift besitzt. Durch den
   Einsatz des <em>&lt;cond:placeholder /&gt;</em>-Tags lässt sich die bedingte Ausgabe sehr einfach realisieren:
</p>
<gen:highlight type="apf-xml">
&lt;h2 class="..."&gt;${headline}&lt;/h2&gt;
&lt;cond:placeholder name="sub-headline"&gt;
   &lt;h3 class="..."&gt;${content}&lt;/h3&gt;
&lt;/cond:placeholder&gt;
&lt;p&gt;
   ${content}
&lt;/p&gt;
</gen:highlight>
<p>
   Der <em>&lt;cond:placeholder /&gt;</em>-Tag verhält sich innerhalb eines Templates wie ein &quot;normaler&quot;
   Platzhalter (siehe <int:link pageid="046" anchor="Chapter-2-1-Placeholder" />). Damit lässt er sich innerhalb eines
   Controllers sehr einfach mit anderen Platzhalter kombinieren.
</p>
<p>
   Der Controller gestaltet sich damit wie folgt:
</p>
<gen:highlight type="php">
class TeaserController extends BaseDocumentController {

   public function transformContent() {
      $teaser = $this->getTeaser();
      $this->setPlaceHolders([
         'headline' => $teaser->getHeadline(),
         'sub-headline' => $teaser->getSubHeadline(),
         'content' => $teaser->getContent()
      ]);
   }

}
</gen:highlight>
<p>
   Die Zwischen-Überschrift wird nun nur dann ausgegeben, sofern die Methode <em>getSubHeadline()</em> einen nicht
   leeren Inhalt liefern.
</p>
<p>
   Soll die Zwischen-Überschrift nur dann angezeigt werden, wenn Sie eine Länge von mindestens 5 und maximal 20 Zeichen
   besitzt, so lässt sich dies durch Anpassung im Template wie folgt realisieren:
</p>
<gen:highlight type="apf-xml">
&lt;h2 class="..."&gt;${headline}&lt;/h2&gt;
&lt;cond:placeholder name="sub-headline" condition="between(5,20)"&gt;
   &lt;h3 class="..."&gt;${content}&lt;/h3&gt;
&lt;/cond:placeholder&gt;
&lt;p&gt;
   ${content}
&lt;/p&gt;
</gen:highlight>
<div class="hint">
   Die Liste der verfügbaren Bedingungen entnehmen Sie bitte <a href="#Chapter-4-3-Verfuegbare-Bedingungen">Kapitel 4.3</a>.
</div>
<p>
   Innerhalb des <em>&lt;cond:placeholder /&gt;</em>-Tags lässt sich ebenfalls die
   <a href="#Chapter-2-Verfuegbare-Funktionen">erweiterte Templating-Syntax</a> anwenden. Damit können Sie mit Hilfe
   von <em>&#36;{content}</em> auch Listen bzw. Objekte darstellen.
</p>
<p>
   Das folgende Beispiel definiert zusätzlich zur optionalen Zwischen-Überschrift noch einen optionalen, weiterführenden
   Link:
</p>
<gen:highlight type="apf-xml">
&lt;h2 class="..."&gt;${headline}&lt;/h2&gt;
&lt;cond:placeholder name="sub-headline"&gt;
   &lt;h3 class="..."&gt;${content}&lt;/h3&gt;
&lt;/cond:placeholder&gt;
&lt;p&gt;
   ${content}
&lt;/p&gt;
&lt;cond:placeholder name="link"&gt;
   &lt;a href="${content->getUrl()}"&gt;${content->getLabel()}&lt;/a&gt;
&lt;/cond:placeholder&gt;
</gen:highlight>
<p>
   Der Controller muss zur Ausgabe des Links wie folgt erweitert werden:
</p>
<gen:highlight type="php">
class TeaserController extends BaseDocumentController {

   public function transformContent() {
      $teaser = $this->getTeaser();
      $this->setPlaceHolders([
         'headline' => $teaser->getHeadline(),
         'sub-headline' => $teaser->getSubHeadline(),
         'content' => $teaser->getContent(),
         'link' => $teaser->getMoreLink()
      ]);
   }

}
</gen:highlight>
<p>
   Liefert die Methode <em>getMoreLink()</em> ein assoziatives Array mit den Offsets <em>more-link</em> und
   <em>more-label</em> zurück so kann die Ausgabe wie folgt vorgenommen werden:
</p>
<gen:highlight type="apf-xml">
&lt;cond:placeholder name="link"&gt;
   &lt;a href="${content['more-link']}"&gt;${content['more-label']}&lt;/a&gt;
&lt;/cond:placeholder&gt;
</gen:highlight>
<p>
   Ein komplexeres Szenario ergibt sich, sofern bei nicht gepflegtem Link ein Verweis auf die Startseite angezeigt
   werden soll. Der folgende Template-Code zeigt - sofern vorhanden - den weiterführenden Link oder einen Verweis auf
   die Startseite an:
</p>
<gen:highlight type="apf-xml">
   &lt;cond:placeholder name="link" condition="empty()"&gt;
   &lt;a href="/"&gt;Startseite&lt;/a&gt;
&lt;/cond:placeholder&gt;
&lt;cond:placeholder name="link"&gt;
   &lt;a href="${content->getUrl()}"&gt;${content->getLabel()}&lt;/a&gt;
&lt;/cond:placeholder&gt;
</gen:highlight>

<h4 id="Chapter-4-2-Template"><a href="#Chapter-4-2-Template">4.2. Template</a></h4>
<p>
   Die Signatur des <em>&lt;cond:template /&gt;</em>-Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="" expression="" [condition=""]&gt;
   ...
&lt;/cond:template&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>content-mapping</strong>:
      Definiert, welcher Inhalt aus dem <strong>Eltern-Dokument</strong> zur Ausgabe genutzt werden soll. Die Evaluierung
      wird dabei mit Hilfe der erweiterten Templating-Syntax (siehe <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a>)
      vorgenommen. Das Ergebnis steht innerhalb des Tags dann im Data-Attribut <em>content</em> zur weiteren Nutzung zur
      Verfügung.
   </li>
   <li>
      <strong>expression</strong>:
      Mit Hilfe des im Attribut <em>expression</em> definierten Ausdrucks wird der Vergleichswert errechnet. Dieser wird
      dann gegen die im Attribut <em>condition</em> definierten Bedingung geprüft um zu entscheiden, ob der Inhalt
      ausgegeben werden soll oder nicht. Die Evaluierung wird dabei ebenfalls mit Hilfe der erweiterten Templating-Syntax
      (siehe <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a>) vorgenommen.
   </li>
   <li>
      <strong>condition</strong> (optional):
      Definiert die Bedingung, die über die Ausgabe des Inhalts entscheidet (<strong>Standard:</strong>
      <em>notEmpty()</em>). Details zu den verfügbaren Bedingungen entnehmen Sie bitte
      <a href="#Chapter-4-3-Verfuegbare-Bedingungen">Kapitel 4.3</a>.
   </li>
</ul>
<div class="warn">
   Die Attribute des Tags lassen sich auch wie folgt lesen: <em>content-mapping</em> definiert den Kontext der Ausgabe
   und mit Hilfe von <em>expression</em> wird der Wert evaluiert, der mit Hilfe der <em>condition</em> zur
   Ausgabesteuerung bewertet wird.
</div>
<p>
   Template-Fragmente - wie beispielsweise auch das
   <int:link pageid="046" anchor="Chapter-2-3-Template">&lt;html:template /&gt;</int:link>-Tag - sind für die Ausgabe von
   sich wiederholenden oder nur unter bestimmten Bedingungen anzuzeigenden Inhalten gedacht. Nutzen Sie das
   <em>&lt;html:template /&gt;</em>-Tag, übernimmt der Controller die Steuerung der Evaluierung der Bedingung und
   die Ausgabe. Mit dem <em>&lt;cond:template /&gt;</em>-Tag lässt sich die Anzeige-Logik komplett an das Template
   delegieren um den Controller schlank zu halten.
</p>
<p>
   Der <em>&lt;cond:template /&gt;</em>-Tag bietet Ihnen die Möglichkeit, komplexe, bedingte Ausgaben im Template zu
   formulieren. Soll der in <a href="#Chapter-4-1-Platzhalter">Kapitel 4.1</a> beschriebene Teaser
   nur dann ausgegeben werden, wenn er für die Darstellung freigegeben ist, so kann die Ausgabe im Template wie folgt
   erledigt werden:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="teaser" expression="content-&gt;displayIt()" condition="true()"&gt;
   &lt;h2 class="..."&gt;${content-&gt;getHeadline()}&lt;/h2&gt;
   &lt;cond:template content-mapping="content" expression="content-&gt;getSubHeadline()" condition="notEmpty()"&gt;
      &lt;h3 class="..."&gt;${content-&gt;getSubHeadline()}&lt;/h3&gt;
   &lt;/cond:template&gt;
   &lt;p&gt;${content-&gt;getText()}&lt;/p&gt;
   &lt;cond:template content-mapping="content-&gt;getMoreLink()" expression="content" condition="notEmpty()"&gt;
      &lt;a href="${content-&gt;getUrl()}"&gt;${content-&gt;getLabel()}&lt;/a&gt;
   &lt;/cond:template&gt;
&lt;/cond:template&gt;
</gen:highlight>
<div class="hint">
   Die Bennenung der Variablen bzw. Data-Attribute kann vollständig frei definiert werden. Bitte beachten Sie, dass die
   Namen der Data-Attribute in Controller und Template übereinstimmen müssen!
</div>
<p>
   Da die Darstellung komplett dem Template überlassen ist, lässt sich innerhalb des Controllers sehr einfach mit einem
   <int:link pageid="164" lang="en">View-Model</int:link> (Englisch) arbeiten. Dies hilft Ihnen dabei, eine klare
   Datenstruktur aufzubauen und mit dem Inhalt verbundene Logik im <em>Domänen-Objekt</em> bzw. <em>View-Model</em> zu
   kapseln. Dies hilft Ihnen die Testbarkeit und damit die Qualität Ihrer Software zu erhöhen.
</p>
<p>
   Zur Ausgabe eines Teasers ist folgender Controller-Code erforderlich:
</p>
<gen:highlight type="php">
class TeaserController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('teaser', $this->getTeaser());
   }

}
</gen:highlight>
<p>
   Die Funktion <em>getTeaser()</em> liefert dabei eine Instanz der Klasse <em>Teaser</em> mit folgenden Methoden zurück:
</p>
<gen:highlight type="php">
class Teaser {

   public function displayIt() { ... }
   public function getHeadline() { ... }
   public function getSubHeadline() { ... }
   public function getText() { ... }
   public function getMoreLink() { ... }

}
</gen:highlight>
<p>
   <em>getMoreLink()</em> gibt eine Instanz der Klasse <em>MoreLink</em> mit folgenden Methoden zurück:
</p>
<gen:highlight type="php">
class MoreLink {

   public function getUrl() { ... }
   public function getLabel() { ... }

}
</gen:highlight>
<div class="hint">
   Die genannten Methoden können mit Hilfe der erweiterten Templating-Syntax (siehe
   <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a>) zur Ausgabe von Inhalten sowie zur Formulierung von
   Mappings und Bedingungen genutzt werden.
</div>
<p>
   Mit Hilfe der umschließenden Tag-Definition
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="teaser" expression="content-&gt;displayIt()" condition="true()"&gt;
   ...
&lt;/cond:template&gt;
</gen:highlight>
<p>
   werden folgende Dinge definiert:
</p>
<ul>
   <li>
      Das Attribut <em>content-mapping</em> definiert, welcher Inhalt innerhalb des Templates in der Variable
      <em>content</em> zur weiteren Verarbeitung und Ausgabe zur Verfügung stehen soll (<em>Kontext</em> der Ausgabe).
      In diesem Fall wird das Data-Attribut <em>teaser</em> aus dem <strong>Eltern-Dokument</strong> genutzt, das gemäß
      Controller-Code eine Instanz der Klasse <em>Teaser</em> enthält.
   </li>
   <li>
      Der Inhalt des <em>expression</em>-Attributs evaluiert denjenigen Wert, der mit der im Attribut <em>condition</em>
      formulierten Bedingung verglichen werden soll. Auf Basis des <em>content-mapping</em>, kann im Ausdruck auf das
      Data-Attribut <em>content</em> verwendet werden.
      <br />
      In diesem Fall wird die Methode <em>displayIt()</em> der Klasse <em>Teaser</em> genutzt, die einen boolschen
      Wert zurück liefert.
   </li>
   <li>
      Die im Attribut <em>condition</em> formulierte Bedingung legt fest, ob der Inhalt des Templates ausgegeben wird
      oder nicht. Trifft die Bedingung <em>true()</em> zu - bzw. liefert die Methode <em>displayIt()</em> den Wert
      <em>true</em> -, so wird das Template dargestellt.
   </li>
</ul>
<p>
   Innerhalb des Templates sind zwei weitere <em>&lt;cond:template /&gt;</em>-Tags definiert, die sich um die optionale
   Ausgabe der Zwischen-Überschrift und des weiterführenden Links kümmern.
</p>
<p>
   Die Zwischenüberschrift wird mit Hilfe der Tag-Definition
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="content" expression="content-&gt;getSubHeadline()" condition="notEmpty()"&gt;
   &lt;h3 class="..."&gt;${content-&gt;getSubHeadline()}&lt;/h3&gt;
&lt;/cond:template&gt;
</gen:highlight>
<p>
   dann ausgegeben, wenn die Methode <em>getSubHeadline()</em> einen nicht leeren Inhalt zurück liefert. Die
   Tag-Definition liest sich wie folgt:
</p>
<ul>
   <li>
      Als Inhalt (<em>Kontext</em> der Ausgabe) wird der Inhalt des Data-Attributs <em>content</em> des
      <strong>Eltern-Elements</strong> genutzt werden. Dies wird durch den Ausdruck im Attribut <em>content-mapping</em>
      festgelegt. Dabei handelt es sich auch hier um die Instanz der Klasse <em>Teaser</em>.
   </li>
   <li>
      Die <em>expression</em> definiert, dass die von der Methode <em>getSubHeadline()</em> zurückgegebene
      Zwischenüberschrift zur Steuerung der Ausgabe heran gezogen werden soll.
   </li>
   <li>
      Mit Hilfe der Bedingung <em>notEmpty()</em> wird überprüft, ob die Zwischenüberschrift vorhanden ist. Ist die
      Zeichenkette nicht leer, wird das HTML-Gerüst inklusive der Überschrift ausgegeben.
   </li>
</ul>
<p>
   Ähnlich verhält es sich mit dem weiterführenden Link. Hier wurde das <em>content-mapping</em> allerdings dazu genutzt,
   die Instanz der Klasse <em>MoreLink</em>, die von der Methode <em>geMoreLink()</em> zurückgegeben wird, im
   Data-Attribut <em>content</em> zur Verfügung zu stellen. Dies erleichtert nicht nur die Formulierung der Bedingungen,
   sondern auch die Ausgabe innerhalb des Templates.
</p>
<p>
   Der weiterführende Link lässt sich basierend auf dem Vorhandensein eines Links in der <em>Teaser</em>-Instanz wie
   folgt bewerkstelligen:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="content-&gt;getMoreLink()" expression="content" condition="notEmpty()"&gt;
   &lt;a href="${content-&gt;getUrl()}"&gt;${content-&gt;getLabel()}&lt;/a&gt;
&lt;/cond:template&gt;
</gen:highlight>
<p>
   Die Tag-Definition lässt sich folgendermaßen interpretieren:
</p>
<ul>
   <li>
      Als Inhalt (<em>Kontext</em> der Ausgabe) wird der Rückgabe-Wert der Methode <em>getMoreLink()</em> der
      <em>Teaser</em>-Instanz im Data-Attributs <em>content</em> des <strong>Eltern-Elements</strong> genutzt. Die
      Methode gibt entweder eine Instanz der Klasse <em>MoreLink</em> oder <em>null</em> zurück.
   </li>
   <li>
      Zur Ausgabe-Steuerung soll ebenfalls der Rückgabe-Wert der Methode <em>getMoreLink()</em> genutzt werden. Dies wird
      im Attribut <em>expression</em> definiert indem direkt auf das Data-Attribut <em>contemnt</em> verwiesen wird.
   </li>
   <li>
      Die im Attribut <em>condition</em> definierte Bedingung prüft nun, ob der weiterführende Link vorhanden ist
      (Data-Attribut <em>content</em> enthält eine Instanz der Klasse <em>MoreLink</em>) und gibt das Template zur
      Ausgabe frei.
   </li>
</ul>
<div class="hint">
   Die Schachtelungstiefe von <em>&lt;cond:template /&gt;</em>-Tags ist nicht begrenzt. Damit lassen sich auch noch
   komplexere Konstrukte definieren.
</div>
<div class="hint">
   Mit Hilfe der in <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a> beschriebenen erweiterten Templating-Syntax
   kann sich innerhalb eines Templates auch auf ausserhalb definierte Inhalte zugreifen. Wird im Controller ein
   zusätzliches Data-Attribut <em>headline-color</em> definiert, kann dies wie folgt zur Ausgabe-Formatierung verwendet
   werden:
<gen:highlight type="apf-xml">
&lt;cond:template ...&gt;
   &lt;h2
      class="${this->getParentObject()->getParentObject()->getData('headline-color')}"&gt;
      ...
   &lt;/h2&gt;
   ...
&lt;/cond:template&gt;
</gen:highlight>
</div>

<h4 id="Chapter-4-3-Verfuegbare-Bedingungen"><a href="#Chapter-4-3-Verfuegbare-Bedingungen">4.3. Verfügbare Bedingungen</a></h4>
<p>
   Zur Ausgabe-Steuerung stehen folgende Bedingungen zur Verfügung:
</p>
<ul>
   <li>
      <strong>true()</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert <em>true</em> ist.
   </li>
   <li>
      <strong>false()</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert <em>false</em> ist.
   </li>
   <li>
      <strong>empty()</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert leer ist. Dies lässt sich sowohl auf Zeichenketten
      als auch auf Objekte anwenden.
   </li>
   <li>
      <strong>notEmpty()</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert nicht leer ist. Dies lässt sich sowohl auf Zeichenketten
      als auch auf Objekte anwenden.
   </li>
   <li>
      <strong>matches(&lt;Zeichenkette&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert mit dem übergebenen Wert übereinstimmt. Der Vergleich lässt
      sich mit Zeichenketten und Ziffern durchführen.
   </li>
   <li>
      <strong>regExp(&lt;string&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert mit dem regulären Ausdruck übereinstimmt. Details zu den
      verwendbaren Audrücken entnehmen Sie bitte der Dokumentation unter
      <a href="http://php.net/manual/de/reference.pcre.pattern.syntax.php" class="external">PCRE Pattern Syntax</a>.
      <div class="hint">
         Bitte beachten Sie, dass doppelte Anführungszeichen im Tag-Attribut <em>condition</em> durch <em>&amp;quot;</em>
         ersetzt werden müssen!
      </div>
   </li>
   <li>
      <strong>contains(&lt;Zeichenkette&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert im übergebenen Wert enthalten ist.
   </li>
   <li>
      <strong>longerThan(&lt;Zahl&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert mehr Zeichen besitzt als im übergebenen Wert definiert wurde.
   </li>
   <li>
      <strong>shorterThan(&lt;Zahl&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert weniger Zeichen besitzt als im übergebenen Wert definiert wurde.
   </li>
   <li>
      <strong>length(&lt;Zahl&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert exakt die Anzahl an Zeichen besitzt die im übergebenen Wert
      definiert wurde.
   </li>
   <li>
      <strong>between(&lt;Zahl&gt;,&lt;Zahl&gt;)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert eine definierte Anzahl von Zeichen besitzt (Miminal- und
      Maximal-Werte eingeschlossen).
   </li>
   <li>
      <strong>lowerThan(&lt;Zahl&gt)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert kleiner als der übergebene Referenz-Wert ist (nummerischer
      Vergleich basierend auf Float-Zahlen).
   </li>
   <li>
      <strong>equalTo(&lt;Zahl&gt)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert kleiner mit dem übergebenen Referenz-Wert übereinstimmt
      (nummerischer Vergleich basierend auf Float-Zahlen).
   </li>
   <li>
      <strong>greaterThan(&lt;Zahl&gt)</strong>:
      Die Prüfung ist erfolgreich wenn der zu prüfende Wert größer als der übergebene Referenz-Wert ist (nummerischer
      Vergleich basierend auf Float-Zahlen).
   </li>
</ul>
<div class="warn">
   Mehrere Argumente werden jeweils durch ein Komma getrennt, Zeichenketten mit Leerzeichen müssen mit einfachen
   Anführungszeichen umschlossen werden!
</div>

<h3 id="Chapter-5-Iterative-Ausgabe"><a href="#Chapter-5-Iterative-Ausgabe">5. Iterative Ausgabe</a></h3>
<p>
   Ein weiterer häufiger Anwendungsfall in Web-Anwendungen ist die Ausgabe von sich wiederholenden Inhalten. Das APF
   bietet für die Realisierung von beliebigen Listen eine einfache Umsetzung mit Hilfe von Templates an.
</p>
<div class="hint">
   Bitte beachten Sie, dass der <em>&lt;loop:template /&gt;</em>-Tag für einfache Anwendungsfälle gedacht ist.
   Für komplexere Anwendungsfälle wie beispielsweise der Ausgabe von verschachtelten Listen empfiehlt das APF-Team die
   Nutzung des <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator-Tags</int:link>.
</div>
<p>
   Der <em>&lt;loop:template /&gt;</em>-Tag erlaubt die Definition eines HTML-Gerüsts, das das Aussehen eines
   Listen-Elements repräsentiert. Das HTML-Markup einer unsortierte Liste lässt sich damit durch den umliegenden
   HTML-Codes (Beginn und Ende der Liste) und des Inhalts des Schleifen-Templates definieren.
</p>
<p>
   Die Signatur des Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;loop:template content-mapping="" [name=""] [transform-on-place="true|false"]&gt;
   ...
&lt;/loop:template&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>content-mapping</strong>:
      Definiert, welcher Inhalt aus dem Template zur Ausgabe genutzt werden soll. Die Evaluierung wird dabei mit Hilfe
      der erweiterten Templating-Syntax (siehe <a href="#Chapter-2-Verfuegbare-Funktionen">Kapitel 2</a>) vorgenommen.
      Das Ergebnis steht innerhalb des Tags dann im Data-Attribut <em>content</em> zur weiteren Nutzung zur Verfügung.
   </li>
   <li>
      <strong>name</strong> (optional):
      Name des Templates. Über den Namen kann auf das Element zugegriffen werden.
      (<strong>Zeichen:</strong> [A-Za-z0-9-_]).
   </li>
   <li>
      <strong>transform-on-place</strong> (optional):
      Aktiviert die direkte Ausgabe des Inhalts im Template. Erfüllt die selbe Funktion als die Methode
      <em>transformOnPlace()</em>.
   </li>
</ul>
<p>
   Möchten Sie eine unsortierte Liste von Links generieren, so lässt sich das Template wie folgt definieren:
</p>
<gen:highlight type="apf-xml">
<ul>
<loop:template name="list" content-mapping="items">
   <li><a href="${content['url']}">${content['title']}</a></li>
</loop:template>
</ul>
</gen:highlight>
<p>
   Zur Ausgabe der Liste ist folgender Controller-Code nötig:
</p>
<gen:highlight type="php">
$this->setData(
      'items',
      [
            ['url' => '/shop', 'title' => 'Web-Shop'],
            ['url' => '/about', 'title' => 'Über uns'],
            ['url' => '/contact', 'title' => 'Kontakt-Formular']
      ]
);
$template = $this->getTemplate('list');
$template->transformOnPlace();
</gen:highlight>
<p>
   Neben der Ausgabe von sich wiederholenden Inhalten können im Template auch statische Platzhalter definiert werden.
   Soll jedes Listen-Element eine bestimmte, dynamische CSS-Klasse erhalten, so kann dies wie folgt erreicht werden:
</p>
<gen:highlight type="apf-xml">
<ul>
<loop:template name="list" content-mapping="items">
   <li class="${css-class}"><a href="${content['url']}">${content['title']}</a></li>
</loop:template>
</ul>
</gen:highlight>
<p>
   Im Controller kann das als ganz normaler Platzhalter injiziert werden:
</p>
<gen:highlight type="php">
$this->setData(
      'items',
      [
            ['url' => '/shop', 'title' => 'Web-Shop'],
            ['url' => '/about', 'title' => 'Über uns'],
            ['url' => '/contact', 'title' => 'Kontakt-Formular']
      ]
);

$template = $this->getTemplate('list');
$template->setPlaceHolder('css-class', 'foo');

$template->transformOnPlace();
</gen:highlight>
<p>
   Neben den beschriebenen Möglichkeiten lassen sich alle Funktionalitäten des
   <int:link pageid="046" anchor="Chapter-2-3-Template"><em>&lt;html:template /&gt;</em></int:link>-Tags nutzen. Zur
   Ausgabe von Inhalten können Sie neben dem Zugriff auf Array-Offsets auch den Zugriff auf Objekte nutzen. Details
   hierzu entnehmen Sie bitte <a href="#Chapter-3-Erweiterung-der-Syntax">Kapitel 3</a>.
</p>
<div class="hint">
   Stehen die Inhalte zur Ausgabe in einem Eltern-Dokument zur Verfügung - z.B. einem Modul-Knoten, der das aktuelle
   Template umschließt - so kann der Tag mit folgender Templating-Syntax zur Ausgabe der Liste genutzt werden:
<gen:highlight type="apf-xml">
<ul>
   <loop:template
         name="list"
         content-mapping="this->getParentObject()->getData('items')">
      <li><a href="${content['url']}">${content['title']}</a></li>
   </loop:template>
</ul>
</gen:highlight>
</div>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_161" />