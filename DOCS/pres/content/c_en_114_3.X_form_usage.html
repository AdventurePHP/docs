<doku:title parent="119" tags="forms,validation,manipulation,initialization,construction,dynamic forms,controller" title="Usage of forms" urlname="Usage-of-forms">
  This documentation page describes the structure and usage of forms. Among these are validation,
  presetting as well as field manipulation within the document controller. Further dynamic form
  generation is described.
</doku:title>
<p>
   The adventure PHP framework contains a comprehensive form support based on the taglib concept. The
   basics of forms and the available taglibs are described in the <int:link pageid="113" /> chapter. This section now
   discusses the usage of forms, dynamic form generation, and implementation of custom form taglibs in detail.
</p>

<h3 id="Chapter-1-Forms-and-controller"><a href="#Chapter-1-Forms-and-controller">1. Forms &amp; controller</a></h3>
<p>
   Forms are kind of template fragments, that exist within the APF DOM tree, but are not displayed at
   transformation. To display a form, a document controller is needed. The reason for it is simple:
   nearly every form is attached to operations which should be executed with sending the form (e.g.
   save data).
</p>
<p>
   In order to display a form, the following controller code can be used:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('Search');
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Thereby, the <strong>$form</strong> variable contains a reference on the
   <strong>HtmlFormTag</strong> instance, that encapsulates an APF form with all it's child
   elements. Having this reference, the form can be manipulated, filled, displayed, or adapted. Details
   can be taken from the subsequent chapters.
</p>

<h3 id="Chapter-2-API-of-the-form-taglibs"><a href="#Chapter-2-API-of-the-form-taglibs">2. API of the form taglibs</a></h3>
<p>
   As described within the previous section, a form can be referenced within a document controller
   easily. This section deals with the API of the form taglibs, that gives you an idea if the
   functionality included.
</p>
<div class="hint">
   It is recommended to have the <int:link pageid="002"/>
   opened during development times. This eases work much, because each taglib has it's own API,
   that is described within the API documentation in detail.
</div>
<p>
   The basic form element is defined within the <strong>AbstractFormControl</strong> class. There, the structure
   is defined as well as the basic functionality is included. Due to the fact, that all taglibs are subjected to
   the <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram">page controller lifecycle</int:link>
   each form element must implement the methods, a &quot;normal&quot; taglib must implement, too.
</p>
<div class="hint">
   Form elements know about their validation status. Hence, each element can be queried it's
   status. Concerning the implementation, this means, that a form collects the status of all
   controls and returns the aggregated value executing the <strong>isValid()</strong> method.
</div>
<p>
   Class <strong>AbstractFormControl</strong> implements the following methods:
</p>
<ul>
   <li>
      <strong>isValid():</strong> The function enables you to query the validity status from
      inside the form as well as from the outside.
   </li>
   <li>
      <strong>markAsInvalid():</strong> Marks a form element as invalid.
   </li>
   <li>
      <strong>markAsValid():</strong> Marks a form element as valid.
   </li>
   <li>
      <strong>markAsSent():</strong> Marks an element as sent (only relevant for forms and buttons).
   </li>
   <li>
      <strong>isSent():</strong> Checks, whether a form was sent or not.
   </li>
   <li>
      <strong>isChecked():</strong> Returns true, in case a checkbox is checked and false otherwise.
   </li>
   <li>
      <strong>check():</strong> Enables a checkbox.
   </li>
   <li>
      <strong>uncheck():</strong> Deactivates a checkbox.
   </li>
   <li>
      <strong>getValue():</strong> Returns the input of an element. Normally, this is just the content of the
      <em>value</em> attribute, except in special cases, as, for example, text areas, which store the user input
      as content of the tag.
   </li>
   <li>
      <strong>setValue():</strong> Sets the input of an element. Normally, this is just the content of the <em>value</em>
      attribute, except in special cases as for example text areas which store the user input as content of the
      tag.
   </li>
   <li>
      <strong>isFilled():</strong> Returns <em>true</em> in case a text field or text area was filled with text and
          <em>false</em> otherwise. This works only for text fields and text areas (form:text and form:area).
   </li>
   <li>
      <strong>isSelected():</strong> Returns <em>true</em> in case something was selected in a single or multi select
          and <em>false</em> otherwise. If something was selected which returns <em>""</em> the method returns <em>false</em>
          too. This works only with single select or multi select (form:select and form:multiselect).
   </li>
   <li>
      <strong>isVisible():</strong> Returns the visibility status of the present form control. <em>true</em> indicates
      that the control is visible, <em>false</em> marks form controls that are not included to be displayed during the
      form generation.
   </li>
   <li>
      <strong>hide():</strong> Hides a form control from the form output.
   </li>
   <li>
      <strong>show():</strong> Sets the visibility status of a form control to <em>true</em>.
   </li>
   <li>
      <strong>reset():</strong> Resets a form control to it's initial state. Details can be taken from
      <a href="#Chapter-9-Resetting-forms">chapter 9</a>.
   </li>
   <li>
      <strong>addFilter():</strong> Adds a filter to the current form control.
   </li>
   <li>
      <strong>addValidator():</strong> Adds a validator to the current form control.
   </li>
   <li>
      <strong>getFilters():</strong> Returns all filters registered with the current form control. This information
      can be used to e.g. setup Java-Script-based client-side filtering.
   </li>
   <li>
      <strong>getValidators():</strong> Returns all validators registered with the current form control. This information
      can be used to e.g. setup Java-Script-based client-side validation.
   </li>
   <li>
      <strong>addAttribute():</strong> Can be used to add content to an existing attribute. This is
      used when notifying invalid form elements.
   </li>
   <li>
      <strong>notifyValidationListeners():</strong> Notifies all listeners of a form element, that
      it is invalid.
   </li>
   <li>
      <strong>presetValue():</strong> This method provides presetting for form text fields. It
      can be directly used or overwritten for custom form elements.
   </li>
   <li>
      <strong>setPlaceHolder():</strong> This method implements a generic method to set place holder
      tags within sub tags of the form tag. Please note, that place holder tags must be named
      <strong>*:placeholder</strong> to be able to use the method.
   </li>
   <li>
      <strong>addAttributeToWhitelist():</strong> Adds the attribute applied to the method to the
      white list of the current form control. This causes the attribute to be included into the HTML
      source code.
   </li>
</ul>
<p>
   Using this methods, the developer is supported to implement custom form taglibs as described in
   chapter 7.
</p>
<div class="hint">
   <p>
      White-listing has been introduced along with the client side form validator extension. This mechanism is
      responsible to only render XHTML compatible attributes to the HTML source code. Not suitable attributes -
      e.g. used for validation control - are ignored.
   <p>
   <p>
      Creating custom form taglibs you must care about the attributes of your taglib. Hence, we
      recommend to add the desired attributes within the constructor of the taglib:
   </p>
<gen:highlight type="php">
class SpecialFormControlTag extends AbstractFormControl {
   public function __construct() {
      $this->attributeWhiteList[] = 'name';
      $this->attributeWhiteList[] = 'accesskey';
   }
}
</gen:highlight>
</div>

<h3 id="Chapter-3-Validation"><a href="#Chapter-3-Validation">3. Validation</a></h3>
<p>
   Validation is executed via the <strong>form:addvalidator</strong>, that attaches a validator to the
   desired form control. The validator is executed, when the click event of a form button is fired.
   Having a look at the timing, validation is executed within the <strong>onAfterAppend()</strong>
   method of each taglib. This is after the analysis phase (at this time, the <strong>onParseTime()</strong>
   of each taglib is executed) and the DOM tree is fully created by the page controller.
</p>
<p>
   Within the <strong>onAfterAppend()</strong> method of the <strong>form:addvalidator</strong> tag,
   the validator is created and initialized with the necessary information (button and target form
   control) and given to the target element. The element itself executes the validator in case it is
   active and checks the result. In case of errors, the <strong>notify()</strong> method of the
   validator is called.
</p>

<h4 id="Chapter-3-1-Validation-status-query"><a href="#Chapter-3-1-Validation-status-query">3.1. Validation status query</a></h4>
<p>
   Since each form element knows about it's validation status within the new implementation, the
   form's <em>isValid()</em> method must query the status of each form element. Using a document
   controller, you can get the form status as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('MyForm');
      if($form->isSent()){
         echo 'Form was send');
      }
      if($form->isValid()){
         echo 'Form is valid';
      }
   }
}
</gen:highlight>
<p>
   Further, you can ask a single form element to return it's status using the subsequent PHP code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('MyForm');
      $searchField = &$form->getFormElementByName('searchterm');
      if($searchField->isValid()){
         echo 'Search field is valid';
      }
   }
}
</gen:highlight>
<p>
   To decide, whether a button has been clicked, use the following code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('MyForm');
      $button = &$form->getFormElementByID('button');
      if($button->isSent()){
         echo 'Search button was clicked';
      }
   }
}
</gen:highlight>
<div class="hint">
   To get an overview of the existent methods, please refer to the
   <int:link pageid="002" /> of the
   classes <strong>HtmlFormTag</strong>, <strong>AbstractFormControl</strong> and the dedicated
   form taglibs (e.g. <strong>TextFieldTag</strong>).
</div>

<h4 id="Chapter-3-2-Display-of-validation-messages"><a href="#Chapter-3-2-Display-of-validation-messages">3.2. Display of validation messages</a></h4>
<p>
   Introducing form validation, the fields containing wrong data are often marked with red borders and
   the user is presented a validation message. To achieve this, the taglibs
   <strong>&lt;form:error /&gt;</strong> (used for global error messages) and
   <strong>&lt;form:listener /&gt;</strong> can be used. As an alternative, you may use place holders,
   that are filled with the appropriate error messages within the controller code.
</p>

<h5 id="Chapter-3-2-1-Form-error"><a href="#Chapter-3-2-1-Form-error">3.2.1. Form error</a></h5>
<p>
   The <strong>&lt;form:error /&gt;</strong> displays it's content, in case the form is not valid -
   regardless which field is invalid. For this reason, the tag queries the form's status at transformation time:
</p>
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:error&gt;
      Please fill in the mandatory fields!
   &lt;/form:error&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:button name="send" value="Save" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('product-form');
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Within the <strong>&lt;form:error /&gt;</strong> tag, you may define further tags for formatting
   or content generation purposes as described in chapter
   <int:link pageid="113" anchor="Chapter-3-19-Error">display of form errors</int:link>.
</p>

<h5 id="Chapter-3-2-2-Listener"><a href="#Chapter-3-2-2-Listener">3.2.2. Listener</a></h5>
<p>
   The <strong>&lt;form:listener /&gt;</strong> tag is aimed to display field specific errors. As noted
   in the introduction chapter, the <strong>notify()</strong> method is called, when a form control
   is considered invalid. This method then notifies all listener tags, that have registered on this
   event to display their content at transformation time.
</p>
<p>
   In the below, field specific messages are displayed in case a desired field is marked invalid:
</p>
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:listener control="code"&gt;
      Please fill in a five letter product code!
   &lt;/form:listener&gt;
   &lt;form:text name="code" minlength="5" maxlength="5"/&gt;
   &lt;form:listener control="title"&gt;
      Please fill in a title with at least 20 characters!
   &lt;/form:listener&gt;
   &lt;form:text name="title" minlength="20"/&gt;
   &lt;form:listener control="description"&gt;
      Please provide a verbose product description!
   &lt;/form:listener&gt;
   &lt;form:area name="description" minlength="30"/&gt;
   &lt;form:button name="send" value="Save" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TextLengthValidator"
      control="code|title|description"
      button="send"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('product-form');
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Within the <strong>&lt;form:listener /&gt;</strong> tag, you may define further tags for formatting
   or content generation purposes as described in chapter
   <int:link pageid="113" anchor="Chapter-3-18-Listener">listener</int:link>.
</p>

<h4 id="Chapter-3-3-Manual-validation"><a href="#Chapter-3-3-Manual-validation">3.3. Manual validation within the document controller</a></h4>
<p>
   In some kind of situation it may be easier or faster to do form validation within a document
   controller instead of writing a validator. In order to allow marking form controls a new form
   control method was introduced in <strong>Version 1.14</strong>.
</p>
<p>
   As an example, the form field <em>searchterm</em> contained in the subsequent form should be
   validated using a custom rule within a document controller:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="search"&gt;
   &lt;label for="searchterm"&gt;Search term:&lt;/label&gt;
   &lt;form:text id="searchterm" name="searchterm" value="" /&gt;
   &lt;form:button name="search" value="GO" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   The corresponding controller contains the following code to invalidate the search term field in
   case it contains an <em>e</em>:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class SearchController extends BaseDocumentController {

   public function transformContent() {

      $form = &$this->getForm('search');
      $searchTerm = &$form->getFormElementById('searchterm')

      if(stripos($searchTerm->getValue(), 'e') !== false) {
         $searchTerm->markAsInvalid();
         $searchTerm->appendCssClass(AbstractFormValidator::$DEFAULT_MARKER_CLASS);
      }

      $form->transformOnPlace();

   }

}
</gen:highlight>
<p>
   Sending the form including any word that contains the letter <em>e</em> the <em>searchterm</em>
   field is technically and optically marked as invalid. The latter is done by adding the default
   validation marker css class. In case you want to apply your own css class you can do this by
   applying a hard-coded class name or by taking it from the form control's attribute list
   (e.g. <em>valmarkerclass</em>).
</p>

<h3 id="Chapter-4-Handle-form-content"><a href="#Chapter-4-Handle-form-content">4. Handle form content</a></h3>
<p>
   A frequent job with the handling of forms is the readout of values. To support this, the following
   methods can be used in the document controller:
</p>
<ul>
   <li>
      <strong>getFormElementByID():</strong> Returns a form element selected by id
      (Attribute: <em>id</em>).
   </li>
   <li>
      <strong>getFormElementByName():</strong> Returns a form element selected by name
      (Attribute: <em>name</em>).
   </li>
   <li>
      <strong>getFormElementsByTagName():</strong> Returns a list of form elements selected by tag name
      (z.B. <em>form:text</em>).
   </li>
</ul>

<h4 id="Chapter-4-1-Select-by-name"><a href="#Chapter-4-1-Select-by-name">4.1. Select by name</a></h4>
<p>
   In case you are facing the task to gather the values of the form described in chapter 3.2.2., you can
   use the subsequent controller code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('product-form');

      if($form->isSent() && $form->isValid()){

         $code = &$form->getFormElementByName('code');
         echo 'product code: '.$code->getValue();

         $title = &$form->getFormElementByName('title');
         echo 'product title: '.$title->getValue();

         $description = &$form->getFormElementByName('description');
         echo 'product desc: '.$description->getValue();
      }

   }
}
</gen:highlight>
<div class="hint">
   Using text ares, the content of the tag is not contained in the <strong>value</strong> attribute
   but within the content of the tag. This is identical to the HTML tag definition.
</div>
<p>
   Due to the fact, that an APF form is a DOM subtree containing form taglibs, a place holder within
   an error tag can be addressed with two steps. First, get the instance of the error tag, and second
   get the place holder's instance from the error tag. To have a dedicated example, consider the
   following form definition:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="product-form"&gt;
   &lt;form:error name="error"&gt;
      &lt;html:placeholder name="ph1" /&gt;
   &lt;/form:error&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>
<p>
   To fill the place holder within the <strong>&lt;form:error /&gt;</strong> tag use the following
   controller code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('product-form');
      $error = &$form->getFormElementByName('error');

      // simple way:
      $error->setPlaceHolder('ph1','My placeholder value');

      // alternative way:
      $placeHolder = $error->getFormElementByName('ph1');
      $placeHolder->setContent('My placeholder value');
   }
}
</gen:highlight>
<div class="hint">
   To select a form element by id, the same procedure can be used. Please ensure, to use the
   content of the id attribute of the desired form element in combination with the
   <em>getFormElementByID()</em> method.
</div>

<h4 id="Chapter-4-2-Selection-by-tag"><a href="#Chapter-4-2-Selection-by-tag">4.2. Selection by tag</a></h4>
<p>
   In some cases, it may be useful to select form elements by it's tag name. For this application case,
   the <strong>getFormElementsByTagName()</strong> method is available. It returns a list of form controls
   filtered by the given tag name.
</p>
<p>
   In combination with the <int:link pageid="063" anchor="Chapter-4-3-Saving-objects" />
   the method can be used to read the content of the form elements and directly map them to a
   <strong>GenericDomainObject</strong>. Achieving this, you can use the following code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class EditController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('...');
      $textFields = &$form->getFormElementsByTagName('form:text');
      $user = new GenericDomainObject('User');
      $count = count($textFields);
      for($i = 0; $i < $count; $i++){
         $user->setProperty(
            $textFields[$i]->getAttribute('name'),
            $textFields[$i]->getValue()
         );
      }
   }
}
</gen:highlight>
<p>
   Please note, that the method returns only those elements which exist as direct child nodes in all cases.
</p>

<h3 id="Chapter-5-Manipulation-of-forms"><a href="#Chapter-5-Manipulation-of-forms">5. Manipulation of forms</a></h3>
<p>
   The implementation of the form taglibs of the framework included several opportunities to manipulate
   form elements or their values. The next chapters thus describe solutions for the most frequent tasks.
</p>

<h4 id="Chapter-5-1-Presetting"><a href="#Chapter-5-1-Presetting">5.1. Form presetting</a></h4>
<p>
   To preset form controls (e.g. within an edit dialog) the
</p>
<ul>
   <li><strong>getFormElementByName()</strong>,</li>
   <li><strong>getFormElementByTagName()</strong>, or</li>
   <li><strong>getFormElementByID()</strong></li>
</ul>
<p>
   methods can be used to gather an instance of the desired form control. After that, you can take one
   of the standard method
</p>
<ul>
   <li><strong>getAttribute()</strong></li>
</ul>
<p>
   or
</p>
<ul>
   <li><strong>setAttribute()</strong></li>
</ul>
<p>
   respectively to retrieve or fill the content.
</p>
<p>
   The subsequent code box defines a form, that is filled using the php code below:
</p>
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="UserEdit" method="post"&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
$form = &$this->getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
$userID->setAttribute('value','...');

$firstName = &$form->getFormElementByName('FirstName');
$fFirstName->setAttribute('value','...');

$lastName = &$form->getFormElementByName('LastName');
$lastName->setAttribute('value','...');
</gen:highlight>

<h4 id="Chapter-5-2-Prefilling-of-form-controls"><a href="#Chapter-5-2-Prefilling-of-form-controls">5.2. Pre-filling of form controls</a></h4>
<p>
   Treatment of select and multi select fields is a bit different to normal form controls. But, the
   framework provides methods to ease pre-filling of select fields. The subsequent code is used to
   pre-fill a form, that contains select fields in addition to normal text fields:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="UserCreate" method="post"&gt;
   &lt;strong&gt;Salutation&lt;/strong&gt;:
   &lt;form:select name="Salutation" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;FirstName&lt;/strong&gt;:
   &lt;form:text name="FirstName" /&gt;
   &lt;br /&gt;
   &lt;strong&gt;LastName&lt;/strong&gt;:
   &lt;form:text name="LastName" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;strong&gt;Groups&lt;/strong&gt;:
   &lt;br /&gt;
   &lt;form:multiselect name="Group" /&gt;
   &lt;br /&gt;
   &lt;br /&gt;
   &lt;form:button name="Edit" value="Save" /&gt;
   &lt;form:hidden name="userid" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   The below controller code prefills the form:
</p>
<gen:highlight type="php">
$form = &$this->getForm('UserCreate');
$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['DisplayName'], $salutations[$i]['Value']);
}
$groups = array(...);
$group = &$form->getFormElementByName('Groups');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['DisplayName'], $groups[$i]['Value']);
}
</gen:highlight>
<div class="hint">
   In order to mark options as selected, please use the <strong>setOption2Selected()</strong> method.
</div>
<p>
   The following code box gives presents an example taken from the <int:link pageid="095" />.
   The controller code first fills the select field and then preselects the desired option.
</p>
<gen:highlight type="php">
$form = &$this->getForm('PermissionSetEdit');

// load permissions and fill the select field
$allPermissions = $uM->loadPermissionList();
$permField = &$form->getFormElementByName('Permission[]');
for($i = 0; $i < count($allPermissions); $i++){
   $permField->addOption($allPermissions[$i]->getProperty('DisplayName'),$allPermissions[$i]->getProperty('PermissionID'));
}

// preselect the options
$selectedPermissions = $uM->loadPermissionsOfPermissionSet($permSet);
for($i = 0; $i < count($selectedPermissions); $i++){
   $permField->setOption2Selected($selectedPermissions[$i]->getProperty('PermissionID'));
}
</gen:highlight>

<h4 id="Chapter-5-3-Readout-of-form-controls"><a href="#Chapter-5-3-Readout-of-form-controls">5.3. Readout of form controls</a></h4>
Readout of form controls is similar to prefilling. Please note, that simple and multi select fields
are handled a little bit different. The following code example shows how the values can be read out
from the form described in chapter 3.1:
<gen:highlight type="php">
$form = &$this->getForm('UserEdit');

$userID = &$form->getFormElementByName('userid');
echo $userID->getValue();

$firstName = &$form->getFormElementByName('FirstName');
echo $firstName->getValue();

$lastName = &$form->getFormElementByName('LastName');
echo $lastName->getValue();
</gen:highlight>
<p>
   In order to get the selected options of simple and multi select fields,
   <strong>getSelectedOption()</strong> and <strong>getSelectedOptions()</strong> can be used. The
   subsequent code box describes how:
</p>
<gen:highlight type="php">
$form = &$this->getForm('UserCreate');

$salutations = array(...);
$salutation = &$form->getFormElementByName('Salutation');
for($i = 0; $i < count($salutations); $i++){
   $salutation->addOption($salutations[$i]['Value'],$salutations[$i]['DisplayName']);
}

$option = &$salutation->getSelectedOption();
echo $option->getAttribute('value').', '.$option->getContent();

$groups = array(...);
$group = &$form->getFormElementByName('Groups[]');
for($i = 0; $i < count($groups); $i++){
   $group->addOption($groups[$i]['Value'],$groups[$i]['DisplayName']);
}

$selectedGroups = &$group->getSelectedOptions();
for($i = 0; $i < count($selectedGroups); $i++){
   echo $selectedGroups[$i]->getAttribute('value').', '.$selectedGroups[$i]->getContent();
}
</gen:highlight>
<div class="warn">
   Analyzing dynamically filled select fields only works in case the field is filled with the desired options prior
   to reading the selected option(s). In case you do not fill the options, <em>getSelectedOption()</em> or
   <em>getSelectedOptions()</em> respectively will return an empty result (<em>null</em>). This is especially important,
   in case the form is evaluated after form submission. To get correct results, filling the select field must be
   independent of the state of the form.
</div>

<h3 id="Chapter-6-Dynamic-forms"><a href="#Chapter-6-Dynamic-forms">6. Dynamic forms</a></h3>
<p>
   In some cases it is necessary to generate forms dynamically. For this reason, the form taglib
   (<em>HtmlFormTag</em>) features the methods
</p>
<ul>
  <li>addFormElement()</li>
  <li>addFormContent()</li>
  <li>addFormContentBeforeMarker()</li>
  <li>addFormContentAfterMarker()</li>
  <li>addFormElementBeforeMarker()</li>
  <li>addFormElementAfterMarker()</li>
</ul>
<p>
   The first two functions can be used to add content (i.e. plain text or html) or form elements at the
   end of the form. The latter ones are intended to add content or form at certain positions. For this
   reason, the <strong>&lt;form:marker /&gt;</strong> tag was introduced. The tag itself does not generate
   any output, but can be used for positioning purposes along with the "<em>addForm*[Before|After]Marker()</em>"
   methods.
</p>
<p>
   The following chapters describe, how a dynamic form can be generated displaying form coordinate fields
   (triangle, square, ...). Depending on the type, the corresponding fields are displayed. If the type
   is set to "square", four fields are displayed ...
</p>
<img src="/media/content/dynamic_forms_02.png" alt="APF - dynamic Form generation; selection of the 'square' type" />
<p>
   ... in case of "triangle" three fields are presented:
</p>
<img src="/media/content/dynamic_forms_01.png" alt="APF - dynamic form generation; selection of the 'triangle' type" />

<h4 id="Chapter-6-1-Form-definition"><a href="#Chapter-6-1-Form-definition">6.1. Form definition</a></h4>
<p>
   As already mentioned, the dynamic definition can be done in two flavours. While using
   <em>addFormElement()</em> and/or <em>addFormContent()</em>, no marker is needed. Instead, the
   following example uses marker, because the form already contains structural elements (e.g. table).
</p>
<p>
   The following code box shows the form definition needed to display the form denoted above. To keep
   things simple, no CSS was added. Taking a closer look at the definition, you can see, that the form
   consists of a static select field, that defines the types available and a marker tag for positioning.
   Further, a document controller is specified, to add the desired form elements in front of the marker:
</p>
<gen:highlight type="apf-xml">
&lt;@controller
   class="VENDOR\..\SelectController"
@&gt;
&lt;html:form name="type" method="post"&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;
        Please choose the desired form type:
        &lt;form:select name="type"&gt;
          &lt;select:option value="triangle"&gt;triangle&lt;/select:option&gt;
          &lt;select:option value="square"&gt;square&lt;/select:option&gt;
        &lt;/form:select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;form:button name="submit" value="send" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;form:marker name="fields" /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-6-2-Controller"><a href="#Chapter-6-2-Controller">6.2. Controller</a></h4>
<p>
   The document controller is responsible for generating the form field, that depends on the type of
   the geometrical shape. For this reason, the constructor contains a definition of the form fields
   that should be displayed for a concrete type. Afterwards, the typ is read from the select field and
   the form is enhanced with additional content and fields. The following code box presents the
   implementation of the document controller needed for this functionality:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class SelectController extends BaseDocumentController {

   // specify form element container
   private $formElements = array();

   public function __construct(){

      // define form elements for the triangle
      $this->formElements['triangle'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->formElements['triangle'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->formElements['triangle'][] = array('label' => 'coord 3','name' => 'coordthree');

      // define form elements for the square
      $this->formElements['square'][] = array('label' => 'coord 1','name' => 'coordone');
      $this->formElements['square'][] = array('label' => 'coord 2','name' => 'coordtwo');
      $this->formElements['square'][] = array('label' => 'coord 3','name' => 'coordthree');
      $this->formElements['square'][] = array('label' => 'coord 4','name' => 'coordfour');

   }

   pubic function transformContent(){

      // get form reference
      $form = &$this->getForm('type');

      // get current decision
      $Select = &$form->getFormElementByName('type');
      $Option = &$Select->getSelectedOption();
      if($Option === null){
         $CurrentType = 'triangle';
      }
      else{
         $CurrentType = $Option->getAttribute('value');
      }

      // add form elements
      for($i = 0; $i < count($this->formElements[$CurrentType]); $i++){

         // add label
         $form->addFormContentBeforeMarker('fields',$this->formElements[$CurrentType][$i]['label'].': ');

         // add text field (name attribute is present to enable validation and presetting!)
         $currentElement = &$form->addFormElementBeforeMarker(
                                'fields',
                                'form:text',
                                array('name' => $this->formElements[$CurrentType][$i]['name'])
                             );

         // configure further form element attributes
         $currentElement->setAttribute('style','width: 200px;');

         // add a line break
         $form->addFormContentBeforeMarker('fields','');

      }

      // display form
      $form->transformOnPlace();

   }

}
</gen:highlight>

<h4 id="Chapter-6-3-Dynamic-filters-and-validators"><a href="#Chapter-6-3-Dynamic-filters-and-validators">6.3. Dynamic filters and validators</a></h4>
<p>
   As described in chapter <int:link pageid="113" anchor="Chapter-4-2-Construction-of-validators">construction of validators</int:link>
   and
   <int:link pageid="113" anchor="Chapter-5-2-Construction-of-filters">construction of filters</int:link>
   validators and filters are attached to a form control as an <strong>Observer</strong>. Using dynamic
   forms, this can be simulated by imitating the <em>&lt;form:addvalidator /&gt;</em> and
   <em>&lt;form:addfilter /&gt;</em> tags. This means, that you can add a filter or validator
   using the <strong>addValidator()</strong> and <strong>addFilter()</strong> method respectively. The
   following code sample describes this approach in detail:
</p>
<gen:highlight type="php">
// gather button instance of the form
$button = &$form->getFormElementByName('submit');

// create dynamic form elements
for($i = 0; $i < count($this->formElements[$CurrentType]); $i++){

   // add label
   $form->addFormContentBeforeMarker('fields',$this->formElements[$CurrentType][$i]['label'].': ');

   // add text field (name attribute is present to enable validation and presetting!)
   $currentElement = &$form->addFormElementBeforeMarker(
                           'fields',
                           'form:text',
                           array('name' => $this->formElements[$CurrentType][$i]['name'])
                       );

   // configure further form element attributes
   $currentElement->setAttribute('style','width: 200px;');

   // add filter to the current element
   $filter = new NoSpecialCharactersFilter($currentElement,$button);
   $currentElement->addFilter($filter);

   // add validator to the current element
   $validator = new TextLengthValidator($currentElement,$button);
   $currentElement->addValidator($validator);

   // add a line break
   $form->addFormContentBeforeMarker('fields','');

}
</gen:highlight>
<div class="hint">
   Please respect the order of filters and validators defining dynamic forms. If you do not, 
   undesirable validation effects may occur, because filters are executed after validators.
</div>
<div class="warn">
   Please note that form validation checks using
   <gen:highlight type="php">$form->isValid()</gen:highlight>
   must be placed after the addition of dynamic validators and filters. Otherwise, wrong input is not detected.
</div>

<h4 id="Chapter-6-4-Notes"><a href="#Chapter-6-4-Notes">6.4. Notes</a></h4>
<p>
   An APF form element does need information about the name of itself already at creation time. If the
   element doesn't know it's own name, presetting and validation cannot be enabled. In order to use
   presetting and validation in combination with dynamic form elements, the <em>addFormElement()</em>,
   <em>addFormElementBeforeMarker()</em> and <em>addFormElementBeforeMarker()</em> functions possess a
   third parameter. This parameter expects an associative list of tag attributes, that are applied to
   the form object on creation time. Creating dynamic form elements, it is thus recommended to at least
   apply the name of the tag to the third argument:
</p>
<gen:highlight type="php">
array(
      'name' => 'current_name'
     )
</gen:highlight>
<p>
   Please note, that the tag attributes are also interesting for addressing the form objects after
   appending them to the form via the <em>getFormElementByName()</em> or <em>getFormElementByID()</em>
   methods.
</p>

<h3 id="Chapter-7-Enhancement-of-form-controls"><a href="#Chapter-7-Enhancement-of-form-controls">7. Enhancement of form controls</a></h3>
<p>
   The concept of the APF's page controller allows you to write own tags to create reusable elements.
   This also continues with forms. Custom form controls can be added using the <strong>&lt;core:addtaglib /&gt;</strong>
   tag.
</p>
<p>
   The difference between a normal taglib and a form taglib is the fact, that each form taglib extends
   <strong>AbstractFormControl</strong> class or - effectively - implements the <em>FormControl</em> interface. Hence,
   the form control inherits an advanced tag definition and some more functionality to enable the
   <strong>&lt;html:form /&gt;</strong> tag to handle the control. The extra functionality mentioned in the last
   sentence merely consists of validation and filter handling code.
</p>
<div class="warn">
   <p>
      Please note, that the <em>&lt;html:form /&gt;</em> tag only treats tags as form elements in case they implement
      the <em>FormControl</em> interface. All other tags are not included in validation, filtering and requesting the
      current status.
   </p>
   <p>
      This allows you to use any kind of tags within forms that are not part of the form's functionality (e.g. field
      labels.
   </p>
</div>
<p>
   The next three chapters describe the creation of custom form controls, validators and filters.
   Besides, implementation examples are presented.
</p>

<h4 id="Chapter-7-1-Form-controls"><a href="#Chapter-7-1-Form-controls">7.1. Form controls</a></h4>
<p>
   As mentioned above, an APF form control is defined by the abstract class <strong>AbstractFormControl</strong>.
   In order to implement a custom form element, the class' functionality must be enhanced.
</p>
<p>
   As an example, a form element should be discussed that generates a hidden input field in order to
   protect a form. In the next chapter, we are going to implement the appropriate validator. In case,
   the control is filled, we consider the field invalid and assume, that it was filled by automated
   scripts. Otherwise, the field is defined to be valid. In various blog entries this kind of fields
   are also as called
   <a class="external" href="http://nedbatchelder.com/text/stopbots.html" title="Stopping spambots with hashes and honeypots">honeypot fields</a>.
</p>
<p>
   Let's start with the basics of the element. As described in the last sentence, the tag should
   generate a hidden text input field. To achieve this, the taglib must return the desired source
   code:
</p>
<gen:highlight type="php">
class HoneypotFormControlTag extends AbstractFormControl {
   public function transform(){
      $htmlCode  = (string)'&lt;input ';
      $htmlCode .= $this->getAttributesAsString($this->attributes);
      $htmlCode .= 'type="text" ';
      $htmlCode .= 'style="margin: 0px; padding: 0px; display: none; height: 0px; width: 0px;"';
      $htmlCode .= ' /&gt;';
      return $htmlCode;
   }
}
</gen:highlight>
<p>
   Due to the fact, that validation and filter attachment as well as the method returning the validity
   status of the tag is already included in the <strong>AbstractFormControl</strong> class, the code printed
   above is all that you need by now.
</p>
<p>
   In order to use the newly created form control, the <strong>&lt;core:addtaglib /&gt;</strong> tag
   can be used to announce the tag to the form:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\..\HoneypotFormControlTag"
   prefix="form"
   name="honeypot"
/&gt;
&lt;html:form name="CheckedForm"&gt;
   ...
   &lt;form:honeypot name="check" /&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>
<p>
   The real functionality is now included in the <strong>honeypot field</strong> validator. See the
   next chapter for details.
</p>

<h4 id="Chapter-7-2-Validators"><a href="#Chapter-7-2-Validators">7.2. Validators</a></h4>
<p>
   Validators are defined separately and are attached as observer.
   In order to support this mechanism, a form control must be aware of validators. In case of the honey
   pot field, the functionality is already included in the tag, because it extends the base class
   <strong>AbstractFormControl</strong>. Thus, the validator is applied the content of the <strong>value</strong>
   attribute and is thus able to act as described in the introduction.
</p>
<p>
   For convenience, we call the validator <strong>HoneypotValidator</strong>. In common sense, it is a
   text field validator and can thus use the <strong>TextFieldValidator</strong> class as a basis. This
   class derives from <strong>AbstractFormValidator</strong>, what is the bas class for all validators.
</p>
<p>
   Each validator must implement the <strong>validate()</strong> method, that is applied the content to
   validate. In case of the <em>HoneypotValidator</em> the content of the text field must be empty to
   consider the control valid. If not, the field is marked as invalid. The following code can be used
   to implement the described functionality:
</p>
<gen:highlight type="php">
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }
   ...
}
</gen:highlight>
<p>
   Due to the fact, that <strong>TextFieldValidator</strong> already contains the functionality that
   is necessary to notify a &quot;real&quot; text field and mark it with a special css class in case
   of errors. As of this use case, we do not need this functionality and though we have to
   suppress it. For this reason, we are going to overwrite the <strong>notify()</strong> method
   (defined within <strong>TextFieldValidator</strong>), that is called when a field failed validation:
</p>
<gen:highlight type="php">
class HoneypotValidator extends TextFieldValidator {
   public function validate($input){
      if(empty($input)){
         return true;
      }
      return false;
   }

   public function notify(){
      $this->control->markAsInvalid();
      $this->notifyValidationListeners($this->control);
   }
}
</gen:highlight>
<p>
   In contrast to the implementation of the <strong>TextFieldValidator</strong> class, the line
</p>
<gen:highlight type="php">
$this->markControl($this->control);
</gen:highlight>
<p>
   is not included. This disables the optical marking of the form element using a custom css class.
</p>
<p>
   The following code box describes the application of the validator together with the above honeypot field:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\.. \HoneypotFormControlTag"
   prefix="form"
   name="honeypot"
/&gt;
&lt;html:form name="CheckedForm"&gt;
   &lt;form:honeypot name="check" /&gt;
   &lt;form:button name="send" value="Send" /&gt;
   &lt;form:addvalidator
      namespace="..."
      class="APF\tools\form\validator\HoneypotValidator"
      control="check"
      button="send"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Thanks to the independent definition and implementation of the validator, it can also be applied to
   other text fields. These are all text fields and text areas shipped with the APF release.
</p>

<h4 id="Chapter-7-3-Filter"><a href="#Chapter-7-3-Filter">7.3. Filter</a></h4>
<p>
   Applying the honeypot field no filter is needed. Hence, this chapter describes a filter, that
   substitutes German umlauts with their phoneme equivalents (e.g. ä -> ae).
</p>
<p>
   The <strong>GermanUmlautsFilter</strong> thus implements the <strong>AbstractFormFilter</strong> class
   that is the base class for all form filters just as the <strong>AbstractFormValidator</strong> is
   for validators. The abstract form filter class defines the interface for all concrete form filter
   implementations.
</p>
<p>
   Further, each form filter implements <strong>filter()</strong> method. The function takes the
   content to filter as an argument and returns the filtered content.
</p>
<p>
   The skeleton of the filter is as follows:
</p>
<gen:highlight type="php">
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return $input;
   }
}
</gen:highlight>
<p>
   The functionality of the filter is a simple string replace call using the PHP standard function
   <strong>str_replace()</strong>:
</p>
<gen:highlight type="php">
class GermanUmlautsFilter extends AbstractFormFilter {
   public function filter($input){
      return str_replace(
         array('ä','ö','ü','Ä','Ö','Ü','ß'),
         array('ae','oe','ue','Ae','Oe','Ue','ss'),
         $input
      );
   }
}
</gen:highlight>
<p>
   The application of the filter using a text field or a text area can be taken from the below code box:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="UmlautsForm"&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:area name="comment" /&gt;
   &lt;form:button name="send" value="Send" /&gt;
   &lt;form:addfilter
      class="...\GermanUmlautsFilter"
      control="name|comment"
      button="send"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-7-4-MultiFileUpload"><a href="#Chapter-7-4-MultiFileUpload">7.4. MultiFileUpload</a></h4>
<p>
   Besides, you can use a tool for creating uploads offered with preview function as well as percentage progress
   indicator: the MultiFileUpload. For detailed information about this tool refer the documentation in the Wiki
   (German only):
   <a class="wiki" href="${getBaseUrl(WikiBaseURL)}/MultiFileUpload" title="MultiFileUpload im Wiki">MultiFileUpload im Wiki</a>.
</p>

<h3 id="Chapter-8-Visibility-of-form-controls"><a href="#Chapter-8-Visibility-of-form-controls">8. Visibility of form controls</a></h3>
<p>
   Form controls can be assigned a visibility status. This status is used during the transformation to decide whether a
   form control is displayed or not. This allows you to show or hide form controls within a <int:link pageid="006"/>.
</p>
<p>
   In addition to the visibility status dependent form controls can be defined by each control. In case the control is
   requested to hide from the output the dependent fields will do so as well. Using this feature, you may create
   <a href="#Chapter-6-Dynamic-forms">dynamic forms</a> - with some limitation.
</p>
<p>
   The following chapters describe the use cases and the respective implementation.
</p>

<h4 id="Chapter-8-1-Manipulation-of-the-visibility-by-template"><a href="#Chapter-8-1-Manipulation-of-the-visibility-by-template">8.1. Manipulation of the visibility by template</a></h4>
<div class="hint">
   Pleae note that this feature is available in version 3.3 and above.
</div>
<p>
   Form controls described under <int:link pageid="113" /> support visibility definition directly within the template.
   To define visibility, please use attribute <em>hidden</em>. In case the value is set to <em>true</em>, the form control
   is not rendered and validation is omitted. In case the attribute is not specified of set to default value <em>false</em>
   the field will be displayed and validated as always.
</p>
<div class="hint">
   By default, each control is visible.
</div>
<p>
   Within the following form definition checkbox <em>stay-logged-in</em> is hidden by default:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="log-in"&gt;
   &lt;label for="user-name"&gt;User name:&lt;/label&gt;
   &lt;form:select name="user-name" id="user-name" /&gt;

   &lt;label for="password"&gt;Password:&lt;/label&gt;:
   &lt;form:text name="password" id="password" /&gt;

   &lt;label for="stay-logged-in"&gt;Stay logged-in?&lt;/label&gt;:
   &lt;form:checkbox name="stay-logged-in" id="stay-logged-in" hidden="true"/&gt;

   &lt;form:button name="log-in" value="Log-in" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   In case the checkbox should be displayed under certain circumstances you may want to use the following controller code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class LoginController extends BaseDocumentController {

   public function transformContent() {

      $form = &$this->getForm('log-in');

      $checkbox = &$form->getFormElementByName('stay-logged-in');
      $checkbox->show();

      ...

      $form->transformOnPlace();

   }

}
</gen:highlight>

<h4 id="Chapter-8-2-Manipulation-of-the-visibility-via-controller"><a href="#Chapter-8-2-Manipulation-of-the-visibility-via-controller">8.2. Manipulation of the visibility via controller</a></h4>
<p>
   <em>AbstractFormControl</em> class defines the
</p>
<ul>
   <li><em>hide()</em></li>
   <li><em>show()</em></li>
   <li><em>isVisible()</em></li>
</ul>
<p>
   methods to define and manipulate visibility. Since all form controls are derived from this class, the visibility
   feature is theoretically present for all form controls. Please note the list of supported controls in
   <a href="#Chapter-8-5-Supported-controls">chapter 8.4</a>.
</p>
<p>
   <em>isVisible()</em> can be used to query the current visibility status within a document controller or within a tag.
   <em>show()</em> defines the control as <em>visible</em>, <em>hide()</em> sets the form control to <em>invisible</em>.
</p>
<div class="hint">
   By default, each control is visible.
</div>
<p>
   For our further examples, we will use the following log-in form:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="log-in"&gt;
   &lt;label for="user-name"&gt;User name:&lt;/label&gt;
   &lt;form:select name="user-name" id="user-name" /&gt;

   &lt;label for="password"&gt;Password:&lt;/label&gt;:
   &lt;form:text name="password" id="password" /&gt;

   &lt;label for="stay-logged-in"&gt;Stay logged-in?&lt;/label&gt;:
   &lt;form:checkbox name="stay-logged-in" id="stay-logged-in" /&gt;

   &lt;form:button name="log-in" value="Log-in" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   As you can take from the code bos the form contains one field for the user name, one for the password, as well as
   one field that notifies the underlying application to create a permanent log-in.
</p>
<p>
   In order to hide the checkbox for the permanent log-in you may use the following controller code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class LoginController extends BaseDocumentController {

   public function transformContent() {

      $form = &$this->getForm('log-in');

      $checkbox = &$form->getFormElementByName('stay-logged-in');
      $checkbox->hide();

      ...

      $form->transformOnPlace();

   }

}
</gen:highlight>
<p>
   When the form is displayed the checkbox is not visible anymore and users cannot interact with it.
</p>
<p>
   Please note the hints in <a href="#Chapter-8-6-Implementation-of-custom-controls">chapter 8.5</a> on the implementation
   of custom form controls respecting the visibility definition.
</p>

<h4 id="Chapter-8-3-Hiding-dependent-controls"><a href="#Chapter-8-3-Hiding-dependent-controls">8.3. Hiding dependent controls</a></h4>
<p>
   One problem of the code described in <a href="#Chapter-8-2-Manipulation-of-the-visibility-via-controller">chapter 8.1.</a>
   is: the label element describing the checkbox' meaning is still present. You can avoid that by defining the label as
   an APF form tag. It can then be referred to as a dependent control within the checkbox' tag definition using the
   <em>dependent-controls</em> attribute. In case you hide the checkbox the label tag will be hidden, too.
</p>
<p>
   The tag definition of the form is now as follows:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="log-in"&gt;
   &lt;label for="user-name"&gt;User name:&lt;/label&gt;
   &lt;form:select name="user-name" id="user-name" /&gt;

   &lt;label for="password"&gt;Password:&lt;/label&gt;:
   &lt;form:text name="password" id="password" /&gt;

   &lt;form:label name="stay-logged-in-label" for="stay-logged-in"&gt;Stay logged-in?&lt;/form:label&gt;:
   &lt;form:checkbox
      name="stay-logged-in"
      id="stay-logged-in"
      dependent-controls="stay-logged-in-label"
   /&gt;

   &lt;form:button name="log-in" value="Log-in" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Defining dependent tags can be done recursively. In case you define the password field as a dependent control of the
   label tag, both the checkbox and the label plus the password field are hidden.
</p>
<p>
   To define multiple fields as dependent controls, please specify a pipe-separated list (<em>|</em>) of control names.
   Example:
</p>
<gen:highlight type="code">
stay-logged-in-label|password
</gen:highlight>

<h4 id="Chapter-8-4-Hide-group"><a href="#Chapter-8-4-Hide-group">8.4. Hide a group</a></h4>
<p>
   A more sophisticated is to control visibility of form controls using groups. This allows showing and hiding of
   several form controls at the same time and let's you also control surrounding HTML code which is not possible with
   the approach described in <a href="#Chapter-8-3-Hiding-dependent-controls">chapter 8.2</a>.
</p>
<p>
   Defining a group you can use the <int:link pageid="113" anchor="Chapter-3-23-Group">&lt;form:group /&gt;</int:link>
   tag. The tag itself does not generate any output but displays the form controls and HTML code defined therein.
</p>
<p>
   The form setup can thus be updated as follows:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="log-in"&gt;
   &lt;p&gt;
      &lt;label for="user-name"&gt;User name:&lt;/label&gt;
      &lt;form:select name="user-name" id="user-name" /&gt;
   &lt;/p&gt;

   &lt;p&gt;
      &lt;label for="password"&gt;Password:&lt;/label&gt;:
      &lt;form:text name="password" id="password" /&gt;
   &lt;/p&gt;

   &lt;form:group name="stay-logged-in-group"&gt;
      &lt;p&gt;
         &lt;form:label for="stay-logged-in"&gt;Stay logged-in?&lt;/form:label&gt;:
         &lt;form:checkbox
            name="stay-logged-in"
            id="stay-logged-in"
         /&gt;
      &lt;/p&gt;
   &lt;/form:group&gt;

   &lt;p&gt;
      &lt;form:button name="log-in" value="Log-in" /&gt;
   &lt;/p&gt;
&lt;/html:form&gt;
</gen:highlight>
<div class="hint">
   Please note, that the HTML markup has been added <em>&lt;p /&gt;</em> tags to demonstrates that you can also hide
   the HTML markup that wraps form controls.
</div>
<p>
   Hiding the check box for activating the permanent log-in can be realized within the controller as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class LoginController extends BaseDocumentController {

   public function transformContent() {

      $form = &$this->getForm('log-in');

      $group = &$form->getFormElementByName('stay-logged-in-group');
      $group->hide();

      ...

      $form->transformOnPlace();

   }

}
</gen:highlight>
<p>
   In case above group should be hidden by default, attribute <em>hidden</em> can be set to <em>true</em> within the
   template directly:
</p>
<gen:highlight type="apf-xml">
&lt;form:group name="stay-logged-in-group" hidden="true"&gt;
   &lt;p&gt;
      &lt;form:label for="stay-logged-in"&gt;Stay logged-in?&lt;/form:label&gt;:
      &lt;form:checkbox
         name="stay-logged-in"
         id="stay-logged-in"
      /&gt;
   &lt;/p&gt;
&lt;/form:group&gt;
</gen:highlight>
<p>
   In order to display the group under certain circumstances, the following controller code can be used:
</p>
<gen:highlight type="php">
$group = &$form->getFormElementByName('stay-logged-in-group');
$group->show();
</gen:highlight>

<h4 id="Chapter-8-5-Supported-controls"><a href="#Chapter-8-5-Supported-controls">8.5. Supported controls</a></h4>
<p>
   Defining the visibility state is not supported by all form control types. This is because elements like the
   <int:link pageid="113" anchor="Chapter-3-4-Hidden">&lt;form:hidden /&gt;</int:link> tag do not generate visible
   output - even before 1.17 - and for elements such as the
   <int:link pageid="113" anchor="Chapter-3-19-Error">&lt;form:error /&gt;</int:link> tag it doesn't make sense from a
   business requirements perspective.
</p>
<p>
   Please note the following list of tags supporting the visibility definition:
</p>
<ul>
   <li><em>&lt;form:button /&gt;</em></li>
   <li><em>&lt;form:imagebutton /&gt;</em></li>
   <li><em>&lt;form:reset /&gt;</em></li>
   <li><em>&lt;form:checkbox /&gt;</em></li>
   <li><em>&lt;form:file /&gt;</em></li>
   <li><em>&lt;form:label /&gt;</em></li>
   <li><em>&lt;form:multiselect /&gt;</em></li>
   <li><em>&lt;form:select /&gt;</em></li>
   <li><em>&lt;form:password /&gt;</em></li>
   <li><em>&lt;form:radio /&gt;</em></li>
   <li><em>&lt;form:text /&gt;</em></li>
   <li><em>&lt;form:area /&gt;</em></li>
   <li><em>&lt;form:date /&gt;</em></li>
   <li><em>&lt;form:time /&gt;</em></li>
   <li><em>&lt;form:group /&gt;</em></li>
</ul>

<h4 id="Chapter-8-6-Implementation-of-custom-controls"><a href="#Chapter-8-6-Implementation-of-custom-controls">8.6. Implementation of custom controls</a></h4>
<p>
   The definition of the visibility definition is structurally defined within the <em>AbstractFormControl</em> class and
   is thus present to all form controls. As the behaviour of what should happen when a form control is marked hidden is
   managed by each form control individually you must take care of the visibility status implementing custom form
   controls - either respect the state or consciously ignore it.
</p>
<p>
   The visibility status is held with the <em>AbstractFormControl::$isVisible</em> class variable. <em>true</em> means
   that the control is <em>visible</em>, <em>false</em> indicates that the controls listed in
   <a href="#Chapter-8-5-Supported-controls">chapter 8.4</a> are not displayed.
</p>
<p>
   To respect the visibility status with custom form controls, the subsequent code can be used as a template:
</p>
<gen:highlight type="php">
class MyCustomFormTag extends AbstractFormControl {

   ...

   public function transform() {
      if ($this->isVisible) {
         return '...what ever your tag generates as its output...';
      }
      return '';
   }

   ...
}
</gen:highlight>
<p>
   Another use case implementing custom form controls is hiding adjacent form controls directly within the tag code.
   This may be necessary when one control type defines a direct dependency to another type.
</p>
<p>
   Hiding all check boxes within a given form can be implemented like this within a custom form tag:
</p>
<gen:highlight type="php">
class MyCustomFormTag extends AbstractFormControl {

   ...

   public function onAfterAppend() {

      $form = &$this->getForm();
      $controls = $form->getFormElementsByTagName('form:checkbox');

      foreach ($controls as $control) {
         $control->hide();
      }

      ...

   }

   ...
}
</gen:highlight>

<h3 id="Chapter-9-Resetting-forms"><a href="#Chapter-9-Resetting-forms">9. Resetting forms</a></h3>
<p>
   In case you intend to reset a form to it's initial state after it has been sent you may want to use the <em>reset()</em>
   method. This method is available for the entire form (<em>HtmlForm::reset()</em>) and for each form control separately
   (<em>FormControl::reset()</em>).
</p>
<p>
   Calling <em>reset()</em> on the instance of a form each single form control (implementing the <em>FormControl</em>
   interface) is reset to it's initial state:
</p>
<gen:highlight type="php">
$this->getForm('log-in')->reset();
</gen:highlight>
<p>
   To reset a certain form control you can also use <em>reset()</em>:
</p>
<gen:highlight type="php">
$this->getForm('log-in')->getFormElementByName('username')->reset();
</gen:highlight>
<div class="warn">
   Please be aware to re-implement the <em>reset()</em> method when creating custom form controls as the reset mechanism
   might be different to the standard implementation in <em>AbstractFormControl</em>.
</div>

<h3 id="Chapter-10-Filling-DTOs-and-Models"><a href="#Chapter-10-Filling-DTOs-and-Models">10. Filling DTOs and Models</a></h3>
<p>
   In order to read out form
</p>
<gen:highlight type="apf-xml">
<html:form name="address">
   <form:text name="street" />
   <form:text name="number" />
   <form:text name="zip" />
   <form:text name="city" />
   <form:button name="submit" value="Next" />
</html:form>
</gen:highlight>
<p>
   and fill the respective values into a DTO or a Model you may use the following controller code:
</p>
<gen:highlight type="php">
$model = new AddressModel();
$model->setStreet($form->getFormElementByName('street')->getValue());
$model->setNumber($form->getFormElementByName('number')->getValue());
$model->setZip($form->getFormElementByName('zip')->getValue());
$model->setCity($form->getFormElementByName('city')->getValue());
</gen:highlight>
<p>
   Especially for complex forms this leads to a huge amount of controller code. A more elegant approach is to delegate
   mapping to the form itself:
</p>
<gen:highlight type="php">
$model = new AddressModel();
$form->fillModel($model);
</gen:highlight>
<p>
   The following chapters provide an introduction to this feature and contain in-depth use cases.
</p>

<h4 id="Chapter-10-1-Concept"><a href="#Chapter-10-1-Concept">10.1. Concept</a></h4>
<p>
   Assignment of values within method <em>fillModel()</em> is based on the assumption that the name of a form control
   corresponds to the name of the DTO or Model property.
</p>
<p>
   This convention limits complexity of DTO or Model implementation and avoids creation of mapping tables (e.g. form
   field -&gt; DTO/Model method).
</p>
<p>
   Calling method <em>fillModel()</em> the form assigns values to properties of the DTO or Model based on form controls
   matching the name of the properties. In case a Model defines a property called <em>$street</em> the form evaluates
   corresponding field <em>street</em> to fill the Model property.
</p>
<p>
   The mapping implementation is not restricted to properties with a public setter method but injects values based on
   PHP's <em>Reflection</em> API. Given DTO
</p>
<gen:highlight type="php">
class AddressModel {

   private $street;

   ...

}
</gen:highlight>
<p>
   can be easily filled from the following form:
</p>
<gen:highlight type="apf-xml">
<html:form name="address">
   <form:text name="street" />
   ...
   <form:button name="submit" value="Next" />
</html:form>
</gen:highlight>
<div class="hint">
   DTO or Model properties can be defined with any type of visibility. Mapping works for both <em>private</em> and
   <em>protected</em> properties as well as for <em>public</em> ones.
</div>
<p>
   Since each form control complies with interface <em>FormControl</em> values can be retrieved by <em>getValue()</em>.
   Depending on implementation, this method either returns the value to be written to the DTO or Model or it's object
   representation (e.g. <em>SelectBoxOptionTag</em> for select box tags).
</p>
<p>
   In case you are using a DTO or Model win conjunction with an O/R mapper (e.g. <int:link pageid="063" />) or any
   external API the value's data format must be form-independent (e.g. <em>String</em> or <em>Integer</em>). Translation
   of form-dependent object representations into simple data types is managed by so-called <em>FormControlToModelMapper</em>.
</p>
<p>
   In case a mapper implementation takes responsibility for a given form field - this is evaluated by <em>applies()</em>
   - the mappers' <em>getValue()</em> method is used within <em>fillModel()</em> to evaluate the form-independent value.
</p>
<p>
   Within APF's default configuration there are already several mappers registered to handle all shipped field types:
</p>
<ul>
   <li>
      <strong>StandardControlToModelMapper</strong>
      (String-based fields as well as date and time selection components)
   </li>
   <li>
      <strong>RadioButtonToModelMapper</strong>
      (Radio buttons)
   </li>
   <li>
      <strong>SelectBoxToModelMapper</strong>
      (Select boxes)
   </li>
   <li>
      <strong>MultiSelectBoxToModelMapper</strong>
      (Multi select boxes)
   </li>
</ul>
<p>
   Method <em>fillModel()</em> supports applying an optional list of fields to be processed during mapping. This is
   helpful in case a single DTO or Model is used for a multi-step form and not all fields are contained in the current
   step.
</p>
<p>
   The list can also be used in case you intend to fill only certain fields or you want to prevent data getting
   overwritten.
</p>
<p>
   In case the current step within a registration process only asks for your address filling the <em>AddressModel</em>
   can be limited to the current set of fields as follows:
</p>
<gen:highlight type="php">
$model = new AddressModel();
$form->fillModel($model, ['street', 'number', 'ZIP', 'city']);
</gen:highlight>
<div class="hint">
   In case a <em>FormException</em> is emitted during filling a single property this is not stopping the mapping process.
   Catching all such exception guarantees that filling the model is completed in any case, however, error analysis my
   become more complex. During implementation decision has been taken to catch exceptions to allow easy re-use of
   existing models with forms.
</div>

<h4 id="Chapter-10-2-Usage"><a href="#Chapter-10-2-Usage">10.2. Usage</a></h4>
<p>
   This chapter talks about usage of <em>fillModel()</em> within your application.
</p>
<div class="hint">
   In case your DTOs or models are based on the generic o/r mapper, please be informed that the feature described in
   this chapter can only be used in combination with
   <int:link pageid="063" anchor="Chapter-7-Custom-domain-objects">custom domain objects</int:link>.
</div>

<h5 id="Chapter-10-2-1-Filling-DTOs"><a href="#Chapter-10-2-1-Filling-DTOs">10.2.1. Filling DTOs</a></h5>
<p>
   The following form may be used to let users authenticate against a web site. It contains two fields for entering user
   name and password as well as a check box to store authentication permanently:
</p>
<gen:highlight type="apf-xml">
<html:form name="log-in">
   <form:text name="user" />
   <form:text name="pass" />
   <form:checkbox name="stay_logged_in" value="yes" />
   ...
   <form:button name="submit" value="Log-in" />
</html:form>
</gen:highlight>
<p>
   Assuming you are using an API that expects DTO class <em>LoginData</em> to authenticate a user, it is necessary
   to fill the respective DTO within the controller and pass it onto the API. Using <em>fillModel()</em> this is as
   follows:
</p>
<gen:highlight type="php">
class LoginController extends BaseDocumentController {

   public function transformContent() {

      $form = $this->getForm('log-in');

      if ($form->isSent() && $form->isValid()) {
         $model = new LoginData();
         $form->fillModel($model);
         $this->executeLogIn($model);
      }

   }

   protected function executeLogIn(LoginData $data) {
      ...
   }

}
</gen:highlight>
<p>
   Please find the structure of the DTO within the subsequent code box:
</p>
<gen:highlight type="php">
class LoginData {

   private $user;
   private $pass;
   private $stay_logged_in;

   public function getUser() {
      return $this->user;
   }

   public function getPass() {
      return $this->pass;
   }

   public function getStayLoggedIn() {
      return $this->stay_logged_in;
   }

}
</gen:highlight>
<div class="hint">
   Please note, that filling DTOs the name of the form field must exactly match the name of the DTO property. Further,
   not all characters are allows as part of property names in PHP classes (e.g. "-").
</div>

<h5 id="Chapter-10-2-2-Filling-multiple-DTOs"><a href="#Chapter-10-2-2-Filling-multiple-DTOs">10.2.2. Filling multiple DTOs</a></h5>
<p>
   Semantically, sign-up forms normally contain several types of data: personal data such as name and date of birth,
   home address, and electronic contact data such as e-mail and phone number.
</p>
<p>
   In case the data model of your application or an API provides such kind of data segregation you can directly re-use
   existing DTOs or Models the same way as described in <a href="#Chapter-10-2-1-Filling-DTOs">chapter 10.2.1</a>.
</p>
<p>
   The following code box describes a sign-up form with three parts: personal data, postal address, and e-mail as
   communication data:
</p>
<gen:highlight type="apf-xml">
<html:form name="sign-up">

   <form:text name="firstName" />
   <form:text name="lastName" />

   <form:text name="street" />
   <form:text name="number" />
   <form:text name="zip" />
   <form:text name="city" />

   <form:text name="email" />

   <form:button name="sign-up" value="Sign up"/>
</html:form>
</gen:highlight>
<p>
   For this example, let's assume your application defines a DTO for each of the parts described above:
</p>
<gen:highlight type="php">
class PersonalData {

   private $firstName;
   private $lastName;

   public function getFirstName() {
      return $this->firstName;
   }

   public function getLastName() {
      return $this->lastName;
   }

}

class PostalAddress {

   private $street;
   private $number;
   private $zip;
   private $city;

   public function getStreet() {
      return $this->street;
   }

   public function getNumber() {
      return $this->number;
   }

   public function getZip() {
      return $this->zip;
   }

   public function getCity() {
      return $this->city;
   }

}

class CommunicationData {

   private $email;

   public function getEmail() {
      return $this->email;
   }

}
</gen:highlight>
<p>
   Filling above DTOs and conduct the sign-up can be easily achieved with the subsequent controller:
</p>
<gen:highlight type="php">
class SignUpController extends BaseDocumentController {

   public function transformContent() {

      $form = $this->getForm('sign-up');

      if ($form->isSent() && $form->isValid()) {
         $personal = new PersonalData();
         $address = new PostalAddress();
         $communication = new CommunicationData();
         $form
               ->fillModel($personal)
               ->fillModel($address)
               ->fillModel($communication);
         $this->signUp($personal, $address, $communication);
      }

   }

   protected function signUp(PersonalData $personal, PostalAddress $address, CommunicationData $communication) {
      ...
   }

}
</gen:highlight>

<h5 id="Chapter-10-2-3-Filling-dedicated-fields"><a href="#Chapter-10-2-3-Filling-dedicated-fields">10.2.3. Filling dedicated fields</a></h5>
<p>
   Provided, ZIP code is already captured at the beginning of a sign-up process it has already been stored within the
   DTO or Model at an earlier stage. In case the user hits the sign-up form described in
   <a href="#Chapter-10-2-2-Filling-multiple-DTOs">chapter 10.2.2</a> ZIP code should only be displayed but not written
   to the DTO or Model again.
</p>
<p>
   This might be necessary in case ZIP code is essential to the sign-up and has been validated earlier in the process.
</p>
<p>
   In case you want to store all data except ZIP within your DTO you may want to use the follwing controller code:
</p>
<gen:highlight type="php">
$personal = new PersonalData();
$address = new PostalAddress();
$communication = new CommunicationData();
$form
      ->fillModel($personal)
      ->fillModel($address, ['street', 'number', 'city'])
      ->fillModel($communication);
</gen:highlight>
<p>
   Applying a list of fields to be mapped to the model the <em>PostalAddress</em> instance will only be filled with the
   content of <em>street</em>, <em>number</em>, and <em>city</em>. The content of the <em>$zip</em> property remains
   as-is.
</p>
<div class="hint">
   With dynamic forms the list of available fields can be assembled as follows:
<gen:highlight type="php">
$names = [];
foreach ($form->getFormElementsByTagName('form:text') as &$field) {
   $names[] = $field->getAttribute('name');
}

$model = new AddressModel();
$form->fillModel($model, names);
</gen:highlight>
</div>

<h4 id="Chapter-10-3-Extension"><a href="#Chapter-10-3-Extension">10.3. Extension</a></h4>
<p>
   Writing custom form tags that are not returning the desired data format with <em>getValue()</em> it is necessary to
   introduce a custom translator (<em>mapper</em>) and to register it with the form tag (see concept in
   <a href="#Chapter-10-1-Concept">chapter 10.1</a>). This approach has also been applied with APF's select field since
   <em>getValue()</em> returns an instance of the selected option (class <em>SelectBoxOptionTag</em>) just as
   <em>getSelectedOption()</em> does. However, the DTO or Model property requires the effective value.
</p>
<p>
   Interface <em>FormControlToModelMapper</em> describes the structure of the translator of form values for a dedicated form control
   into an independent (primitive) data format:
</p>
<gen:highlight type="php">
interface FormControlToModelMapper {

   public static function applies(FormControl $control);

   public static function getValue(FormControl $control);

}
</gen:highlight>
<p>
   As an example for a custom <em>FormControlToModelMapper</em> the following tag should be used displaying a select box of
   existing users:
</p>
<gen:highlight type="php">
class UserSelectionTag extends AbstractFormControl {

   public function getValue() {
      return $this->getSelectedUser();
   }

   /**
    * @return UmgtUser
    */
   public function getSelectedUser() {
      $user = new UmgtUser();
      $user->setObjectId($this->getSelectedUserId());

      return $user;
   }

   /**
    * @return int
    */
   protected function getSelectedUserId() {
      return ...;
   }

}
</gen:highlight>
<p>
   Methods <em>getValue()</em> and <em>getSelectedUser()</em> return an instance of the currently selected user. This is
   helpful for controller implementation as the result can be directly used without conversion with components such as
   the <em>UmgtManager</em> (see <int:link pageid="142" />).
</p>
<p>
   In case you are using a DTO or Model that can only handle simple data types you are required to write a mapper.
</p>
<p>
   Implementation of method <em>applies()</em> defines for which field type the mapper is responsible for:
</p>
<gen:highlight type="php">
class UserSelectionTagToModelMapper implements FormControlToModelMapper {

   public static function applies(FormControl $control) {
      return $control instanceof UserSelectionTag;
   }

   ...
}
</gen:highlight>
<p>
   In this case, the mapper is only used with <em>UserSelectionTag</em> fields.
</p>
<div class="warn">
   Please note, that inappropriately framed definitions of responsibility may lead to wrong results! Hence, please
   define exact conditions within <em>applies()</em>.
</div>
<p>
   Translation of the returned value is defined in method <em>getValue()</em>:
</p>
<gen:highlight type="php">
class UserSelectionTagToModelMapper implements FormControlToModelMapper {

   public static function applies(FormControl $control) {
      return $control instanceof UserSelectionTag;
   }

   public static function getValue(FormControl $control) {
      /* @var $control UserSelectionTag */
      $user = $control->getSelectedUser();

      return $user === null ? null : $user->getObjectId();
   }

}
</gen:highlight>
<p>
   Method <em>getValue()</em> evaluates the currently selected user and returns it's internal ID. In case no user is
   selected <em>null</em> is returned instead.
</p>
<p>
   In order to make the form use the newly created mapper it must be registered with the form. This can be done with the
   following code snippet:
</p>
<gen:highlight type="php">
HtmlFormTag::addFormControlToModelMapper(UserSelectionTagToModelMapper::class);
</gen:highlight>
<div class="hint">
   <em>FormControlToModelMapper</em> can be registered once for the entire application such as tags (see
   <int:link pageid="147" anchor="Chapter-3-DOM-structure"/>). For this reason, you can put your statements into your
   bootstrap file (e.g. <em>index.php</em>).
</div>
<p>
   Using custom mappers it might be necessary to adapt the standard configuration. In case you intend to exclusively use
   <em>UserSelectionTagToModelMapper</em> and <em>StandardControlToModelMapper</em> please add the following code to your
   bootstrap file:
</p>
<gen:highlight type="php">
HtmlFormTag::clearFormControlToModelMappers();
HtmlFormTag::addFormControlToModelMapper(UserSelectionTagToModelMapper::class);
HtmlFormTag::addFormControlToModelMapper(StandardControlToModelMapper::class);
</gen:highlight>
<div class="hint">
   The mapping mechanism described here can also be used in an inverted way. If you want to work with an object
   representation within your DTO or Model you can also create instances from simple data types with the following
   <em>FormControlToModelMapper</em> implementation:
<gen:highlight type="php">
class SelectBoxToUserToModelMapper implements FormControlToModelMapper {

   public static function applies(FormControl $control) {
      return $control instanceof SelectBoxTag && $control->getAttribute('user');
   }

   public static function getValue(FormControl $control) {
      /* @var $control SelectBoxTag */
      $option = $control->getSelectedOption();

      if ($option === null) {
         return null;
      }

      $user = new UmgtUser();
      $user->setObjectId($option->getValue());

      return $user;
   }

}
</gen:highlight>
   Your DTO or Model now contains a <em>UmgtUser</em> instance within the desired property.
</div>

<h3 id="Chapter-11-Filling-forms-with-DTOs-and-Models"><a href="#Chapter-11-Filling-forms-with-DTOs-and-Models">11. Filling forms with DTOs and Models</a></h3>
<div class="hint">
   Please note that this feature is not available before version 3.3!
</div>
<p>
   In order to fill form
</p>
<gen:highlight type="apf-xml">
<html:form name="address">
   <form:text name="street" />
   <form:text name="number" />
   <form:text name="zip" />
   <form:text name="city" />
   <form:button name="submit" value="Next" />
</html:form>
</gen:highlight>
<p>
   using a DTOs or Model you may use the following controller code:
</p>
<gen:highlight type="php">
$model = new AddressModel();
$form->getFormElementByName('street')->setValue($model->setStreet()));
$form->getFormElementByName('number')->setValue($model->setNumber()));
$form->getFormElementByName('zip')->setValue($model->setZip()));
$form->getFormElementByName('city')->setValue($model->setCity()));
</gen:highlight>
<p>
   Especially for complex forms this leads to a huge amount of controller code. A more elegant approach is to delegate
   mapping to the form itself:
</p>
<gen:highlight type="php">
$model = new AddressModel();
$form->fillForm($model);
</gen:highlight>
<p>
   The following chapters provide an introduction to this feature and contain in-depth use cases.
</p>

<h4 id="Chapter-11-1-Concept"><a href="#Chapter-11-1-Concept">11.1. Concept</a></h4>
<p>
   Assignment of values within method <em>fillForm()</em> is based on the assumption that the name of a form control
   corresponds to the name of the DTO or Model property.
</p>
<p>
   This convention limits complexity of DTO or Model implementation and avoids creation of mapping tables (e.g. form
   field -&gt; DTO/Model method).
</p>
<p>
   Calling method <em>fillForm()</em> the form assigns the form fields values of the DTO or Model that take the same
   name. In case a Model defines a property called <em>$street</em> the form evaluates corresponding field <em>street</em>
   be filled with the Model property.
</p>
<p>
   The mapping implementation is not restricted to properties with a public setter method but injects values based on
   PHP's <em>Reflection</em> API. Given DTO
</p>
<gen:highlight type="php">
class AddressModel {

   private $street;

   ...

}
</gen:highlight>
<p>
   can be easily used to fill the following form:
</p>
<gen:highlight type="apf-xml">
<html:form name="address">
   <form:text name="street" />
   ...
   <form:button name="submit" value="Next" />
</html:form>
</gen:highlight>
<div class="hint">
   DTO or Model properties can be defined with any type of visibility. Mapping works for both <em>private</em> and
   <em>protected</em> properties as well as for <em>public</em> ones.
</div>
<p>
   Since each form control complies with interface <em>FormControl</em> values can be set by <em>setValue()</em>.
   Depending on implementation, this method initializes the form control either with a simple or complex data type (e.g.
   (e.g. <em>SelectBoxOptionTag</em> for select box tags).
</p>
<p>
   In case you are using a DTO or Model win conjunction with an O/R mapper (e.g. <int:link pageid="063" />) or any
   external API the value's data format must be form-independent (e.g. <em>String</em> or <em>Integer</em>). Translation
   of a simple data type into an object representation is managed by so-called <em>ModelToFormControlMapper</em>.
</p>
<p>
   In case a mapper implementation takes responsibility for a given form field - this is evaluated by <em>applies()</em>
   - the mappers' <em>setValue()</em> method is used within <em>fillForm()</em> to inject the DTO or Model data into the
   form control.
</p>
<p>
   Within APF's default configuration there are already several mappers registered to handle all shipped field types:
</p>
<ul>
   <li>
      <strong>StandardModelToFormControlMapper</strong>
      (String-based fields as well as date and time selection components)
   </li>
   <li>
      <strong>ModelToRadioButtonMapper</strong>
      (Radio buttons)
   </li>
   <li>
      <strong>ModelToSelectBoxMapper</strong>
      (Select boxes)
   </li>
   <li>
      <strong>ModelToMultiSelectBoxMapper</strong>
      (Multi select boxes)
   </li>
</ul>
<p>
   Method <em>fillForm()</em> supports applying an optional list of fields to be processed during mapping. This is
   helpful in case you try to fill a form where not all fields are contained in the DTO or Model and the latter one
   should be used for a multi-step form.
</p>
<p>
   The list can also be used in case you intend to fill only certain fields or you want to prevent data getting
   overwritten.
</p>
<p>
   In case the current step within a registration process only asks for your address filling form with the <em>AddressModel</em>
   can be limited to the current set of fields as follows:
</p>
<gen:highlight type="php">
$model = new AddressModel();
$form->fillForm($model, ['street', 'number', 'ZIP', 'city']);
</gen:highlight>
<div class="hint">
   In case a <em>FormException</em> is emitted during filling this is not stopping the mapping process. Catching all
   such exception guarantees that filling a form is completed in any case, however, error analysis my become more
   complex. During implementation decision has been taken to catch exceptions to allow easy re-use of existing models
   with forms.
</div>

<h4 id="Chapter-11-2-Usage"><a href="#Chapter-11-2-Usage">11.2. Usage</a></h4>
<p>
   This chapter talks about usage of <em>fillForm()</em> within your application.
</p>
<div class="hint">
   In case your DTOs or models are based on the generic o/r mapper, please be informed that the feature described in
   this chapter can only be used in combination with
   <int:link pageid="063" anchor="Chapter-7-Custom-domain-objects">custom domain objects</int:link>.
</div>

<h5 id="Chapter-11-2-1-Filling-forms"><a href="#Chapter-11-2-1-Filling-forms">11.2.1. Filling forms</a></h5>
<p>
   Semantically, sign-up forms normally contain several types of data: personal data such as name and date of birth,
   home address, and electronic contact data such as e-mail and phone number.
</p>
<p>
   In case the data model of your application or an API provides such kind of data segregation you can directly re-use
   existing DTOs or Models.
</p>
<p>
   The following code box describes a sign-up form with three parts: personal data, postal address, and e-mail as
   communication data:
</p>
<gen:highlight type="apf-xml">
<html:form name="edit">

   <form:text name="firstName" />
   <form:text name="lastName" />

   <form:text name="street" />
   <form:text name="number" />
   <form:text name="zip" />
   <form:text name="city" />

   <form:text name="email" />

   <form:button name="sign-up" value="Speichern"/>
</html:form>
</gen:highlight>
<p>
   For this example, let's assume your application defines a DTO for each of the parts described above:
</p>
<gen:highlight type="php">
class PersonalData {

   private $firstName;
   private $lastName;
   private $password;

   public function getFirstName() {
      return $this->firstName;
   }

   public function getLastName() {
      return $this->lastName;
   }

   public function getPassword() {
      return $this->lastName;
   }

}

class PostalAddress {

   private $street;
   private $number;
   private $zip;
   private $city;

   public function getStreet() {
      return $this->street;
   }

   public function getNumber() {
      return $this->number;
   }

   public function getZip() {
      return $this->zip;
   }

   public function getCity() {
      return $this->city;
   }

}

class CommunicationData {

   private $email;

   public function getEmail() {
      return $this->email;
   }

}
</gen:highlight>
<p>
   Using above DTOs you can easily fill a given form with the following controller code:
</p>
<gen:highlight type="php">
class EditController extends BaseDocumentController {

   public function transformContent() {

      $form = $this->getForm('edit');

      if ($form->isSent()) {
         if ($form->isValid()) {
            $personal = new PersonalData();
            $address = new PostalAddress();
            $communication = new CommunicationData();
            $form
                  ->fillModel($personal)
                  ->fillModel($address)
                  ->fillModel($communication);
            $this->saveUserData($personal, $address, $communication);
         } else {
            $form->transformOnPlace();
         }
   } else {
         $form
               ->fillForm($this->loadPersonalData())
               ->fillForm($this->loadAddress())
               ->fillForm($this->loadCommunicationData());

          $this->getResponse()->forward(...);
      }

   }

   protected function saveUserData(PersonalData $personal, PostalAddress $address, CommunicationData $communication) {
      ...
   }

   protected function loadPersonalData() {
      ...
   }

   protected function loadAddress() {
      ...
   }

   protected function loadCommunicationData() {
      ...
   }

}
</gen:highlight>
<p>
   Within method <em>transformContent()</em> the approach described in
   <a href="#Chapter-10-2-2-Filling-multiple-DTOs">chapter 10.2.2</a> is used to fill one or more DTOs or models.
</p>

<h5 id="Chapter-11-2-2-Filling-dedicated-fields"><a href="#Chapter-11-2-2-Filling-dedicated-fields">11.2.2. Filling dedicated fields</a></h5>
<p>
   For security reasons, password fields should not be filled with the real values with edit dialogues. In case you
   intend to use an existing DTO or model method <em>fillForm()</em> allows specification of form controls to be filled.
   The password field can be excluded easily this way.
</p>
<p>
   Filling a form except for the password field can be solved with the following controller code:
</p>
<gen:highlight type="php">
$personal = new PersonalData();
$form->fillForm($personal, ['firstName', 'lastName']);
</gen:highlight>
<p>
   Applying above list only fields <em>firstName</em> and <em>lastName</em> from <em>PersonalData</em> are injected into
   the form.
</p>

<h4 id="Chapter-11-3-Extension"><a href="#Chapter-11-3-Extension">11.3. Extension</a></h4>
<p>
   In case you are using custom form tags that expect a different value format using method <em>setValue()</em> as
   stored in the DTO or model a translation instance is required (<em>Mapper</em>) (see alco concept in
   <a href="#Chapter-11-1-Concept">chapter 11.1</a>). This approach is used by the multi-select field implementatin
   shipped with the APF since methods <em>setValue()</em> and <em>setOption2Selected()</em> of the
   <em>MultiSelectBoxTag</em> don't accept an option list but single values. DTO or models often store a list of selected
   values.
</p>
<p>
   Interface <em>ModelToFormControlMapper</em> describes the structure of a translator between the value stored in the DTO
   or model and the form control:
</p>
<gen:highlight type="php">
interface ModelToFormControlMapper {

   public static function applies(FormControl $control);

   public static function setValue(FormControl &$control, $value);

}
</gen:highlight>
<p>
   As an example for an implementation of <em>ModelToFormControlMapper</em> the following tag should be used. The tag
   represents a user select box:
</p>
<gen:highlight type="php">
class UserSelectionTag extends AbstractFormControl {

   /**
    * @param UmgtUser $value
    */
   public function &setValue($value) {
      $id = $value->getObjectId();
      $this->setSelectedUserId($id);

      return $this;
   }

   /**
    * @param int $id
    */
   protected function setSelectedUserId($id) {
      ...
   }

}
</gen:highlight>
<p>
   Using <em>setValue()</em> the tag can be initialized with the currently selected user. For controllers this is quite
   convenient since results returned by component such as the <em>UmgtManager</em> (see <int:link pageid="142" />) can
   be directly (re-)used.
</p>
<p>
   In case the DTO or model stores simple data types the mapper needs to translate between the simple data type and an
   instance of class <em>UmgtUser</em>.
</p>
<p>
   Implementation of method <em>applies()</em> defines for which field type the mapper is responsible for:
</p>
<gen:highlight type="php">
class ModelToUserSelectionTagMapper implements ModelToFormControlMapper {

   public static function applies(FormControl $control) {
      return $control instanceof UserSelectionTag;
   }

   ...
}
</gen:highlight>
<p>
   In this case, the mapper is only used with <em>UserSelectionTag</em> fields.
</p>
<div class="warn">
   Please note, that inappropriately framed definitions of responsibility may lead to wrong results! Hence, please
   define exact conditions within <em>applies()</em>.
</div>
<p>
   Translation of simple data type into an instance of class <em>UmgtUser</em> and initializing of the tag using method
   <em>setValue()</em> can be implemented as follows:
</p>
<gen:highlight type="php">
class ModelToUserSelectionTagMapper implements ModelToFormControlMapper {

   public static function applies(FormControl $control) {
      return $control instanceof UserSelectionTag;
   }

   public static function setValue(FormControl $control, $value) {
      $user = new UmgtUser();
      $user->setObjectId($value);

      /* @var $control UserSelectionTag */
      $control->setValue($user);
   }

}
</gen:highlight>
<p>
   Within method <em>setValue()</em> the value returned by the DTO or model is used to create and fill a <em>UmgtUser</em>
   instance. Thereafter, the instance is used to initialize the tag with the currently selected user.
</p>
<p>
   In order to make the form use the newly created mapper it must be registered with the form. This can be done with the
   following code snippet:
</p>
<gen:highlight type="php">
HtmlFormTag::addModelToFormControlMapper(ModelToUserSelectionTagMapper::class);
</gen:highlight>
<div class="hint">
   <em>ModelToFormControlMapper</em> can be registered once for the entire application such as tags (see
   <int:link pageid="147" anchor="Chapter-3-DOM-structure"/>). For this reason, you can put your statements into your
   bootstrap file (e.g. <em>index.php</em>).
</div>
<p>
   Using custom mappers it might be necessary to adapt the standard configuration. In case you intend to exclusively use
   <em>ModelToUserSelectionTagMapper</em> and <em>StandardControlToModelMapper</em> please add the following code to your
   bootstrap file:
</p>
<gen:highlight type="php">
HtmlFormTag::clearFormControlToModelMappers();
HtmlFormTag::addModelToFormControlMapper(ModelToUserSelectionTagMapper::class);
HtmlFormTag::addModelToFormControlMapper(StandardControlToModelMapper::class);
</gen:highlight>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="en_114" />