<doku:title parent="119" tags="dokumentation,iterator,media,append,node,front,controller" title="Spezielle Tags" urlname="Spezielle-Tags">
  Auf dieser Dokumentationsseite werden Funktionen des Frameworks besprochen die für spezielle
  Anwendungsfälle oder komplexere Designs verwendet werden können.
</doku:title>
<p>
   Auf dieser Dokumentationsseite werden Funktionen des Frameworks besprochen die für spezielle
   Anwendungsfälle oder komplexere Designs verwendet werden können.
</p>
<div class="hint">
   Bitte beachten Sie, dass innerhalb von Tag-Definitionen ausschließlich Leerzeichen eingesetzt werden dürfen. Tabs
   oder Zeilenumbrüche werden nicht erkannt und es kommt u.U. zu Fehlern beim Auslesen der Tag-Definitionen!
</div>

<h3 id="Chapter-1-Iterator"><a href="#Chapter-1-Iterator">1. Iterator</a></h3>
<p>
   Das Iterator-Tag hilft Ihnen die Ausgabe von Listen von Objekten oder assoziativen Arrays zu bewerkstelligen.
   Die Tag-Definition in einer Template-Datei definiert dabei die Formatierung der Ausgabe, die Daten erhält der Iterator
   im Controller.
</p>

<h4 id="Chapter-1-1-Aufbau"><a href="#Chapter-1-1-Aufbau">1.1. Aufbau</a></h4>
<p>
   Der Iterator-Tag ist wie folgt aufgebaut:
</p>
<ul>
   <li>
      Der umschließende <em>&lt;html:iterator /&gt;</em>-Tag definiert ein wiederverwendbares Fragment
      innerhalb eines APF-Templates. Der Iterator verhält sich dabei ähnlich wie der
      <int:link pageid="046" anchor="Chapter-2-3-Template">&lt;html:template /&gt;-Tag</int:link>. Dieser ist ebenfalls
      ein wiederverwendbares Element, das durch den Controller gesteuert bzw. zur Erzeugung der Ausgabe genutzt wird.
      Wird der Iterator im Controller nicht durch <em>HtmlIteratorTag::transformOnPlace()</em> zur Darstellung freigegeben
      oder die Ausgabe mit Hilfe der Methode <em>HtmlIteratorTag::transformIterator()</em> in einen Platzhalter eingesetzt,
      generiert er selbst keine Ausgabe.
   </li>
   <li>
      Der <em>&lt;iterator:item /&gt;</em>-Tag beschreibt das sich wiederholende Element innerhalb des Iterators.
      Innerhalb des Tags können beliebiger HTML-Code, Platzhalter und weitere Tags zur Ausgabe definiert werden.
   </li>
   <li>
      Sofern gewünscht, können Sie den <em>&lt;iterator:fallback /&gt;</em>-Tag nutzen, um eine elternative Ausgabe zu
      erzeugen, falls der Iterator keine Elemente zur Ausgabe vorfindet. Der Tag basiert auf dem
      <int:link pageid="046" anchor="Chapter-2-3-Template">&lt;html:template /&gt;-Tag</int:link> und besitzt daher
      alle Funktionalitäten, die Sie bereits kennen.
   </li>
   <li>
      Der Bereich innerhalb des <em>&lt;html:iterator /&gt;</em>- und ausserhalb des <em>&lt;iterator:item /&gt;</em>-Tags
      kann für beliebigen HTML-Code sowie weitere Platzhalter und eigene Tags genutzt werden, die für die Ausgabe eingesetzt
      werden.
   </li>
</ul>
<p>
   Die Definition des Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name=""&gt;
   ...
   [&lt;html:placeholder name="" /&gt;]
   [&lt;html:getstring namespace="" config="" entry="" /&gt;]
   [&lt;core:addtaglib class="" prefix="" name="" /&gt;]
   ...
   &lt;iterator:item [getter=""]&gt;
     ...
     &lt;html:placeholder name="" /&gt;
     [&lt;html:getstring namespace="" config="" entry="" /&gt;]
     ...
   &lt;/iterator:item&gt;
   ...
   [&lt;iterator:fallback&gt;
      ...
      [&lt;html:placeholder name="" /&gt;]
      [&lt;html:getstring namespace="" config="" entry="" /&gt;]
      ...
   &lt;/iterator:fallback&gt;]
   ...
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   Innerhalb eines <em>&lt;iterator:item /&gt;</em>-Tags können beliebig viele Platzhalter
   (<em>&lt;html:placeholder /&gt;</em>) und HTML-Elemente definiert werden.
</p>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong> (1): Name des Iterators. Wird zur Referenzierung innerhalb des Controllers benötigt.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9]</code>)
  </li>
  <li>
    <strong>getter</strong>: Name der Methode, mit der Attribute eines Objekts abgerufen werden können.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>name</strong> (2): Name des Platzhalters.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9]</code>)
  </li>
</ul>
<p>
   Details zur Verwendung des <em>&lt;iterator:item /&gt;</em>- und <em>&lt;iterator:fallback /&gt;</em>-Tags entnehmen
   Sie bitten den folgenden Kapiteln.
</p>
<div class="hint">
   Für die Ausgabe von sprachabhängigen Werten können Sie den Tag
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link> verwenden.
   Reicht die Funktionalität nicht aus, können Sie mit Hilfe von
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link> eigene Tags eingebunden
   werden.
</div>

<h4 id="Chapter-1-2-Definition-der-Datenstruktur"><a href="#Chapter-1-2-Definition-der-Datenstruktur">1.2. Definition der Datenstruktur</a></h4>
<p>
   Der Iterator kann mit zwei Arten von Inhalten umgehen: assoziativen Arrays und Objekt-Listen. Aus Gründen der
   Flexibilität bei der Erstellung des Templates innerhalb des <em>&lt;iterator:item /&gt;</em>-Tags empfiehlt sich
   die Nutzung von Objekt-Listen (siehe <a href="#Chapter-1-2-2-Objekt-Listen">Kapitel 1.2.2</a>).
</p>

<h5 id="Chapter-1-2-1-Assoziative-Arrays"><a href="#Chapter-1-2-1-Assoziative-Arrays">1.2.1. Assoziative Arrays</a></h5>
<p>
   Zur Ausgabe von Listen beherrscht der Iterator die Verarbeitung von assoziativen Arrays als Daten-Strukturen für ein
   <em>&lt;iterator:item /&gt;</em>. Zur Ausgabe einer Produkt-Liste der Form
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name="products-list-simple"&gt;
   &lt;h2&gt;Produkte&lt;/h2&gt;
   &lt;p&gt;
      Die folgende Liste stellt unsere Produkte dar:
   &lt;/p&gt;
   &lt;ul&gt;
   &lt;iterator:item&gt;
      &lt;li&gt;
         &lt;h3&gt;&lt;html:placeholder name="name" /&gt;&lt;/h3&gt;
         &lt;img src="&lt;html:placeholder name="img" /&gt;" /&gt;
         &lt;span&gt;&lt;html:placeholder name="price" /&gt;&lt;/span&gt;
      &lt;/li&gt;
   &lt;/iterator:item&gt;
   &lt;/ul&gt;
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   erwartet der Iterator folgende Datenstruktur:
</p>
<gen:highlight type="php">
class IteratorTestController extends BaseDocumentController {

   public function transformContent() {

      $data = [
            [
                  'name'  => 'Günstiges Mobiltelefon',
                  'price' => '150€',
                  'img'   => 'cheapo.png'
            ],
            [
                  'name'  => 'Mittelklasse Mobiltelefon',
                  'price' => '350€',
                  'img'   => 'mid-range.png'
            ],
            [
                  'name'  => 'Premium Mobiltelefon',
                  'price' => '550€',
                  'img'   => 'premium.png'
            ]
      ];

      $iterator = $this->getIterator('products-list-simple');
      $iterator->fillDataContainer($data);
      $iterator->transformOnPlace();

   }

}
</gen:highlight>
<div class="hint">
   Bitte beachten Sie, dass der Iterator eine <em>nummerische</em> Liste von Inhalten erwartet, die dann als assoziatives
   Array ausgeprägt sind. Assoziative Listen mit wiederum assoziativen Inhalten können nicht verarbeitet werden.
</div>
<p>
   Die Methode <em>fillDataContainer()</em> liefert die Instanz des gewünschten Iterators zurück, der im Dokument definiert
   wurde, mit Hilfe von <em>transformOnPlace()</em> wird der Iterator dargestellt.
</p>
<p>
   Die innerhalb des <em>&lt;iterator:item /&gt;</em>-Tag definierten Platzhalter
   (z.B. <em>&lt;html:placeholder name="name" /&gt;</em>) referenzieren auf die in der Datenstruktur enthaltenen Werte.
   Der Name des Schlüssels muss dabei mit den Wert des Attributs <em>name</em> übereinstimmen. Nicht gefundene Werte
   werden mit <em>null</em> ersetzt.
</p>
<p>
   Neben der klassichen Definition von Platzhaltern lässt sich im <em>&lt;iterator:item /&gt;</em>-Tag auch die erweiterte
   Template-Syntax zur Definition von Platzhaltern einsetzen:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name="products-list-simple"&gt;
   &lt;h2&gt;Produkte&lt;/h2&gt;
   &lt;p&gt;
      Die folgende Liste stellt unsere Produkte dar:
   &lt;/p&gt;
   &lt;ul&gt;
   &lt;iterator:item&gt;
      &lt;li&gt;
         &lt;h3&gt;&#36;{name}&lt;/h3&gt;
         &lt;img src="&#36;{img}" /&gt;
         &lt;span&gt;&#36;{price}&lt;/span&gt;
      &lt;/li&gt;
   &lt;/iterator:item&gt;
   &lt;/ul&gt;
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   Details entnehmen Sie bitte dem Kapitel <int:link pageid="047" />.
</p>
<div class="hint">
   Im Rahmen der erweiterten Template-Syntax können Sie auf die Inhalten eines Arrays innerhalb eines Schleifen-Durchlaufs
   auch wie folgt zugreifen:
<gen:highlight type="apf-xml">
&lt;iterator:item&gt;
   &lt;li&gt;
      &lt;h3&gt;&#36;{item['name']}&lt;/h3&gt;
      &lt;img src="&#36;{item['img']}" /&gt;
      &lt;span&gt;&#36;{item['price']}&lt;/span&gt;
   &lt;/li&gt;
&lt;/iterator:item&gt;
</gen:highlight>
   Der Iterator stellt dazu das aktuell Objekt im Data-Attribut <em>item</em> zur Verfügung. Mischformen aller drei
   Varianten (klassiche Platzhalter, Platzhalter nach der erweiterten Template-Syntax und Array-Zugriffe) sind
   ebenfalls zulässig.
</div>

<h5 id="Chapter-1-2-2-Objekt-Listen"><a href="#Chapter-1-2-2-Objekt-Listen">1.2.2. Objekt-Listen</a></h5>
<p>
   Der Zugriff auf Objekt-Listen verhält sich sehr ähnlich wie der im <a href="#Chapter-1-2-1-Assoziative-Arrays">Kapitel 1.2.1</a>
   beschrieben Modell. Unterschied ist dabei, dass es sich beim Inhalt der Listen um Instanzen von beliebigen Objekten
   handelt.
</p>
<p>
   Zur Ausgabe einer Produkt-Liste der Form
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name="products-list-objects"&gt;
   &lt;h2&gt;Produkte&lt;/h2&gt;
   &lt;p&gt;
      Die folgende Liste stellt unsere Produkte dar:
   &lt;/p&gt;
   &lt;ul&gt;
   &lt;iterator:item&gt;
      &lt;li&gt;
         &lt;h3&gt;&lt;html:placeholder getter="getName" /&gt;&lt;/h3&gt;
         &lt;img src="&lt;html:placeholder getter="getImg" /&gt;" /&gt;
         &lt;span&gt;&lt;html:placeholder getter="getPrice" /&gt;&lt;/span&gt;
      &lt;/li&gt;
   &lt;/iterator:item&gt;
   &lt;/ul&gt;
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   erwartet der Iterator folgende Datenstruktur:
</p>
<gen:highlight type="php">
class Article {

   private $name;
   private $price;
   private $img;

   public function __construct($name, $price, $img) {
      $this->name = $name;
      $this->price = $price;
      $this->img = $img;
   }

   public function getImg() {
      return $this->img;
   }

   public function getName() {
      return $this->name;
   }

   public function getPrice() {
      return $this->price;
   }

}

class IteratorTestController extends BaseDocumentController {

   public function transformContent() {

      $data = [
            new Article('Günstiges Mobiltelefon', '150€', 'cheapo.png'),
            new Article('Mittelklasse Mobiltelefon', '350€', 'mid-range.png'),
            new Article('Premium Mobiltelefon', '550€', 'premium.png')
      ];

      $iterator = $this->getIterator('products-list-objects');
      $iterator->fillDataContainer($data);
      $iterator->transformOnPlace();

   }

}
</gen:highlight>
<div class="hint">
   Bitte beachten Sie, dass der Iterator eine <em>nummerische</em> Liste von Objekten erwartet. Assoziative Listen mit
   Objekt-Inhalten können nicht verarbeitet werden.
</div>
<p>
   Die Methode <em>getIterator()</em> liefert die Instanz des gewünschten Iterators zurück, der im Dokument definiert
   wurde, mit Hilfe von <em>transformOnPlace()</em> wird der Iterator dargestellt.
</p>
<p>
   Die innerhalb des <em>&lt;iterator:item /&gt;</em>-Tag definierten Platzhalter
   (z.B. <em>&lt;html:placeholder name="name" /&gt;</em>) referenzieren auf die in den Objekten enthaltenen Werte.
   Der Name der Methode wird im Attribut <em>getter</em> des <em>&lt;iterator:item /&gt;</em>-Tag definiert. Nicht
   gefundene Methoden führen zu einer <em>Exception</em>.
</p>
<p>
   Das Auslesen eines Attributes eines Objektes kann auf zwei Arten stattfinden:
</p>
<ul>
   <li>
      Auf Ebene des <em>&lt;iterator:item/&gt;</em>-Tag wird eine für alle Platzhalter gültige Methode definiert.
      Ist das der Fall, kann innerhalb des <em>&lt;html:placeholder/&gt;</em>-Tags über das Attribut <em>name</em>
      der Name des Attributes angegeben werden, über den die Eigenschaft des Objekts referenziert wird. Beispiel:
<gen:highlight type="apf-xml">
&lt;html:iterator name="..."&gt;
 &lt;iterator:item getter="getProperty"&gt;
   &lt;html:placeholder name="DisplayName" /&gt;
 &lt;/iterator:item&gt;
&lt;/html:iterator&gt;
</gen:highlight>
      In dieser Konstellation erwartet das Tag, dass das auszugebende Objekt eine Methode
      <gen:highlight type="php">public function getProperty($name)</gen:highlight>
      implementiert, die den Wert des Attributes (hier <em>DisplayName</em>) zurück liefert. Dies ist das
      Standard-Verhalten in allen Releases vor 1.14.
   </li>
   <li>
      Im Rahmen der erweiterten Template-Syntax können Sie auf die Inhalten der Objekte innerhalb eines Schleifen-Durchlaufs
      auch wie folgt zugreifen:
<gen:highlight type="apf-xml">
&lt;iterator:item&gt;
   &lt;li&gt;
      &lt;h3&gt;&#36;{item-&gt;getName()}&lt;/h3&gt;
      &lt;img src="&#36;{item-&gt;getImg()}" /&gt;
      &lt;span&gt;&#36;{item-&gt;getPrice()}&lt;/span&gt;
   &lt;/li&gt;
&lt;/iterator:item&gt;
</gen:highlight>
      Der Iterator stellt dazu das aktuell Objekt im Data-Attribut <em>item</em> zur Verfügung.
   </li>
</ul>
<div class="hint">
   Mischformen der zwei Varianten (generische Getter und Objekt-Zugriff nach der erweiterten Template-Syntax) sind
   ebenfalls zulässig.
</div>

<h4 id="Chapter-1-3-Anwendung"><a href="#Chapter-1-3-Anwendung">1.3. Anwendung</a></h4>

<h5 id="Chapter-1-3-1-Einbindung-im-Template"><a href="#Chapter-1-3-1-Einbindung-im-Template">1.3.1. Einbindung im Template</a></h5>
<p>
   In einem Document-Controller stehen Ihnen dann folgende Methoden zur Verfügung, mit der Sie den Iterator nutzen
   lässt:
</p>
<gen:highlight type="php">
class ListController extends BaseDocumentController {

   public function transformContent() {

      // Iterator aus dem aktuellen Dokument beziehen
      $iterator = $this->getIterator('...');

      // Daten an den Iterator übergeben (Liste mit assoziativen Arrays oder Objekten)
      $iterator->fillDataContainer(array(
         ...
      ));

      // Ausgeben des Iterators wo er im Template definiert wurde, ...
      $iterator->transformOnPlace();

      // ... oder den Inhalt in einen Platzhalter einsetzen
      $this->setPlaceHolder('...', $iterator->transformIterator());

   }

}
</gen:highlight>

<h5 id="Chapter-1-3-2-Nummerierung-von-Listen"><a href="#Chapter-1-3-2-Nummerierung-von-Listen">1.3.2. Nummerierung von Listen</a></h5>
<p>
   Sollen die Einträge einer Liste bzw. Tabelle nummeriert werden, können Sie innerhalb eines
   <em>&lt;iterator:item /&gt;</em>-Tags einen Platzhalter definieren der den Namen <em>IterationNumber</em> trägt.
   Beispiel:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name=""&gt;
  &lt;iterator:item [getter=""]&gt;    
    &lt;html:placeholder name="IterationNumber"&gt;
  &lt;/iterator:item&gt;
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   Bei Bedarf kann sie Start-Position der Zählvariable kann im Controller manipuliert werden. Hierzu lässt sich die
   Methode <em>HtmlIteratorTag::setIterationNumber()</em> nutzen:
</p>
<gen:highlight type="php">
class ListController extends BaseDocumentController {

   public function transformContent() {

      $iterator = $this->getIterator('...');

      $iterator->fillDataContainer(array(
         ...
      ));

      $iterator->setIterationNumber(5);
      $iterator->transformOnPlace();

   }

}
</gen:highlight>
<p>
   Zu weiteren Optionen der Manipulation, ziehen Sie bitte <a href="#Chapter-1-3-3-Nutzung-des-Pagers">Kapitel 1.3.3</a>
   zu Rate.
</p>
<div class="hint">
   Die Definition des Platzhalters <em>IterationNumber</em> kann sowohl in klassischer Form über einen
   <em>&lt;html:placeholder /&gt;</em>-Tag als auch mit der erweiterten Templating-Syntax erfolgen.
</div>

<h5 id="Chapter-1-3-3-Nutzung-des-Pagers"><a href="#Chapter-1-3-3-Nutzung-des-Pagers">1.3.3. Nutzung des Pagers</a></h5>
<p>
   Nutzt man das Iterator-Tag in Verbindung mit dem <int:link pageid="092" />, sollte die Nummerierung auf einer anderen Seite nicht
   wieder bei 1 beginnen, sondern fortgesetzt werden. Um dies zu erreichen, muss für den
   <em>&lt;html:iterator /&gt;</em>-Tag das Attribut <em>pager</em> definiert werden. Als Wert muss das
   <em>pager</em>-Attribut den Namen einer Sektion der Pager-Konfigurationsdatei erhalten.
</p>
<p>
   Im folgenden Beispiel würde die Iterator-TagLib die Konfiguration <em>/APF/config/modules/pager/{ENVIRONMENT}_pager.ini</em>
   aufrufen und die Konfigurations-Werte der Sektion <em>PagerExample</em> verwenden:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name="" pager="PagerExample"&gt;
  &lt;iterator:item [getter=""]&gt;    
    &lt;html:placeholder name="IterationNumber"&gt;
  &lt;/iterator:item&gt;
&lt;/html:iterator&gt;
</gen:highlight>

<h5 id="Chapter-1-3-4-Definition-von-Alternativ-Inhalten"><a href="#Chapter-1-3-4-Definition-von-Alternativ-Inhalten">1.3.4. Definition von Alternativ-Inhalten</a></h5>
<p>
   Bei der Ausgabe von Listen ist häufig auch die Darstellung eines Alternativ-Inhalts gefragt. Diesen Anwendungsfall
   unterstützt der Iterator über das <em>&lt;iterator:fallback /&gt;</em>-Tag. Dieses wird ausgegeben, sofern dem
   Iterator keine Inhalte zur Ausgabe zur Verfügung stehen.
</p>
<p>
   Zur Steuerung der Ausgabe stehen zwei Optionen zur Verfügung:
</p>
<ul>
   <li>
      <strong>normal</strong> (Standard): der Alternativ-Inhalt wird zusätzlich zum übrigen HTML-Markup ausgegeben.
   </li>
   <li>
      <strong>replace</strong>: der Alternativ-Inhalt ersetzt das übrige HTML-Markup vollständig.
   </li>
</ul>
<p>
   Der Modus kann über da Attribut <em>fallback-mode</em> des <em>&lt;html:iterator /&gt;</em>-Tag gesteuert werden.
</p>
<p>
   Der folgende Code-Block zeigt die Ausgabe einer Produkt-Liste inkl. Alternativ-Inhalt:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name="products-list-simple" fallback-mode="replace"&gt;
   &lt;h2&gt;Produkte&lt;/h2&gt;
   &lt;p&gt;
      Die folgende Liste stellt unsere Produkte dar:
   &lt;/p&gt;
   &lt;ul&gt;
   &lt;iterator:item&gt;
      &lt;li&gt;
         &lt;h3&gt;&lt;html:placeholder name="name" /&gt;&lt;/h3&gt;
         &lt;img src="&lt;html:placeholder name="img" /&gt;" /&gt;
         &lt;span&gt;&lt;html:placeholder name="price" /&gt;&lt;/span&gt;
      &lt;/li&gt;
   &lt;/iterator:item&gt;
   &lt;/ul&gt;
   &lt;iterator:fallback&gt;
      &lt;h2&gt;Keine Produkte verfügbar&lt;/h2&gt;
      &lt;p&gt;
         Leider sind aktuell keine Produkte erhältlich.
         Bitte besuchen Sie uns in &lt;html:placeholder name="count" /&gt; Tagen wieder.
      &lt;/p&gt;
   &lt;/iterator:fallback&gt;
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   Solange Produkte verfügbar sind, wird eine Liste von Produkten ausgegeben, sofern keine Produkte erhältlich sind,
   wird dir Liste durch den Alternativ-Inhalt ersetzt.
</p>
<p>
   Die Alternativ-Inhalte lassen sich wie vom <em>&lt;html:template /&gt;</em>-Tag gewohnt anpassen. Der folgende
   Code-Block zeigt Ihnen, wie Sie den Platzhalter im <em>&lt;iterator:fallback /&gt;</em>-Tag mit der gewünschten
   Anzahl an Tagen füllen können:
</p>
<gen:highlight type="php">
class ProductsController extends BaseDocumentController {

   public function transformContent() {

      $iterator = $this->getIterator('products-list-simple');

      ...

      $fallback = $iterator->getFallbackContent();
      $fallback->setPlaceHolder('count', '3');

      $iterator->transformOnPlace();

   }

}
</gen:highlight>

<h5 id="Chapter-1-3-5-Auswertung-von-Status-Variablen"><a href="#Chapter-1-3-5-Auswertung-von-Status-Variablen">1.3.5. Auswertung von Status-Variablen</a></h5>
<p>
   Der Iterator stellt für jeden Schleifen-Durchlauf mehrere Status-Variablen zur Verfügung. Diese können zur direkten
   Ausgabe genutzt werden oder in eigenen Tags ausgewertet werden. Die Informationen lassen sich über das Data-Attribut
   <em>status</em> abfragen, das eine Instanz der Klassen <em>APF\tools\html\taglib\IteratorStatus</em> beinhaltet.
   Dieses verfügt über folgende Methoden:
</p>
<gen:highlight type="php">
class IteratorStatus {

   public function getCssClass() {
      return $this->cssClass;
   }

   public function isFirst($asString = false) {
      return $asString === false ? $this->isFirst : $this->convertToString($this->isFirst);
   }

   public function isLast($asString = false) {
      return $asString === false ? $this->isLast : $this->convertToString($this->isLast);
   }

   public function getItemCount() {
      return $this->itemCount;
   }

   public function getCounter() {
      return $this->counter;
   }

}
</gen:highlight>
<p>
   Die Methoden lassen sich wie folgt für die Generierung der Ausgabe nutzen:
</p>
<ul>
   <li>
      <strong>getCssClass()</strong>: liefert eine für den Schleifen-Durchlauf passende CSS-Klasse zur Formatierung
      zurück. Im Auslieferungszustand des APF erhalten Sie <em>first</em> für den ersten Eintrag, <em>middle</em> für
      die Folgenden und <em>last</em> für das letzte Element der Liste. Die Namen der CSS-Klassen können über die
      Attribute <em>first-element-css-class</em>, <em>middle-element-css-class</em> und <em>last-element-css-class</em>
      des <em>&lt;html:iterator /&gt;</em> an den jeweiligen Anwendungsfall angepasst werden.
   </li>
   <li>
      <strong>isFirst()</strong>: liefert <em>true</em>, falls das aktuelle Element das erste in der Liste ist. Wird
      das optionale Argument mit dem Wert <em>true</em> belegt, liefert die Methode keinen <em>boolean</em>-Wert,
      sondern einen <em>string</em>, der sich - insbesondere für den Wert <em>false</em> - einfacher verarbeiten lässt
      (z.B. als Präfix/Suffix einer CSS-Klasse).
   </li>
   <li>
      <strong>isLast()</strong>: liefert <em>true</em> für das letzte Element der Liste. Wird das optionale Argument
      mit dem Wert <em>true</em> belegt, liefert die Methode keinen <em>boolean</em>-Wert, sondern einen <em>string</em>,
      der sich - insbesondere für den Wert <em>false</em> - einfacher verarbeiten lässt (z.B. als Präfix/Suffix einer
      CSS-Klasse).
   </li>
   <li>
      <strong>getItemCount()</strong>: liefert die Gesamt-Anzahl der Elemente in der Liste.
   </li>
   <li>
      <strong>getCounter()</strong>: liefert eine fortlaufende Nummer zurück, die zur Beschriftung genutzt werden kann.
   </li>
</ul>
<p>
   Das folgende Beispiel zeigt die Ausgabe einer Produkt-Liste, die das Status-Objekt zur Formatierung der Ausgabe nutzt:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator
      name="products-list-objects-extended"
      first-element-css-class="prd-first separator"
      middle-element-css-class="prd-center"
      last-element-css-class="prd-last"&gt;
   &lt;h2&gt;Produkte&lt;/h2&gt;
   &lt;p&gt;
      Die folgende Liste stellt unsere Produkte dar:
   &lt;/p&gt;
   &lt;ul&gt;
      &lt;iterator:item&gt;
         &lt;li
               class="&#36;{status-&gt;getCssClass()}"
               data-item-count="&#36;{status-&gt;getItemCount()}"
               data-is-first="&#36;{status-&gt;isFirst(true)}"
               data-is-last="&#36;{status-&gt;isLast(true)}"&gt;
            &lt;h3&gt;(&#36;{item-&gt;getCounter()}) &#36;{item-&gt;getName()}&lt;/h3&gt;
            &lt;img src="&#36;{item-&gt;getImg()}" /&gt;
            &lt;span&gt;&#36;{item-&gt;getPrice()}&lt;/span&gt;
         &lt;/li&gt;
      &lt;/iterator:item&gt;
   &lt;/ul&gt;
&lt;/html:iterator&gt;
</gen:highlight>
<p>
   Die entsprechende HTML-Ausgabe gestaltet sich daraus wie folgt (gekürzt):
</p>
<gen:highlight type="apf-xml">
<ul>
   <li
         class="prd-first separator"
         data-item-count="3"
         data-is-first="1"
         data-is-last="0">
      <h3>Cheap mobile phone</h3>
      <img src="cheapo.png"/>
      <span>150€</span>
   </li>
   <li
         class="prd-center"
         data-item-count="3"
         data-is-first="0"
         data-is-last="0">
      <h3>Mid-range mobile phone</h3>
      <img src="mid-range.png"/>
      <span>350€</span>
   </li>
   <li
         class="prd-last"
         data-item-count="3"
         data-is-first="0"
         data-is-last="1">
      <h3>Premium mobile phone</h3>
      <img src="premium.png"/>
      <span>550€</span>
   </li>
</ul>
</gen:highlight>

<h5 id="Chapter-1-3-6-Schachtelung-von-Iteratoren"><a href="#Chapter-1-3-6-Schachtelung-von-Iteratoren">1.3.6. Schachtelung von Iteratoren</a></h5>
<p>
   Für die Ausgabe von verschachtelten Listen lassen sich Iteratoren auch mehrfach schachteln. Der folgende Code-Block
   definiert eine verschachtelte Datenstruktur, die eine Liste mit Frauen- und Männer-Namen mit jeweils zwei Beispielen
   enthält:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;

class IteratorStackingController extends BaseDocumentController {

   public function transformContent() {

      $iterator = $this->getIterator('names');
      $iterator->fillDataContainer([
            [
                  'name' => 'Women names:',
                  'list' => [
                        ['name' => 'Maria'],
                        ['name' => 'Theodora']
                  ]
            ],
            [
                  'name' => 'Men names:',
                  'list' => [
                        ['name' => 'John'],
                        ['name' => 'George']
                  ]
            ]
      ]);

   }

}
</gen:highlight>
<p>
   Möchten Sie die Namen mit Hilfe einer verschachtelten Liste ausgeben, so lässt sich dafür folgender Template-Code
   nutzen:
</p>
<gen:highlight type="apf-xml">
&lt;html:iterator name="names" transform-on-place="true"&gt;
   &lt;ul&gt;
   &lt;iterator:item&gt;
      &lt;li&gt;
         &lt;item:fill-iterator name="examples" data="item['list']"/&gt;
         (&#36;{status-&gt;getCounter()}) &#36;{item['name']}
         &lt;ul&gt;
            &lt;html:iterator name="examples" transform-on-place="true"&gt;
               &lt;iterator:item&gt;
                  &lt;li&gt;(&#36;{status-&gt;getCounter()}) &#36;{item['name']}&lt;/li&gt;
               &lt;/iterator:item&gt;
            &lt;/html:iterator&gt;
         &lt;/ul&gt;
      &lt;/li&gt;
   &lt;/iterator:item&gt;
   &lt;/ul&gt;
&lt;/html:iterator>
</gen:highlight>
<p>
   Der <em>&lt;item-fill-iterator /&gt;</em>-Tag sorgt analog der <em>fillDataContainer()</em>-Methode dafür, dass
   der Iterator - in diesem Fall der geschachtelte Iterator <em>examples</em> -  mit Daten befüllt wird. Dabei bedient
   er sich aus den Inhalten des aktuellen Schleifendurchlaufs und injiziert die Inhalte des Attributs <em>list</em> in
   den geschachtelten Iterator zur Ausgabe.
</p>
<p>
   Das Attribut <em>name</em> des <em>&lt;item-fill-iterator /&gt;</em>-Tags referenziert auf den geschachtelten Iterator
   - in diesem Fall <em>examples</em> - und das Attribut <em>data</em> wird zur Evaluierung des Inhalts genutzt, der
   in den geschachtelten Iterator ijiziert wird. Die Syntax folgt der im Kapitel <int:link pageid="161" /> beschriebenen
   erweiterten Templating-Syntax.
</p>
<p>
   Die Ausgabe der im Controller definierten Liste gestaltet sich wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;ul&gt;
   &lt;li&gt;
      (1) Women names:
      &lt;ul&gt;
         &lt;li&gt;(1) Maria&lt;/li&gt;
         &lt;li&gt;(2) Theodora&lt;/li&gt;
      &lt;/ul&gt;
   &lt;/li&gt;
   &lt;li&gt;
      (2) Men names:
      &lt;ul&gt;
         &lt;li&gt;(1) John&lt;/li&gt;
         &lt;li&gt;(2) George&lt;/li&gt;
      &lt;/ul&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</gen:highlight>
<div class="warn">
   Da die Steuerung eines Iterators im Document-Controller stattfindet, muss im geschachtelten Iterator das Attribut
   <em>transform-on-place</em> auf den Wert <em>true</em> gesetzt werden. Andernfalls wird der Iterator nicht ausgegeben!
</div>
<div class="hint">
   Die Implementierung erlaubt eine beliebig tiefe Schachtelung von Iteratoren. Bitte vergewissen Sie sich dabei, dass
   jede Sub-Instanz auch entsprechend initialisiert wird.
</div>

<h3 id="Chapter-2-Mediastream"><a href="#Chapter-2-Mediastream">2. Mediastream-Tags</a></h3>
<p>
   Die Mediastream-Tags ermöglichen es dem Entwickler, Ressourcen zur Gestaltung der GUI direkt
   im Namespace des Moduls abzulegen und daraus auszuliefern. Hierzu stellt das Framework einerseits
   eine abstrakte TagLib-Implementierung und einige konkrete TagLibs zur Verfügung, die eine
   Medien-URL generieren, andererseite eine allgemeingültig verwendbare FrontController-Action,
   die die adressierten Medien ausliefert.
</p>
<p>
   Um die Tags einsetzen zu können, muss sichergestellt sein, dass für die Action, die mit
   der Auslieferung betraut ist eine validie Konfiguration für den aktuellen Applikations-Kontext
   existiert. Die Konfiguration wird dabei unter
</p>

<gen:highlight type="code">/APF/config/tools/media/actions/{CONTEXT}/{ENVIRONMENT}_actionconfig.ini</gen:highlight>
<p>
   erwartet. Der Inhalt der Datei kann der nachfolgenden Code-Box entnommen werden:
</p>
<gen:highlight type="ini">
[streamMedia]
ActionClass = "APF\tools\media\actions\StreamMediaAction"
</gen:highlight>
<p>
   Eine Beispieldatei findet sich ebenfalls in der <strong>apf-configpack-*</strong>-Release-Datei
   unter <strong>tools/media/actions/</strong>.
<p>
<p>
   Die folgende Code-Box zeigt die Anwendung innerhalb eines Formulars:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="TestFormular"&gt;
   &lt;img src="&lt;html:mediastream
      namespace="APF\modules\mymodule\pres\images"
      filename="phone_icon.png"
   /&gt;" alt="" /&gt;
   &lt;form:text name="phonenumber" /&gt;
   &lt;br /&gt;
   &lt;form:button name="send" value="Absenden" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Wie dem Beispiel zu entnehmen ist, erwartet der <em>&lt;html:mediastream /&gt;</em>-Tag folgende
   Attribute:
</p>
<ul>
  <li>
    <strong>namespace</strong>: Namespace zur gewünschten Medien-Datei.
    (<strong>Zeichen:</strong>: <code>[A-Za-z0-9:]</code>)
  </li>
  <li>
    <strong>filename</strong>: Name der Medien-Datei.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_.-]</code>)
  </li>
</ul>
<div class="hint">
   Möchten Sie den Namespace der auszuliefernden Datei zusätzlich beeinflussen um z.B. diese
   beispielsweise abhängig vom aktuellen Kontext ablegen zu können, so kann folgende Vorgehenweise gewählt werden:
</div>
<ol>
  <li>
    Ausstatten des Tags mit einer eindeutigen ID:
<gen:highlight type="apf-xml">
&lt;img src="&lt;html:mediastream
                     namespace="APF\modules\mymodule\pres\images"
                     filename="phone_icon.png"
                     id="PhoneIcon"
             /&gt;"
        alt=""
/&gt;
</gen:highlight>
  </li>
  <li>
    Manipulieren des Namespaces im Document-Controller:
<gen:highlight type="php">
class ExampleController extends BaseDocumentController {

   public function transformContent(){
      $mediaStreamTag = $this->getMediaStreamTagByID('PhoneIcon');
      $mediaStreamTag->setAttribute($mediaStreamTag->getAttribute('namespace').'\\'.$this->getContext());
   }

   private function getMediaStreamTagByID($id){
      $children = $this->getDocument()->getChildren();
      foreach($children as &$child){
         if($child instanceof MediaInclusionTag){
            return $child;
         }
      }
      throw new InvalidArgumentException('No media stream tag contained within the current document!');
   }
}
</gen:highlight>
  </li>
  <li>
      Manipulation des Datei-Namens innerhalb eines Templates:
<gen:highlight type="php">
class ExampleController extends BaseDocumentController {

   public function transformContent() {
      $FileTemplate = $this->getTemplate('file');
      $mediaStreamTag = $this->getMediaStreamTagByID('FileIconID', $FileTemplate);
      $mediaStreamTag->setAttribute('extension', 'png');
      $mediaStreamTag->setAttribute('filebody', 'dateinameOhneEndung');
   }

   private function getMediaStreamTagByID($id, TemplateTag &$template) {
      $children = $template->getChildren();

      foreach ($children as &$child) {
         if ($child instanceof MediaInclusionTag && $child->getAttribute('id') == $id) {
            return $child;
         }
      }
      throw new InvalidArgumentException('No media stream tag contained within the current template "'
                                         . $template->getAttribute('name') . '"!');
   }
}
</gen:highlight>
  </li>
</ol>
<p>
   Die zur Auslieferung der Bilder eingesetzte Front-Controller-Action <em>StreamMediaAction</em> bietet
   die Möglichkeit, erlaubte Datei-Typen und deren MIME-Typen explizit zu konfigurieren. Damit ist es möglich die
   Standard-Werte zu überschreiben um weniger oder mehr Typen zuzulassen. Im Standard-Setup sind folgende Endungen erlaubt:
</p>
<ul>
   <li><em>png</em> bzw. <em>image/png</em></li>
   <li><em>jpeg</em> bzw. <em>image/jpg</em></li>
   <li><em>jpg</em> bzw. <em>image/jpg</em></li>
   <li><em>gif</em> bzw. <em>image/gif</em></li>
   <li><em>css</em> bzw. <em>text/css</em></li>
   <li><em>js</em> bzw. <em>text/javascript</em></li>
</ul>
<p>
   Um die vorhandenen Werte neu zu definieren muss die Konfigurations-Datei <em>{ENVIRONMENT}_allowed_extensions.ini</em>
   unter dem Pfad <em>APF\tools\media\{CONTEXT}</em> angelegt werden. Die erlaubten Endungen können dann in der Form
</p>
<gen:highlight type="ini">
[Default]
jpg = "image/jpg"
xml = "text/xml"
psd = "application/psd"
</gen:highlight>
<p>
   definiert werden.
</p>

<h3 id="Chapter-3-Generischer-importdesign-Tag"><a href="#Chapter-3-Generischer-importdesign-Tag">3. Generischer importdesign-Tag</a></h3>
<p>
   In komplexeren Applikationen ist es oft notwendig, die durch <strong>&lt;*:importdesign /&gt;</strong>-Tags
   definierten Views dynamisch füllen zu können. Vielfach möchte der Entwickler in
   aufwändigeren Strukturen die Informationen des Applikationsmodels verwenden. Um dies
   uneingeschränkt zu ermöglichen und eine Applikationssteuerung aus der Business-Schicht zu
   ermöglichen, wurde das Framework mit einem generischen importdesign-Tag ausgestattet, der es
   erlaubt sowohl den Namen des Templates aus auch den Namespace desselben dynamisch aus einem
   Model-Objekt zu beziehen.
</p>
<p>
   Die Signatur des generischen Tags gestaltet sich dabei wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;generic:importdesign
   model-class=""
   model-mode="NORMAL|SINGLETON|SESSIONSINGLETON"
   namespace-param=""
   template-param=""
   [get-method=""]
   [dependent-action-namespace=""
   dependent-action-name=""
   [dependent-action-params=""]]
/&gt;
</gen:highlight>
Den Attributen kommt dabei folgende Bedeutung zu:
<ul>
  <li>
    <strong>model-class</strong>: Voll-qualifizierter Klassen-Name der Model-Klasse.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_\]</code>)
  </li>
  <li>
    <strong>model-mode</strong>: Instanzierungsmodus des Models.
    (<strong>Erlaubte Werte</strong>: <code>NORMAL|SINGLETON|SESSIONSINGLETON</code>)
  </li>
  <li>
    <strong>namespace-param</strong>: Name des Model-Parameters für den Template-Namespace.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_.-]</code>)
  </li>
  <li>
    <strong>template-param</strong>: Name des Model-Parameters für den Template-Namen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_.-]</code>)
  </li>
  <li>
    <strong>get-method</strong>: Name der Mode-Methode mit dem die Parameter abgefragt werden
    können. Dieser wird der Wert des <em>namespaceparam</em> bzw. <em>templateparam</em> als
    Parameter übergeben und erwartet den zugehörigen Rückgabewert.
    Standardmäßig wird die Funktion <strong>getAttribute()</strong> verwendet.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_]</code>)
  </li>
  <li>
    <strong>dependent-action-namespace</strong> / <strong>dependent-action-name</strong> /
    <strong>dependent-action-params</strong>: Die drei Optionen dienen dazu, eine abhängige Action
    automatisch beim Front-Controller zu registrieren. Dies ist vor Allem dann hilfreich, wenn ein
    Modul über das Tag eingebunden wird und eine Front-Controller-Action zur Steuerung der
    Navigation verwendet wird.
    <br />
    Das Attribut <strong>dependent-action-namespace</strong> definiert den Namespace der Action (z.B.
    <em>ACME\site\biz</em>) und <strong>dependent-action-name</strong> den Namen/Alias der Action
    (z.B. <em>Navigate</em>). <strong>dependent-action-params</strong> beinhaltet die Parameter der
    Action in der Form <strong>param1:value1|param2:value2</strong>, wie aus dem URL-Layout des
    Front-Controllers bekannt.
  </li>
</ul>
<p>
   Um das Tag anwenden zu könen, muss dieses zunächst via
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="APF\tools\html\taglib\GenericImportTemplateTag"
   prefix="generic"
   name="importdesign"
/&gt;
</gen:highlight>
<p>
   bekannt gemacht werden.
</p>
<strong>Hinweise:</strong>
<ul>
  <li>
    Als Anwendungsbeispiel kann der Artikel <int:link pageid="079" lang="en" /> (englisch)
    herangezogen werden. Dieser beschreibt, wie die vorliegende Dokuentationswebseite aufgebaut ist
    und welche Mittel des Frameworks sie nutzt.
  </li>
  <li>
    Soll eine Front-Controller-Action zu Navigationszwecken verwendet werden, so muss bei der
    Klassendefinition die Variable <em>$keepInURL</em> mit <em>true</em>
    initialisiert werden. Dies bewirkt, dass die Action bei der Link-Generierung mit dem
    <int:link pageid="138">LinkGenerator</int:link> erfasst wird.
  </li>
  <li>
    Die Registrierung der Action wird nur dann durchgeführt, wenn die Attribute
    <strong>dependent-action-namespace</strong> und <strong>dependent-action-name</strong> gefüllt
    sind und die Action noch nicht gegistriert ist. Die Angabe von Parametern ist optional.
  </li>
</ul>

<h3 id="Chapter-4-Core-appendnode"><a href="#Chapter-4-Core-appendnode">4. core:appendnode-Tag</a></h3>
<p>
   Aus einer Diskussion über wiederverwendbare Template-Fragmente (z.B. Formulare) entstand die
   Idee, eine TagLib zu entwerfen, die Inhalte aus einem beliebigen Template in den aktuellen
   Gültigkeitsbereich zu importieren. Durch die generische DOM-Struktur der GUI-Elemente des
   Frameworks ist dies auf sehr einfache Weise möglich.
</p>
<p>
   Um die Funktion allgemeingültig zur Verfügung zu stellen, wurde im 1.8er-Zweig der
   <em>&lt;core:appendnode /&gt;</em>-Tag hinzugefügt, der beliebige Templates
   &quot;importieren&quot; kann. Der Tag erwartet - ähnlich dem importdesign-Tag - die statischen Attribute
   <em>namespace</em> und <em>template</em>.
</p>
<div class="hint">
   Zusätzlich ist das Attribut <em>includestatic</em> verfügbar. Ist dieses auf den Wert <em>true</em> eingestellt, so
   wird sämtlicher Inhalt des inkludierten Templates übernommen. Enthält es einen anderen Wert oder ist nicht
   vorhanden, werden nur die aktuell im eingebundenen Template enthaltenen DOM-Knoten (Instanzen von
   Taglibs) übernommen.
</div>

<h4 id="Chapter-4-1-Einbindung-von-Templates"><a href="#Chapter-4-1-Einbindung-von-Templates">4.1. Einbindung von Templates</a></h4>
<p>
   Um ein wiederverwendbares Template einbinden zu können, muss das Tag im gewünschten
   Template wir folgt platziert werden:
</p>
<gen:highlight type="apf-xml">
&lt;core:appendnode
   namespace="..."
   template="..."
   [includestatic="true"]
/&gt;
</gen:highlight>
<p>
   Soll beispielweise ein Template zur Ausgabe eines Domänen-Objekts in mehreren View-Templates
   eingesetzt werden, so schickt es sich, dieses in einem eigenen Template (Namespace:
   <em>APF\sites\testsite\pres\templates\generic</em>; Template: <em>generic_templates</em>) zu
   definieren. Die Definition kann dabei folgende Gestalt haben:
</p>
<gen:highlight type="apf-xml">
&lt;html:template name="ReusableTemplate"&gt;
  ...
  &lt;html:placeholder name="DisplayName"&gt;
  ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Um das Template in einem anderen verwenden zu können, muss die Template-Datei wie folgt in die
   bestehende eingebunden werden:
</p>
<gen:highlight type="apf-xml">
&lt;core:appendnode
   namespace="APF\sites\testsite\pres\templates\generic"
   template="generic_templates"
/&gt;
</gen:highlight>

<h4 id="Chapter-4-2-Verwendung-der-Elemente"><a href="#Chapter-4-2-Verwendung-der-Elemente">4.2. Verwendung der Elemente</a></h4>
<p>
   Die Verwendung der durch das <em>&lt;core:appendnode /&gt;</em>-Tag eingebundenen Elements
   gestaltet sich identisch zur bisherigen Vorgehensweise, da die Elemente in den Gültigkeitsbereich
   des gewünschten Templates importiert werden. Damit können weiterhin die im
   Document-Controller zur Verfügung stehenden Methoden (z.B. <em>getTemplate()</em>) verwendet
   werden.
</p>
<p>Das im Kapitel 4.1 aufgezeigte Template könn wie auch bisher mit</p>
<gen:highlight type="php">
$tmpl = $this->getTemplate('ReusableTemplate');
</gen:highlight>
<p>adressiert werden.</p>

<h4 id="Chapter-4-3-Wichtige-Hinweise"><a href="#Chapter-4-3-Wichtige-Hinweise">4.3. Wichtige Hinweise</a></h4>
<p>
   Das Parsen des eingebundenen Templates erfolgt identisch zu den per <em>&lt;core:importdesign /&gt;</em>-Tag
   eingebundenen Template-Dateien.
</p>
<p>
   Die <em>&lt;core:appendnode /&gt;</em>-TagLib legt im Ursprungstemplate Marker-Tags an, damit
   die <em>transformOnPlace()</em>-Methoden genutzt werden können. Bitte beachten Sie, dass
   die eingebundenen Kinder in der Reihenfolge der Definition im zusätzlichen Template eingebunden
   werden!
</p>
<p>Sofern auch statischer Inhalt des eingebundenen Templates wie z.B.</p>
<gen:highlight type="apf-xml">
<div class="formattingContainer">
   &lt;html:template name="ReusableTemplate"&gt;
     ...
   &lt;/html:template&gt;
</div>
</gen:highlight>
<p>
   übernommen werden soll, muss das Attribut <em>includestatic</em> auf den Wert <em>true</em>
   gestellt werden.
</p>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_078" />