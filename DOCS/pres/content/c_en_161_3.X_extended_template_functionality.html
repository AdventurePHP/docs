<doku:title parent="119" tags="templates,place holders,object access" title="Extended template functionality" urlname="Extended-template-functionality">
   The present chapter deals with the extended templating functionality like short place holders and object access on
   data attributes. Besides extension of template expressions is discussed.
</doku:title>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   Based on <int:link pageid="047" /> the APF provides an extend set of template functionality for easier templating.
</p>
<p>
   Using the APF as is it already provides an extensive set of possibilities as described in
   <a href="#Chapter-2-Available-functionality">chapter 2</a>. In <a href="#Chapter-3-Extending-the-syntax">chapter 3</a>
   you can read about how the syntax can be extended.
</p>

<h3 id="Chapter-2-Available-functionality"><a href="#Chapter-2-Available-functionality">2. Available functionality</a></h3>
<p>
   In addition to the functionality described in <int:link pageid="047" anchor="Chapter-2-Content-of-templates"/>
   you may also want to use dynamic template expressions within APF templates. They provide a shortcut for place holders such as
   <em>&lt;html:placeholder /&gt;</em> as well as a pseudo language to access data attributes of APF DOM nodes. Besides,
   method calls and array access of data attributes is possible.
</p>
<p>
   The following chapters describe both features and give hints on using them within your application.
</p>

<h4 id="Chapter-2-1-Place-holders"><a href="#Chapter-2-1-Place-holders">2.1. Place holders</a></h4>
<p>
   Besides the well-known APF tags for place holders such as the
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="foo" /&gt;
</gen:highlight>
<p>
   you may also want to use the shorthand version
</p>
<gen:highlight type="apf-xml">
&#36;{foo}
</gen:highlight>
<p>
   It helps to reduce size of your templates and potential solves issues with IDE support for HTML files.
</p>
<div class="hint">
   The short version of the place holders are constructed by start symbol <em>&#36;{</em>, followed by a unique identifier
   and closing symbol <em>}</em>. The name must not contain further brackets. Allowed are upper case and lower case
   letters as well as hyphens and underlines.
</div>
<p>
   Accessing place holders in shorthand writing is the sam as for usual place holders. In case you want to fill the
   place holders in template
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="&#36;{css-class}">
   <p>
      &#36;{intro-text}
   </p>
   <p>
      &#36;{detail-text}
   </p>
   <p>
      <a href="&#36;{link-target}">&#36;{link-label}</a>
   </p>
</div>
</gen:highlight>
<p>
   you can use the following controller code for that:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      $this->setPlaceHolder('css-class', $model->getCssClass());
      $this->setPlaceHolder('intro-text', $model->getIntroText());
      $this->setPlaceHolder('detail-text', $model->getDetailText());
      $this->setPlaceHolder('link-target', $model->getMoreLink()->getTarget());
      $this->setPlaceHolder('link-label', $model->getMoreLink()->getLabel());

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>

<h4 id="Chapter-2-2-Object-access"><a href="#Chapter-2-2-Object-access">2.2. Object access</a></h4>
<p>
   The <em>pseudo templating language</em> of the APF allows you to access data attributes of APF DOM nodes with
   dynamic expressions and to print the content that is stored there within templates.
</p>
<p>
   The template example described in <a href="#Chapter-2-1-Place-holders">chapter 2.1</a> can be simplified using the
   <em>pseudo language</em> as follows:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="&#36;{news->getCssClass()}">
   <p>
      &#36;{news->getIntroText()}
   </p>
   <p>
      &#36;{news->getDetailText()}
   </p>
   <p>
      <a href="&#36;{news->getMoreLink()->getLinkTarget()}">
         &#36;{news->getMoreLink()->getLinkLabel()}
      </a>
   </p>
</div>
</gen:highlight>
<p>
   The controller is also reduced by several lines:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<p>
   Using this approach repetitive code can be thrown out of controllers and clarity improves.
</p>
<p>
   Basis for the <em>pseudo template language</em> is the APF DOM model. It allows - similar to HTML nodes - to define
   data attributes. Class <em>Document</em> therefor provides <em>setData()</em> and<em>getData()</em>. Within a class
   derived from <em>BaseDocumentController</em> you can use methods with the same name to access data attributes of the
   current DOM node.
</p>
<p>
   The subsequent chapters describe the different features of the template language in detail.
</p>

<h5 id="Chapter-2-2-1-List-access"><a href="#Chapter-2-2-1-List-access">2.2.1. List access</a></h5>
<p>
   Using the<em>pseudo template language</em> of the APF you can access lists similar to the PHP syntax. You may both
   declare simple and multi-level arrays with numeric and/or alphanumeric offsets.
</p>
<p>
   Within templates you can access simple or nested lists with simple content or even lists with complex content
   (objects). If necessary, access to complex content requires further interaction. Please refer to
   <a href="#Chapter-2-2-2-Object-access">chapter 2.2.2</a> and
   <a href="#Chapter-2-2-3-Combined-access">chapter 2.2.3</a> for more information.
</p>
<p>
   The following code box contains different list access types for templates:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Access to the first numeric offset --&gt;
&#36;{news[0]}

&lt;!-- Access to the offset xyz --&gt;
&#36;{news['xyz']}

&lt;!-- Access to the numeric offset 1 and within that list to numeric offset 2 --&gt;
&#36;{news[1][2]}

&lt;!-- Access to the numeric offset 1 and within that list to the alphanumeric offset xyz --&gt;
&#36;{news[1]['xyz']}

&lt;!-- Access using mixed offset declarations --&gt;
&#36;{news[1][2][3][4]}
&#36;{news[1]['two'][3]['four']}
</gen:highlight>
<p>
   To be able to use the expressions to access data the DOM node has to be added the respective data with the controller
   first:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      // Access to the first numeric offset
      $this->setData(
         'news',
         array(
            0 => $model
         )
      );

      // Access to the offset xyz
      $this->setData(
         'news',
         array(
            'xyz' => $model
         )
      );

      // Access to the numeric offset 1 and within that list to numeric offset 2
      $this->setData(
         'news',
         array(
            1 => array(
               2 => $model
            )
         )
      );

      // Access to the numeric offset 1 and within that list to the alphanumeric offset xyz
      $this->setData(
         'news',
         array(
            1 => array(
               'xyz' => $model
            )
         )
      );

      // Access using mixed offset declarations
      $this->setData(
         'news',
         array(
            1 => array(
               2 => array(
                  3 => array(
                     4 => $model
                  )
               )
            )
         )
      );
      $this->setData(
         'news',
         array(
            1 => array(
               'two' => array(
                  3 => array(
                     'four' => $model
                  )
               )
            )
         )
      );

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<div class="hint">
   In case the list elements implement the <em>__toString()</em> method output can be generated directly by list
   access without any further method calls.
</div>

<h5 id="Chapter-2-2-2-Object-access"><a href="#Chapter-2-2-2-Object-access">2.2.2. Object access</a></h5>
<p>
   Besides accessing lists the <em>pseudo template language</em> of the APF offers access to objects of data attributes.
   The syntax follows the PHP syntax as well.
</p>
<p>
   Method calls of any number and kind can be constructed as well as being mixed with list access. For array access
   syntax, please refer to <a href="#Chapter-2-2-3-Combined-access">chapter 2.2.3</a>.
</p>
<p>
   The following code box shows some examples of method calls:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Call to the getCssClass() method of the ContentModel class --&gt;
&#36;{news->getCssClass()}

&lt;!--
   Call to the getLinkLabel() method of the LinkModel class returned by
   a call to getMoreLink() of class ContentModel
--&gt;
&#36;{news->getMoreLink()->getLinkLabel()}
</gen:highlight>
<p>
   To be able to use the expressions to access data the DOM node has to be added the respective data with the controller
   first:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

}
</gen:highlight>

<h5 id="Chapter-2-2-3-Combined-access"><a href="#Chapter-2-2-3-Combined-access">2.2.3. Combined access</a></h5>
<p>
   Array access syntax described under <a href="#Chapter-2-2-1-List-access">chapter 2.2.1</a> and
   method call syntax under <a href="#Chapter-2-2-2-Object-access">chapter 2.2.2</a> can be combined to more complex
   expressions. For instance, you can combine an array access and one or more method calls to access the data of a
   list and their items very easily.
</p>
<div class="hint">
   Please note, that multiple method calls or list access calls must be separated by <em>-&gt;</em>.
</div>
<p>
   In case you intend to print the first three news entries you may want to use the following template:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<ul class="news-list">
   <li>&#36;{news[0]->getIntroText()}</li>
   <li>&#36;{news[1]->getIntroText()}</li>
   <li>&#36;{news[2]->getIntroText()}</li>
</ul>
</gen:highlight>
<p>
   The controller to create the output is as follows:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getNews());
   }

   /**
    * @return ContentModel[]
    */
   private function getNews() {
      ...
   }

}
</gen:highlight>
<p>
   Method <em>getNews()</em> returns a list of <em>ContentModel</em> instances.
</p>
<p>
   The implementation of the <em>pseudo template language</em> allows further combinations of expressions:
</p>
<gen:highlight type="apf-xml">
&lt;!-- Call to getBar() on the third element returned by getFoo() --&gt;
&#36;{news->getFoo()->[3]->getBar()}

&lt;!--
   Call to getBaz() on the result of a getBar() call that is stored
   in offset foo of the 5th element of data attribute news
--&gt;
&#36;{news[5]['foo']->getBar()->getBaz()}
</gen:highlight>
<div class="warn">
   Please note, that the examples listed here require a corresponding data structure. Erroneous expressions will lead
   to errors and thus break application execution.
</div>

<h3 id="Chapter-3-Extending-the-syntax"><a href="#Chapter-3-Extending-the-syntax">3. Extending the syntax</a></h3>
<p>
   The extended templating syntax is based on an APF parser functionality processing logical expressions. Expressions
   are started with <em>&#36;{</em> and are closed with by <em>}</em>. The part between the two tokens defines the
   real instruction. Using this syntax you can easily realize place holders and access data attributes in a shorter
   way compared to an XML notation.
</p>
<p>
   All tokens found during processing of templates or tag structures are translated into APF DOM nodes and placed into
   the appropriate hierarchy of the DOM tree. With this approach you can easily access them within the application by
   existing mechanisms.
</p>
<p>
   Extending the templating syntax described in <a href="#Chapter-2-Available-functionality">chapter 2</a> you can
   register custom expressions using <em>Document::addTemplateExpression()</em> which works similar to
   <em>Document::addTagLib()</em>.
</p>
<p>
   The following chapters describe the structure and usage of custom expressions.
</p>

<h4 id="Chapter-3-1-Definition"><a href="#Chapter-3-1-Definition">3.1. Definition</a></h4>
<p>
   A template expression is defined by the <em>TemplateExpression</em> interface. Each expression implementation is used
   by APF parser to determine whether it is delegated the processing of the expression between <em>&#36;{</em> and
   <em>}</em>. If yes, the implementation is requested to create the corresponding DOM node representation.
</p>
<p>
   The interface is as follows:
</p>
<gen:highlight type="php">
namespace APF\core\pagecontroller;

interface TemplateExpression {

   public static function applies($token);

   public static function getDocument($token);

}
</gen:highlight>
<p>
   Method <em>applies()</em> is used by the APF parser to evaluate the appropriate implementation by the current token
   being processed. For this reason, the parser expects the implementation to return <em>true</em> in case the expression
   should be processed by this particular expression. If not, <em>false</em> is expected as return value.
</p>
<p>
   In case a template contains expression
</p>
<gen:highlight type="apf-xml">
${getString(APF\modules\comments, language.ini, header.title)}
</gen:highlight>
<p>
   the parser applies <em>getString(APF\modules\comments, language.ini, header.title)</em> to  <em>applies()</em>.
</p>
<p>
   <em>getDocument()</em> then creates the DOM node that is delegated the processing of the expression. Therewith,
   the APF clearly follows the HMVC paradigm to create and maintain UI components and to encapsulate UI functionality
   within tags.
</p>

<h4 id="Chapter-3-2-Implementation"><a href="#Chapter-3-2-Implementation">3.2. Implementation</a></h4>
<p>
   The implementation of a template expression includes an implementation of the <em>TemplateExpression</em> interface
   and a tag that is returned by the <em>getDocument()</em> method. The <em>TemplateExpression</em> implementation
   describes the expression and the tag represents the functionality of the expression.
</p>
<p>
   The following implementation example within this section realizes a short syntax of the
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link> tag. As a result, it
   outputs localized content from a language file according to the language of the application.
</p>
<p>
   Please note the following code box that contains an implementation for a short hand version of the
   <em>&lt;html:getstring /&gt;</em> tag:
</p>
<gen:highlight type="php">
namespace VENDOR\..\expression;

class GetStringTemplateExpression implements TemplateExpression {

   const START_TOKEN = 'getString(';
   const END_TOKEN = ')';

   public static function applies($token) {
      return strpos($token, self::START_TOKEN) !== false && strpos($token, self::END_TOKEN) !== false;
   }

   public static function getDocument($token) {

      $startTokenPos = strpos($token, self::START_TOKEN);
      $endTokenPos = strpos($token, self::END_TOKEN, $startTokenPos + 1);

      $arguments = explode(',', substr($token, $startTokenPos + 10, $endTokenPos - $startTokenPos - 10));

      $object = new LanguageLabelTag();
      $object->setAttribute('namespace', trim($arguments[0]));
      $object->setAttribute('config', trim($arguments[1]));
      $object->setAttribute('entry', trim($arguments[2]));

      return $object;

   }

}
</gen:highlight>
<p>
   Within method <em>applies()</em> the implementation determines whether it is responsible for processing the applied
   token. This is done by checking whether an opening and closing token exists.
</p>
<div class="warn">
   Please note, that processing template expressions is based on strings and not using XML structures. Thus, please
   ensure that all custom expressions are unique within your project and can be detected without as such.
</div>
<p>
   <em>getDocument()</em> then creates a tag instance that takes responsibility for processing the expression logic. In
   case of the <em>getString()</em> expression the <em>LanguageLabelTag</em> tag delivered with the APF is re-used as it
   already contains the functionality to display language-dependent content based on the <em>namespace</em>, <em>config</em>,
   and <em>entry</em> attributes.
</p>
<p>
   Hints on implementing custom tags can be found under <int:link pageid="147" />.
</p>

<h4 id="Chapter-3-3-Configuration"><a href="#Chapter-3-3-Configuration">3.3. Configuration</a></h4>
<p>
   In case you want to use the template expression created in the last chapter it must be registered within the
   bootstrap file. For this reason, you might want to use the following code:
</p>
<gen:highlight type="php">
Document::addTemplateExpression('VENDOR\..\expression\GetStringTemplateExpression');
</gen:highlight>
<p>
   Now, you can use the newly created expression within your template as follows:
</p>
<gen:highlight type="apf-xml">
<h2>Example</h2>
<p>
   ${getString(APF\modules\comments, language.ini, header.title)}
</p>
</gen:highlight>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="en_161" />