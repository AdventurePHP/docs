<doku:title parent="119" tags="templates,place holders,object access" title="Extended template functionality" urlname="Extended-template-functionality">
   The present chapter deals with the extended templating functionality like short place holders and object access on
   data attributes. Besides extension of template expressions is discussed.
</doku:title>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   Based on <int:link pageid="047" /> the APF provides an extend set of template functionality for easier templating.
</p>
<p>
   Using the APF as is it already provides an extensive set of possibilities as described in
   <a href="#Chapter-2-Available-functionality">chapter 2</a>. In <a href="#Chapter-3-Extending-the-syntax">chapter 3</a>
   you can read about how the syntax can be extended.
</p>
<div class="hint">
   Chapter <int:link pageid="164" /> contains an extensive article on using <em>view models</em> to keep your controllers
   skinny and easy to test. The article used the mechanisms described on this page to keep the view templates simple and
   clear.
</div>

<h3 id="Chapter-2-Available-functionality"><a href="#Chapter-2-Available-functionality">2. Available functionality</a></h3>
<p>
   In addition to the functionality described in <int:link pageid="047" anchor="Chapter-2-Content-of-templates"/>
   you may also want to use dynamic template expressions within APF templates. They provide a shortcut for place holders such as
   <em>&lt;html:placeholder /&gt;</em> as well as a pseudo language to access data attributes of APF DOM nodes. Besides,
   method calls and array access of data attributes is possible.
</p>
<p>
   The following chapters describe both features and give hints on using them within your application.
</p>

<h4 id="Chapter-2-1-Place-holders"><a href="#Chapter-2-1-Place-holders">2.1. Place holders</a></h4>
<p>
   Besides the well-known APF tags for place holders such as the
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="foo" /&gt;
</gen:highlight>
<p>
   you may also want to use the shorthand version
</p>
<gen:highlight type="apf-xml">
&#36;{foo}
</gen:highlight>
<p>
   It helps to reduce size of your templates and potential solves issues with IDE support for HTML files.
</p>
<div class="hint">
   The short version of the place holders are constructed by start symbol <em>&#36;{</em>, followed by a unique identifier
   and closing symbol <em>}</em>. The name must not contain further brackets. Allowed are upper case and lower case
   letters as well as hyphens and underlines.
</div>
<p>
   Accessing place holders in shorthand writing is the sam as for usual place holders. In case you want to fill the
   place holders in template
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="&#36;{css-class}">
   <p>
      &#36;{intro-text}
   </p>
   <p>
      &#36;{detail-text}
   </p>
   <p>
      <a href="&#36;{link-target}">&#36;{link-label}</a>
   </p>
</div>
</gen:highlight>
<p>
   you can use the following controller code for that:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      $this->setPlaceHolder('css-class', $model->getCssClass());
      $this->setPlaceHolder('intro-text', $model->getIntroText());
      $this->setPlaceHolder('detail-text', $model->getDetailText());
      $this->setPlaceHolder('link-target', $model->getMoreLink()->getTarget());
      $this->setPlaceHolder('link-label', $model->getMoreLink()->getLabel());

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>

<h4 id="Chapter-2-2-Object-access"><a href="#Chapter-2-2-Object-access">2.2. Object access</a></h4>
<p>
   The <em>pseudo templating language</em> of the APF allows you to access data attributes of APF DOM nodes with
   dynamic expressions and to print the content that is stored there within templates.
</p>
<p>
   The template example described in <a href="#Chapter-2-1-Place-holders">chapter 2.1</a> can be simplified using the
   <em>pseudo language</em> as follows:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<div class="&#36;{news->getCssClass()}">
   <p>
      &#36;{news->getIntroText()}
   </p>
   <p>
      &#36;{news->getDetailText()}
   </p>
   <p>
      <a href="&#36;{news->getMoreLink()->getLinkTarget()}">
         &#36;{news->getMoreLink()->getLinkLabel()}
      </a>
   </p>
</div>
</gen:highlight>
<p>
   The controller is also reduced by several lines:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<p>
   Using this approach repetitive code can be thrown out of controllers and clarity improves.
</p>
<p>
   Basis for the <em>pseudo template language</em> is the APF DOM model. It allows - similar to HTML nodes - to define
   data attributes. Class <em>Document</em> therefor provides <em>setData()</em> and<em>getData()</em>. Within a class
   derived from <em>BaseDocumentController</em> you can use methods with the same name to access data attributes of the
   current DOM node.
</p>
<p>
   The subsequent chapters describe the different features of the template language in detail.
</p>

<h5 id="Chapter-2-2-1-List-access"><a href="#Chapter-2-2-1-List-access">2.2.1. List access</a></h5>
<p>
   Using the<em>pseudo template language</em> of the APF you can access lists similar to the PHP syntax. You may both
   declare simple and multi-level arrays with numeric and/or alphanumeric offsets.
</p>
<p>
   Within templates you can access simple or nested lists with simple content or even lists with complex content
   (objects). If necessary, access to complex content requires further interaction. Please refer to
   <a href="#Chapter-2-2-2-Object-access">chapter 2.2.2</a> and
   <a href="#Chapter-2-2-3-Combined-access">chapter 2.2.3</a> for more information.
</p>
<p>
   The following code box contains different list access types for templates:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Access to the first numeric offset --&gt;
&#36;{news[0]}

&lt;!-- Access to the offset xyz --&gt;
&#36;{news['xyz']}

&lt;!-- Access to the numeric offset 1 and within that list to numeric offset 2 --&gt;
&#36;{news[1][2]}

&lt;!-- Access to the numeric offset 1 and within that list to the alphanumeric offset xyz --&gt;
&#36;{news[1]['xyz']}

&lt;!-- Access using mixed offset declarations --&gt;
&#36;{news[1][2][3][4]}
&#36;{news[1]['two'][3]['four']}
</gen:highlight>
<p>
   To be able to use the expressions to access data the DOM node has to be added the respective data with the controller
   first:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {

      $model = $this->getModel();

      // Access to the first numeric offset
      $this->setData(
         'news',
         array(
            0 => $model
         )
      );

      // Access to the offset xyz
      $this->setData(
         'news',
         array(
            'xyz' => $model
         )
      );

      // Access to the numeric offset 1 and within that list to numeric offset 2
      $this->setData(
         'news',
         array(
            1 => array(
               2 => $model
            )
         )
      );

      // Access to the numeric offset 1 and within that list to the alphanumeric offset xyz
      $this->setData(
         'news',
         array(
            1 => array(
               'xyz' => $model
            )
         )
      );

      // Access using mixed offset declarations
      $this->setData(
         'news',
         array(
            1 => array(
               2 => array(
                  3 => array(
                     4 => $model
                  )
               )
            )
         )
      );
      $this->setData(
         'news',
         array(
            1 => array(
               'two' => array(
                  3 => array(
                     'four' => $model
                  )
               )
            )
         )
      );

   }

   /**
    * @return ContentModel
    */
   private function getModel() {
      return new ContentModel();
   }

}
</gen:highlight>
<div class="hint">
   In case the list elements implement the <em>__toString()</em> method output can be generated directly by list
   access without any further method calls.
</div>

<h5 id="Chapter-2-2-2-Object-access"><a href="#Chapter-2-2-2-Object-access">2.2.2. Object access</a></h5>
<p>
   Besides accessing lists the <em>pseudo template language</em> of the APF offers access to objects of data attributes.
   The syntax follows the PHP syntax as well.
</p>
<p>
   Method calls of any number and kind can be constructed as well as being mixed with list access. For array access
   syntax, please refer to <a href="#Chapter-2-2-3-Combined-access">chapter 2.2.3</a>.
</p>
<p>
   The following code box shows some examples of method calls:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
&lt;!-- Call to the getCssClass() method of the ContentModel class --&gt;
&#36;{news->getCssClass()}

&lt;!--
   Call to the getLinkLabel() method of the LinkModel class returned by
   a call to getMoreLink() of class ContentModel
--&gt;
&#36;{news->getMoreLink()->getLinkLabel()}
</gen:highlight>
<p>
   To be able to use the expressions to access data the DOM node has to be added the respective data with the controller
   first:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getModel());
   }

}
</gen:highlight>
<div class="hint">
   In addition to accessing data attributes you can also access the current tag instance where the expression is defined
   and will be executed in. For this reason, you can use the <em>this</em> keyword. In case you want to display the name
   of the template an expression is defined within you may want to use the following template code:
<gen:highlight type="apf-xml">
&lt;html:template name="foo"&gt;
   Template name: &#36;{this-&gt;getAttribute('name')}
&lt;/html:template&gt;
</gen:highlight>
</div>

<h5 id="Chapter-2-2-3-Combined-access"><a href="#Chapter-2-2-3-Combined-access">2.2.3. Combined access</a></h5>
<p>
   Array access syntax described under <a href="#Chapter-2-2-1-List-access">chapter 2.2.1</a> and
   method call syntax under <a href="#Chapter-2-2-2-Object-access">chapter 2.2.2</a> can be combined to more complex
   expressions. For instance, you can combine an array access and one or more method calls to access the data of a
   list and their items very easily.
</p>
<div class="hint">
   Please note, that multiple method calls or list access calls must be separated by <em>-&gt;</em>.
</div>
<p>
   In case you intend to print the first three news entries you may want to use the following template:
</p>
<gen:highlight type="apf-xml">
<@controller
   class="VENDOR\..\controller\SampleController"
@>
<ul class="news-list">
   <li>&#36;{news[0]->getIntroText()}</li>
   <li>&#36;{news[1]->getIntroText()}</li>
   <li>&#36;{news[2]->getIntroText()}</li>
</ul>
</gen:highlight>
<p>
   The controller to create the output is as follows:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;

class SampleController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('news', $this->getNews());
   }

   /**
    * @return ContentModel[]
    */
   private function getNews() {
      ...
   }

}
</gen:highlight>
<p>
   Method <em>getNews()</em> returns a list of <em>ContentModel</em> instances.
</p>
<p>
   The implementation of the <em>pseudo template language</em> allows further combinations of expressions:
</p>
<gen:highlight type="apf-xml">
&lt;!-- Call to getBar() on the third element returned by getFoo() --&gt;
&#36;{news->getFoo()->[3]->getBar()}

&lt;!--
   Call to getBaz() on the result of a getBar() call that is stored
   in offset foo of the 5th element of data attribute news
--&gt;
&#36;{news[5]['foo']->getBar()->getBaz()}
</gen:highlight>
<div class="warn">
   Please note, that the examples listed here require a corresponding data structure. Erroneous expressions will lead
   to errors and thus break application execution.
</div>

<h3 id="Chapter-3-Extending-the-syntax"><a href="#Chapter-3-Extending-the-syntax">3. Extending the syntax</a></h3>
<p>
   The extended templating syntax is based on an APF parser functionality processing logical expressions. Expressions
   are started with <em>&#36;{</em> and are closed with by <em>}</em>. The part between the two tokens defines the
   real instruction. Using this syntax you can easily realize place holders and access data attributes in a shorter
   way compared to an XML notation.
</p>
<p>
   All tokens found during processing of templates or tag structures are translated into APF DOM nodes and placed into
   the appropriate hierarchy of the DOM tree. With this approach you can easily access them within the application by
   existing mechanisms.
</p>
<p>
   Extending the templating syntax described in <a href="#Chapter-2-Available-functionality">chapter 2</a> you can
   register custom expressions using <em>Document::addTemplateExpression()</em> which works similar to
   <em>Document::addTagLib()</em>.
</p>
<p>
   The following chapters describe the structure and usage of custom expressions.
</p>

<h4 id="Chapter-3-1-Definition"><a href="#Chapter-3-1-Definition">3.1. Definition</a></h4>
<p>
   A template expression is defined by the <em>TemplateExpression</em> interface. Each expression implementation is used
   by APF parser to determine whether it is delegated the processing of the expression between <em>&#36;{</em> and
   <em>}</em>. If yes, the implementation is requested to create the corresponding DOM node representation.
</p>
<p>
   The interface is as follows:
</p>
<gen:highlight type="php">
namespace APF\core\pagecontroller;

interface TemplateExpression {

   public static function applies($token);

   public static function getDocument($token);

}
</gen:highlight>
<p>
   Method <em>applies()</em> is used by the APF parser to evaluate the appropriate implementation by the current token
   being processed. For this reason, the parser expects the implementation to return <em>true</em> in case the expression
   should be processed by this particular expression. If not, <em>false</em> is expected as return value.
</p>
<p>
   In case a template contains expression
</p>
<gen:highlight type="apf-xml">
&#36;{getString(APF\modules\comments, language.ini, header.title)}
</gen:highlight>
<p>
   the parser applies <em>getString(APF\modules\comments, language.ini, header.title)</em> to  <em>applies()</em>.
</p>
<p>
   <em>getDocument()</em> then creates the DOM node that is delegated the processing of the expression. Therewith,
   the APF clearly follows the HMVC paradigm to create and maintain UI components and to encapsulate UI functionality
   within tags.
</p>

<h4 id="Chapter-3-2-Implementation"><a href="#Chapter-3-2-Implementation">3.2. Implementation</a></h4>
<p>
   The implementation of a template expression includes an implementation of the <em>TemplateExpression</em> interface
   and a tag that is returned by the <em>getDocument()</em> method. The <em>TemplateExpression</em> implementation
   describes the expression and the tag represents the functionality of the expression.
</p>
<p>
   The following implementation example within this section realizes a short syntax of the
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link> tag. As a result, it
   outputs localized content from a language file according to the language of the application.
</p>
<p>
   Please note the following code box that contains an implementation for a short hand version of the
   <em>&lt;html:getstring /&gt;</em> tag:
</p>
<gen:highlight type="php">
namespace VENDOR\..\expression;

class GetStringTemplateExpression implements TemplateExpression {

   const START_TOKEN = 'getString(';
   const END_TOKEN = ')';

   public static function applies($token) {
      return strpos($token, self::START_TOKEN) !== false && strpos($token, self::END_TOKEN) !== false;
   }

   public static function getDocument($token) {

      $startTokenPos = strpos($token, self::START_TOKEN);
      $endTokenPos = strpos($token, self::END_TOKEN, $startTokenPos + 1);

      $arguments = explode(',', substr($token, $startTokenPos + 10, $endTokenPos - $startTokenPos - 10));

      $object = new LanguageLabelTag();
      $object->setAttribute('namespace', trim($arguments[0]));
      $object->setAttribute('config', trim($arguments[1]));
      $object->setAttribute('entry', trim($arguments[2]));

      return $object;

   }

}
</gen:highlight>
<p>
   Within method <em>applies()</em> the implementation determines whether it is responsible for processing the applied
   token. This is done by checking whether an opening and closing token exists.
</p>
<div class="warn">
   Please note, that processing template expressions is based on strings and not using XML structures. Thus, please
   ensure that all custom expressions are unique within your project and can be detected without as such.
</div>
<p>
   <em>getDocument()</em> then creates a tag instance that takes responsibility for processing the expression logic. In
   case of the <em>getString()</em> expression the <em>LanguageLabelTag</em> tag delivered with the APF is re-used as it
   already contains the functionality to display language-dependent content based on the <em>namespace</em>, <em>config</em>,
   and <em>entry</em> attributes.
</p>
<p>
   Hints on implementing custom tags can be found under <int:link pageid="147" />.
</p>

<h4 id="Chapter-3-3-Configuration"><a href="#Chapter-3-3-Configuration">3.3. Configuration</a></h4>
<p>
   In case you want to use the template expression created in the last chapter it must be registered within the
   bootstrap file. For this reason, you might want to use the following code:
</p>
<gen:highlight type="php">
Document::addTemplateExpression('VENDOR\..\expression\GetStringTemplateExpression');
</gen:highlight>
<p>
   Now, you can use the newly created expression within your template as follows:
</p>
<gen:highlight type="apf-xml">
<h2>Example</h2>
<p>
   &#36;{getString(APF\modules\comments, language.ini, header.title)}
</p>
</gen:highlight>

<h3 id="Chapter-4-Conditional-display"><a href="#Chapter-4-Conditional-display">4. Conditional display</a></h3>
<p>
   Conditional display is a common use case in web applications. The APF offers two tag implementations that cover simple
   and also complex use cases.
</p>
<p>
   <em>&lt;cond:placeholder /&gt;</em> dislays content in case the condition is met and <em>&lt;cond:template /&gt;</em>
   covers more complex conditional display use cases.
</p>
<div class="hint">
   Both <em>&lt;cond:placeholder /&gt;</em> and <em>&lt;cond:template /&gt;</em> combine output definition and condition
   directly within the template. This not only improves readability but also helps to keep controller code clean.
</div>
<p>
   The following chapters describe usage of both tags based on comprehensive examples.
</p>

<h4 id="Chapter-4-1-Place-holder"><a href="#Chapter-4-1-Place-holder">4.1. Place holder</a></h4>
<p>
   The signature if the <em>&lt;cond:placeholder /&gt;</em> tag is as follows:
</p>
<gen:highlight type="apf-xml">
&lt;cond:placeholder name="" [condition=""]&gt;
   ... ${content} ...
&lt;/cond:placeholder&gt;
</gen:highlight>
<strong>Attribute description:</strong>
<ul>
   <li>
      <strong>name</strong>:
      Name of the place holder. Can be used to access the element e.g. by controller.
      (<strong>Zeichen:</strong> [A-Za-z0-9-_])
   </li>
   <li>
      <strong>condition</strong> (optional):
      Definition of the display condition (<strong>Default:</strong>
      <em>notEmpty()</em>). Details on all available conditions can be taken from
      <a href="#Chapter-4-3-Available-conditions">chapter 4.3</a>.
   </li>
   <li>
      <strong>&#36;{content}</strong>:
      Using the (inner) <em>content</em> place holder the content set within a controller can be positioned within the
      conditional place holder.
   </li>
</ul>
<p>
   The follwing example shows a teaser template that has an optional sub line. Using the
   <em>&lt;cond:placeholder /&gt;</em> tag template definition is quite simple:
</p>
<gen:highlight type="apf-xml">
&lt;h2 class="..."&gt;${headline}&lt;/h2&gt;
&lt;cond:placeholder name="sub-headline"&gt;
   &lt;h3 class="..."&gt;${content}&lt;/h3&gt;
&lt;/cond:placeholder&gt;
&lt;p&gt;
   ${content}
&lt;/p&gt;
</gen:highlight>
<p>
   The <em>&lt;cond:placeholder /&gt;</em> tag just behaves like a &quot;normaler&quot; place holder within templates
   (see <int:link pageid="046" anchor="Chapter-2-1-Placeholder" />). Hence, you can combine it with other place holders
   setting data within your controller:
</p>
<gen:highlight type="php">
class TeaserController extends BaseDocumentController {

   public function transformContent() {
      $teaser = $this->getTeaser();
      $this->setPlaceHolders([
         'headline' => $teaser->getHeadline(),
         'sub-headline' => $teaser->getSubHeadline(),
         'content' => $teaser->getContent()
      ]);
   }

}
</gen:highlight>
<p>
   The sub line is displayed in case method <em>getSubHeadline()</em> returns a non-empty content.
</p>
<p>
   In case you want to display the sub line only in case it contains a minimum length of 5 and a maximum number of
   20 characters you can easily achieve this by adapting the template definition as follows:
</p>
<gen:highlight type="apf-xml">
&lt;h2 class="..."&gt;${headline}&lt;/h2&gt;
&lt;cond:placeholder name="sub-headline" condition="between(5,20)"&gt;
   &lt;h3 class="..."&gt;${content}&lt;/h3&gt;
&lt;/cond:placeholder&gt;
&lt;p&gt;
   ${content}
&lt;/p&gt;
</gen:highlight>
<div class="hint">
   Please refer to <a href="#Chapter-4-3-Available-conditions">chapter 4.3</a> for a complete list of available
   conditions.
</div>
<p>
   Within a <em>&lt;cond:placeholder /&gt;</em> tag the
   <a href="#Chapter-2-Available-functionality">extended templating syntax</a> can be used as known for other use cases.
   This means that you can easily display lists or objects using <em>&#36;{content}</em>.
</p>
<p>
   The next example extends above teaser example by an optional link - represented by an object - referring to
   additional content:
</p>
<gen:highlight type="apf-xml">
&lt;h2 class="..."&gt;${headline}&lt;/h2&gt;
&lt;cond:placeholder name="sub-headline"&gt;
   &lt;h3 class="..."&gt;${content}&lt;/h3&gt;
&lt;/cond:placeholder&gt;
&lt;p&gt;
   ${content}
&lt;/p&gt;
&lt;cond:placeholder name="link"&gt;
   &lt;a href="${content->getUrl()}"&gt;${content->getLabel()}&lt;/a&gt;
&lt;/cond:placeholder&gt;
</gen:highlight>
<p>
   To fill the template, the controller code needs some adaption:
</p>
<gen:highlight type="php">
class TeaserController extends BaseDocumentController {

   public function transformContent() {
      $teaser = $this->getTeaser();
      $this->setPlaceHolders([
         'headline' => $teaser->getHeadline(),
         'sub-headline' => $teaser->getSubHeadline(),
         'content' => $teaser->getContent(),
         'link' => $teaser->getMoreLink()
      ]);
   }

}
</gen:highlight>
<p>
   In case method <em>getMoreLink()</em> would return an associative array with offsets <em>more-link</em> and
   <em>more-label</em> you can also use the following template markup:
</p>
<gen:highlight type="apf-xml">
&lt;cond:placeholder name="link"&gt;
   &lt;a href="${content['more-link']}"&gt;${content['more-label']}&lt;/a&gt;
&lt;/cond:placeholder&gt;
</gen:highlight>
<p>
   Scenarions become more sophisticated in case you want to display a link to the start page if the teaser link is
   not there. The following template code shows how to either display the more link if it's present or a link to the
   start page:
</p>
<gen:highlight type="apf-xml">
   &lt;cond:placeholder name="link" condition="empty()"&gt;
   &lt;a href="/"&gt;Startseite&lt;/a&gt;
&lt;/cond:placeholder&gt;
&lt;cond:placeholder name="link"&gt;
   &lt;a href="${content->getUrl()}"&gt;${content->getLabel()}&lt;/a&gt;
&lt;/cond:placeholder&gt;
</gen:highlight>

<h4 id="Chapter-4-2-Template"><a href="#Chapter-4-2-Template">4.2. Template</a></h4>
<p>
   The signature of the <em>&lt;cond:template /&gt;</em> tag is as follows:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="" expression="" [condition=""]&gt;
   ...
&lt;/cond:template&gt;
</gen:highlight>
<strong>Attribute description:</strong>
<ul>
   <li>
      <strong>content-mapping</strong>:
      Defines which content of the <strong>parent document</strong> should be used to generate the output. Evaluation
      is conducted using the extended templating syntax (see <a href="#Chapter-2-Available-functionality">chapter 2</a>).
      The result of this evaluation is pushed to data attribute <em>content</em> for further usage.
   </li>
   <li>
      <strong>expression</strong>:
      Based on attribute <em>expression</em> the comparison value is calculated. This value will be matched against the
      condition defined in attribute <em>condition</em> to decide whether or not to display the content.  Evaluation
      is conducted using the extended templating syntax (see <a href="#Chapter-2-Available-functionality">chapter 2</a>).
   </li>
   <li>
      <strong>condition</strong> (optional):
      Defines the condition deciding on whether or not the content is displayed (<strong>Default:</strong>
      <em>notEmpty()</em>). Details on all available conditions can be taken from
      <a href="#Chapter-4-3-Available-conditions">chapter 4.3</a>.
   </li>
</ul>
<div class="warn">
   Above tag attributes can also be read as follows: <em>content-mapping</em> definines the display context and
   <em>expression</em> evaluated the value that is matched against the <em>condition</em> to control content display.
</div>
<p>
   Template fragments - such as the <int:link pageid="046" anchor="Chapter-2-3-Template">&lt;html:template /&gt;</int:link>
   tag - are designed to display self-repeating or conditional content. Using the <em>&lt;html:template /&gt;</em> tag
   the controller is responsible to evaluate conditions and control output generation. Using the
   <em>&lt;cond:template /&gt;</em> tag display logic can be delegated to the template completely and in turn keeps
   controller code slim.
</p>
<p>
   <em>&lt;cond:template /&gt;</em> is capable of constructing complex conditional output scenarios directly within
   templates. In case the teaser described in <a href="#Chapter-4-1-Place-holder">chapter 4.1</a> should only be
   displayed in case it has been approved you can manage this with the following template setup:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="teaser" expression="content-&gt;displayIt()" condition="true()"&gt;
   &lt;h2 class="..."&gt;${content-&gt;getHeadline()}&lt;/h2&gt;
   &lt;cond:template content-mapping="content" expression="content-&gt;getSubHeadline()" condition="notEmpty()"&gt;
      &lt;h3 class="..."&gt;${content-&gt;getSubHeadline()}&lt;/h3&gt;
   &lt;/cond:template&gt;
   &lt;p&gt;${content-&gt;getText()}&lt;/p&gt;
   &lt;cond:template content-mapping="content-&gt;getMoreLink()" expression="content" condition="notEmpty()"&gt;
      &lt;a href="${content-&gt;getUrl()}"&gt;${content-&gt;getLabel()}&lt;/a&gt;
   &lt;/cond:template&gt;
&lt;/cond:template&gt;
</gen:highlight>
<div class="hint">
   Naming of variables and/or data attributes can be defined at your convenience. Please note that names of data attributes
   must be equal in controller and template!
</div>
<p>
   As display control is completely delegated to the template you can easily work with
   <int:link pageid="164">view models</int:link> within your controller. This not only helps to define a clear data
   structure but also allows encapsulation of associated logic into <em>domain objects</em> or <em>view models</em>
   respectively. In turn, testability increases and so does the quality of your software.
</p>
<p>
   Displaying the teaser the following controller code is required:
</p>
<gen:highlight type="php">
class TeaserController extends BaseDocumentController {

   public function transformContent() {
      $this->setData('teaser', $this->getTeaser());
   }

}
</gen:highlight>
<p>
   Method <em>getTeaser()</em> returns an instance of class <em>Teaser</em> containing the following functions:
</p>
<gen:highlight type="php">
class Teaser {

   public function displayIt() { ... }
   public function getHeadline() { ... }
   public function getSubHeadline() { ... }
   public function getText() { ... }
   public function getMoreLink() { ... }

}
</gen:highlight>
<p>
   <em>getMoreLink()</em> returns an instance of class <em>MoreLink</em> containing the following methods:
</p>
<gen:highlight type="php">
class MoreLink {

   public function getUrl() { ... }
   public function getLabel() { ... }

}
</gen:highlight>
<div class="hint">
   All methods can be used for displaying content or defining conditions or mappings according to the extended templating
   syntax described in <a href="#Chapter-2-Available-functionality">chapter 2</a>.
</div>
<p>
   Outer tag definition
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="teaser" expression="content-&gt;displayIt()" condition="true()"&gt;
   ...
&lt;/cond:template&gt;
</gen:highlight>
<p>
   defines the teaser container:
</p>
<ul>
   <li>
      Attribute <em>content-mapping</em> defines which content should be assigned to variable <em>content</em> within
      the template for further processing and content display (display <em>context</em>). Tn this case data attribute
      <em>teaser</em> from the <strong>parent document</strong> should be used containing an instance of class
      <em>Teaser</em> injected by the controller.
   </li>
   <li>
      Attribute <em>expression</em> evaluates the value that should be compared with the condition defined in attribute
      <em>condition</em>. Based on the <em>content-mapping</em> data attribute <em>content</em> can be used within this
      expression.
      <br />
      Above example used method <em>displayIt()</em> of class <em>Teaser</em> returning a boolean value.
   </li>
   <li>
      Attribute <em>condition</em> specifies the condition which deciding whether or not to display the content of the
      template. In case condition <em>true()</em> matches - or in other words: <em>displayIt()</em> returns value
      <em>true</em> -, the template is going to be displayed.
   </li>
</ul>
<p>
   Within the outer template definition, two additional <em>&lt;cond:template /&gt;</em> tags are defined to deal with
   the optional sub line and the continuative link.
</p>
<p>
   The sub line is wrapped with the following tag definition:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="content" expression="content-&gt;getSubHeadline()" condition="notEmpty()"&gt;
   &lt;h3 class="..."&gt;${content-&gt;getSubHeadline()}&lt;/h3&gt;
&lt;/cond:template&gt;
</gen:highlight>
<p>
   In case method <em>getSubHeadline()</em> returns a non-empty content the headline is displayed including the
   surrounding HTML markup. The tag definition can be interpreted as follows:
</p>
<ul>
   <li>
      The sub line (display <em>context</em>) is taken from data attribute <em>content</em> of the <strong>parent
      element</strong>. This is defined with attribute <em>content-mapping</em>. The effective content is an instance of
      class <em>Teaser</em>.
   </li>
   <li>
      <em>expression</em> defines that the result returned by <em>getSubHeadline()</em> will be used for output control.
   </li>
   <li>
      Based on condition <em>notEmpty()</em> the template checks whether or not the sub line is present. If the string
      is not empty the sub line is displayed including the surrounding HTML markup.
   </li>
</ul>
<p>
   Template definition of the continuative link is pretty much the same. Here, the <em>content-mapping</em> has been used
   to map the instance of class <em>MoreLink</em> to data attribute <em>content</em> returned by <em>geMoreLink()</em>.
   This not only eases condition definition but also output generation within the template.
</p>
<p>
   Displaying the link based on existence of the <em>MoreLink</em> instance within the <em>Teaser</em> class as follows:
</p>
<gen:highlight type="apf-xml">
&lt;cond:template content-mapping="content-&gt;getMoreLink()" expression="content" condition="notEmpty()"&gt;
   &lt;a href="${content-&gt;getUrl()}"&gt;${content-&gt;getLabel()}&lt;/a&gt;
&lt;/cond:template&gt;
</gen:highlight>
<p>
   The tag definition can be interpreted as follows:
</p>
<ul>
   <li>
      Content (display <em>context</em>) is assigned the return value of <em>getMoreLink()</em> of the <em>Teaser</em>
      instance of data attribute <em>content</em> within the <strong>parent element</strong>. The named method either
      returns an instance of class <em>MoreLink</em> oder <em>null</em>.
   </li>
   <li>
      Decision on whether or not to display the link should also be based on the return value of <em>getMoreLink()</em>.
      This is defined in attirbute <em>expression</em> directly referring to the <em>content</em> data attribute.
   </li>
   <li>
      The condition defined within attribute <em>condition</em> checks whether the continuative link is present (data
      attribute <em>content</em> contains an instance <em>MoreLink</em>) and displays the template.
   </li>
</ul>
<div class="hint">
   The nesting level of <em>&lt;cond:template /&gt;</em> tags is not limited. This allows definition of any level of
   complexity regarding conditional output.
</div>
<div class="hint">
   Using the extended expression syntax described in <a href="#Chapter-2-Available-functionality">chapter 2</a> you can
   also access data defined outside of the template. In case the controller sets an additional data attribute
   <em>headline-color</em> you can use it as follows:
<gen:highlight type="apf-xml">
&lt;cond:template ...&gt;
   &lt;h2
      class="${this->getParentObject()->getParentObject()->getData('headline-color')}"&gt;
      ...
   &lt;/h2&gt;
   ...
&lt;/cond:template&gt;
</gen:highlight>
</div>

<h4 id="Chapter-4-3-Available-conditions"><a href="#Chapter-4-3-Available-conditions">4.3. Available conditions</a></h4>
<p>
   Please refer to the following list for all existing conditions:
</p>
<ul>
   <li>
      <strong>true()</strong>:
      Check returns true in case the value to evaluate is <em>true</em>.
   </li>
   <li>
      <strong>false()</strong>:
      Check returns true in case the value to evaluate is <em>false</em>.
   </li>
   <li>
      <strong>empty()</strong>:
      Check returns true in case the value to evaluate is empty. This check both applies to strings and objects.
   </li>
   <li>
      <strong>notEmpty()</strong>:
      Check returns true in case the value to evaluate is not empty. This check both applies to strings and objects.
   </li>
   <li>
      <strong>matches(&lt;string&gt;)</strong>:
      Check returns true in case the value to evaluate matches the given string. This check both applies to strings and
      numbers.
   </li>
   <li>
      <strong>contains(&lt;string&gt;)</strong>:
      Check returns true in case the value to evaluate contains the given value.
   </li>
   <li>
      <strong>longerThan(&lt;number&gt;)</strong>:
      Check returns true in case the value to evaluate has more characters as defined within the given value.
   </li>
   <li>
      <strong>shorterThan(&lt;number&gt;)</strong>:
      Check returns true in case the value to evaluate has less characters as defined within the given value.
   </li>
   <li>
      <strong>length(&lt;number&gt;)</strong>:
      Check returns true in case the value to evaluate has exactly the number of characters defined in the given value.
   </li>
   <li>
      <strong>between(&lt;number&gt;,&lt;number&gt;)</strong>:
      Check returns true in case the value to evaluate has a number of characters between the given minimum and maximum
      number (minimum and maximum values included).
   </li>
</ul>
<div class="warn">
   Multiple arguments are separated by comma, strings including blanks must be delimited by simple quotes!
</div>

<h3 id="Chapter-5-Recurring-data-display"><a href="#Chapter-5-Recurring-data-display">5. Recurring data display</a></h3>
<p>
   Another typical use case in web applications is displaying recurring data. The APF offers a simple template-based
   solution for displaying arbitrary lists.
</p>
<div class="hint">
   Please note that the <em>&lt;loop:template /&gt;</em> tag is designed for simple use cases. For more complex use cases
   such as nested lists the APF team recommends usage of the <int:link pageid="078" anchor="Chapter-1-Iterator">iterator tag</int:link>.
</div>
<p>
   The <em>&lt;loop:template /&gt;</em> tag allows definition of the HTML markup that represents a single list entry.
   HTML markup for an unordered list can thus be generated by surrounding HTML (list start and end) and the content
   of a loop template.
</p>
<p>
   The signature of the tag is as follows:
</p>
<gen:highlight type="apf-xml">
&lt;loop:template content-mapping="" [name=""]&gt;
   ...
&lt;/loop:template&gt;
</gen:highlight>
<strong>Description of the attributes:</strong>
<ul>
   <li>
      <strong>content-mapping</strong>:
      Defines which content of the template should be used to generate the output. Evaluation is conducted using the
      extended templating syntax (see <a href="#Chapter-2-Available-functionality">chapter 2</a>). The result of this
      evaluation is pushed to data attribute <em>content</em> for further usage
   </li>
   <li>
      <strong>name</strong>:
      Name of the templates. The name is used to access this object within a document controller.
      (<strong>Allowed characters:</strong> [A-Za-z0-9-_]).
   </li>
</ul>
<p>
   In case you intent to generate an unsorted list the following template definition is required:
</p>
<gen:highlight type="apf-xml">
<ul>
<loop:template name="list" content-mapping="items">
   <li><a href="${content['url']}">${content['title']}</a></li>
</loop:template>
</ul>
</gen:highlight>
<p>
   Displaying the list, the following controller code can be used:
</p>
<gen:highlight type="php">
$template = $this->getTemplate('list');
$template->setData(
      'items',
      [
            ['url' => '/shop', 'title' => 'Web shop'],
            ['url' => '/about', 'title' => 'About us'],
            ['url' => '/contact', 'title' => 'Contact form']
      ]
);
$template->transformOnPlace();
</gen:highlight>
<p>
   Besides displaying recurring data also static place holders can be defined. In case each list element should be
   given a dynamic CSS class you can adapt above template as follows:
</p>
<gen:highlight type="apf-xml">
<ul>
<loop:template name="list" content-mapping="items">
   <li class="${css-class}"><a href="${content['url']}">${content['title']}</a></li>
</loop:template>
</ul>
</gen:highlight>
<p>
   Within your controller simply inject the CSS class as place holder into the template:
</p>
<gen:highlight type="php">
$template = $this->getTemplate('list');
$template->setData(
      'items',
      [
            ['url' => '/shop', 'title' => 'Web shop'],
            ['url' => '/about', 'title' => 'About us'],
            ['url' => '/contact', 'title' => 'Contact form']
      ]
);
$template->setPlaceHolder('css-class', 'foo');

$template->transformOnPlace();
</gen:highlight>
<p>
   Apart from the functionality described above the loop template includes all functionality of the
   <int:link pageid="046" anchor="Chapter-2-3-Template"><em>&lt;html:template /&gt;</em></int:link> tag. Displaying
   content you may also want to use object access notation. Details can be taken from
   <a href="#Chapter-3-Extending-the-syntax">chapter 3</a>.
</p>
<div class="hint">
   In case you inject the content into the parent document of the loop template to display within your controller as
   described in the subsequent code box
<gen:highlight type="php">
$this->setData(
      'items',
      [
            ['url' => '/shop', 'title' => 'Web shop'],
            ['url' => '/about', 'title' => 'About us'],
            ['url' => '/contact', 'title' => 'Contact form']
      ]
);
</gen:highlight>
   you may want to use the extended templating syntax to display the desired list:
<gen:highlight type="apf-xml">
<ul>
   <loop:template
         name="list"
         content-mapping="this->getParentObject()->getData('items')">
      <li><a href="${content['url']}">${content['title']}</a></li>
   </loop:template>
</ul>
</gen:highlight>
</div>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="en_161" />