<doku:title parent="100" tags="taglib,taglibs,tag,parser" title="Implementierung von Tags" urlname="Implementierung-von-Tags">
   Dieses Kapitel beschreibt die Bedeutung und die Implementierung von eigenen Tags/Taglibs mit dem APF.
</doku:title>

<h3 id="Chapter-1-Einfuehrung"><a href="#Chapter-1-Einfuehrung">1. Einführung</a></h3>
<p>
   Dieses Kapitel widmet sich den APF-Tags (a.k.a. Taglibs), deren Bedeutung und Implementierung.
</p>
<p>
   Der <int:link pageid="098"/> basiert auf dem gleichnamigen Software-Entwurfsmuster und ist ein zentraler Bestandteil
   des APF. Er ermöglicht dem Entwickler über das Tag-Konzept, eigene Funktionalitäten zur Erzeugung und Transformation
   des HMVC-DOM-Baumes zu injizieren. Tags bilden damit nicht nur die Basis des APF-HMVC-Konzepts, sondern können auch
   zur Erweiterung desselben genutzt werden.
</p>
<p>
   Des Weiteren können Tags dazu verwendet werden um darin enthaltene Funktionalitäten in unterschiedlichen Projekten
   wiederzuverwenden. APF-Templates verarbeiten - als Schutz vor unkontrollierter Verteilung von Logik - lediglich Tags
   und keinen PHP-Code. Damit ist automatisch sichergestellt, dass View-Logik lediglich in Tags oder Controller enthalten
   sein kann.
</p>

<h4 id="Chapter-1-1-Page-Controller"><a href="#Chapter-1-1-Page-Controller">1.1. Page-Controller</a></h4>
<p>
   Aufgabe des <int:link pageid="098"/> ist der Aufbau und die Transformation der internen Template-Struktur.
   Hierzu bietet er ein Tag-API, die einem definierten Timing-Modell folgend Tags einliest, daraus Dokumente im Baum
   erzeugt und aus dem Baum anschließend eine HTML-Ausgabe erzeugt. Andere Formate wie beispielsweise XML sind ebenfalls
   möglich. Der Parser ist kein &quot;echter&quot; XML-Parser, beherrscht jedoch die Auflösung von explizit- und
   selbst-schließenden Tags sowie die Schachtelung von Tags in beliebig tiefen Hierarchien.
</p>
<div class="warn">
   Bitte beachten Sie die Hinweise im Kapitel <a href="#Chapter-6-Tag-Hierarchie">Tag-Hierarchie</a> zu den Restriktionen
   des Parsers.
</div>
<p>
   Die mit dem APF ausgelieferten <int:link pageid="046"/> bieten bereits eine Reihe an Standard-Funktionalitäten wie
   das Einbinden einer weiteren Template-Datei, die Definition von wiederverwendbaren Template-Fragmenten und das
   Bekanntgeben von eigenen Tags an.
</p>

<h4 id="Chapter-1-2-XML-Parser"><a href="#Chapter-1-2-XML-Parser">1.2. XML-Parser</a></h4>
<p>
   Der <em>XMLParser</em> dient dem Page-Controller zur Analyse einer Tag-Definition im Template und wird bei der
   Erstellung von <em>Document</em>-Instanzen genutzt.
</p>
<div class="warn">
   Der <em>XMLParser</em> verarbeitet aus Performance-Gründen nur durch Leerzeichen getrennte Attribute. Die Werte von
   Attributen müssen mit doppelten Anführungszeichen umschlossen sein.
</div>

<h3 id="Chapter-2-Definition-eines-Tags"><a href="#Chapter-2-Definition-eines-Tags">2. Definition eines Tags</a></h3>
<p>
   Ein APF-Tag definiert sich durch folgende Bestandteile:
</p>
<ul>
   <li>
      <strong>Prefix</strong>: das <em>Prefix</em> des Tags dient im Allgemeinen zur Strukturierung der Tags in Gruppen
      (z.B. <em>core</em> für Tags, die mit dem APF mitgeliefert werden). Dieser Teil ist mit XML-Namespaces vergleichbar.
   </li>
   <li>
      <strong>Name</strong>: der <em>Name</em> des Tags bezeichnet den Tag selbst. Dieser Teil ist mit XML-Tag-Namen
      vergleichbar.
   </li>
   <li>
      <strong>Attribute</strong>: die Attribute des Tags können zur Konfiguration des Tags genutzt werden. Sie dürfen
      keine weiteren Tags enthalten.
   </li>
   <li>
      <strong>Inhalt</strong>: der Inhaltsbereich des Tags kann weitere Tags oder Text enthalten. Der APF-Parser löst
      dort enthaltene Tags entsprechend auf und hängt diese als Kinder in die aktuelle Hierarchie ein. Einfacher Text
      ist später ebenfalls in der Tag-Instanz verfügbar.
   </li>
</ul>
<p>
   Folgende Tag-Definition könnte zur Ausgabe des aktuellen Datums in einem Template genutzt werden:
</p>
<gen:highlight type="apf-xml">
<current:date format="H:i" />
</gen:highlight>
<p>
   Dabei ist <em>current</em> das Prefix des Tags, <em>date</em> der Name und das Attribut <em>format</em> beinhaltet
   das Ausgabe-Format. Der Tag definiert keinen Inhalt.
</p>
<p>
   Zur Darstellung einer Bildergalerie könnte folgendes Tag genutzt werden:
</p>
<gen:highlight type="apf-xml">
<img:gallery>
   <h3>Mein Urlaub 2012</h3>
   <p>
      Diese Bilder stammen aus meinem Urlaub im Jahr 2012:
   </p>
   <gallery:datasource
      namspace="..."
      class="..."
   />
</img:gallery>
</gen:highlight>
<p>
   In diesem Beispiel beinhaltet der <em>&lt;img:gallery /&gt;</em>-Tag statisches HTML, was später zur Formatierung der
   Ausgabe genutzt werden kann und einen weiteren Tag zur Angabe der Datenquelle (z.B. aus einer Datenbank). Zur
   Verwendung des Tags muss auch dieses zunächst dem APF-Parser bekannt gegeben werden.
</p>

<h3 id="Chapter-3-DOM-Struktur"><a href="#Chapter-3-DOM-Struktur">3. DOM-Struktur</a></h3>
<p>
   Wie im Kapitel <a href="#Chapter-1-1-Page-Controller">Kapitel 2</a> angesprochen erzeugt der <int:link pageid="098"/>
   aus der Tag-Struktur in den Template-Dateien einen DOM-Baum. Dieser ähnelt dem eines Browsers, der aus den HTML-Tags
   ebenfalls eine Speicherstruktur erzeugt.
</p>
<p>
   Der Unterschied zur DOM-Struktur eines Browsers besteht darin, dass die einzelnen Knoten jeweils eigene Funktionalität
   zur Transformation bzw. Darstellung beinhalten, die der Page-Controller während der Transformationsphase nutzt. Details
   zum Timing-Modell des Page-Controller finden Sie <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">hier</int:link>.
</p>
<p>
   Jeder Tag - bzw. ab einem definierten Zeitpunkt seine Instanz - durchläuft einen definierten Zyklus. Zunächst wird
   die Struktur des Tags analysiert, dann seine Substanz (Attribute und Inhalt). Anschließend wird gemäß der
   Tag-Definition  eine Instanz des Tags erstellt und mit dem vom <em>XMLParser</em> analysierten Inhalt initialisiert.
</p>
<div class="hint">
   Der Page-Controller verarbeitet Tags nur dann, wenn sie im aktuellen Knoten bekannt sind. Aus diesem Grund müssen
   eigene Tags zunächst bekannt gegeben werden. Dies kann mit Hilfe des <em>&lt;core:addtaglib /&gt;</em>-Tag oder einem
<gen:highlight type="php">
$this->tagLibs[] = new TagLib(...);
</gen:highlight>
   in einem eigenen Tag erreicht werden. Die Nutzung des <em>&lt;core:addtaglib /&gt;</em>-Tags ist immer dann notwendig,
   wenn Sie innerhalb eines Templates einen eigenen Tag bekannt geben wollen, das PHP-Code-Beispiel nutzen Sie, wenn Sie
   innerhalb eines eigenen Tags dem APF-Parser eine weitere Hierarchie-Stufe bekannt geben wollen.
</div>
<p>
   Zur Bekanntgabe eines Tags werden <em>Präfix</em> und <em>Name</em> sowie <em>Namespace</em> und
   <em>Klassen-Name</em> der Tag-Implementierung beschrieben. Dabei kann eine Implementierung über unterschiedliche
   <em>Präfix</em>- und <em>Namens</em>-Angaben mehrfach in unterschiedlichen Hierarchien oder Projekten genutzt werden.
   Die Klasse <em>TagLib</em> besitzt folgende Signatur (gekürzt):
</p>
<gen:highlight type="php">
final class TagLib {

   private $class;
   private $prefix;
   private $name;

   public function __construct($class, $prefix, $name) {
   }

}
</gen:highlight>
<p>
   Details zu unterschiedlichen Ebenen von Tags können Sie im Kapitel <a href="#Chapter-6-Tag-Hierarchie">Tag-Hierarchie</a>
   nachlesen.
</p>

<h3 id="Chapter-4-Klassenstruktur-eines-Tags"><a href="#Chapter-4-Klassenstruktur-eines-Tags">4. Klassenstruktur eines Tags</a></h3>
<p>
   Die Struktur eines Tags beschreibt die Klasse <em>Document</em>. Diese ist die Mutter aller Tag-Implementierungen des
   APF und definiert eine Reihe von Methoden, die innerhalb des Timing-Modells des Page-Controllers zu unterschiedlichen
   Zwecken aufgerufen werden.
</p>
<p>
   Die Signatur de Klasse <em>Document</em> ist wie folgt (gekürzt):
</p>
<gen:highlight type="php">
class Document extends APFObject {

   protected $objectId = null;
   protected $parentObject = null;
   protected $children = array();
   protected $content;
   protected $tagLibs = array();

   public function __construct() {
   }

   public function onParseTime() {
   }

   public function onAfterAppend() {
   }

   public function transform() {
   }

}
</gen:highlight>
<p>
   Den aufgeführten Elementen kommt dabei folgende Bedeutung zu:
</p>
<ul>
   <li>
      Im Feld <em>objectId</em> wird die eindeutige interne Objekt-Id gespeichert, die jeder Tag vom APF-Parser bei
      Erzeugen erhält. Diese wird u.a. bei der Vergabe von <int:link pageid="004"/>-Tags genutzt um jedes DOM-Element
      eindeutig zu referenzieren.
   </li>
   <li>
      <em>parentObject</em> referenziert auf das Vater-Objekt innerhalb des DOM-Baumes. Diese Referenz kann zur
      Traversierung des DOM-Baumes genutzt werden. Der Root-Knoten hat keinen Vater.
   </li>
   <li>
      In der Liste <em>children</em> finden sich alle Kind-Knoten des aktuellen DOM-Elements. Diese Liste kann zur
      Traversierung des DOM-Baumes genutzt werden. Hat ein DOM-Knoten keine Kinder, ist die Liste leer.
   </li>
   <li>
      Die Variable <em>content</em> beinhaltet den textuellen Inhalt eines Tags und die Platzhalter, die der
      Page-Controller bei der Erzeugung des DOM-Baumes hinterlässt um den exakten Zusammenbau des HTML-Quelltextes
      sicher zu stellen.
   </li>
   <li>
      In der Variable <em>attributes</em> - aus der Klasse <em>APFObject</em> vererbt - findet sich eine assoziative
      Liste der Tag-Attribute wieder. Besitzt das Tag keine Attribute, ist die Liste leer.
   </li>
   <li>
      Die <em>tagLibs</em>-Liste beinhaltet die für den aktuellen Knoten bekannte Tags. Wie im vorangegangenen Kapitel
      angesprochen, verarbeitet der APF-Parser nur bekannte Tags innerhalb einer Hierarchie-Stufe bzw. innerhalb eines
      DOM-Elements. Welche Tags bekannt oder eben nicht bekannt sind, bestimmt demnach der Inhalt dieser Liste.
      <div class="hint">
         Die <em>tagLibs</em>-Liste kann in eigenen Tag-Implementierungen dazu genutzt werden, neue Tags bekannt zu geben
         oder bereits bekannte Tags zu entfernen. Da die Manipulation der Liste in die eine oder die andere Richtung direkte
         Auswirkung auf die Verarbeitung von Tags hat, behalten Sie bitte die Bedeutung stets im Hinterkopf!
      </div>
   </li>
   <li>
      Der Konstruktor einer Tag-Klasse wird bei der Erzeugung der Tag-Instanz aufgerufen. Der Parser übergibt jedoch
      keine Argumente. Die Methode kann dazu genutzt werden, weitere Tags für die vorliegende Hierarchie bekannt zu
      geben oder Standard-Werte zu belegen.
      <div class="warn">
         Zum Zeitpunkt der Ausführung des Konstruktors sind weder die Attribute des Tags noch der Inhalt verfügbar.
         Ebenso sind der Kontext und die Sprache des Tags noch nicht initialisiert.
      </div>
   </li>
   <li>
      Nachdem der Tag geparst wurde wird die Methode <em>onParseTime()</em> aufgerufen. Zu diesem Zeitpunkt sind die
      Attribute des Tags und der Inhalt in der Instanz verfügbar. Auch Kontext und Sprache des Tags sind initialisiert.
      Diese Methode kann dazu genutzt werden, den Tag mit Hilfe der verfügbaren Informationen weiter zu initialsieren
      oder den Tag-Inhalt weitere zu analysieren (z.B. enthaltene Kind-Tags parsen).
   </li>
   <li>
      Ist der Knoten in den DOM-Baum eingehangen - sprich sind Vater und Kinder bekannt - wird die Methode
      <em>onAfterAppend()</em> aufgerufen. Innerhalb dieser Methode können Sie nun Logik platzieren, die auf Vater und
      Kinder Auswirkung hat.
   </li>
   <li>
      Wird der aktuelle DOM-Knoten transformiert, ruft der Page-Controller die Methode <em>transform()</em> Ihres
      Tags auf. Platzieren Sie hier bitte diejenige Logik, die zur Erzeugung von HTML-Quelltext benötigt wird. Tags, die
      innerhalb des DOM-Baumes lediglich zur Konfiguration oder Initialisierung dienen generieren oft keine Ausgabe (z.B.
      <em>&lt;core:addtaglib /&gt;</em>). Wie sich Ihr Tag letztlich verhält bleibt Ihrer Implementierung überlassen.
      <div class="hint">
         Sofern die Methode <em>transform()</em> in eigenen TagLibs überschrieben wird, muss
         sich der Entwickler selbst um die Transformation der Kind-Knoten kümmern. Dies kann im
         einfachsten Fall durch
<gen:highlight type="php">
foreach($this->children as $objectId => $DUMMY){
   $this->content = str_replace(
      '<'.$objectId.' />',
      $this->children[$objectId]->transform(),
      $this->content
   );
}
</gen:highlight>
         erreicht werden, wenn in den Methoden <em>onParseTime()</em> oder <em>onAfterAppend()</em> die
         Parser-Funktion <em>extractTagLibTags()</em> aufgerufen wurde. Weitere Hinweise können dem
         Foren-Beitrag
         <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a>
         entnommen werden.
      </div>
   </li>
</ul>
<p>
   Für die Transformation von Kind-Knoten können folgende Methoden genutzt werden:
</p>
<ul>
   <li>
      <strong>transformChildren()</strong>
      Transformiert die Kind-Knoten im internen Inhalts-Puffer (<em>$this->content</em>).
   </li>
   <li>
      <strong>transformChildrenAndPreserveContent()</strong>
      Transformiert die Kind-Knoten und gibt das Ergebnis zurück. Der interne Inhalts-Puffer
      (<em>$this->content</em>) wird dabei für eine erneute Transformation beibehalten.
   </li>
   <li>
      <strong>transformChildrenAsEmpty()</strong>
      Entfernt die internen Positionsmarker des APF-Parsers (siehe Hinweis in Kapitel
      <a href="#Chapter-5-2-4-Erzeugen-der-Ausgabe">5.2.4. Erzeugen der Ausgabe</a>)
      im internen Inhalts-Puffer (<em>$this->content</em>).
   </li>
   <li>
      <strong>transformChildrenAsEmptyAndPreserveContent()</strong>
      Entfernt die internen Positionsmarker des APF-Parsers (siehe Hinweis in Kapitel
      <a href="#Chapter-5-2-4-Erzeugen-der-Ausgabe">5.2.4. Erzeugen der Ausgabe</a>) und gibt das Ergebnis zurück.
      Der interne Inhalts-Puffer (<em>$this->content</em>) wird dabei für eine erneute Transformation beibehalten.
   </li>
</ul>

<h3 id="Chapter-5-Implementierung"><a href="#Chapter-5-Implementierung">5. Implementierung</a></h3>

<h4 id="Chapter-5-1-Einfacher-Tag"><a href="#Chapter-5-1-Einfacher-Tag">5.1. Einfacher Tag</a></h4>
<p>
   Dieses Kapitel beschäftigt sich mit einfachen Tags. &quot;Einfach&quot; meint in diesem Zusammenhang einen Tag, der
   eine bestimmte Aufgabe erledigt, jedoch keine weitere Hierarchie erzeugt - sprich keine Kind-Tags besitzt.
</p>
<p>
   Als Beispiel soll die Ausgabe der aktuellen Uhrzeit aus <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a>
   dienen. Hierzu muss der Tag lediglich zur Transformations-Zeit die Uhrzeit im gewünschten Format zurückgeben.
   Abhängigkeiten zu anderen Tags im Baum und die Notwendigkeit der Initialisierung bestehen nicht. Der Quellcode des
   Tags gestaltet sich damit wie folgt (Namespace: <em>VENDOR\tags</em>):
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class HourDisplayTag extends Document {

   public function transform() {
     return date($this->getAttribute('format'));
   }

}
</gen:highlight>
<p>
   Innerhalb eines Templates lässt er sich wie anschließend gezeigt verwenden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\tags\HourDisplayTag"
   prefix="current"
   name="date"
/&gt;
<current:date format="H:i:s" />
</gen:highlight>
<div class="hint">
   Der Konstruktor der Klasse <em>Document</em> gibt mögliche Kind-Tags bekannt, die in der aktuellen Implementierung
   nicht benötigt werden. Insofern könnte als mögliche Speicherverbrauchsoptimierung ebenso der Konstruktor überschrieben
   werden damit sichergestellt ist, dass der Tag keine weiteren Kinder verarbeiten kann.
</div>

<h4 id="Chapter-5-2-Komplexer-Tag"><a href="#Chapter-5-2-Komplexer-Tag">5.2. Komplexer Tag</a></h4>
<p>
   Als &quot;komplexer&quot; Tag versteht das APF einen Tag mit weiteren - in der Hierarchie nicht eingeschränkten -
   Kind-Knoten.
</p>
<p>
   Als Beispiel soll die Ausgabe einer Bildergalerie aus <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a> dienen.
   Dieser Tag definiert zunächst statischen Inhalt, der zur Ausgabe einer Überschrift und eines Einleitungstextes
   genutzt wird. Die Generierung der Ausgabe selbst wird vom <em>&lt;img:gallery /&gt;</em>-Tag mit Hilfe eines
   <em>Content-Providers</em>, der durch den <em>&lt;gallery:datasource /&gt;</em>-Tag definiert wird.
</p>
<div class="hint">
   Bitte beachten Sie, dass die Struktur des Beispiels willkürlich gewählt und nicht für Ihre Implementierungen bindend
   ist. Es wäre sowohl denk- als auch realisierbar den Content-Provider über Tag-Attribute zu definieren und die
   Formatierung der Galerie über weitere Elemente (siehe z.B. <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator</int:link>)
   zu realisieren.
</div>

<h5 id="Chapter-5-2-1-Basis"><a href="#Chapter-5-2-1-Basis">5.2.1. Basis</a></h5>
<p>
   Die Basis-Struktur des Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\tags\GalleryDataSourceTag;

class GalleryTag extends Document {

   public function __construct() {
      $this->tagLibs[] = new TagLib(
         'VENDOR\tags\GalleryDataSourceTag',
         'gallery',
         'datasource'
      );
   }

   ...

}
</gen:highlight>
<p>
   Im Konstruktor des Tags wird dem Parser der <em>&lt;gallery:datasource /&gt;</em>-Tag bekannt gegeben.
</p>

<h5 id="Chapter-5-2-2-Konfiguration-des-Content-Provider"><a href="#Chapter-5-2-2-Konfiguration-des-Content-Provider">5.2.2. Konfiguration des Content-Provider</a></h5>
<p>
   Widmen wir uns nun zunächst der Konfiguration des <em>Content-Providers</em>. Hierzu spendieren wir dem
   <em>&lt;img:gallery /&gt;</em>-Tag ein privates Feld und einen Setter, damit der <em>&lt;gallery:datasource /&gt;</em>-Tag
   die Instanz übergeben kann:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\..\ImageGalleryContentProvider;

class GalleryTag extends Document {

   private $contentProvider;

   ...

   public function setContentProvider(ImageGalleryContentProvider $provider) {
      $this->contentProvider = $provider;
   }

   ...

}
</gen:highlight>
<p>
   Der Provider selbst definiert sich durch folgendes Interface:
</p>
<gen:highlight type="php">
interface ImageGalleryContentProvider {
   /**
    * @return GalleryImage[]
    */
   public function getImages();
}

class GalleryImage {

   private $title;
   private $description;
   private $imageUrl;

   public function __construct($title, $description, $imageUrl) {
      $this->title = $title;
      $this->description = $description;
      $this->imageUrl = $imageUrl;
   }

   public function getDescription() {
      return $this->description;
   }

   public function getImageUrl() {
      return $this->imageUrl;
   }

   public function getTitle() {
     return $this->title;
   }

}
</gen:highlight>
<p>
   Gemäß unseres Beispieles ist der <em>&lt;gallery:datasource /&gt;</em>-Tag dafür zuständig den gewünschten Provider
   zu erzeugen und dem <em>GalleryTag</em> mitzugeben. Dies lässt sich innerhalb der <em>onAfterAppend()</em>-Methode
   erledigen, da zu diesem Zeitpunkt der Vater-Knoten bekannt ist:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\tags\GalleryTag;

class GalleryDataSourceTag extends Document {

   public function __construct() {
   }

   public function onAfterAppend() {
      $provider = &$this->getServiceObject(
         $this->getAttribute('class')
      );
      /* @var $parent GalleryTag */
      $parent = &$this->getParentObject();
      $parent->setContentProvider($provider);
   }

   public function transform() {
      return '';
   }

}
</gen:highlight>
<p>
   Da der <em>GalleryDataSourceTag</em> keine weiteren Kinder erwartet, wurde der Konstruktor von <em>Document</em> leer
   überschrieben. In der Methode <em>onAfterAppend()</em> erzeugt das Tag den gewünschten Provider mit Hilfe des
   <int:link pageid="107" anchor="Chapter-3-2-1-ServiceManager-Einfache-Services">ServiceManager</int:link> um der Instanz
   Kontext und Sprache des aktuellen Elements mitzugeben. Anschließend wird dem Vater-Element des DOM-Baumes - hier
   eine Instanz der Klasse <em>GalleryTag</em> wie mit dem Type-Hint angegeben wird - der Provider injiziert.
</p>
<p>
   Die leer überschriebene <em>transform()</em>-Methode sorgt dafür, dass keine weiteren Kind-Elemente transformiert oder
   eine Ausgabe erzeugt wird. Dies ist im aktuellen Beispiel nicht notwendig.
</p>

<h5 id="Chapter-5-2-3-Parsen-des-GalleryDataSourceTag"><a href="#Chapter-5-2-3-Parsen-des-GalleryDataSourceTag">5.2.3. Parsen des GalleryDataSourceTag</a></h5>
<p>
   Damit der <em>GalleryDataSourceTag</em> seine Arbeit verrichten kann muss der <em>GalleryTag</em> dafür sorgen, dass
   er auch vom Page-Controller erfasst und ausgeführt wird. Dazu bringt der Page-Controller bereits eine Parser-Methode
   mit, die in jeder von <em>Document</em> erbenden Klasse ausgeführt werden kann - <em>extractTagLibTags()</em>.
</p>
<p>
   Zu welchem Zeitpunkt diese aufgerufen werden soll entscheiden zunächst Sie selbst. Beachten Sie dabei jedoch immer das
   <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Ablaufdiagramm des Page-Controller</int:link> um den für
   den Anwendungsfall richtigen Zeitpunkt zu wählen. In unserem Fall ist lediglich wichtig, dass der Provider <em>vor</em>
   der Erzeugung der Inhalte ausgeführt wird. Damit sind theoretisch drei Möglichkeiten denkbar:
</p>
<ul>
   <li>In einer eigenen <em>onParseTime()</em>-Methode.</li>
   <li>In einer eigenen <em>onAfterAppend()</em>-Methode.</li>
   <li>Zu Beginn der <em>transform()</em>-Methode.</li>
</ul>
<p>
   Üblicherweise schickt es sich für die Analyse von weiteren Kind-Strukturen die <em>onParseTime()</em>-Methode zu
   nutzen, da Sie damit sicherstellen, dass die weiteren Elemente im Baum ebenfalls die Möglichkeit haben, Kind-Knoten
   zeitlich korrekt zu erzeugen.
</p>
<p>
   Um den <em>GalleryDataSourceTag</em> zu erzeugen und auszuführen, reicht folgender Quellcode:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   ...

}
</gen:highlight>
<p>
   Alles Weitere erledigt der APF-Parser für Sie gemäß den bekannten Tags.
</p>

<h5 id="Chapter-5-2-4-Erzeugen-der-Ausgabe"><a href="#Chapter-5-2-4-Erzeugen-der-Ausgabe">5.2.4. Erzeugen der Ausgabe</a></h5>
<p>
   Die Ausgabe der Bildergalerie erfolgt in der Methode <em>transform()</em>, die vom Page-Controller bei der Transformation
   des Baumes aufgerufen wird. Diese muss nun dafür sorgen, dass die Bilder, die vom Provider geliefert werden
   entsprechend ausgegeben werden.
</p>
<p>
   Unter der Annahme, dass alle Bilder als ungeordnete Liste mit entsprechendem Platz für Beschreibungen ausgegeben werden,
   gestaltet sich die Methode <em>transform()</em> wie folgt:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
            . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
            . '<p>' . $image->getDescription() . '</p>'
            . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);
   }

}
</gen:highlight>
<p>
   Mit der aktuellen Implementierung werden alle Bilder als Listen-Elemente nach dem im <em>&lt;img:gallery /&gt;</em>-Tag
   vorhandenen statischen Inhalt angezeigt.
</p>
<div class="hint">
   Soll in einem Tag kein statischer Inhalt zugelassen werden, so kann dieser in der <em>transform()</em>-Methode durch
   <em>setContent()</em> durch einen dynamisch erzeugten überschrieben werden.
</div>
<div class="hint">
   Damit bei der Transformation die Inhalte eines Tags an der korrekten Stelle ausgegeben werden,
   erzeugt die Methode <em>extractTagLibTags()</em> Platzhalter der Form
   <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Dabei entspricht <em>{OBJECT_ID}</em>
   dem Wert der Klassen-Variable <em>$this->objectId</em> und dem Array-Offset, in dem die
   Kind-Tags gespeichert werden (<em>$this->children</em>). Dieser Wert kann dann bei der
   Implementierung von eigenen <em>transform()</em>-Methoden für die Ersetzung des Inhalts
   genutzt werden.
</div>
<p>
   Im Fall des <em>&lt;img:gallery /&gt;</em>-Tags sollen die Kind-Tags keine Ausgabe erzeugen, was prinzipiell mit der
   <em>GalleryDataSourceTag::transform()</em>-Methode sichergestellt. Da der APF-Parser jedoch zur Positionierung der
   Ausgabe Platzhalter erzeugt, müssen diese in unserem Beispiel dennoch ersetzt werden. Dies kann durch folgende
   Erweiterung passieren:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
         . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
         . '<p>' . $image->getDescription() . '</p>'
         . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);

      foreach ($this->children as $objectId => $DUMMY) {
         $this->content = str_replace(
            '<' . $objectId . ' />',
            $this->children[$objectId]->transform(),
            $this->content
         );
      }
   }

}
</gen:highlight>

<h4 id="Chapter-5-3-Document-API"><a href="#Chapter-5-3-Document-API">5.3. Document-API</a></h4>
<p>
   Zur Implementierung von Tag-Logik stehen zahlreiche Methoden zur Verfügung. Diese umfassen das Parsen von Tag-Strukturen,
   das Traversieren des Baumes und das Manipulieren oder Auslesen von Tag-Informationen. Diese sind:
</p>
<ul>
   <li>
      <strong>extractTagLibTags()</strong>:
      Analysiert die bekannten Kind-Tags und erstellen den DOM-Baum daraus.
   </li>
   <li>
      <strong>extractExpressionTags()</strong>:
      Analysiert und interpretiert APF Pseudo-Template-Ausdrücke und erstellen die zugehörigen DOM-Baum-Elemente. Bitte
      beachten Sie die Hinweise unter <int:link pageid="047" anchor="Chapter-3-Erweiterte-Template-Funktionen" /> zur
      Verwendung der Ausdrücke. Weitere Details dazu finden Sie ebenso im Proposal unter
      <a class="wiki" href="http://wiki.adventure-php-framework.org/Erweitertes_Templating">Erweitertes Templating</a>.
   </li>
   <li>
      <strong>getParentObject()</strong>:
      Liefert die Instanz des Vater-Tags im DOM-Baum. Sofern kein Vater vorhanden ist, liefert die Methode <em>null</em>.
   </li>
   <li>
      <strong>setParentObject()</strong>:
      Injiziert eine Instanz als Vater-Tags des entsprechenden DOM-Knotens.
   </li>
   <li>
      <strong>getChildren()</strong>:
      Liefert die Liste aller Kinder des Tags. Sofern keine Kinder vorhanden sind, wird eine leere Liste zurückgegeben.
   </li>
   <li>
      <strong>getContent()</strong>:
      Liefert den Inhalt des befragten DOM-Elements.
   </li>
   <li>
      <strong>setContent()</strong>:
      Beschreibt den Inhalt des entsprechenden DOM-Elements.
   </li>
   <li>
      <strong>getChildNode()</strong>:
      Liefert einen Kind-Knoten, der einem definierten Selektor genügt.
   </li>
   <li>
      <strong>getChildNodes()</strong>:
      Liefert mehrere Kind-Knoten, der einem definierten Selektor genügen.
   </li>
   <li>
      <strong>getAttribute()</strong>:
      Liefert den Wert eines Attributes.
   </li>
   <li>
      <strong>setAttribute()</strong>:
      Definiert den Wert eines Attributes.
   </li>
   <li>
      <strong>getAttributes()</strong>:
      Liefert die Liste der aktuellen Attribute.
   </li>
   <li>
      <strong>getAttributesAsString()</strong>:
      Generiert eine XML-Repräsentation der übergebenen Attribute an Hand einer optionalen Whitelist.
   </li>
</ul>
<p>
   Weitere Methoden der Klasse <em>Document</em> oder der Basis-Klasse ihres aktuellen Tags finden Sie in der
   <int:link pageid="002"/>.
</p>

<h3 id="Chapter-6-Tag-Hierarchie"><a href="#Chapter-6-Tag-Hierarchie">6. Tag-Hierarchie</a></h3>
<p>
   Der Tag-Parser des APF besitzt aus Performance- und Konsistenz-Gründen einigen Restriktionen gegenüber einem
   &quot;echten&quot; XML-Parser. Diese sind:
</p>
<ul>
   <li>Tag-Attribute können nur durch Leerzeichen getrennt werden. Tab-Zeichen nicht nicht möglich.</li>
   <li>Der Inhalt von Tag-Attribute wird nur in doppelten Anführungszeichen erkannt.</li>
   <li>
      Tag-Hierarchien werden nur dann richtig aufgelöst, wenn ein Tag - bestehend aus Präfix und Namen - nur in einer
      Ebene bekannt sind. Dies erfordert die Registrierung einer Tag-Implementierung in unterschiedlichen Ebenen mit
      einer anderen Präfix-Name-Kombination.
      <div class="warn">
         Möchten Sie einen Tag auf &quot;höchster&quot; Ebene in einer Template-Datei und gleichzitig in einer tiefer
         gelegenen Struktur verwenden, ordnet der Parser die Instanzen falsch zu. Beispiel:
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\..\FooBarTag"
   prefix="foo"
   name="tag"
/&gt;
&lt;foo:bar id="..."/&gt;
&lt;html:template name="..."&gt;
   &lt;template:addtaglib
      class="VENDOR\..\FooBarTag"
      prefix="foo"
      name="tag"
   /&gt;
   &lt;foo:bar id="..."/&gt;
&lt;/html:template&gt;
</gen:highlight>
         In diesem Fall ordnet der Parser die Instanz des Tags <em>&lt;foo:bar /&gt;</em> der obersten Ebene zu. Im
         <em>&lt;html:template /&gt;</em>-Tag ist kein <em>&lt;foo:bar /&gt;</em> vorhanden, sondern lediglich ein
         Platzhalter und es kommt bei der Transformation zu einem Fehler bzw. einem nicht nachvollziehbaren Verhalten.
      </div>
   </li>
   <li>
      Die Definition eines Tags wirden nur dann erkannt, wenn Tag-Deklaration und Attribute durch ein Leerzeichen
      getrennt sind. Dies gilt insbesondere für mehrzeilige Tag-Definitionen von verschachtelten Tags. Folgendes
      Beispiel wird vom APF-Parser nicht erkannt:
<gen:highlight type="apf-xml">
&lt;form:recaptcha
      name="my-captcha"&gt;
   &lt;recaptcha:getstring
         ...
   /&gt;
&lt;/form:recaptcha&gt;
</gen:highlight>
      Um die auftretende <em>ParserException</em> zu beheben, kann entweder hinter <em>&lt;form:recaptcha</em> ein
      Leerzeichen eingefügt oder das Attribut <em>name</em> auf der selben Zeile wie <em>&lt;form:recaptcha</em>
      aufgeführt werden.
<div class="hint">
   Dieser Fehler tritt vermehrt in IDEs auf, die beim Speichern von HTML-Dateien unnötige Leerzeilen am Ende einer Zeile
   automatisch entfernen.
</div>
   </li>
   <li>
      Als verarbeitbare Tags werden nur APF-Tags erkannt. Einfache HTML-Tags können nicht erfasst werden und dies
      erfordert u.U. die Implementierung von Wrapper-Tags für die Abstraktion.
   </li>
</ul>

<h4 id="Chapter-6-1-Einfache-Hierarchien"><a href="#Chapter-6-1-Einfache-Hierarchien">6.1. Einfache Hierarchien</a></h4>
<p>
   Einfache Tag-Hierarchien sind solche, bei denen Tags in unterschiedlichen Ebenen nur einmal vorkommen. Die Einschränkung
   des Tag-Parsers wirkt sich dabei vor allem auf den aktuell verarbeiteten Knoten - in der Regel das aktuelle Template -
   aus.
</p>
<p>
   Als Beispiel soll uns folgendes Template dienen, in dem ein weiteres eingebunden wird:
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="..." /&gt;
&lt;core:importdesign
   namespace="..."
   template="template2"
/&gt;
</gen:highlight>
<p>
   Das per <em>template2</em> eingebundene Template - dieses stellt die nächste Hierarchie-Stufe im DOM-Baum dar - hat
   folgenden Inhalt:
</p>
<gen:highlight type="apf-xml">
&lt;html:placeholder name="" /&gt;
&lt;html:template name="..."&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Da die beiden <em>&lt;html:placeholder /&gt;</em>-Tags in unterschiedlichen Template-Dateien definiert sind, werden
   sie den jeweiligen Hierarchien korrekt zugeordnet.
</p>
<div class="hint">
   Bitte beachten Sie, dass APF-Tags nur dann verarbeitet werden können, wenn sie dem APF-Parser bekannt sind.
   Benutzen Sie eigene Tags, geben Sie diese bitte mit Hilfe der <em>&lt;*:addtaglib /&gt;</em>-Tags bekannt.
</div>
<div class="warn">
   Ein per <em>&lt;*:addtaglib /&gt;</em>-Tag bekannt gegebener Tag gilt nur innerhalb des aktuellen DOM-Knotens!
   Beabsichtigen Sie einen eigenen Tag sowohl in der ersten Hierarchie - quasi &quot;direkt&quot; in der Template-Datei
   - als auch einer tiefer gelegenen zu verwenden, so muss der Tag in beiden bekannt gegeben werden. Beachten Sie hierzu
   bitte die Hinweise im nächsten Kapitel.
</div>

<h4 id="Chapter-6-2-Komplexe-Hierarchien"><a href="#Chapter-6-2-Komplexe-Hierarchien">6.2. Komplexe Hierarchien</a></h4>
<p>
   Als Beispiel für komplexe Hierarchien, soll ein Tag dienen, der auf Basis eines Schlüssels Übersetzungen für die
   aktuell gewählte Sprache ausgibt. Er soll auf Ebene einer Template-Datei, innerhalb eines
   <em>&lt;html:template /&gt;</em>-Tags und in einem eigenen Tag eingesetzt werden.
</p>
<p>
   Als Basis für die weitere Diskussion soll folgende Template-Datei dienen:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\..\GetTextTag"
   prefix="html"
   name="text"
/&gt;
&lt;html:text key="..." /&gt;

&lt;html:template name=""&gt;
   &lt;core:addtaglib
         class="VENDOR\..\GetTextTag"
         prefix="template"
         name="text"
      /&gt;
   &lt;template:text key="..." /&gt;
&lt;/html:template&gt;

&lt;user:control-panel&gt;
   &lt;control-panel:text key="..." /&gt;
   &lt;control-panel:navi /&gt;
&lt;/user:control-panel&gt;
</gen:highlight>
<p>
   Der <em>GetTextTag</em> wird innerhalb der ersten Hierarchie und im <em>&lt;html:template /&gt;</em>-Tag durch einen
   <em>&lt;*:addtaglib /&gt;</em>-Tag bekannt gegeben, im <em>&lt;user:control-panel /&gt;</em>-Tag ist er bereits durch
   die Implementierung bekannt.
</p>
<div class="warn">
   Durch die in <a href="#Chapter-6-Tag-Hierarchie">Kapitel 6</a> beschriebene Einschränkungen des APF-Parsers ist es
   notwendig für die Verwendung des <em>&lt;*:text /&gt;</em>-Tags innerhalb von <em>&lt;html:template /&gt;</em> und
   <em>&lt;user:control-panel /&gt;</em> ein eigenes Präfix zu wählen. Sind Präfix und Name des <em>&lt;*:text /&gt;</em>-Tags
   in allen Hierarchien identisch wird der Parser die Instanzen derjenigen Hierarchie zuweisen in der er zuerst bekannt
   gegeben wurde - in diesem Fall der ersten.
</div>
<div class="hint">
   Aus den oben genannten Gründen und um die Zugehörigkeit eines Tags zu einer Hierarchie auszudrücken empfiehlt es sich,
   Präfix und Namen eines Tags gemäß der Hierarchie zu vergeben. Im obigen Beispiel wurden die Kind-Tags des
   <em>&lt;user:control-panel /&gt;</em> mit dem Präfix <em>control-panel</em> ausgestattet. Für tiefer strukturierte
   Hierarchien kann folgendes Beispiel als Vorlage dienen:
<gen:highlight type="apf-xml">
&lt;shop:basket&gt;
   &lt;basket:title /&gt;
   &lt;basket:products&gt;
      &lt;products:listing /&gt;
      &lt;products:sum /&gt;
   &lt;/basket:products&gt;
&lt;/shop:basket&gt;
</gen:highlight>
   Weitere Hinweise finden Sie im Forum unter
   <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=4&amp;t=38">Schachtelung TagLibs</a>.
</div>

<h4 id="Chapter-6-3-Verschachtelte-Strukturen"><a href="#Chapter-6-3-Verschachtelte-Strukturen">6.3. Verschachtelte Strukturen</a></h4>
<p>
   Ab dem Release 1.17 ist der APF-Parser in der Lage verschachtelte Strukturen von Tags mit identischem Prefix und
   Namen innerhalb eines Dokuments bzw. einer Datei zu verarbeiten (siehe <a href="#Chapter-6-Tag-Hierarchie">Kapitel 6</a>).
   Die übrigen Einschränkung des APF-Parsers gegenüber einem vollwertigen XML-Parser bleiben jedoch erhalten.
</p>
<p>
   Die folgende Code-Box stellt ein Beispiel einer hierarchischen Struktur da, die ab dem APF 1.17 korrekt verarbeitet
   wird:
</p>
<gen:highlight type="apf-xml">
<foo:bar>
   ...
   <foo:bar>
      ...
      <foo:bar>
         ...
      </foo:bar>
      ...
   </foo:bar>
   ...
   <foo:bar />
   ...
   <foo:bar>
      ...
   </foo:bar>
   ...
</foo:bar>
<foo:bar>
   ...
</foo:bar>
</gen:highlight>
<p>
   Der beschriebene Quellcode zeigt eine asymmetrische Struktur von unterschiedlichen <em>&lt;foo:bar /&gt;</em>-Tags,
   die unterschiedlich tief verschachtelt sind und selbst- und explizit schließende Tags beinhaltet. Der Parser
   verarbeitet nun symmentrische (gleiche Anzahl von öffnenden wie schließenden Tags) und asymmetrische (ungleiche
   Anzahl von öffnenden und schließenden Tags) Strukturen und ordnet die jeweiligen Inhalte den definierten Ebenen
   korrekt zu.
</p>
<p>
   Als Anwendungsbeispiel soll folgende verschachtelte HTML-Liste dienen, die sich am <em>&lt;ul /&gt;</em>-Tag
   orientiert:
</p>
<gen:highlight type="apf-xml">
<html:list>
   <list:item>Kapitel 1</list:item>
   <list:item>
      Kapitel 2
      <html:list>
         <list:item>Kapitel 2.1</list:item>
         <list:item>Kapitel 2.2</list:item>
      </html:list>
   </list:item>
   <list:item>Kapitel 3</list:item>
</html:list>
</gen:highlight>
<p>
   Bei der Implementierung von Tags für verschachtelte Strukturen kann das Verhalten je nach Platzierung bzw.
   Hierarchie-Stufe im Baum variieren. Dies ist beim gewählten Beispiel nicht der Fall, da sich das zu generierende HTML
   an der Tag-Struktur orientiert.
</p>
<div class="hint">
   Der APF-Parser analysiert die in einem Dokument enthaltenen Tags an Hand der registrierten Tags, die im
   <em>$this->tagLibs</em>-Array vorgehalten werden. Dabei geht er chronologisch vor und analysiert die definierten Tags
   in der Reihenfolge, in der sie registriert wurden.
</div>
<p>
   Diese Tatsache ist insbesondere für sich gegenseitig überlagernde Strukturen wichtig, da bei falsch gewählter
   Reihenfolge der bekannten Tags die korrekte Zuordnung der Instanzen zu den gewünschten Ebenen nicht korrekt
   ausgeführt wird. Das oben aufgeführte Beispiel basiert auf der folgenen, vereinfachten Struktur:
</p>
<gen:highlight type="apf-xml">
<ul>
   <li>
      <ul>
         <li></li>
      </ul>
   </li>
</ul>
</gen:highlight>
<p>
   Beim Parsen der Tags muss nun darauf geachtet werden, dass zuerst alle <em>&lt;ul/&gt;</em>-Tags und innerhalb
   dieser zunächst die <em>&lt;li/&gt;</em>-Tags verarbeitet werden. Anschließend kann innerhalb der <em>&lt;li/&gt;</em>-Tags
   nach weiteren Unterstrukturen gesucht werden.
</p>
<div class="hint">
   Der APF-Parser arbeitet nach dem Prinzip, dass die innenliegenden Strukturen zunächst nicht weiter analysiert werden,
   sondern direkt an die Kind-Instanz weiter gereicht werden. So sind Sie in der Lage bei der Implementierung eines Tags
   selbst in der Kind-Instanz über die Verarbeitung zu entscheiden.
</div>
<p>
   Diese beiden Hinweise können direkt als Handlungsanweisung für die Implementierung genutzt werden. Die Tag-Repräsentation
   einer Liste hat damit folgende Gestalt:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class UnorderedListTag extends Document {

   public function __construct() {
      $this->tagLibs = array(
         new TagLib('SANDBOX\pres\taglib\ListElementTag', 'list', 'item')
      );
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function transform() {
      return '<ul>' . parent::transform() . '</ul>';
   }

}
</gen:highlight>
<p>
   Der <em>UnorderedListTag</em> registriert Listen-Einträge als mögliche Kinder und erzeugt die HTML-Ausgabe durch
   Umschließen des Inhalts mit einem <em>&lt;ul/&gt;</em>-Tag. Weitere <em>&lt;html:list/&gt;</em>-Tags werden nicht
   beachtet, da diese erst innerhalb von <em>&lt;list:item/&gt;</em>-Tags verarbeitet werden sollen.
</p>
<div class="warn">
   Bei Nutzung von verschachtelten Strukturen müssen Sie selbst für die Verarbeitung des Inhalts eines Tags sorgen.
   Dazu ist im Allgemeinen die Registrierung des äußeren Tags als innere Struktur notwendig - der Tag muss sich also
   zusätzlich selbst kennen! Ist dies nicht der Fall, wird der Aufbau der rekursiven Struktur unterbrochen.
</div>
<p>
   Die Implementierung eines Listen-Elements kann wie folgt realisiert werden:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class ListElementTag extends Document {

   public function __construct() {
      $this->tagLibs = array(
         new TagLib('SANDBOX\pres\taglib\UnorderedListTag', 'html', 'list')
      );
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function transform() {
      return '<li>' . parent::transform() . '</li>';
   }

}
</gen:highlight>
<p>
   Der Konstruktor der <em>ListElementTag</em>-Klasse registriert für die Analyse des Inhalts zunächst den
   <em>&lt;html:list/&gt;</em>-Tag um sicherzustellen, dass weiterführende Unterstrukturen richtig aufgebaut werden.
   Die Listen-Tag-Implementierung kennt also die Listen-Element-Implementierung und umgekehrt. So ist bei verschachtelten
   Strukturen ein rekursiver Aufbau von beliebig tiefen Strukturen möglich.
</p>

<h3 id="Chapter-7-Anwendungsbeispiele"><a href="#Chapter-7-Anwendungsbeispiele">7. Anwendungsbeispiele</a></h3>
<p>
   In diesem Kapitel finden Sie Anwendungsbeispiele für Tags, die Sie in Ihrer täglichen Arbeit mit dem APF als
   Vorlage für eigene Implementierungen bzw. als Coding-Guideline nutzen können. Als Daumenregel gilt:
</p>
<div class="hint">
   Ein Tag wird erst notwendig, wenn die Anforderung mit Hilfe eines <int:link pageid="047"/> - inkl. aller
   <int:link pageid="046" /> - und einem <int:link pageid="006" /> nicht mehr zu realisieren ist (z.B. Manipulationen
   des DOM-Baums). Weiterhin empfielt es sich, Funktionalität in Tags abzufassen, wenn immer wieder verwendete Elemente
   in unterschiedlichen Templates genutzt werden soll ohne den Code zu duplizieren oder unnötige Vererbungshierarchien
   zu erzeugen.
</div>

<h4 id="Chapter-7-1-Einfacher-Tag-mit-Attributen"><a href="#Chapter-7-1-Einfacher-Tag-mit-Attributen">7.1. Einfacher Tag mit Attributen</a></h4>
<p>
   Als Beispiel für einen einfachen Tag soll uns der <em>&lt;html:text /&gt;</em>-Tag aus
   <a href="#Chapter-6-2-Komplexe-Hierarchien">Kapitel 6.2</a> dienen. Dieser gibt einen sprachabhängigen Text aus, der
   an Hand eines Attributs definiert wird. Beispiel:
</p>
<gen:highlight type="apf-xml">
&lt;html:text key="log-in.mousover.text" /&gt;
</gen:highlight>
<p>
   Die Implementierung des Tags beinhaltet die Verarbeitung des Attributs und die Ausgabe des Textes zur
   Transformationszeit. Dies kann mit folgender Implementierung bewerkstelligt werden:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class TranslationTextTag extends Document {

   public function transform() {
     return gettext($this->getAttribute('key'));
   }

}
</gen:highlight>
<p>
   Sollen die Attribute eines Tags bei der Generierung der Ausgabe einbezogen werden, kann die Methode
   <em>getAttributesAsString()</em> genutzt werden. Als Beispiel soll ein Tag genutzt werden, der die Ausgabe eines
   Bildes aus einer Medien-Datenbank an Hand einer externen ID erzeugt:
</p>
<gen:highlight type="apf-xml">
&lt;html:img
   key="IMG-12345"
   width="100"
   height="120"
   alt="Diese Bild zeigt ein rotes Auto"
/&gt;
</gen:highlight>
<p>
   Die zugehörige Implementierung kann wie folgt aussehen:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class MAMImageTag extends Document {

   public function transform() {

      $width = $this->getAttribute('width', '50');
      $height = $this->getAttribute('height', '50');
      $key = $this->getAttribute('key');

      $whiteList = array(
         'alt',
         'height',
         'width',
         'id',
         'style',
         'title'
      );

      return '<img src="'
            . $this->getImageUrl($key, $width, $height) . '" '
            . $this->getAttributesAsString($this->getAttributes(), $whiteList)
            . ' />';
   }

   private function getImageUrl($key, $width, $height) {
     ...
   }

}
</gen:highlight>
<p>
   In der obigen Code-Box wird die Methode <em>getAttribute()</em> dazu genutzt um die Werte der angegebenen Attribute
   auszulesen. Da einige der Attribute für die Ausgabe wiederverwendet werden sollen, wird der Methode
   <em>getAttributesAsString()</em> eine Liste an erlaubten Attributen - in diesem Fall kompatibel zur XHTML- bzw.
   HTML5-Spezifikation - mitgegeben. Die Ausgabe des Tags ist damit ein Image-Tag, der mit Hilfe der (HTML-)Attribute
   <em>id</em>, <em>style</em> und <em>class</em> formatiert werden kann.
</p>

<h4 id="Chapter-7-2-Einfacher-Tag-mit-Inhalt"><a href="#Chapter-7-2-Einfacher-Tag-mit-Inhalt">7.2. Einfacher Tag mit Inhalt</a></h4>
<p>
   Neben den Attributen eines Tags kann dieser auch einfachen und komplexen Inhalt definieren. Als Implementierungsbeispiel
   soll in diesem Kapitel folgender Tag genutzt werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
<p>
   Ausgabe des Tags soll eine in HTML-Entitäten codierte E-Mail-Adresse sein, um sie vor Bots oder Spidern zu schützen.
   Hierzu muss der Inhalt des Tags ausgelesen und im Rahmen der Transformation des Tags ausgegeben werden. Dies führt
   zu folgender Implementierung:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use APF\tools\string\StringAssistant;

class EntityEncodeTag extends Document {

   public function transform() {
      return StringAssistant::encodeCharactersToHTML($this->getContent());
   }

}
</gen:highlight>
<p>
   Mit der Methode <em>getContent()</em> kann auf den Inhalt des Tags zugegriffen werden. Dieser wird mit Hilfe des
   <em>StringAssistant</em> in HTML-Entitäten umgewandelt.
</p>

<h4 id="Chapter-7-3-Zugriff-auf-den-umliegenden-DOM-Baum"><a href="#Chapter-7-3-Zugriff-auf-den-umliegenden-DOM-Baum">7.3. Zugriff auf den umliegenden DOM-Baum</a></h4>
<p>
   Wie im <a href="#Chapter-1-Einfuehrung">Kapitel 1</a> angesprochen erzeugt der <int:link pageid="098" /> aus den
   genutzten Templates und den darin enthaltenen Tags einen DOM-Baum. Das Verhalten ist - bis auf die Art der Erzeugung
   - mit dem eines Browsers vergleichbar, der ebenfalls aus dem angelieferten HTML einen DOM-Baum erzeugt und diesen
   grafisch aufbereitet.
</p>
<p>
   Da Tags und <int:link pageid="006" /> Teil des Baumes sind haben Sie dort die Möglichkeit auf alle umliegenden Knoten
   zuzugreifen. Hierzu gibt es im Wesentlichen zwei Methoden:
</p>
<ul>
   <li><em>getParentObject()</em></li>
   <li><em>getChildren()</em></li>
</ul>
<p>
   Innerhalb eines Tags können Sie mit diesen Methoden direkt auf die umliegenden Elemente zugreifen, innerhalb eines
   <int:link pageid="006" /> beziehen Sie mit <em>getDocument()</em> eine Referenz auf den aktuellen DOM-Knoten und
   können ab diesem mit den oben genannten Methoden navigieren.
</p>
<p>
   Als Beispiel für den Zugriff auf soll folgendes Template dienen:
</p>
<gen:highlight type="apf-xml">
&lt;html:template name="test1"&gt;
   ...
&lt;/html:template&gt;
&lt;html:template name="test2"&gt;
   &lt;template:addtaglib
      class="VENDOR\..\TemplateNameDisplayTag"
      prefix="template"
      name="display-name"
   /&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Der <em>TemplateNameDisplayTag</em> hat dabei die Aufgabe, die Namen aller Templates auszugeben, die im Baum auf
   gleicher Ebene hängen wie sein Vater. Hierzu kann folgende Implementierung genutzt werden:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class TemplateNameDisplayTag extends Document {
   public function transform() {
      $template = &$this->getParentObject();
      $grandFather = &$template->getParentObject();

      $nodes = $grandFather->getChildren();

      $buffer = '<ul>';
      foreach ($nodes as $objectId => $DUMMY) {
         $buffer .= '<li>' . $nodes[$objectId]->getAttribute('name') . '</li>';
      }

      return $buffer . '</ul>';
   }
}
</gen:highlight>
<p>
   Ein weiterführendes Beispiel finden Sie im Forum unter
   <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=1152">Placeholder über Taglib füllen</a>.
</p>

<h4 id="Chapter-7-4-Komplexer-Tag-mit-Attributen-und-Inhalt"><a href="#Chapter-7-4-Komplexer-Tag-mit-Attributen-und-Inhalt">7.4. Komplexer Tag mit Attributen und Inhalt</a></h4>
<p>
   Die vorangegangenen Kapitel haben sich mit dem Zugriff auf Attribute, der Ausgabe von Attributen und dem Zugriff und
   der Verarbeitung von Tag-Inhalten beschäftigt. In diesem Abschnitt beschäftigen wir uns mit komplexeren Tags, die
   weitere Strukturen definieren und Inhalte sowie Attribute in die Abbildung ihrer Logik einbeziehen.
</p>
<p>
   Als Beispiel soll uns ein Tag dienen, der Navigationsknoten vom Typ <em>NavigationNode</em> ausgibt:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="APF\extensions\navigation\pres\tags\NavigationNodeTag"
   prefix="navi"
   name="template"
/&gt;
&lt;navi:template id="main-navi"&gt;&lt;!-- NavigationNodeTag --&gt;
   &lt;navi:item status="active"&gt;&lt;!-- NavigationItemTag --&gt;
      &lt;li class="active"&gt;
         &lt;item:content/&gt;&lt;!-- ItemTemplateContentTag --&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;
   &lt;navi:item status="inactive"&gt;
      &lt;li&gt;
         &lt;item:content/&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;

   &lt;ul id="main-navigation"&gt;
      &lt;navi:content/&gt;&lt;!-- NavigationContentTag --&gt;
   &lt;/ul&gt;
&lt;/navi:template&gt;
</gen:highlight>
<p>
   Der Tag wird in einem <int:link pageid="006" /> gefüllt und stellt die Liste der Kinder des übergebenen
   Navigationsknotens gemäß den definierten Formatierungen dar. Dabei beschreiben die <em>&lt;navi:item /&gt;</em>-Tags
   die aktiven und inaktiven Zustände der Navigationsknotens und mit Hilfe von <em>&lt;navi:content/&gt;</em> lässt sich
   die Ausgabe in ein HTML-Gerüst packen. Der Tag <em>&lt;item:content/&gt;</em> platziert die Ausgabe eines konkreten
   Knotens und kann ebenfalls mit eigenem HTML versehen werden. Zur Erläuterung der Tag-Hierarchie sind die Namen der
   korrespondierenden Tags als HTML-Kommentar angefügt.
</p>
<p>
   Zur Befüllung des <em>&lt;navi:template /&gt;</em>-Tags in einem Template lässt sich folgender Controller nutzen:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;
use APF\extensions\navigation\biz\SimpleNavigationNode;

class NavigationTagExampleController extends BaseDocumentController {
   public function transformContent() {
      $root = new SimpleNavigationNode(null, null, null);
      $levelOne = new SimpleNavigationNode('Level 1', '#');

      $root->setChildren(array(
         clone $levelOne->setInactive(),
         clone $levelOne->setActive(),
         clone $levelOne->setInactive()
      ));

      $navi = $this->getDocument()->getChildNode('id', 'main-navi', 'NavigationNodeTag');
      $navi->setNode($root);
   }
}
</gen:highlight>
<p>
   Die folgende Code-Box zeigt nun die Implementierung der Tags:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

interface NavigationNode {
   public function getLabel();
   public function getUrl();
   public function getParent();
   public function getChildren();
}

class SimpleNavigationNode implements NavigationNode {

   private $label;
   private $url;
   private $isActive = false;
   private $parent;
   private $children = array();

   public function __construct($label, $url) {
      $this->label = $label;
      $this->url = $url;
   }

   public function getLabel() {
      return $this->label;
   }

   public function getUrl() {
      return $this->url;
   }

   public function isActive() {
      return $this->isActive;
   }

   public function setActive() {
      $this->isActive = true;
      return $this;
   }

   public function setInactive() {
      $this->isActive = false;
      return $this;
   }

   public function getParent() {
      return $this->parent;
   }

   public function getChildren() {
      return $this->children;
   }

   public function setParent(NavigationNode $node) {
      $this->parent = $node;
   }

   public function setChildren(array $nodes) {
      $this->children = $nodes;
   }

}

class NavigationNodeTag extends Document {

   private $node;

   public function __construct() {
      $this->tagLibs = array(
         new TagLib('APF\extensions\navigation\pres\tags\NavigationItemTag', 'navi', 'item'),
         new TagLib('APF\extensions\navigation\pres\tags\NavigationContentTag', 'navi', 'content')
      );
   }

   public function setNode(NavigationNode $node) {
      $this->node = $node;
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function transform() {

      $buffer = '';

      $navigationNodes = $this->node->getChildren();
      if (count($navigationNodes) > 0) {
         foreach ($navigationNodes as $node) {
            $buffer .= $this
               ->getTemplate($node->isActive() ? 'active' : 'inactive')
               ->getOutput($node);
         }
      }

      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof NavigationContentTag) {
            // fill the navi:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $buffer, $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }

      return $content;
   }

   private function getTemplate($status) {
      return $this->getChildNode('status', $status, 'NavigationItemTag');
   }

}

class NavigationItemTag extends Document {

   public function __construct() {
      $this->tagLibs = array(
         new TagLib('APF\extensions\navigation\pres\tags\ItemTemplateContentTag', 'item', 'content')
      );
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function getOutput(NavigationNode $node) {
      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof ItemTemplateContentTag) {
            // fill the item:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $children[$objectId]->setNode($node)->transform(), $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }
      return $content;
   }

   public function transform() {
      return '';
   }

}

class ItemTemplateContentTag extends Document {

   private $node;

   public function setNode(NavigationNode $node) {
      $this->node = $node;
      return $this;
   }

   public function transform() {
      if ($this->node === null) {
         return '';
      }
      return '<a href="' . $this->node->getUrl() . '">' . $this->node->getLabel() . '</a>';
   }

}

class NavigationContentTag extends Document {
}
</gen:highlight>
<div class="warn">
   Das hier beschriebene Beispiel dient dazu, die Möglichkeiten des APF aufzuzeigen und ist nicht als
   Referenz-Implementierung für die Ausgabe von Navigationen gedacht.
</div>

<h3 id="Chapter-8-Weiterfuehrende-Links"><a href="#Chapter-8-Weiterfuehrende-Links">8. Weiterführende Links</a></h3>
<p>
   Sofern Sie weitere Informationen benötigen, können Sie folgende Threads aus dem Forum nutzen:
</p>
<ul>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=1126">TagLib unterschiedliche Zustände</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=982">Taglib innerhalb eines Templates</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=827">Taglib der Template rundherum läd</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=540">Taglibs</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=505">Mehrere Checkboxes taglib aus DB holen und ausgeben</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=456">Taglib-Call innerhalb eines Taglib-Call</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=191">transform() von eigenem taglib nicht ausgeführt</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=177">Menü taglib-modul</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=122">Performance TagLibs</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=37">Taglibs vs. Templates</a></li>
</ul>
<p>
   Im Wiki finden sich folgende Seiten zu den APF-Tags:
</p>
<ul>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/All-in-one_Include-Tag">All-in-one Include-Tag</a></li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/Timing-Modell_des_Page-Controller">Timing-Modell des Page-Controller</a></li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/WYSIWYG_%2B_APF-Formulare">WYSIWYG + APF-Formulare</a></li>
</ul>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_147" />