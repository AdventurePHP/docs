<doku:title parent="100" tags="taglib,taglibs,tag,parser" title="Implementation of tags" urlname="Implementation-of-tags">
   This chapter describes the concepts and the usage of tags/taglibs within the APF.
</doku:title>

<h3 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction">1. Introduction</a></h3>
<p>
   This chapter focuses on APF tags (a.k.a. Taglibs). It describes the concepts and supports development of custom tags.
</p>
<p>
   The <int:link pageid="098"/> is based on the same-name pattern and is one of the central elements of the APF. It
   enables you - as a developer - to inject custom functionality for the creation and transformation of the APF DOM tree.
   Thus, tags are not only a basis for the APF's HMVC concept but can be used to enhance it easily.
</p>
<p>
   Further, tags may be used to re-use functionality encapsulated within a tag within several projects. Since APF
   templates only process tags and no PHP code un-controlled spread of logic is prevented automatically. This means, that
   view logic can only reside within tags and controllers.
</p>

<h4 id="Chapter-1-1-Page-controller"><a href="#Chapter-1-1-Page-controller">1.1. Page controller</a></h4>
<p>
   The <int:link pageid="098"/> is responsible for creating and transforming of the internal template structure. For this
   reason he provides a tag API that parses tags - following a dedicated timing model -, creates documents within the
   DOM tree and finally creates the HTML output. Different formats such as XML can be produced, too. The parser itself
   is no &quot;real&quot; XML parser but resolves explicitly and self closing tags as well as unlimited tag hierarchies.
</p>
<div class="warn">
   Please note the restrictions of the APF parser within the <a href="#Chapter-6-The-APF-parser">The APF parser</a>
   chapter.
</div>
<p>
   The <int:link pageid="046"/> shipped with the APF provide a series of standard functionality such as inclusion of
   further templates, definition of reusable template fragments and inclusion of custom tags.
</p>

<h4 id="Chapter-1-2-XML-parser"><a href="#Chapter-1-2-XML-parser">1.2. XML parser</a></h4>
<p>
   The <em>XMLParser</em> used by the page controller during creation of the <em>Document</em> instances is intended for
   analyzing tag definitions.
</p>
<div class="warn">
   Due to performance reasons, the <em>XMLParser</em> only processes tag attributes that are separated by blanks.
   Further, values must be delimited by double-quotes.
</div>

<h3 id="Chapter-2-Definition-of-a-tag"><a href="#Chapter-2-Definition-of-a-tag">2. Definition of a tag</a></h3>
<p>
   An APF tag is defined by the following parts:
</p>
<ul>
   <li>
      <strong>Prefix</strong>: the <em>prefix</em> is commonly used to group tags (e.g. <em>core</em> for tags that are
      shipped with the APF). This part is similar to XML namespaces.
   </li>
   <li>
      <strong>Name</strong>: the <em>Name</em> can be considered as declaration. This part is similar to XML tag names.
   </li>
   <li>
      <strong>Attributes</strong>: the attributes of a tag can be used for configuration. Attribute vales must not
      contain further tags.
   </li>
   <li>
      <strong>Content</strong>: the content area can contain further tags or simple text. The APF parser resolves tags
      defined there and adds them to the current hierarchy level. Simple text is also available within the tag for
      further usage.
   </li>
</ul>
<p>
   The tag contained in the subsequent code box can be used to print the current date to the template it is contained in:
</p>
<gen:highlight type="apf-xml">
<current:date format="H:i" />
</gen:highlight>
<p>
   Within this declaration, <em>current</em> is the prefix, <em>date</em> is the name, and the attribute <em>format</em>
   contains the output format. This tag does not define any content.
</p>
<p>
   To display an image gallery the following tag definition can be used:
</p>
<gen:highlight type="apf-xml">
<img:gallery>
   <h3>My holiday in 2012</h3>
   <p>
      These pictures are from my holiday in 2012:
   </p>
   <gallery:datasource
      namspace="..."
      class="..."
   />
</img:gallery>
</gen:highlight>
<p>
   In the above example the <em>&lt;img:gallery /&gt;</em> tag contains static HTML - that is used for formatting later
   on - as well as a further tag that defines the data source (z.B. database). Using this tag it must be made known to
   the APF parser.
</p>

<h3 id="Chapter-3-DOM-structure"><a href="#Chapter-3-DOM-structure">3. DOM structure</a></h3>
<p>
   As mentioned in <a href="#Chapter-1-1-Page-controller">chapter 2</a> the <int:link pageid="098"/> creates a DOM tree
   out of the tag structure within the template files. This tree is similar to a browser's DOM tree that creates a memory
   reference out of HTML tags.
</p>
<p>
   The difference between the DOM tree of a browser and the APF implementation is that each node provides logic for
   transformation and displaying that the page controller uses during the transformation phase.
   Details on the timing model of the page controller can be found <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram">here</int:link>.
</p>
<p>
   Each tag - or from a particular point in time it's instance - passes the same life cycle. At the beginning, the
   structure of the tag is analyzed, then it's substance (attributes and content). After that, a DOM node instance is
   created regarding the tag definition and the substance the <em>XMLParser</em> has extracted from the template.
</p>
<div class="hint">
   <p>
      The page controller is designed to process all tags that either match
   </p>
<gen:highlight type="apf-xml">
&lt;prefix:name /&gt;
</gen:highlight>
   <p>
      or
   </p>
<gen:highlight type="apf-xml">
&lt;prefix:name&gt;&lt;/prefix:name&gt;
</gen:highlight>
   <p>
      including all tag attributes defined along with the tag. According to <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a>
      a tag can be defined with any number of attributes.
   </p>
   <p>
      Creating the DOM tree the parser used the list of registered tags to create a tag instance. The list contains the
      name of the class that implements the tag. Tags shipped with the APF are already registered within the
      <em>bootstrap.php</em>.
   </p>
   <p>
      Tags can be both registered for <strong>all templates</strong> as well as per <strong>DOM node</strong>. This allows
      you to register project-specific tags at a central place and at the same time - if necessary - overwrite APF tags
      locally.
   </p>
</div>
<div class="hint">
   <p>
      In case you want to register a tag for an entire project you can add the following line to your bootstrap file:
   </p>
<gen:highlight type="php">
Document::addTagLib('VENDOR\..\DateDisplayTag', 'date', 'display');
</gen:highlight>
   <p>
      In case the tag should only be registered with the current DOM node the tag implementation is as follows:
   </p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class MyTag extends Document {

   public function __construct() {
      $this->addInstanceTagLib('VENDOR\..\SpecialDateDisplayTag', 'date', 'display');
   }

}
</gen:highlight>
   <p>
      Using the <em>&lt;date:display /&gt;</em> tag within your project the APF parser will create an instance of
      <em>DateDisplayTag</em>. Using it within <em>MyTag</em> the APF parser creates as <em>SpecialDateDisplayTag</em>
      instead.
   </p>
   <p>
      Within templates custom tags can be registered using the <em>&lt;core:addtaglib /&gt;</em> tag. It includes an
      option to register your custom tag both globally for all templates and locally for the current DOM node. Details
      can be found in chapter <int:link pageid="046" anchor="Chapter-1-1-Addtaglib" />.
   </p>
</div>
<div class="warn">
   Please note that the APF parser processes all XML tags with scheme <em>&lt;prefix:name &gt;</em>. This may lead to
   issues in case you intend to write namespace'd XML tags directly to the HTML source code. Using the old notation of
   the <em>Google +1</em> inclusion via
<gen:highlight type="apf-xml">
&lt;g:plusone&gt;&lt;/g:plusone&gt;
</gen:highlight>
   The parser will complain about a missing tag definition. In such cases, please use alternative inclusion methods
   or implement a wrapper tag that generates the output.
</div>

<h3 id="Chapter-4-Class-structure-of-tags"><a href="#Chapter-4-Class-structure-of-tags">4. Class structure of tags</a></h3>
<p>
   The structure of tags is defined by the <em>Document</em> class. This class is the mother of all tag implementations
   of the APF. It defines several methods that are used within the timing model of the page controller for different
   reasons.
</p>
<p>
   Please note the following signature (condensed):
</p>
<gen:highlight type="php">
class Document extends APFObject {

   protected $objectId = null;
   protected $parentObject = null;
   protected $children = array();
   protected $content;

   protected static $knownTags = array();
   protected $knownInstanceTags = array();
   protected static $knownExpressions = array();

   protected $data = array();

   protected static $documentIndex = array();

   public function __construct() {
   }

   public function onParseTime() {
   }

   public function onAfterAppend() {
   }

   public function transform() {
   }

}
</gen:highlight>
<p>
   The items from the code box have the following meaning:
</p>
<ul>
   <li>
      The field <em>objectId</em> stores the internal unique object id the object receives from the APF parser during
      creation. The value is e.g. used for <int:link pageid="004"/> tags or to refer a DOM element by it's unique
      identifier.
   </li>
   <li>
      <em>parentObject</em> refers to the father object within the DOM tree. This reference can be used to navigate
      the DOM tree. The root node does not have a father.
   </li>
   <li>
      The list of <em>children</em> contains all child nodes of the current DOM node. This list can be used to navigate
      the DOM tree. In case a DOM node does not have children, the list is empty.
   </li>
   <li>
      The <em>content</em> field contains the textual content of the node as well as place holder tags created by the
      page controller during DOM tree creation in order to guarantee correct assembling of the HTML source code.
   </li>
   <li>
      The <em>attributes</em> list - inherited from <em>APFObject</em> - contains a list of tag attributes and their
      respective values. In case a tag defines no attributes the list is empty.
   </li>
   <li>
      The (static) <em>knownTags</em> list contains tags registered for <em>all templates</em>. When the APF parser
      detects a tag according to the expected syntax this list is being used to find the name of the respective
      implementation (fully qualified class name) using tag prefix and name.
   </li>
   <li>
      The <em>knownInstanceTags</em> list also contains a list of tag prefixes and names referring to the respective
      tag implementations. The difference is that this list is only valid for the present DOM node instance. When the
      APF parser finds a local definition of the tag definition the local one will be used. With this mechanism, you
      can e.g. overwrite tag implementations delivered with the APF using <em>Document::addInstanceTagLib()</em>. In
      contrast to it's static pendent <em>Document::addTagLib()</em> it fills the dynamic list of the current node.
      <div class="warn">
         Please be aware that the APF parser uses the global list again for child tags of the current DOM node. Recursive
         inheritance is not implemented.
      </div>
   </li>
   <li>
      The constructor of the tag class is called when creating the tag instance. But the parser does not apply arguments.
      It can be used to add known tags to the current hierarchy or to initialize default values.
      <div class="warn">
         On execution time of the constructor neither tag attributes nor content has been initialized within the tag.
         Further, context and language are not available at this time, too.
      </div>
   </li>
   <li>
      After the tag has been parsed, the <em>onParseTime()</em> is called. At this particular point in time, the
      attributes and the content of the tag are available. Moreover, context and language are initialized. This method
      can be used the initialize the tag with the information available or to analyze the content of the tag (e.g. parse
      child tags).
   </li>
   <li>
      After the node has been added to the DOM tree - this means that the father node and the children are initialized -
      the <em>onAfterAppend()</em> is called. Within this method you may execute logic that affects father and child
      nodes.
   </li>
   <li>
      During transformation, the page controller calls the <em>transform()</em> method of your tag. Please place all
      logic needed for creating the appropriate HTML source code within this method. Tags that are intended for
      configuration or initialization often generate no output (e.g. the <em>&lt;core:addtaglib /&gt;</em> tag). However,
      it is up to you how your tag acts.
      <div class="hint">
         In case the <em>transform()</em> method is overwritten by your custom tag, you have to take care of the
         transformation of the child nodes by yourself. This may be done as follows:
<gen:highlight type="php">
foreach($this->children as $objectId => $DUMMY){
   $this->content = str_replace(
      '<'.$objectId.' />',
      $this->children[$objectId]->transform(),
      $this->content
   );
}
</gen:highlight>
         You can use the snippet above in case the parser function <em>extractTagLibTags()</em> has been called within
         <em>onParseTime()</em> or <em>onAfterAppend()</em>. Further notes can be taken from the forum post
         <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a> (German).
      </div>
   </li>
</ul>
<p>
   You may use the following methods to transform child nodes:
</p>
<ul>
   <li>
      <strong>transformChildren()</strong>
      Transforms the child nodes within the internal content buffer (<em>$this->content</em>).
   </li>
   <li>
      <strong>transformChildrenAndPreserveContent()</strong>
      Transforms the child nodes and returns the result. The internal content buffer (<em>$this->content</em>)
      is preserved for further transformation runs.
   </li>
   <li>
      <strong>transformChildrenAsEmpty()</strong>
      Removes the internal position markers of the APF parser (see hint in chapter
      <a href="#Chapter-5-2-4-Output-creation">5.2.4. Output creation</a>) within the internal content buffer
      (<em>$this->content</em>).
   </li>
   <li>
      <strong>transformChildrenAsEmptyAndPreserveContent()</strong>
      Removes the internal position markers of the APF parser (see hint in chapter
      <a href="#Chapter-5-2-4-Output-creation">5.2.4. Output creation</a>) and returns the result.
      The internal content buffer (<em>$this->content</em>) is preserved for further transformation runs.
   </li>
</ul>

<h3 id="Chapter-5-Implementation"><a href="#Chapter-5-Implementation">5. Implementation</a></h3>

<h4 id="Chapter-5-1-Simple-tag"><a href="#Chapter-5-1-Simple-tag">5.1. Simple tag</a></h4>
<p>
   This chapter deals with a simple tag. &quot;Simple&quot; in this case means that the tag does a dedicated job but
   creates no extra hierarchy - precisely he has no children.
</p>
<p>
   As an example we use the tag from <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a> that displays the current
   time. The functionality of the tag is just to return the current time using the applied format at transformation time.
   There is no dependency to other tags within the DOM tree and there is no need for further initialization. The source
   code of the tag might be as follows (namespace: <em>VENDOR\tags</em>):
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class HourDisplayTag extends Document {

   public function transform() {
      return date($this->getAttribute('format'));
   }

}
</gen:highlight>
<p>
   Within a template, the tag can be used as follows:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\tags\HourDisplayTag"
   prefix="current"
   name="date"
/&gt;
&lt;current:date format="H:i:s" /&gt;
</gen:highlight>

<h4 id="Chapter-5-2-Complex-tag"><a href="#Chapter-5-2-Complex-tag">5.2. Complex tag</a></h4>
<p>
   A &quot;complex&quot; tag is a tag that defines further child nodes - not limited in their hierarchy.
</p>
<p>
   As an example we take the image gallery tag from <a href="#Chapter-2-Definition-of-a-tag">chapter 2</a>. This tag
   defines static content that includes a headline and an introduction text. The content of the gallery itself is
   - represented by the <em>&lt;img:gallery /&gt;</em> tag - is created by the <em>&lt;gallery:datasource /&gt;</em> tag
   using a <em>Content-Providers</em>.
</p>
<div class="hint">
   Please note that the structure of this example has been chosen to depict essential attributes of the APF tag
   implementation. It is not a rule of how your tags and applications must be structured. To realize this particular
   use case, you may also define the content provider within the gallery tag using attributes and use a further formatting
   element to generate the output (e.g. using a mechanism like the <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator</int:link>
   tag).
</div>

<h5 id="Chapter-5-2-1-Basis"><a href="#Chapter-5-2-1-Basis">5.2.1. Basis</a></h5>
<p>
   The basic structure of the tag is as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\tags\GalleryDataSourceTag;

class GalleryTag extends Document {

   public function __construct() {
      Document::addTagLib(
         'VENDOR\tags\GalleryDataSourceTag',
         'gallery',
         'datasource'
      );
   }

   ...

}
</gen:highlight>
<p>
   Within the constructor the <em>&lt;gallery:datasource /&gt;</em> tag is published to the parser. In this case,
   global registration is used. This allows usage of the tag within all levels of the DOM tree and within all templates.
</p>
<div class="hint">
   Registration of tags can be done within your bootstrap file as we are using static (=global) registration in this case.
   This means that the point in time is relevant rather than the place of registration. According to the
   <int:link pageid="098" anchor="Chapter-2-1-Timing-model">timing Model</int:link> the constructor of the
   <em>GalleryTag</em> class is executed before children are being analyzed. With this knowledge registering tag
   implementations can be encapsulated with the component it self and thus allow ease usage.
</div>

<h5 id="Chapter-5-2-2-Configuration-of-the-content-provider"><a href="#Chapter-5-2-2-Configuration-of-the-content-provider">5.2.2. Configuration of the content provider</a></h5>
<p>
   Let us now turn to the configuration of the <em>Content-Providers</em>. To be able to configure the provider freely,
   the <em>&lt;img:gallery /&gt;</em> tag is added a private member plus getter and setter. This enables the
   <em>&lt;gallery:datasource /&gt;</em> tag to apply the instance of the provider:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\..\ImageGalleryContentProvider;

class GalleryTag extends Document {

   private $contentProvider;

   ...

   public function setContentProvider(ImageGalleryContentProvider $provider) {
      $this->contentProvider = $provider;
   }

   ...

}
</gen:highlight>
<p>
   The provider itself is defined by the following interface:
</p>
<gen:highlight type="php">
interface ImageGalleryContentProvider {
   /**
    * @return GalleryImage[]
    */
   public function getImages();
}

class GalleryImage {

   private $title;
   private $description;
   private $imageUrl;

   public function __construct($title, $description, $imageUrl) {
      $this->title = $title;
      $this->description = $description;
      $this->imageUrl = $imageUrl;
   }

   public function getDescription() {
      return $this->description;
   }

   public function getImageUrl() {
      return $this->imageUrl;
   }

   public function getTitle() {
     return $this->title;
   }

}
</gen:highlight>
<p>
   Within our current sample the <em>&lt;gallery:datasource /&gt;</em> tag creates the desired provider and passes it
   to the <em>GalleryTag</em>. This functionality can be implemented within the <em>onAfterAppend()</em> method, because
   at time of execution of this method the father node is initialized:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\tags\GalleryTag;

class GalleryDataSourceTag extends Document {

   public function onAfterAppend() {
      $provider = &$this->getServiceObject(
         $this->getAttribute('class')
      );
      /* @var $parent GalleryTag */
      $parent = &$this->getParentObject();
      $parent->setContentProvider($provider);
   }

   public function transform() {
      return '';
   }

}
</gen:highlight>
<p>
   Within the <em>onAfterAppend()</em> method the desired provider is created using the
   <int:link pageid="107" anchor="Chapter-3-2-1-ServiceManager-Simple-services">ServiceManager</int:link>
   to automatically pass context and language to the instance. After that, the father element of the tag - an instance
   of the <em>GalleryTag</em> class as stated by the IDE type hint - is injected the provider.
</p>
<p>
   The <em>transform()</em> method ensures, that no additional children are transformed and that the tag generates no
   output. This is not necessary here.
</p>

<h5 id="Chapter-5-2-3-Parsing-the-GalleryDataSourceTag"><a href="#Chapter-5-2-3-Parsing-the-GalleryDataSourceTag">5.2.3. Parsing the GalleryDataSourceTag</a></h5>
<p>
   In order to enable the <em>GalleryDataSourceTag</em> to create and inject the gallery content provider the
   <em>GalleryTag</em> has to publish the tag to be caught and executed by the page controller. To create an instance
   of the tag, the page controller brings the <em>Document::extractTagLibTags()</em> method inherited from the
   <em>Document</em> class.
</p>
<p>
   The point in time when this method is called is subjected to your decision. To ensure proper functionality, please
   keep the
   <int:link pageid="098" anchor="Chapter-2-1-Activity-diagram">Activity diagram of the page controller</int:link>
   in mind to choose the correct point in time. In our use case it is important to create and inject the provider
   <em>before</em> creation of the gallery's content. Hence, there are three possibilities:
</p>
<ul>
   <li>Within the <em>onParseTime()</em> method.</li>
   <li>Within the <em>onAfterAppend()</em> method.</li>
   <li>At the beginning of the <em>transform()</em> method.</li>
</ul>
<p>
   It is recommended to use the <em>onParseTime()</em> method to analyze child node structures to give other nodes the
   chance to be created in correct chronological order, too.
</p>
<p>
   In order to create and execute the <em>GalleryDataSourceTag</em> you might want to use the following code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   ...

}
</gen:highlight>
<p>
   Everything else is done by the APF parser according to the content of the template.
</p>

<h5 id="Chapter-5-2-4-Output-creation"><a href="#Chapter-5-2-4-Output-creation">5.2.4. Output creation</a></h5>
<p>
   The output of the image gallery is created within the <em>transform()</em> function that is called by the page
   controller during transformation of the tree. This method is intended to arrange the images thaat are delivered by
   the provider.
</p>
<p>
   Assuming that all images should be rendered as an unordered list including image and description the
   <em>transform()</em> method looks like this:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
            . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
            . '<p>' . $image->getDescription() . '</p>'
            . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);
   }

}
</gen:highlight>
<p>
   The above implementation displays the images as list elements below the static content contained in the
   <em>&lt;img:gallery /&gt;</em> tag.
</p>
<div class="hint">
   In case static content is not allowed within a custom tag it may be overwritten by <em>setContent()</em>. You can
   overwrite static content with content that has been generated dynamically during a <em>transform()</em> call.
</div>
<div class="hint">
   In order to place the content of your tag correctly during transformation the <em>extractTagLibTags()</em> method
   generates place holders such as <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Thereby,
   <em>{OBJECT_ID}</em> contains the value of the class member <em>$this->objectId</em> and the array offset the child
   node is stored in (<em>$this->children</em>). This value can be used to (re)place the content of the child tag
   within custom <em>transform()</em> implementations.
</div>
<p>
   In case of the <em>&lt;img:gallery /&gt;</em> tag the children should not generate output themselves because this is
   done by the <em>GalleryDataSourceTag::transform()</em> function. Since the APF parser always places place holders to
   be able to position the content during transformation, these place holders must be removed anyway. This can be done
   by the following code:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
         . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
         . '<p>' . $image->getDescription() . '</p>'
         . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);

      foreach ($this->children as $objectId => $DUMMY) {
         $this->content = str_replace(
            '<' . $objectId . ' />',
            $this->children[$objectId]->transform(),
            $this->content
         );
      }
   }

}
</gen:highlight>

<h4 id="Chapter-5-3-Document-API"><a href="#Chapter-5-3-Document-API">5.3. Document API</a></h4>
<p>
   Implementing tag logic the APF provides several methods. They include parsing tag structures, accessing the DOM tree
   and manipulating or reading tag information. These are:
</p>
<ul>
   <li>
      <strong>extractTagLibTags()</strong>:
      Analyzes known child tags and creates the respective DOM tree.
   </li>
   <li>
      <strong>extractExpressionTags()</strong>:
      Analyzes and interprets APF pseudo template expressions and creates the respective DOM tree elements. Please note
      the hints under <int:link pageid="047" anchor="Chapter-3-Extended-templating" /> on how to use the
      expressions. Further details can also be found in proposal
      <a class="wiki" href="${getBaseUrl(WikiBaseURL)}/Erweitertes_Templating/en">Extended templating</a>.
   </li>
   <li>
      <strong>getParentObject()</strong>:
      Returns the instance of the father node within the DOM tree. In case no father is present, <em>null</em> is
      returned.
   </li>
   <li>
      <strong>setParentObject()</strong>:
      Injects the father node of the current item.
   </li>
   <li>
      <strong>getChildren()</strong>:
      Returns the list of all children. In case no child nodes are available an empty list is returned.
   </li>
   <li>
      <strong>getContent()</strong>:
      Returns the content of the DOM element invoked.
   </li>
   <li>
      <strong>setContent()</strong>:
      Writes the content of the DOM element.
   </li>
   <li>
      <strong>getChildNode()</strong>:
      Returns a child node specified by an applied selector.
   </li>
   <li>
      <strong>getChildNodes()</strong>:
      Returns several child nodes specified by an applied selector.
   </li>
   <li>
      <strong>getAttribute()</strong>:
      Returns the value of an attribute.
   </li>
   <li>
      <strong>setAttribute()</strong>:
      Defines the value of an attribute.
   </li>
   <li>
      <strong>getAttributes()</strong>:
      Returns the list of attributes.
   </li>
   <li>
      <strong>getAttributesAsString()</strong>:
      Generates an XML string representation of the given attributes using an optional whitelist.
   </li>
</ul>
<p>
   Further methods of the <em>Document</em> class or the base class of your current tag can be taken from the
   <int:link pageid="002"/>.
</p>

<h3 id="Chapter-6-The-APF-parser"><a href="#Chapter-6-The-APF-parser">6. The APF parser</a></h3>

<h4 id="Chapter-6-1-Features"><a href="#Chapter-6-1-Features">6.1. Features</a></h4>
<p>
   The APF parser includes the following capabilities:
</p>
<ul>
   <li>
      The parser is able to resolve symmetric and asymmetric structures of self-closing and explicit-closing tags as
      well as nested structures. Example:
<gen:highlight type="apf-xml">
<foo:bar>
   ...
   <foo:bar>
      ...
   </foo:bar>
   ...
   <foo:bar />
   ...
</foo:bar>
<foo:bar>
   ...
   <zig:zag>
      ...
      <foo:bar />
      ...
   </zig:zag>
   ...
</foo:bar>
</gen:highlight>
      It resolves tags with the same combination of prefix and name as well as different and assigns them to the right
      level of hierarchy within the APF DOM tree.
   </li>
   <li>
      Registered XML tags can be (re-)used at any level using the defined prefix and name. The parser assigns to the
      DOM tree according to the placement within the respective template.
   </li>
   <li>
      Processing content is subjected to the tag implementation. This applies especially to the tag content (static
      content and further tags). It allows you to decide freely how the content should be treated at implementation time.
      With this approach you can easily influence the construction of the APF DOM tree or display content only if certain
      conditions apply.
   </li>
</ul>
<p>
   Moreover, the APF parser implements the concept of the APF <int:link pageid="098" /> and is responsible for creating
   the DOM tree.
</p>

<h4 id="Chapter-6-2-Restrictions"><a href="#Chapter-6-2-Restrictions">6.2. Restrictions</a></h4>
<p>
   For performance and consistency reasons the APF parser contains several restrictions compared to a &quot;real&quot;
   XML parser. These are:
</p>
<ul>
   <li>Tag attributes must be separated by blanks. Tab signs are not allowed.</li>
   <li>
      Tags are not allowed as attribute values. Using such definitions will lead to a <em>ParserException</em>!
   </li>
   <li>The content of tag attributes must be delimited by double quotes.</li>
   <li>
      The definition of a tag will only be recognized by the APF parser in case tag declaration and attributes are
      separated by space. This is especially important for multi-line tag definitions with nested tags. The following
      example cannot be evaluated by the APF parser:
<gen:highlight type="apf-xml">
&lt;form:recaptcha
name="my-captcha"&gt;
   &lt;recaptcha:getstring
      ...
   /&gt;
&lt;/form:recaptcha&gt;
</gen:highlight>
      In order to fix the <em>ParserException</em> you can either add a blank behind <em>&lt;form:recaptcha</em> or
      place the <em>name</em> attribute on the same line as <em>&lt;form:recaptcha</em>.
<div class="hint">
   This error occurs especially with IDEs that remove unnecessary blanks at the end of HTML files automatically.
</div>
   </li>
   <li>
      Only APF tags can be processed. Simple HTML tags are not covered and it may be necessary to provide wrapper
      implementations for an abstraction purpose.
   </li>
   <li>
      To make reading template files fast tag prefixes und names are limited to <strong>10 characters</strong>!
   </li>
</ul>

<h3 id="Chapter-7-Examples"><a href="#Chapter-7-Examples">7. Examples</a></h3>
<p>
   This chapter contains implementation examples for tags that you may use as a basis for your day-to-day work or as a
   coding guideline. As a rule of thumb, please note:
</p>
<div class="hint">
   Implementing a tag is only necessary in case you are not able to realize your requirements with a
   <int:link pageid="047"/> - including all <int:link pageid="046" /> - and a <int:link pageid="006" /> (e.g. manipulation
   of the DOM tree). Moreover, it is recommended to write tags for functionality that is used within several templates
   or multiple projects especially to support code de-duplication and avoid huge inheritance structures of document
   controllers.
</div>

<h4 id="Chapter-7-1-Simple-tag-with-attributes"><a href="#Chapter-7-1-Simple-tag-with-attributes">7.1. Simple tag with attributes</a></h4>
<p>
   As an example, this chapter will use the <em>&lt;html:text /&gt;</em> tag. It outputs a language dependent text
   identified by the applied key. Example:
</p>
<gen:highlight type="apf-xml">
&lt;html:text key="log-in.mousover.text" /&gt;
</gen:highlight>
<p>
   The implementation of the tag contains the processing of the attribute and the output of the text at transformation
   time. This can be done as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class TranslationTextTag extends Document {

   public function transform() {
     return gettext($this->getAttribute('key'));
   }

}
</gen:highlight>
<p>
   In case attributes should be included in the output generation you may want to use the
   <em>getAttributesAsString()</em> method. As an example, let us take a tag that creates an image tag from an image
   of an external asset management referred to by an external id:
</p>
<gen:highlight type="apf-xml">
&lt;html:img
   key="IMG-12345"
   width="100"
   height="120"
   alt="This image contains a red car"
/&gt;
</gen:highlight>
<p>
   The implementation may look like this:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class MAMImageTag extends Document {

   public function transform() {

      $width = $this->getAttribute('width', '50');
      $height = $this->getAttribute('height', '50');
      $key = $this->getAttribute('key');

      $whiteList = array(
         'alt',
         'height',
         'width',
         'id',
         'style',
         'title'
      );

      return '<img src="'
            . $this->getImageUrl($key, $width, $height) . '" '
            . $this->getAttributesAsString($this->getAttributes(), $whiteList)
            . ' />';
   }

   private function getImageUrl($key, $width, $height) {
     ...
   }

}
</gen:highlight>
<p>
   Within the above code box <em>getAttribute()</em> is used to read the values of the desired tag attributes. Since
   some of the values should be re-used for output generation a white list - in this case a list of XHTML or HTML5
   compatible attributes - is passed to the <em>getAttributesAsString()</em> method together with the attributes of the
   tag. The result of the tag is then an image tag that can be formatted using the <em>id</em>, <em>style</em>, and
   <em>class</em> (HTML) attributes.
</p>
<div class="hint">
   In case you want to mark the <em>key</em> attribute as mandatory you may want to use the
   <em>Document::getRequiredAttribute()</em> method to retrieve it's value. This method throws a
   <em>InvalidArgumentException</em> in case the attribute has not been defined. This eases implementation and executes
   the necessary checks for you internally.
</div>

<h4 id="Chapter-7-2-Simple-tag-with-content"><a href="#Chapter-7-2-Simple-tag-with-content">7.2. Simple tag with content</a></h4>
<p>
   Besides the attributes a tag can define simple or complex content. As an implementation sample for this chapter, we
   are using the following tag definition:
</p>
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
<p>
   As the tag's output we expect an e-mail address that is encoded with HTML entities to protect it against bots or
   spiders. To encode the e-mail address, the content of the tag must be read during transformation. The implementation
   is as follows:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use APF\tools\string\StringAssistant;

class EntityEncodeTag extends Document {

   public function transform() {
      return StringAssistant::encodeCharactersToHTML($this->getContent());
   }

}
</gen:highlight>
<p>
   Using the <em>getContent()</em> function you can access the content of the tag. The content - in this case an e-mail
   address - is then encoded to HTML entities using the <em>StringAssistant</em>.
</p>

<h4 id="Chapter-7-3-Accessing-the-DOM-tree"><a href="#Chapter-7-3-Accessing-the-DOM-tree">7.3. Accessing the DOM tree</a></h4>
<p>
   As noted in <a href="#Chapter-1-Introduction">chapter 1</a> the <int:link pageid="098" /> creates a DOM tree from the
   template files and the tags contained there. You may compare this behaviour - except the way of creation - to a
   browser that creates a DOM tree from the received HTML document to create a graphical representation.
</p>
<p>
   Since tags and <int:link pageid="006" /> are part of the tree you can access all surrounding nodes. To do so, you
   may use the following methods:
</p>
<ul>
   <li><em>getParentObject()</em></li>
   <li><em>getChildren()</em></li>
</ul>
<p>
   Within a tag you can directly use those methods to traverse surrounding elements, in case of a <int:link pageid="006" />
   you need to refer to the current DOM node using the <em>getDocument()</em> function. Having the current document you
   can proceed as noted before.
</p>
<p>
   As an example for this chapter, please note the following template:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\..\TemplateNameDisplayTag"
   prefix="template"
   name="display-name"
/&gt;
&lt;html:template name="test1"&gt;
   ...
&lt;/html:template&gt;
&lt;html:template name="test2"&gt;
   ...
   &lt;template:display-name /&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   The <em>TemplateNameDisplayTag</em> is intended to display the name of all templates, that are located on the same
   level as the tag's father. This can be done with the subsequent implementation:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class TemplateNameDisplayTag extends Document {
   public function transform() {
      $template = &$this->getParentObject();
      $grandFather = &$template->getParentObject();

      $nodes = $grandFather->getChildren();

      $buffer = '<ul>';
      foreach ($nodes as $objectId => $DUMMY) {
         $buffer .= '<li>' . $nodes[$objectId]->getAttribute('name') . '</li>';
      }

      return $buffer . '</ul>';
   }
}
</gen:highlight>
<p>
   Please refer to
   <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=1152">Placeholder über Taglib füllen</a>
   (German) for further examples.
</p>

<h4 id="Chapter-7-4-Complex-tag-with-attributes-and-content"><a href="#Chapter-7-4-Complex-tag-with-attributes-and-content">7.4. Complex tag with attributes and content</a></h4>
<p>
   The previous chapters dealt with accessing attributes, output of attributes and the access and processing of tag
   content. Now, we will have a look at a more complex structure that includes deeper hierarchies, tag content, and
   attributes in their tag logic.
</p>
<p>
   As an example the following template is used as a basis. It displays navigation nodes of type
   <em>NavigationNode</em>:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="APF\extensions\navigation\pres\tags\NavigationNodeTag"
   prefix="navi"
   name="template"
/&gt;
&lt;navi:template id="main-navi"&gt;&lt;!-- NavigationNodeTag --&gt;
   &lt;navi:item status="active"&gt;&lt;!-- NavigationItemTag --&gt;
      &lt;li class="active"&gt;
         &lt;item:content/&gt;&lt;!-- ItemTemplateContentTag --&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;
   &lt;navi:item status="inactive"&gt;
      &lt;li&gt;
         &lt;item:content/&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;

   &lt;ul id="main-navigation"&gt;
      &lt;navi:content/&gt;&lt;!-- NavigationContentTag --&gt;
   &lt;/ul&gt;
&lt;/navi:template&gt;
</gen:highlight>
<p>
   The tag is initialized/filled within a <int:link pageid="006" /> and displays a list of child elements of the applied
   navigation node according to the defined formatting. Thereby, the <em>&lt;navi:item /&gt;</em> tags describe the
   active and inactive status of the navigation nodes and the <em>&lt;navi:content/&gt;</em> let's you place the output
   into the desired HTML skeleton. <em>&lt;item:content/&gt;</em> places the output of a dedicated navigation node and
   allows you to add custom HTML. To easily remember the tag hierarchy and the corresponding tags, the above template
   contains the tag implementation class names as HTML comment.
</p>
<p>
   To fill the <em>&lt;navi:template /&gt;</em> tag within a template the following controller can be used:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;
use APF\extensions\navigation\biz\SimpleNavigationNode;

class NavigationTagExampleController extends BaseDocumentController {
   public function transformContent() {
      $root = new SimpleNavigationNode(null, null, null);
      $levelOne = new SimpleNavigationNode('Level 1', '#');

      $root->setChildren(array(
         clone $levelOne->setInactive(),
         clone $levelOne->setActive(),
         clone $levelOne->setInactive()
      ));

      $navi = $this->getDocument()->getChildNode('id', 'main-navi', 'NavigationNodeTag');
      $navi->setNode($root);
   }
}
</gen:highlight>
<p>
   The subsequent code box contains the tag implementation:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

interface NavigationNode {
   public function getLabel();
   public function getUrl();
   public function isActive();
   public function getParent();
   public function getChildren();
}

class SimpleNavigationNode implements NavigationNode {

   private $label;
   private $url;
   private $isActive = false;
   private $parent;
   private $children = array();

   public function __construct($label, $url) {
      $this->label = $label;
      $this->url = $url;
   }

   public function getLabel() {
      return $this->label;
   }

   public function getUrl() {
      return $this->url;
   }

   public function isActive() {
      return $this->isActive;
   }

   public function setActive() {
      $this->isActive = true;
      return $this;
   }

   public function setInactive() {
      $this->isActive = false;
      return $this;
   }

   public function getParent() {
      return $this->parent;
   }

   public function getChildren() {
      return $this->children;
   }

   public function setParent(NavigationNode $node) {
      $this->parent = $node;
   }

   public function setChildren(array $nodes) {
      $this->children = $nodes;
   }

}

class NavigationNodeTag extends Document {

   private $node;

   public function __construct() {
      self::addTagLib('EXAMPLE\navigation\pres\taglibs\NavigationItemTag', 'navi', 'item');
      self::addTagLib('EXAMPLE\navigation\pres\taglibs\NavigationContentTag', 'navi', 'content');
   }

   public function setNode(NavigationNode $node) {
      $this->node = $node;
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function transform() {

      $buffer = '';

      $navigationNodes = $this->node->getChildren();
      if (count($navigationNodes) > 0) {
         foreach ($navigationNodes as $node) {
            $buffer .= $this
               ->getTemplate($node->isActive() ? 'active' : 'inactive')
               ->getOutput($node);
         }
      }

      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof NavigationContentTag) {
            // fill the navi:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $buffer, $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }

      return $content;
   }

   private function getTemplate($status) {
      return $this->getChildNode('status', $status, 'NavigationItemTag');
   }

}

class NavigationItemTag extends Document {

   public function __construct() {
      self::addTagLib('EXAMPLE\navigation\pres\taglibs\ItemTemplateContentTag', 'item', 'content');
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function getOutput(NavigationNode $node) {
      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof ItemTemplateContentTag) {
            // fill the item:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $children[$objectId]->setNode($node)->transform(), $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }
      return $content;
   }

   public function transform() {
      return '';
   }

}

class ItemTemplateContentTag extends Document {

   private $node;

   public function setNode(NavigationNode $node) {
      $this->node = $node;
      return $this;
   }

   public function transform() {
      if ($this->node === null) {
         return '';
      }
      return '<a href="' . $this->node->getUrl() . '">' . $this->node->getLabel() . '</a>';
   }

}

class NavigationContentTag extends Document {
}
</gen:highlight>
<div class="warn">
   The above code sample is intended to show the APF's capabilities and is no reference implementation for navigation
   creation.
</div>

<h3 id="Chapter-8-Further-links"><a href="#Chapter-8-Further-links">8. Further links</a></h3>
<p>
   In case you need further information on writing tags, please refer to the following forum threads:
</p>
<ul>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=1126">TagLib unterschiedliche Zustände</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=827">Taglib der Template rundherum läd</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=505">Mehrere Checkboxes taglib aus DB holen und ausgeben</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=456">Taglib-Call innerhalb eines Taglib-Call</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=191">transform() von eigenem taglib nicht ausgeführt</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=177">Menü taglib-modul</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=122">Performance TagLibs</a> (German)</li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=37">Taglibs vs. Templates</a> (German)</li>
</ul>
<p>
   The APF wiki contains the following pages on APF tags:
</p>
<ul>
   <li><a class="wiki" href="${getBaseUrl(WikiBaseURL)}/All-in-one_Include-Tag">All-in-one Include-Tag</a> (German)</li>
   <li><a class="wiki" href="${getBaseUrl(WikiBaseURL)}/Timing-Modell_des_Page-Controller">Timing-Modell des Page-Controller</a> (German)</li>
   <li><a class="wiki" href="${getBaseUrl(WikiBaseURL)}/WYSIWYG_%2B_APF-Formulare">WYSIWYG + APF-Formulare</a> (German)</li>
</ul>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="en_147" />