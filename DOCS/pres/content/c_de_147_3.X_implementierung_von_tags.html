<doku:title parent="100" tags="taglib,taglibs,tag,parser" title="Implementierung von Tags" urlname="Implementierung-von-Tags">
   Dieses Kapitel beschreibt die Bedeutung und die Implementierung von eigenen Tags/Taglibs mit dem APF.
</doku:title>

<h3 id="Chapter-1-Einfuehrung"><a href="#Chapter-1-Einfuehrung">1. Einführung</a></h3>
<p>
   Dieses Kapitel widmet sich den APF-Tags (a.k.a. Taglibs), deren Bedeutung und Implementierung.
</p>
<p>
   Der <int:link pageid="098"/> basiert auf dem gleichnamigen Software-Entwurfsmuster und ist ein zentraler Bestandteil
   des APF. Er ermöglicht dem Entwickler über das Tag-Konzept, eigene Funktionalitäten zur Erzeugung und Transformation
   des HMVC-DOM-Baumes zu injizieren. Tags bilden damit nicht nur die Basis des APF-HMVC-Konzepts, sondern können auch
   zur Erweiterung desselben genutzt werden.
</p>
<p>
   Des Weiteren können Tags dazu verwendet werden um darin enthaltene Funktionalitäten in unterschiedlichen Projekten
   wiederzuverwenden. APF-Templates verarbeiten - als Schutz vor unkontrollierter Verteilung von Logik - lediglich Tags
   und keinen PHP-Code. Damit ist automatisch sichergestellt, dass View-Logik lediglich in Tags oder Controller enthalten
   sein kann.
</p>

<h4 id="Chapter-1-1-Page-Controller"><a href="#Chapter-1-1-Page-Controller">1.1. Page-Controller</a></h4>
<p>
   Aufgabe des <int:link pageid="098"/> ist der Aufbau und die Transformation der internen Template-Struktur.
   Hierzu bietet er ein Tag-API, die einem definierten Timing-Modell folgend Tags einliest, daraus Dokumente im Baum
   erzeugt und aus dem Baum anschließend eine HTML-Ausgabe erzeugt. Andere Formate wie beispielsweise XML sind ebenfalls
   möglich. Der Parser ist kein &quot;echter&quot; XML-Parser, beherrscht jedoch die Auflösung von explizit- und
   selbst-schließenden Tags sowie die Schachtelung von Tags in beliebig tiefen Hierarchien.
</p>
<div class="warn">
   Bitte beachten Sie die Hinweise im Kapitel <a href="#Chapter-6-Der-APF-Parser">Der APF-Parser</a> zu den Restriktionen
   des Parsers.
</div>
<p>
   Die mit dem APF ausgelieferten <int:link pageid="046"/> bieten bereits eine Reihe an Standard-Funktionalitäten wie
   das Einbinden einer weiteren Template-Datei, die Definition von wiederverwendbaren Template-Fragmenten und das
   Bekanntgeben von eigenen Tags an.
</p>

<h4 id="Chapter-1-2-XML-Parser"><a href="#Chapter-1-2-XML-Parser">1.2. XML-Parser</a></h4>
<p>
   Der <em>XMLParser</em> dient dem Page-Controller zur Analyse einer Tag-Definition im Template und wird bei der
   Erstellung von <em>Document</em>-Instanzen genutzt.
</p>
<div class="warn">
   Der <em>XMLParser</em> verarbeitet aus Performance-Gründen nur durch Leerzeichen getrennte Attribute. Die Werte von
   Attributen müssen mit doppelten Anführungszeichen umschlossen sein.
</div>

<h3 id="Chapter-2-Definition-eines-Tags"><a href="#Chapter-2-Definition-eines-Tags">2. Definition eines Tags</a></h3>
<p>
   Ein APF-Tag definiert sich durch folgende Bestandteile:
</p>
<ul>
   <li>
      <strong>Prefix</strong>: das <em>Prefix</em> des Tags dient im Allgemeinen zur Strukturierung der Tags in Gruppen
      (z.B. <em>core</em> für Tags, die mit dem APF mitgeliefert werden). Dieser Teil ist mit XML-Namespaces vergleichbar.
   </li>
   <li>
      <strong>Name</strong>: der <em>Name</em> des Tags bezeichnet den Tag selbst. Dieser Teil ist mit XML-Tag-Namen
      vergleichbar.
   </li>
   <li>
      <strong>Attribute</strong>: die Attribute des Tags können zur Konfiguration des Tags genutzt werden. Sie dürfen
      keine weiteren Tags enthalten.
   </li>
   <li>
      <strong>Inhalt</strong>: der Inhaltsbereich des Tags kann weitere Tags oder Text enthalten. Der APF-Parser löst
      dort enthaltene Tags entsprechend auf und hängt diese als Kinder in die aktuelle Hierarchie ein. Einfacher Text
      ist später ebenfalls in der Tag-Instanz verfügbar.
   </li>
</ul>
<p>
   Folgende Tag-Definition könnte zur Ausgabe des aktuellen Datums in einem Template genutzt werden:
</p>
<gen:highlight type="apf-xml">
<current:date format="H:i" />
</gen:highlight>
<p>
   Dabei ist <em>current</em> das Prefix des Tags, <em>date</em> der Name und das Attribut <em>format</em> beinhaltet
   das Ausgabe-Format. Der Tag definiert keinen Inhalt.
</p>
<p>
   Zur Darstellung einer Bildergalerie könnte folgendes Tag genutzt werden:
</p>
<gen:highlight type="apf-xml">
<img:gallery>
   <h3>Mein Urlaub 2012</h3>
   <p>
      Diese Bilder stammen aus meinem Urlaub im Jahr 2012:
   </p>
   <gallery:datasource
      namspace="..."
      class="..."
   />
</img:gallery>
</gen:highlight>
<p>
   In diesem Beispiel beinhaltet der <em>&lt;img:gallery /&gt;</em>-Tag statisches HTML, was später zur Formatierung der
   Ausgabe genutzt werden kann und einen weiteren Tag zur Angabe der Datenquelle (z.B. aus einer Datenbank). Zur
   Verwendung des Tags muss auch dieses zunächst dem APF-Parser bekannt gegeben werden.
</p>

<h3 id="Chapter-3-DOM-Struktur"><a href="#Chapter-3-DOM-Struktur">3. DOM-Struktur</a></h3>
<p>
   Wie im Kapitel <a href="#Chapter-1-1-Page-Controller">Kapitel 2</a> angesprochen erzeugt der <int:link pageid="098"/>
   aus der Tag-Struktur in den Template-Dateien einen DOM-Baum. Dieser ähnelt dem eines Browsers, der aus den HTML-Tags
   ebenfalls eine Speicherstruktur erzeugt.
</p>
<p>
   Der Unterschied zur DOM-Struktur eines Browsers besteht darin, dass die einzelnen Knoten jeweils eigene Funktionalität
   zur Transformation bzw. Darstellung beinhalten, die der Page-Controller während der Transformationsphase nutzt. Details
   zum Timing-Modell des Page-Controller finden Sie <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">hier</int:link>.
</p>
<p>
   Jeder Tag - bzw. ab einem definierten Zeitpunkt seine Instanz - durchläuft einen definierten Zyklus. Zunächst wird
   die Struktur des Tags analysiert, dann seine Substanz (Attribute und Inhalt). Anschließend wird gemäß der
   Tag-Definition  eine Instanz des Tags erstellt und mit dem vom <em>XMLParser</em> analysierten Inhalt initialisiert.
</p>
<div class="hint">
   <p>
      Der Page-Controller verarbeitet alle Tags der Form
   </p>
<gen:highlight type="apf-xml">
&lt;prefix:name /&gt;
</gen:highlight>
   <p>
      (selbstschließend) bzw.
   </p>
<gen:highlight type="apf-xml">
&lt;prefix:name&gt;&lt;/prefix:name&gt;
</gen:highlight>
   <p>
      (explizit schließend), die in einer Template-Datei definiert sind. Gemäß
      <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a> können Tags eine beliebige Anzahl von Attributen
      beinhalten.
   </p>
   <p>
      Bei der Analyse eines Templates greift der APF-Parser auf die Liste der registrierten Tags zurück um die
      Tag-Instanzen zu erstellen. Diese Liste beinhaltet den Klassen-Namen, der die Implementierung eines Tags beschreiben.
      Die mit dem APF mitgelieferten Tags werden bereits in der <em>bootstrap.php</em> registriert.
   </p>
   <p>
      Tags lassen sich sowohl statisch für <strong>alle Templates</strong> als auch dynamisch <strong>pro DOM-Knoten</strong>
      registrieren. Dies ermöglicht es, die für ein Projekt eingesetzten Tags an einer zentralen Stelle zu registrieren
      und gleichzeitig - sofern notwendig - Standard-Tags des APF lokal überschreiben.
   </p>
</div>
<div class="hint">
   <p>
      Möchten Sie einen Tag für das gesamte Projekt registrieren, lässt sich das sehr einfach in der Bootstrap-Datei
      erledigen:
   </p>
<gen:highlight type="php">
Document::addTagLib('VENDOR\..\DateDisplayTag', 'date', 'display');
</gen:highlight>
   <p>
      Soll ein Tag für einen dedizierten DOM-Knoten registriert werden, so lässt sich dies in einer Tag-Implementierung
      wie folgt erreichen:
   </p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class MyTag extends Document {

   public function __construct() {
      $this->addInstanceTagLib('VENDOR\..\SpecialDateDisplayTag', 'date', 'display');
   }

}
</gen:highlight>
   <p>
      Wird der <em>&lt;date:display /&gt;</em>-Tag innerhalb des Projektes eingesetzt, so erzeugt der APF-Parser eine
      Instanz der Klasse <em>DateDisplayTag</em>. Wird er innerhalb von <em>MyTag</em> eingesetzt, so erzeugt der
      APF-Parser eine <em>SpecialDateDisplayTag</em>-Instanz.
   </p>
   <p>
      Innerhalb eines Templates lassen sich eigene Tags mit Hilfe des <em>&lt;core:addtaglib /&gt;</em>-Tag hinzufügen.
      Auch hier haben Sie die Möglichkeit, den Tag für alle Templates oder nur für den aktuelle DOM-Knoten zu registrieren.
      Details hierzu finden Sie in Kapitel <int:link pageid="046" anchor="Chapter-1-1-Addtaglib" />.
   </p>
</div>
<div class="warn">
   Bitte beachten Sie, dass der APF-Parser alle XML-Tags der Form <em>&lt;prefix:name &gt;</em> verarbeitet. Dies kann
   ggf. zu Problemen führen, wenn Sie beabsichtigen, Namespace-behaftete XML-Tags direkt in den HTML-Quelltext zu schreiben.
   Nutzen Sie beispielsweise die alte Notation für die Einbindung von <em>Google +1</em> über
<gen:highlight type="apf-xml">
&lt;g:plusone&gt;&lt;/g:plusone&gt;
</gen:highlight>
   so wird der APF-Parser dies mit einer fehlenden Tag-Definition quittieren. In solchen Fällen empfiehlt es sich auf
   alternative Notationen auszuweichen oder einen Wrapper-Tag für die Ausgabe zu implementieren.
</div>

<h3 id="Chapter-4-Klassenstruktur-eines-Tags"><a href="#Chapter-4-Klassenstruktur-eines-Tags">4. Klassenstruktur eines Tags</a></h3>
<p>
   Die Struktur eines Tags beschreibt die Klasse <em>Document</em>. Diese ist die Mutter aller Tag-Implementierungen des
   APF und definiert eine Reihe von Methoden, die innerhalb des Timing-Modells des Page-Controllers zu unterschiedlichen
   Zwecken aufgerufen werden.
</p>
<p>
   Die Signatur de Klasse <em>Document</em> ist wie folgt (gekürzt):
</p>
<gen:highlight type="php">
class Document extends APFObject {

   protected $objectId = null;
   protected $parentObject = null;
   protected $children = array();
   protected $content;

   protected static $knownTags = array();
   protected $knownInstanceTags = array();
   protected static $knownExpressions = array();

   protected $data = array();

   protected static $documentIndex = array();

   public function __construct() {
   }

   public function onParseTime() {
   }

   public function onAfterAppend() {
   }

   public function transform() {
   }

}
</gen:highlight>
<p>
   Den aufgeführten Elementen kommt dabei folgende Bedeutung zu:
</p>
<ul>
   <li>
      Im Feld <em>objectId</em> wird die eindeutige interne Objekt-Id gespeichert, die jeder Tag vom APF-Parser bei
      Erzeugen erhält. Diese wird u.a. bei der Vergabe von <int:link pageid="004"/>-Tags genutzt um jedes DOM-Element
      eindeutig zu referenzieren.
   </li>
   <li>
      <em>parentObject</em> referenziert auf das Vater-Objekt innerhalb des DOM-Baumes. Diese Referenz kann zur
      Traversierung des DOM-Baumes genutzt werden. Der Root-Knoten hat keinen Vater.
   </li>
   <li>
      In der Liste <em>children</em> finden sich alle Kind-Knoten des aktuellen DOM-Elements. Diese Liste kann zur
      Traversierung des DOM-Baumes genutzt werden. Hat ein DOM-Knoten keine Kinder, ist die Liste leer.
   </li>
   <li>
      Die Variable <em>content</em> beinhaltet den textuellen Inhalt eines Tags und die Platzhalter, die der
      Page-Controller bei der Erzeugung des DOM-Baumes hinterlässt um den exakten Zusammenbau des HTML-Quelltextes
      sicher zu stellen.
   </li>
   <li>
      In der Variable <em>attributes</em> - aus der Klasse <em>APFObject</em> vererbt - findet sich eine assoziative
      Liste der Tag-Attribute wieder. Besitzt das Tag keine Attribute, ist die Liste leer.
   </li>
   <li>
      Die (statische) <em>knownTags</em>-Liste beinhaltet die für <em>alle Templates</em> bekannte Tags. Findet der
      APF-Parser in einem Template einen Tag nach der für ihn bekannten Syntax, wird diese Liste genutzt um an Hand des
      Tag-Präfix und -Namens die korrespondierende Implementierung (voll qualifizierter Klassen-Name) zu finden.
   </li>
   <li>
      Die <em>knownInstanceTags</em>-Liste speichert ebenfalls eine Liste aus Tag-Präfix und -Namen sowie der zu
      nutzenden Tag-Implementierung. Diese besitzt allerdings nur im aktuellen DOM-Knoten Gültigkeit. Findet der
      APF-Parser für den aktuellen DOM-Knoten eine lokale Tag-Definition, so wird diese der globalen vorgezogen.
      Zur Überschreibung von z.B. mit dem APF ausgelieferten Tag-Implementierungen lässt sich die Methode
      <em>Document::addInstanceTagLib()</em> nutzen. Diese befüllt im Gegensatz zur statischen Methode
      <em>Document::addTagLib()</em> die oben genannte Liste.
      <div class="warn">
         Bitte beachten Sie, dass der APF-Parser bei Kind-Tags des aktuellen DOM-Knotens wieder auf die globale Liste
         zurück greift. Eine rekursive Vererbung von Überschreibungen ist nicht vorgesehen.
      </div>
   </li>
   <li>
      Der Konstruktor einer Tag-Klasse wird bei der Erzeugung der Tag-Instanz aufgerufen. Der Parser übergibt jedoch
      keine Argumente. Die Methode kann dazu genutzt werden, weitere Tags für die vorliegende Hierarchie bekannt zu
      geben oder Standard-Werte zu belegen.
      <div class="warn">
         Zum Zeitpunkt der Ausführung des Konstruktors sind weder die Attribute des Tags noch der Inhalt verfügbar.
         Ebenso sind der Kontext und die Sprache des Tags noch nicht initialisiert.
      </div>
   </li>
   <li>
      Nachdem der Tag geparst wurde wird die Methode <em>onParseTime()</em> aufgerufen. Zu diesem Zeitpunkt sind die
      Attribute des Tags und der Inhalt in der Instanz verfügbar. Auch Kontext und Sprache des Tags sind initialisiert.
      Diese Methode kann dazu genutzt werden, den Tag mit Hilfe der verfügbaren Informationen weiter zu initialsieren
      oder den Tag-Inhalt weitere zu analysieren (z.B. enthaltene Kind-Tags parsen).
   </li>
   <li>
      Ist der Knoten in den DOM-Baum eingehangen - sprich sind Vater und Kinder bekannt - wird die Methode
      <em>onAfterAppend()</em> aufgerufen. Innerhalb dieser Methode können Sie nun Logik platzieren, die auf Vater und
      Kinder Auswirkung hat.
   </li>
   <li>
      Wird der aktuelle DOM-Knoten transformiert, ruft der Page-Controller die Methode <em>transform()</em> Ihres
      Tags auf. Platzieren Sie hier bitte diejenige Logik, die zur Erzeugung von HTML-Quelltext benötigt wird. Tags, die
      innerhalb des DOM-Baumes lediglich zur Konfiguration oder Initialisierung dienen generieren oft keine Ausgabe (z.B.
      <em>&lt;core:addtaglib /&gt;</em>). Wie sich Ihr Tag letztlich verhält bleibt Ihrer Implementierung überlassen.
      <div class="hint">
         Sofern die Methode <em>transform()</em> in eigenen TagLibs überschrieben wird, muss
         sich der Entwickler selbst um die Transformation der Kind-Knoten kümmern. Dies kann im
         einfachsten Fall durch
<gen:highlight type="php">
foreach($this->children as $objectId => $DUMMY){
   $this->content = str_replace(
      '<'.$objectId.' />',
      $this->children[$objectId]->transform(),
      $this->content
   );
}
</gen:highlight>
         erreicht werden, wenn in den Methoden <em>onParseTime()</em> oder <em>onAfterAppend()</em> die
         Parser-Funktion <em>extractTagLibTags()</em> aufgerufen wurde. Weitere Hinweise können dem
         Foren-Beitrag
         <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=191" title="transform() von eigenem taglib nicht ausgeführt">transform() von eigenem taglib nicht ausgeführt</a>
         entnommen werden.
      </div>
   </li>
</ul>
<p>
   Für die Transformation von Kind-Knoten können folgende Methoden genutzt werden:
</p>
<ul>
   <li>
      <strong>transformChildren()</strong>
      Transformiert die Kind-Knoten im internen Inhalts-Puffer (<em>$this->content</em>).
   </li>
   <li>
      <strong>transformChildrenAndPreserveContent()</strong>
      Transformiert die Kind-Knoten und gibt das Ergebnis zurück. Der interne Inhalts-Puffer
      (<em>$this->content</em>) wird dabei für eine erneute Transformation beibehalten.
   </li>
   <li>
      <strong>transformChildrenAsEmpty()</strong>
      Entfernt die internen Positionsmarker des APF-Parsers (siehe Hinweis in Kapitel
      <a href="#Chapter-5-2-4-Erzeugen-der-Ausgabe">5.2.4. Erzeugen der Ausgabe</a>)
      im internen Inhalts-Puffer (<em>$this->content</em>).
   </li>
   <li>
      <strong>transformChildrenAsEmptyAndPreserveContent()</strong>
      Entfernt die internen Positionsmarker des APF-Parsers (siehe Hinweis in Kapitel
      <a href="#Chapter-5-2-4-Erzeugen-der-Ausgabe">5.2.4. Erzeugen der Ausgabe</a>) und gibt das Ergebnis zurück.
      Der interne Inhalts-Puffer (<em>$this->content</em>) wird dabei für eine erneute Transformation beibehalten.
   </li>
</ul>

<h3 id="Chapter-5-Implementierung"><a href="#Chapter-5-Implementierung">5. Implementierung</a></h3>

<h4 id="Chapter-5-1-Einfacher-Tag"><a href="#Chapter-5-1-Einfacher-Tag">5.1. Einfacher Tag</a></h4>
<p>
   Dieses Kapitel beschäftigt sich mit einfachen Tags. &quot;Einfach&quot; meint in diesem Zusammenhang einen Tag, der
   eine bestimmte Aufgabe erledigt, jedoch keine weitere Hierarchie erzeugt - sprich keine Kind-Tags besitzt.
</p>
<p>
   Als Beispiel soll die Ausgabe der aktuellen Uhrzeit aus <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a>
   dienen. Hierzu muss der Tag lediglich zur Transformations-Zeit die Uhrzeit im gewünschten Format zurückgeben.
   Abhängigkeiten zu anderen Tags im Baum und die Notwendigkeit der Initialisierung bestehen nicht. Der Quellcode des
   Tags gestaltet sich damit wie folgt (Namespace: <em>VENDOR\tags</em>):
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class HourDisplayTag extends Document {

   public function transform() {
     return date($this->getAttribute('format'));
   }

}
</gen:highlight>
<p>
   Innerhalb eines Templates lässt er sich wie anschließend gezeigt verwenden:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\tags\HourDisplayTag"
   prefix="current"
   name="date"
/&gt;
&lt;current:date format="H:i:s" /&gt;
</gen:highlight>

<h4 id="Chapter-5-2-Komplexer-Tag"><a href="#Chapter-5-2-Komplexer-Tag">5.2. Komplexer Tag</a></h4>
<p>
   Als &quot;komplexer&quot; Tag versteht das APF einen Tag mit weiteren - in der Hierarchie nicht eingeschränkten -
   Kind-Knoten.
</p>
<p>
   Als Beispiel soll die Ausgabe einer Bildergalerie aus <a href="#Chapter-2-Definition-eines-Tags">Kapitel 2</a> dienen.
   Dieser Tag definiert zunächst statischen Inhalt, der zur Ausgabe einer Überschrift und eines Einleitungstextes
   genutzt wird. Die Generierung der Ausgabe selbst wird vom <em>&lt;img:gallery /&gt;</em>-Tag mit Hilfe eines
   <em>Content-Providers</em>, der durch den <em>&lt;gallery:datasource /&gt;</em>-Tag definiert wird.
</p>
<div class="hint">
   Bitte beachten Sie, dass die Struktur des Beispiels willkürlich gewählt und nicht für Ihre Implementierungen bindend
   ist. Es wäre sowohl denk- als auch realisierbar den Content-Provider über Tag-Attribute zu definieren und die
   Formatierung der Galerie über weitere Elemente (siehe z.B. <int:link pageid="078" anchor="Chapter-1-Iterator">Iterator</int:link>)
   zu realisieren.
</div>

<h5 id="Chapter-5-2-1-Basis"><a href="#Chapter-5-2-1-Basis">5.2.1. Basis</a></h5>
<p>
   Die Basis-Struktur des Tags gestaltet sich wie folgt:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\tags\GalleryDataSourceTag;

class GalleryTag extends Document {

   public function __construct() {
      Document::addTagLib(
         'VENDOR\tags\GalleryDataSourceTag',
         'gallery',
         'datasource'
      );
   }

   ...

}
</gen:highlight>
<p>
   Im Konstruktor des Tags wird dem Parser der <em>&lt;gallery:datasource /&gt;</em>-Tag bekannt gegeben. In diesem
   Fall setzen wir auf eine globale Registrierung. Damit kann der Tag unabhängig von der Hierarchie auch in anderen
   Templates eingesetzt werden.
</p>
<div class="hint">
   Die Registrierung des Tags können Sie ebenso in Ihrer Bootstrap-Datei vornehmen, da in diesem Beispiel eine
   statische (=globale) Registrierung vorgenommen wurde. Das bedeutet, dass der Zeitpunkt der Registrierung gegenüber dem
   Ort entscheidend ist. Der Konstruktor der <em>GalleryTag</em>-Klasse wird gemäß
   <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Timing-Modell</int:link> vor dem Parsen seiner
   Kinder ausgeführt. Damit lässt sich die Registrierung von Tag-Implementierungen sehr schön innerhalb einer
   Komponente erledigen (Kapselung!) und somit die Anwendung erleichtern.
</div>

<h5 id="Chapter-5-2-2-Konfiguration-des-Content-Provider"><a href="#Chapter-5-2-2-Konfiguration-des-Content-Provider">5.2.2. Konfiguration des Content-Provider</a></h5>
<p>
   Widmen wir uns nun zunächst der Konfiguration des <em>Content-Providers</em>. Hierzu spendieren wir dem
   <em>&lt;img:gallery /&gt;</em>-Tag ein privates Feld und einen Setter, damit der <em>&lt;gallery:datasource /&gt;</em>-Tag
   die Instanz übergeben kann:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\..\ImageGalleryContentProvider;

class GalleryTag extends Document {

   private $contentProvider;

   ...

   public function setContentProvider(ImageGalleryContentProvider $provider) {
      $this->contentProvider = $provider;
   }

   ...

}
</gen:highlight>
<p>
   Der Provider selbst definiert sich durch folgendes Interface:
</p>
<gen:highlight type="php">
interface ImageGalleryContentProvider {
   /**
    * @return GalleryImage[]
    */
   public function getImages();
}

class GalleryImage {

   private $title;
   private $description;
   private $imageUrl;

   public function __construct($title, $description, $imageUrl) {
      $this->title = $title;
      $this->description = $description;
      $this->imageUrl = $imageUrl;
   }

   public function getDescription() {
      return $this->description;
   }

   public function getImageUrl() {
      return $this->imageUrl;
   }

   public function getTitle() {
     return $this->title;
   }

}
</gen:highlight>
<p>
   Gemäß unseres Beispieles ist der <em>&lt;gallery:datasource /&gt;</em>-Tag dafür zuständig den gewünschten Provider
   zu erzeugen und dem <em>GalleryTag</em> mitzugeben. Dies lässt sich innerhalb der <em>onAfterAppend()</em>-Methode
   erledigen, da zu diesem Zeitpunkt der Vater-Knoten bekannt ist:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use VENDOR\tags\GalleryTag;

class GalleryDataSourceTag extends Document {

   public function onAfterAppend() {
      $provider = &$this->getServiceObject(
         $this->getAttribute('class')
      );
      /* @var $parent GalleryTag */
      $parent = &$this->getParentObject();
      $parent->setContentProvider($provider);
   }

   public function transform() {
      return '';
   }

}
</gen:highlight>
<p>
   In der Methode <em>onAfterAppend()</em> erzeugt das Tag den gewünschten Provider mit Hilfe des
   <int:link pageid="107" anchor="Chapter-3-2-1-ServiceManager-Einfache-Services">ServiceManager</int:link> um der Instanz
   Kontext und Sprache des aktuellen Elements mitzugeben. Anschließend wird dem Vater-Element des DOM-Baumes - hier
   eine Instanz der Klasse <em>GalleryTag</em> wie mit dem Type-Hint angegeben wird - der Provider injiziert.
</p>
<p>
   Die leer überschriebene <em>transform()</em>-Methode sorgt dafür, dass keine weiteren Kind-Elemente transformiert oder
   eine Ausgabe erzeugt wird. Dies ist im aktuellen Beispiel nicht notwendig.
</p>

<h5 id="Chapter-5-2-3-Parsen-des-GalleryDataSourceTag"><a href="#Chapter-5-2-3-Parsen-des-GalleryDataSourceTag">5.2.3. Parsen des GalleryDataSourceTag</a></h5>
<p>
   Damit der <em>GalleryDataSourceTag</em> seine Arbeit verrichten kann muss der <em>GalleryTag</em> dafür sorgen, dass
   er auch vom Page-Controller erfasst und ausgeführt wird. Dazu bringt der Page-Controller bereits eine Parser-Methode
   mit, die in jeder von <em>Document</em> erbenden Klasse ausgeführt werden kann - <em>Document::extractTagLibTags()</em>.
</p>
<p>
   Zu welchem Zeitpunkt diese aufgerufen werden soll entscheiden zunächst Sie selbst. Beachten Sie dabei jedoch immer das
   <int:link pageid="098" anchor="Chapter-2-1-Ablaufdiagramm">Ablaufdiagramm des Page-Controller</int:link> um den für
   den Anwendungsfall richtigen Zeitpunkt zu wählen. In unserem Fall ist lediglich wichtig, dass der Provider <em>vor</em>
   der Erzeugung der Inhalte ausgeführt wird. Damit sind theoretisch drei Möglichkeiten denkbar:
</p>
<ul>
   <li>In einer eigenen <em>onParseTime()</em>-Methode.</li>
   <li>In einer eigenen <em>onAfterAppend()</em>-Methode.</li>
   <li>Zu Beginn der <em>transform()</em>-Methode.</li>
</ul>
<p>
   Üblicherweise schickt es sich für die Analyse von weiteren Kind-Strukturen die <em>onParseTime()</em>-Methode zu
   nutzen, da Sie damit sicherstellen, dass die weiteren Elemente im Baum ebenfalls die Möglichkeit haben, Kind-Knoten
   zeitlich korrekt zu erzeugen.
</p>
<p>
   Um den <em>GalleryDataSourceTag</em> zu erzeugen und auszuführen, reicht folgender Quellcode:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   ...

}
</gen:highlight>
<p>
   Alles Weitere erledigt der APF-Parser für Sie und an Hand des Template-Inhaltes.
</p>

<h5 id="Chapter-5-2-4-Erzeugen-der-Ausgabe"><a href="#Chapter-5-2-4-Erzeugen-der-Ausgabe">5.2.4. Erzeugen der Ausgabe</a></h5>
<p>
   Die Ausgabe der Bildergalerie erfolgt in der Methode <em>transform()</em>, die vom Page-Controller bei der Transformation
   des Baumes aufgerufen wird. Diese muss nun dafür sorgen, dass die Bilder, die vom Provider geliefert werden
   entsprechend ausgegeben werden.
</p>
<p>
   Unter der Annahme, dass alle Bilder als ungeordnete Liste mit entsprechendem Platz für Beschreibungen ausgegeben werden,
   gestaltet sich die Methode <em>transform()</em> wie folgt:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
            . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
            . '<p>' . $image->getDescription() . '</p>'
            . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);
   }

}
</gen:highlight>
<p>
   Mit der aktuellen Implementierung werden alle Bilder als Listen-Elemente nach dem im <em>&lt;img:gallery /&gt;</em>-Tag
   vorhandenen statischen Inhalt angezeigt.
</p>
<div class="hint">
   Soll in einem Tag kein statischer Inhalt zugelassen werden, so kann dieser in der <em>transform()</em>-Methode durch
   <em>setContent()</em> durch einen dynamisch erzeugten überschrieben werden.
</div>
<div class="hint">
   Damit bei der Transformation die Inhalte eines Tags an der korrekten Stelle ausgegeben werden,
   erzeugt die Methode <em>extractTagLibTags()</em> Platzhalter der Form
   <gen:highlight type="apf-xml">&lt;{OBJECT_ID} /&gt;</gen:highlight> Dabei entspricht <em>{OBJECT_ID}</em>
   dem Wert der Klassen-Variable <em>$this->objectId</em> und dem Array-Offset, in dem die
   Kind-Tags gespeichert werden (<em>$this->children</em>). Dieser Wert kann dann bei der
   Implementierung von eigenen <em>transform()</em>-Methoden für die Ersetzung des Inhalts
   genutzt werden.
</div>
<p>
   Im Fall des <em>&lt;img:gallery /&gt;</em>-Tags sollen die Kind-Tags keine Ausgabe erzeugen, was prinzipiell mit der
   <em>GalleryDataSourceTag::transform()</em>-Methode sichergestellt. Da der APF-Parser jedoch zur Positionierung der
   Ausgabe Platzhalter erzeugt, müssen diese in unserem Beispiel dennoch ersetzt werden. Dies kann durch folgende
   Erweiterung passieren:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class GalleryTag extends Document {

   ...

   public function transform() {
      $images = $this->contentProvider->getImages();

      $buffer = '<ul class="gallery-images">';
      foreach ($images as $image) {
         $buffer .= '<li>'
         . '<img src="' . $image->getImageUrl() . '" alt="' . $image->getTitle() . '" />'
         . '<p>' . $image->getDescription() . '</p>'
         . '</li>';
      }
      $buffer .= '</ul>';

      $this->setContent($this->getContent() . $buffer);

      foreach ($this->children as $objectId => $DUMMY) {
         $this->content = str_replace(
            '<' . $objectId . ' />',
            $this->children[$objectId]->transform(),
            $this->content
         );
      }
   }

}
</gen:highlight>

<h4 id="Chapter-5-3-Document-API"><a href="#Chapter-5-3-Document-API">5.3. Document-API</a></h4>
<p>
   Zur Implementierung von Tag-Logik stehen zahlreiche Methoden zur Verfügung. Diese umfassen das Parsen von Tag-Strukturen,
   das Traversieren des Baumes und das Manipulieren oder Auslesen von Tag-Informationen. Diese sind:
</p>
<ul>
   <li>
      <strong>extractTagLibTags()</strong>:
      Analysiert die bekannten Kind-Tags und erstellen den DOM-Baum daraus.
   </li>
   <li>
      <strong>extractExpressionTags()</strong>:
      Analysiert und interpretiert APF Pseudo-Template-Ausdrücke und erstellen die zugehörigen DOM-Baum-Elemente. Bitte
      beachten Sie die Hinweise unter <int:link pageid="047" anchor="Chapter-3-Erweiterte-Template-Funktionen" /> zur
      Verwendung der Ausdrücke. Weitere Details dazu finden Sie ebenso im Proposal unter
      <a class="wiki" href="http://wiki.adventure-php-framework.org/Erweitertes_Templating">Erweitertes Templating</a>.
   </li>
   <li>
      <strong>getParentObject()</strong>:
      Liefert die Instanz des Vater-Tags im DOM-Baum. Sofern kein Vater vorhanden ist, liefert die Methode <em>null</em>.
   </li>
   <li>
      <strong>setParentObject()</strong>:
      Injiziert eine Instanz als Vater-Tags des entsprechenden DOM-Knotens.
   </li>
   <li>
      <strong>getChildren()</strong>:
      Liefert die Liste aller Kinder des Tags. Sofern keine Kinder vorhanden sind, wird eine leere Liste zurückgegeben.
   </li>
   <li>
      <strong>getContent()</strong>:
      Liefert den Inhalt des befragten DOM-Elements.
   </li>
   <li>
      <strong>setContent()</strong>:
      Beschreibt den Inhalt des entsprechenden DOM-Elements.
   </li>
   <li>
      <strong>getChildNode()</strong>:
      Liefert einen Kind-Knoten, der einem definierten Selektor genügt.
   </li>
   <li>
      <strong>getChildNodes()</strong>:
      Liefert mehrere Kind-Knoten, der einem definierten Selektor genügen.
   </li>
   <li>
      <strong>getAttribute()</strong>:
      Liefert den Wert eines Attributes.
   </li>
   <li>
      <strong>setAttribute()</strong>:
      Definiert den Wert eines Attributes.
   </li>
   <li>
      <strong>getAttributes()</strong>:
      Liefert die Liste der aktuellen Attribute.
   </li>
   <li>
      <strong>getAttributesAsString()</strong>:
      Generiert eine XML-Repräsentation der übergebenen Attribute an Hand einer optionalen Whitelist.
   </li>
</ul>
<p>
   Weitere Methoden der Klasse <em>Document</em> oder der Basis-Klasse ihres aktuellen Tags finden Sie in der
   <int:link pageid="002"/>.
</p>

<h3 id="Chapter-6-Der-APF-Parser"><a href="#Chapter-6-Der-APF-Parser">6. Der APF-Parser</a></h3>

<h4 id="Chapter-6-1-Features"><a href="#Chapter-6-1-Features">6.1. Features</a></h4>
<p>
   Der Parser des APF besitzt folgende Funktionalitäten:
</p>
<ul>
   <li>
      Der Parser kann sowohl symmetrische als auch asymmetrische Strukturen von selbst- und explizit schließenden
      Tags erkennen und Verschränkungen auflösen. Beispiel:
<gen:highlight type="apf-xml">
<foo:bar>
   ...
   <foo:bar>
      ...
   </foo:bar>
   ...
   <foo:bar />
   ...
</foo:bar>
<foo:bar>
   ...
   <zig:zag>
      ...
      <foo:bar />
      ...
   </zig:zag>
   ...
</foo:bar>
</gen:highlight>
      Er erkennt dabei Tags mit gleichen und unterschiedlichen Kombinationen aus Präfix und Namen und ordnet diese
      der richtigen Hierarchie innerhalb des APF-DOM-Baums zu.
   </li>
   <li>
      Registrierte XML-Tags lassen sich in allen Ebenen unter Verwendung des definierten Präfix und Namens wiederverwenden.
      Der Parser ordnet diese entsprechend der Positionierung im Template im APF-DOM-Baum an.
   </li>
   <li>
      Die Verarbeitung von Inhalten sind der jeweiligen Tag-Implementierung überlassen. Dies betrifft insbesondere die
      Verarbeitung von Tag-Inhalten (statischer Inhalt und weitere Tags). Dies ermöglicht Ihnen, bei der Implementierung
      frei zu entscheiden, wie mit dem Inhalt umzugehen ist. Auf diese Weise lässt sich der Aufbau des APF-DOM-Baums
      sehr einfach beeinflussen und Inhalte z.B. nur unter bestimmten Bedingungen ausgeben.
   </li>
</ul>
<p>
   Darüber hinaus implementiert der APF-Parser die Konzepte des APF <int:link pageid="098" /> und sorgt für den Aufbau
   des DOM-Baumes.
</p>

<h4 id="Chapter-6-2-Restriktionen"><a href="#Chapter-6-2-Restriktionen">6.2. Restriktionen</a></h4>
<p>
   Der Tag-Parser des APF besitzt aus Performance-Gründen einigen Restriktionen gegenüber einem &quot;echten&quot;
   XML-Parser. Diese sind:
</p>
<ul>
   <li>Tag-Attribute können nur durch Leerzeichen getrennt werden. Tab-Zeichen sind nicht möglich.</li>
   <li>
      Tags in Attribut-Werten können nicht verarbeitet werden. Eine solche Definition führt in der Regel zu einer
      <em>ParserException</em>!
   </li>
   <li>Attribut-Werte müssen mit doppelten Anführungszeichen umschlossen sein.</li>
   <li>
      Die Definition eines Tags wird nur dann erkannt, wenn Tag-Deklaration und Attribute durch ein Leerzeichen
      getrennt sind. Dies gilt insbesondere für mehrzeilige Tag-Definitionen von verschachtelten Tags. Folgendes
      Beispiel wird vom APF-Parser nicht erkannt:
<gen:highlight type="apf-xml">
&lt;form:recaptcha
name="my-captcha"&gt;
   &lt;recaptcha:getstring
         ...
   /&gt;
&lt;/form:recaptcha&gt;
</gen:highlight>
      Um die auftretende <em>ParserException</em> zu beheben, kann entweder hinter <em>&lt;form:recaptcha</em> ein
      Leerzeichen eingefügt oder das Attribut <em>name</em> auf der selben Zeile wie <em>&lt;form:recaptcha</em>
      aufgeführt werden.
<div class="hint">
   Dieser Fehler tritt vermehrt in IDEs auf, die beim Speichern von HTML-Dateien unnötige Leerzeilen am Ende einer Zeile
   automatisch entfernen.
</div>
   </li>
   <li>
      Als verarbeitbare Tags werden nur APF-Tags erkannt. Einfache HTML-Tags können nicht erfasst werden und dies
      erfordert u.U. die Implementierung von Wrapper-Tags für die Abstraktion.
   </li>
   <li>
      Um das Einlesen von Template-Dateien performant zu gestalten ist die Länge von Tag-Präfixes und -Namen auf
      <strong>10 Zeichen</strong> beschränkt!
   </li>
</ul>

<h3 id="Chapter-7-Anwendungsbeispiele"><a href="#Chapter-7-Anwendungsbeispiele">7. Anwendungsbeispiele</a></h3>
<p>
   In diesem Kapitel finden Sie Anwendungsbeispiele für Tags, die Sie in Ihrer täglichen Arbeit mit dem APF als
   Vorlage für eigene Implementierungen bzw. als Coding-Guideline nutzen können. Als Daumenregel gilt:
</p>
<div class="hint">
   Ein Tag wird erst notwendig, wenn die Anforderung mit Hilfe eines <int:link pageid="047"/> - inkl. aller
   <int:link pageid="046" /> - und einem <int:link pageid="006" /> nicht mehr zu realisieren ist (z.B. Manipulationen
   des DOM-Baums). Weiterhin empfielt es sich, Funktionalität in Tags abzufassen, wenn immer wieder verwendete Elemente
   in unterschiedlichen Templates genutzt werden soll ohne den Code zu duplizieren oder unnötige Vererbungshierarchien
   zu erzeugen.
</div>

<h4 id="Chapter-7-1-Einfacher-Tag-mit-Attributen"><a href="#Chapter-7-1-Einfacher-Tag-mit-Attributen">7.1. Einfacher Tag mit Attributen</a></h4>
<p>
   Als Beispiel soll in diesem Kapitel der <em>&lt;html:text /&gt;</em>-Tag implementiert werden. Dieser gibt einen
   sprachabhängigen Text aus, der an Hand eines Attributs definiert wird. Beispiel:
</p>
<gen:highlight type="apf-xml">
&lt;html:text key="log-in.mousover.text" /&gt;
</gen:highlight>
<p>
   Die Implementierung des Tags beinhaltet die Verarbeitung des Attributs und die Ausgabe des Textes zur
   Transformationszeit. Dies kann mit folgender Implementierung bewerkstelligt werden:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class TranslationTextTag extends Document {

   public function transform() {
     return gettext($this->getAttribute('key'));
   }

}
</gen:highlight>
<p>
   Sollen die Attribute eines Tags bei der Generierung der Ausgabe einbezogen werden, kann die Methode
   <em>getAttributesAsString()</em> genutzt werden. Als Beispiel soll ein Tag genutzt werden, der die Ausgabe eines
   Bildes aus einer Medien-Datenbank an Hand einer externen ID erzeugt:
</p>
<gen:highlight type="apf-xml">
&lt;html:img
   key="IMG-12345"
   width="100"
   height="120"
   alt="Diese Bild zeigt ein rotes Auto"
/&gt;
</gen:highlight>
<p>
   Die zugehörige Implementierung kann wie folgt aussehen:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class MAMImageTag extends Document {

   public function transform() {

      $width = $this->getAttribute('width', '50');
      $height = $this->getAttribute('height', '50');
      $key = $this->getAttribute('key');

      $whiteList = array(
         'alt',
         'height',
         'width',
         'id',
         'style',
         'title'
      );

      return '<img src="'
            . $this->getImageUrl($key, $width, $height) . '" '
            . $this->getAttributesAsString($this->getAttributes(), $whiteList)
            . ' />';
   }

   private function getImageUrl($key, $width, $height) {
     ...
   }

}
</gen:highlight>
<p>
   In der obigen Code-Box wird die Methode <em>getAttribute()</em> dazu genutzt um die Werte der angegebenen Attribute
   auszulesen. Da einige der Attribute für die Ausgabe wiederverwendet werden sollen, wird der Methode
   <em>getAttributesAsString()</em> eine Liste an erlaubten Attributen - in diesem Fall kompatibel zur XHTML- bzw.
   HTML5-Spezifikation - mitgegeben. Die Ausgabe des Tags ist damit ein Image-Tag, der mit Hilfe der (HTML-)Attribute
   <em>id</em>, <em>style</em> und <em>class</em> formatiert werden kann.
</p>
<div class="hint">
   Möchten Sie das Attribut <em>key</em> als Pflicht-Attribut kennzeichnen, so können Sie dieses mit Hilfe der Methode
   <em>Document::getRequiredAttribute()</em> beziehen. Die Methode wirft eine <em>InvalidArgumentException</em> sofern
   das geforderte Attribut nicht gesetzt ist. Dies erleichtert die Implementierung und erledigt die notwendigen Prüfungen
   bereits für Sie.
</div>

<h4 id="Chapter-7-2-Einfacher-Tag-mit-Inhalt"><a href="#Chapter-7-2-Einfacher-Tag-mit-Inhalt">7.2. Einfacher Tag mit Inhalt</a></h4>
<p>
   Neben den Attributen eines Tags kann dieser auch einfachen und komplexen Inhalt definieren. Als Implementierungsbeispiel
   soll in diesem Kapitel folgender Tag genutzt werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:entityencode&gt;nobody@example.com&lt;/html:entityencode&gt;
</gen:highlight>
<p>
   Ausgabe des Tags soll eine in HTML-Entitäten codierte E-Mail-Adresse sein, um sie vor Bots oder Spidern zu schützen.
   Hierzu muss der Inhalt des Tags ausgelesen und im Rahmen der Transformation des Tags ausgegeben werden. Dies führt
   zu folgender Implementierung:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;
use APF\tools\string\StringAssistant;

class EntityEncodeTag extends Document {

   public function transform() {
      return StringAssistant::encodeCharactersToHTML($this->getContent());
   }

}
</gen:highlight>
<p>
   Mit der Methode <em>getContent()</em> kann auf den Inhalt des Tags zugegriffen werden. Dieser wird mit Hilfe des
   <em>StringAssistant</em> in HTML-Entitäten umgewandelt.
</p>

<h4 id="Chapter-7-3-Zugriff-auf-den-umliegenden-DOM-Baum"><a href="#Chapter-7-3-Zugriff-auf-den-umliegenden-DOM-Baum">7.3. Zugriff auf den umliegenden DOM-Baum</a></h4>
<p>
   Wie im <a href="#Chapter-1-Einfuehrung">Kapitel 1</a> angesprochen erzeugt der <int:link pageid="098" /> aus den
   genutzten Templates und den darin enthaltenen Tags einen DOM-Baum. Das Verhalten ist - bis auf die Art der Erzeugung
   - mit dem eines Browsers vergleichbar, der ebenfalls aus dem angelieferten HTML einen DOM-Baum erzeugt und diesen
   grafisch aufbereitet.
</p>
<p>
   Da Tags und <int:link pageid="006" /> Teil des Baumes sind haben Sie dort die Möglichkeit auf alle umliegenden Knoten
   zuzugreifen. Hierzu gibt es im Wesentlichen zwei Methoden:
</p>
<ul>
   <li><em>getParentObject()</em></li>
   <li><em>getChildren()</em></li>
</ul>
<p>
   Innerhalb eines Tags können Sie mit diesen Methoden direkt auf die umliegenden Elemente zugreifen, innerhalb eines
   <int:link pageid="006" /> beziehen Sie mit <em>getDocument()</em> eine Referenz auf den aktuellen DOM-Knoten und
   können ab diesem mit den oben genannten Methoden navigieren.
</p>
<p>
   Als Beispiel für den Zugriff auf soll folgendes Template dienen:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="VENDOR\..\TemplateNameDisplayTag"
   prefix="template"
   name="display-name"
/&gt;
&lt;html:template name="test1"&gt;
   ...
&lt;/html:template&gt;
&lt;html:template name="test2"&gt;
   ...
   &lt;template:display-name /&gt;
   ...
&lt;/html:template&gt;
</gen:highlight>
<p>
   Der <em>TemplateNameDisplayTag</em> hat dabei die Aufgabe, die Namen aller Templates auszugeben, die im Baum auf
   gleicher Ebene hängen wie sein Vater. Hierzu kann folgende Implementierung genutzt werden:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

class TemplateNameDisplayTag extends Document {
   public function transform() {
      $template = &$this->getParentObject();
      $grandFather = &$template->getParentObject();

      $nodes = $grandFather->getChildren();

      $buffer = '<ul>';
      foreach ($nodes as $objectId => $DUMMY) {
         $buffer .= '<li>' . $nodes[$objectId]->getAttribute('name') . '</li>';
      }

      return $buffer . '</ul>';
   }
}
</gen:highlight>
<p>
   Ein weiterführendes Beispiel finden Sie im Forum unter
   <a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=1152">Placeholder über Taglib füllen</a>.
</p>

<h4 id="Chapter-7-4-Komplexer-Tag-mit-Attributen-und-Inhalt"><a href="#Chapter-7-4-Komplexer-Tag-mit-Attributen-und-Inhalt">7.4. Komplexer Tag mit Attributen und Inhalt</a></h4>
<p>
   Die vorangegangenen Kapitel haben sich mit dem Zugriff auf Attribute, der Ausgabe von Attributen und dem Zugriff und
   der Verarbeitung von Tag-Inhalten beschäftigt. In diesem Abschnitt beschäftigen wir uns mit komplexeren Tags, die
   weitere Strukturen definieren und Inhalte sowie Attribute in die Abbildung ihrer Logik einbeziehen.
</p>
<p>
   Als Beispiel soll uns ein Tag dienen, der Navigationsknoten vom Typ <em>NavigationNode</em> ausgibt:
</p>
<gen:highlight type="apf-xml">
&lt;core:addtaglib
   class="APF\extensions\navigation\pres\tags\NavigationNodeTag"
   prefix="navi"
   name="template"
/&gt;
&lt;navi:template id="main-navi"&gt;&lt;!-- NavigationNodeTag --&gt;
   &lt;navi:item status="active"&gt;&lt;!-- NavigationItemTag --&gt;
      &lt;li class="active"&gt;
         &lt;item:content/&gt;&lt;!-- ItemTemplateContentTag --&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;
   &lt;navi:item status="inactive"&gt;
      &lt;li&gt;
         &lt;item:content/&gt;
      &lt;/li&gt;
   &lt;/navi:item&gt;

   &lt;ul id="main-navigation"&gt;
      &lt;navi:content/&gt;&lt;!-- NavigationContentTag --&gt;
   &lt;/ul&gt;
&lt;/navi:template&gt;
</gen:highlight>
<p>
   Der Tag wird in einem <int:link pageid="006" /> gefüllt und stellt die Liste der Kinder des übergebenen
   Navigationsknotens gemäß den definierten Formatierungen dar. Dabei beschreiben die <em>&lt;navi:item /&gt;</em>-Tags
   die aktiven und inaktiven Zustände der Navigationsknotens und mit Hilfe von <em>&lt;navi:content/&gt;</em> lässt sich
   die Ausgabe in ein HTML-Gerüst packen. Der Tag <em>&lt;item:content/&gt;</em> platziert die Ausgabe eines konkreten
   Knotens und kann ebenfalls mit eigenem HTML versehen werden. Zur Erläuterung der Tag-Hierarchie sind die Namen der
   korrespondierenden Tags als HTML-Kommentar angefügt.
</p>
<p>
   Zur Befüllung des <em>&lt;navi:template /&gt;</em>-Tags in einem Template lässt sich folgender Controller nutzen:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\BaseDocumentController;
use APF\extensions\navigation\biz\SimpleNavigationNode;

class NavigationTagExampleController extends BaseDocumentController {
   public function transformContent() {
      $root = new SimpleNavigationNode(null, null, null);
      $levelOne = new SimpleNavigationNode('Level 1', '#');

      $root->setChildren(array(
         clone $levelOne->setInactive(),
         clone $levelOne->setActive(),
         clone $levelOne->setInactive()
      ));

      $navi = $this->getDocument()->getChildNode('id', 'main-navi', 'NavigationNodeTag');
      $navi->setNode($root);
   }
}
</gen:highlight>
<p>
   Die folgende Code-Box zeigt nun die Implementierung der Tags:
</p>
<gen:highlight type="php">
use APF\core\pagecontroller\Document;

interface NavigationNode {
   public function getLabel();
   public function getUrl();
   public function isActive();
   public function getParent();
   public function getChildren();
}

class SimpleNavigationNode implements NavigationNode {

   private $label;
   private $url;
   private $isActive = false;
   private $parent;
   private $children = array();

   public function __construct($label, $url) {
      $this->label = $label;
      $this->url = $url;
   }

   public function getLabel() {
      return $this->label;
   }

   public function getUrl() {
      return $this->url;
   }

   public function isActive() {
      return $this->isActive;
   }

   public function setActive() {
      $this->isActive = true;
      return $this;
   }

   public function setInactive() {
      $this->isActive = false;
      return $this;
   }

   public function getParent() {
      return $this->parent;
   }

   public function getChildren() {
      return $this->children;
   }

   public function setParent(NavigationNode $node) {
      $this->parent = $node;
   }

   public function setChildren(array $nodes) {
      $this->children = $nodes;
   }

}

class NavigationNodeTag extends Document {

   private $node;

   public function __construct() {
      self::addTagLib('EXAMPLE\navigation\pres\taglibs\NavigationItemTag', 'navi', 'item');
      self::addTagLib('EXAMPLE\navigation\pres\taglibs\NavigationContentTag', 'navi', 'content');
   }

   public function setNode(NavigationNode $node) {
      $this->node = $node;
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function transform() {

      $buffer = '';

      $navigationNodes = $this->node->getChildren();
      if (count($navigationNodes) > 0) {
         foreach ($navigationNodes as $node) {
            $buffer .= $this
               ->getTemplate($node->isActive() ? 'active' : 'inactive')
               ->getOutput($node);
         }
      }

      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof NavigationContentTag) {
            // fill the navi:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $buffer, $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }

      return $content;
   }

   private function getTemplate($status) {
      return $this->getChildNode('status', $status, 'NavigationItemTag');
   }

}

class NavigationItemTag extends Document {

   public function __construct() {
      self::addTagLib('EXAMPLE\navigation\pres\taglibs\ItemTemplateContentTag', 'item', 'content');
   }

   public function onParseTime() {
      $this->extractTagLibTags();
   }

   public function getOutput(NavigationNode $node) {
      $content = $this->getContent();
      $children = &$this->getChildren();
      foreach ($children as $objectId => $DUMMY) {
         if ($children[$objectId] instanceof ItemTemplateContentTag) {
            // fill the item:content place holder if we get him
            $content = str_replace('<' . $objectId . ' />', $children[$objectId]->setNode($node)->transform(), $content);
         } else {
            // replace parser marker to avoid direct tag output
            $content = str_replace('<' . $objectId . ' />', '', $content);
         }
      }
      return $content;
   }

   public function transform() {
      return '';
   }

}

class ItemTemplateContentTag extends Document {

   private $node;

   public function setNode(NavigationNode $node) {
      $this->node = $node;
      return $this;
   }

   public function transform() {
      if ($this->node === null) {
         return '';
      }
      return '<a href="' . $this->node->getUrl() . '">' . $this->node->getLabel() . '</a>';
   }

}

class NavigationContentTag extends Document {
}
</gen:highlight>
<div class="warn">
   Das hier beschriebene Beispiel dient dazu, die Möglichkeiten des APF aufzuzeigen und ist nicht als
   Referenz-Implementierung für die Ausgabe von Navigationen gedacht.
</div>

<h3 id="Chapter-8-Weiterfuehrende-Links"><a href="#Chapter-8-Weiterfuehrende-Links">8. Weiterführende Links</a></h3>
<p>
   Sofern Sie weitere Informationen benötigen, können Sie folgende Threads aus dem Forum nutzen:
</p>
<ul>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=1126">TagLib unterschiedliche Zustände</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=827">Taglib der Template rundherum läd</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=505">Mehrere Checkboxes taglib aus DB holen und ausgeben</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=456">Taglib-Call innerhalb eines Taglib-Call</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=191">transform() von eigenem taglib nicht ausgeführt</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=177">Menü taglib-modul</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=122">Performance TagLibs</a></li>
   <li><a linkrewrite="false" class="forum" href="${getBaseUrl(ForumBaseURL)}/viewtopic.php?f=5&amp;t=37">Taglibs vs. Templates</a></li>
</ul>
<p>
   Im Wiki finden sich folgende Seiten zu den APF-Tags:
</p>
<ul>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/All-in-one_Include-Tag">All-in-one Include-Tag</a></li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/Timing-Modell_des_Page-Controller">Timing-Modell des Page-Controller</a></li>
   <li><a linkrewrite="false" class="wiki" href="http://wiki.adventure-php-framework.org/WYSIWYG_%2B_APF-Formulare">WYSIWYG + APF-Formulare</a></li>
</ul>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_147" />