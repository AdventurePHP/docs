<doku:title parent="119" tags="form,taglib,validatoren,validator,filter,auto,ausfuellen,presetting" title="Formulare" urlname="Formulare">
   Das APF bietet auf Basis von Taglibs eine komplette Abstraktion von Formularen und
   Formular-Elementen. Diese beherrschen out-of-the-box Presetting (Auto-Ausfüllen), Validierung
   und Filterung. Im Document-Controller steht ein Formular als eigenständiges Objekt mit diversen
   Funktionen zur Verfügung.
</doku:title>
<h3 id="Chapter-1-Einleitung"><a href="#Chapter-1-Einleitung">1. Einleitung</a></h3>
<p>
   Auf Grund der Tatsache, dass der <int:link pageid="098" /> des APF einen
   generischen Rahmen für das Verarbeiten von beliebigen Taglibs bereitstellt, ist es auf dieser
   Basis möglich, Formulare mit verschiedenen Taglibs - wie z.B. Text-Felder - zu abstrahieren.
</p>
<p>
   Das Release des Adventure PHP Framework beinhaltet daher einen Satz von Taglibs, mit denen
   HTML-Formulare vollständig abstrahiert sind und die gleichzeitig Features wie Filterung,
   Validierung und Presetting out-of-the box beherrschen. Mit den mitgelieferten Taglibs können
   Formular-Felder mit beliebigen Filter und Validatoren belegt und eigene Taglibs integriert werden.
</p>
<p>
   Die folgenden Kapitel beschreiben den grundsätzlichen Aufbau und die Verarbeitung von Formularen,
   sowie die vorhandenen Tags und deren Bedeutung und Funktion. Parallel dazu ist es ratsam, die
   <int:link pageid="002" /> bei der Implementierung zu Hilfe nehmen. Diese zeigt - insbesondere bei der Klasse
   <em>HtmlFormTag</em> - auf, welche Möglichkeiten die APF-Formulare bieten.
</p>
<div class="hint">
   Das Kapitel <int:link pageid="114" /> beinhaltet ausführliche Beispiele für die
   Verwendung und Erweiterung von Formularen.
</div>

<h3 id="Chapter-2-Aufbau"><a href="#Chapter-2-Aufbau">2. Aufbau von Formularen</a></h3>
<p>
   Wie in der Einleitung kurz beschrieben, werden Formulare im APF durch Taglibs abgebildet. Die
   Basis-Taglib bildet dabei <em>&lt;html:form /&gt;</em>, die alle weiteren Tags kapselt
   und so ein Formular in einem Document-Controller als <em>ein</em> Objekt zur Verfügung stellt.
   Dieses kann weitere Tags beinhalten, die entweder konkrete Elemente wie ein Text-Feld oder einen
   Button repräsentieren, oder funktionale Tags wie Platzhalter, Listener oder Tags, die eigene
   Formular-Elemente hinzufügen.
</p>
<p>
   Formulare werden - wie auch andere Elemente der GUI - in Template-Dateien definiert. Ein einfaches
   Formular für eine Suche mit einem Eingabe-Feld und einem Button hat folgende Gestalt:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="Search"&gt;
   &lt;form:text name="searchterm" /&gt; &lt;form:button name="search" value="GO" /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Um das Formular anzuzeigen, muss ein Document-Controller für das betreffende Template vorhanden
   sein. Dies hat den Grund, dass ein Formular - im Gegensatz zu anderen Taglibs - immer an eine
   Verarbeitung durch den Entwickler gebunden ist. Sei es das Auslesen des Suchwort und Ausführen
   der Suche oder das Speichern von Nutzerdaten.
</p>
<p>
   Zur Anzeige des Formulars ist folgender Code im Controller erforderlich:
</p>
<gen:highlight type="php">
class SearchController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('Search');
      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Die Absende-Methode eines Formulars lässt sich über das Attribut <em>method</em> bestimmen. Hier stehen die beiden
   Optionen <em>post</em> und <em>get</em> zur Verfügung. Als Standard wurde <em>post</em> definiert.
</p>
<p>
   Im Fall eines <strong>POST</strong> werden alle Inhalte des Formulars in kodierter Form an die im Attribut
   <em>action</em> angegebene URL geschickt.
</p>
<p>
   Das Verhalten für <strong>GET</strong> unterscheidet sich davon. Hier werden die Inhalte aller Felder des Formulars
   an die im Attribut <em>action</em> definierte URL angehängt und diese aufgerufen.
</p>
<div class="hint">
   Bitte beachten Sie, dass gemäß
   <a class="external" href="http://www.w3.org/TR/2011/WD-html5-20110525/association-of-controls-and-forms.html#form-submission-algorithm">HTML5-Spezifikation</a>
   alle URL-Parameter der im Attribut <em>action</em> definierte URL bei einer Übermittlung per <strong>GET</strong>
   verworfen werden. Um diese zu erhalten, setzen Sie bitte das Attribut <em>submit-action-url-params</em> auf den
   Wert <em>true</em>:
<gen:highlight type="apf-xml">
&lt;html:form name="Search" action="/?page=search" method="get" submit-action-url-params="true"&gt;
   &lt;form:text name="searchterm" /&gt;
   &lt;form:button name="search" value="GO" /&gt;
&lt;/html:form&gt;
</gen:highlight>
   Mit der beschriebenen Vorgehensweise stellen Sie sicher, dass der URL-Parameter <em>page</em> bei der Anfrage mit
   übertragen wird.
</div>
<p>
   Die folgenden Kapitel beschreiben nun die vorhandenen Formular-Elemente und deren Einsatzgebiet.
</p>

<h3 id="Chapter-3-Mitgelieferte-Tags"><a href="#Chapter-3-Mitgelieferte-Tags">3. Mitgelieferte Tags</a></h3>
<p>
   Das APF beinhaltet bereits einen umfangreichen Satz and Formular-Elementen, die nach Bedarf
   konfiguriert werden können. Sollten diese nicht ausreichen, können jederzeit eigene
   Formular-Elemente hinzugefügt werden. Siehe hierzu Kapitel <int:link pageid="114" />.
</p>
<p>
   Da das APF einen generischen Tag-Parser beinhaltet, können Formular-Tags mit beliebigen
   Attributen ausgestattet werden. Zu diesen zählen insbesondere
</p>
<ul>
   <li><strong>id="..."</strong></li>
   <li><strong>class="..."</strong></li>
   <li><strong>style="..."</strong></li>
</ul>
<p>
   zur Formatierung der Elemente. Aus diesem Grund werden diese in den Beschreibungen der Taglibs
   nicht weiter erwähnt, sondern es wird lediglich auf die für die Funktion des Tags
   relevanten Attribute eingegangen.
</p>
<div class="hint">
   Ein weiteres generische Attribute ist <em>optional</em>, das zur Kennzeichnung von optionalen
   Feldern hinsichtlich der Validierung genutzt wird. Details können im Kapitel
   <int:link pageid="113" anchor="Chapter-4-1-Verfuegbare-Validatoren">Verfügbare Validatoren</int:link>
   nachgelesen werden.
</div>
<div class="hint">
   Attribute, die mit "[" und "]" geklammert dargestellt sind, haben optionalen Charakter, die
   übrigen müssen verpflichtend angegeben werden.
</div>
<p>
   Das Formular-Tag selbst besitzt drei funktionale Attribute, die zur Definition und Konfiguration
   dienen:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="" [method=""] [action=""] [autocomplete="true|false"]&gt;
   ...
   [&lt;html:placeholder name="" /&gt;]
   [&lt;html:getstring namespace="" config="" entry="" /&gt;]
   [&lt;core:addtaglib class="" prefix="" name="" /&gt;]
   ...
&lt;/html:form&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Formulars. Über den Namen kann auf das Element zugegriffen
    werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>method</strong>: Versand-Methode des Formulars. Standardmäßig wird 
    <strong>post</strong> verwendet.
    (<strong>Zeichen</strong>: <code>[get|post]</code>)
  </li>
  <li>
    <strong>action</strong>: URL, die bei Klick auf den Button aufgerufen werden soll.
  </li>
   <li>
      <strong>autocomplete</strong>: Ist der Wert auf <em>true</em> gesetzt, wird dem Browser gestattet die Inhalte des
      Formulars für ein erneutes Ausfüllen zu speichern. Diese Funktion wird mit <em>false</em> verhindert. Letzteres
      wird insbesondere für Login-Formulare empfohlen.
   </li>
</ul>
<div class="hint">
   Es ist möglich, einen globalen Standard-Wert für das Attribut <em>action</em>
   über die Registry zu definieren. Dies ist in der Bootstrap-Datei durch den Aufruf von
   <gen:highlight type="php">Registry::register('APF\tools', 'FormDefaultMethod','...')</gen:highlight>
   möglich. Damit erhalten alle Formulare - sofern das Attribut in der Tag-Definition nicht gesetzt ist -
   den dort definierten Standard-Wert. Sofern auch dieser nicht gesetzt ist, wird &quot;post&quot;
   verwendet.
</div>
<div class="hint">
   Bitte beachten Sie, dass Text-Felder keine Array-Notation für Namen unterstützen (Beispiel:
   <em>text[de]</em>). Grund dafür ist, dass Text-Felder skalare Werte enthalten sollen. Dieser
   Vereinbarung gemäß lesen die Validatoren auch nur skalare Werte aus und können nicht mit Arrays
   umgehen.
</div>

<h4 id="Chapter-3-1-Button"><a href="#Chapter-3-1-Button">3.1. Button</a></h4>
<p>
   Diese Taglib repräsentiert einen Submit-Button. APF-Formular-Elemente werden Event-basiert
   validiert und gefiltert. Dazu muss zwingend ein Button oder ein Image-Button definiert sein, da
   diese das <em>Click-Event</em> auslösen.
</p>
<gen:highlight type="apf-xml">
&lt;form:button name="" value="" /&gt;

&lt;form:button name=""&gt;
   &lt;button:getstring
      [name=""]
      namespace=""
      config=""
      entry="" /&gt;
&lt;/form:button&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Buttons. Über den Namen kann auf das Element zugegriffen 
    werden. Dies ist insbesondere für die Validatoren und Filter notwendig.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Buttons. Dieser dient der Beschriftung.
  </li>
</ul>
<div class="hint">
   Zur Beschriftung des Buttons kann der <em>&lt;button:getstring /&gt;</em>-Tag eingesetzt werden. Details zur
   Definition der Konfigurations-Dateien können der Definition des Tags
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link> entnommen werden.
</div>

<h4 id="Chapter-3-2-Image-Button"><a href="#Chapter-3-2-Image-Button">3.2. Image-Button</a></h4>
<p>
   Der Image-Button erzeugt einen Button, der als Beschriftung ein Bild nutzt. Die Funktion ist
   identisch zum einfachen Button.
</p>
<gen:highlight type="apf-xml">
&lt;form:imagebutton name="" src="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Buttons. Über den Namen kann auf das Element zugegriffen
    werden. Dies ist insbesondere für die Validatoren und Filter notwendig.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>src</strong>: Bild-Quelle des Buttons.
  </li>
</ul>

<h4 id="Chapter-3-3-Reset"><a href="#Chapter-3-3-Reset">3.3. Reset-Button</a></h4>
<p>
   Neben einem einfachen Button beinhalten die Formular-TagLibs einen Tag für Reset-Buttons. Diese
   repräsentieren einen HTML-Reset-Button und können wie "normale" Buttons im
   Document-Controller adressiert und konfiguriert werden.
</p>
<div class="hint">
   Mit einem Reset-Button ist keine Validierung bzw. Filterung möglich!
</div>
<gen:highlight type="apf-xml">
&lt;form:reset name="" value="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>value</strong>: Wert (Beschriftung) des Reset-Buttons.
  </li>
</ul>

<h4 id="Chapter-3-4-Hidden"><a href="#Chapter-3-4-Hidden">3.4. Hidden-Feld</a></h4>
<gen:highlight type="apf-xml">
&lt;form:hidden name="" value="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Hidden-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Hidden-Feldes.
  </li>
</ul>

<h4 id="Chapter-3-5-Text"><a href="#Chapter-3-5-Text">3.5. Text-Feld</a></h4>
<gen:highlight type="apf-xml">
&lt;form:text name="" [value=""] /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Text-Felds. Über den Namen kann auf das Element zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Text-Feldes.
  </li>
</ul>

<h4 id="Chapter-3-6-Textarea"><a href="#Chapter-3-6-Textarea">3.6. Textarea</a></h4>
<p>
   Eine APF-Text-Area existiert in zwei Ausprägungen: ohne Inhalt als selbstschließender Tag oder mit
   Inhalt, der im Template definiert wurde.
</p>
<gen:highlight type="apf-xml">
&lt;form:area name="" /&gt;
&lt;form:area name=""&gt;...&lt;/form:area&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Textarea. Über den Namen kann auf das Element zugegriffen
    werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>

<h4 id="Chapter-3-7-Passwort"><a href="#Chapter-3-7-Passwort">3.7. Passwort-Feld</a></h4>
<gen:highlight type="apf-xml">
&lt;form:password name="" [value=""]/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Passwort-Felds. Über den Namen kann auf das Element 
    zugegriffen werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Passwort-Feldes.
  </li>
</ul>

<h4 id="Chapter-3-8-Dateiupload"><a href="#Chapter-3-8-Dateiupload">3.8. Dateiupload-Feld</a></h4>
<p>
   Das Dateiupload-Feld besitzt folgende Signatur:
</p>
<gen:highlight type="apf-xml">
&lt;form:file name="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Dateiupload-Felds. Über den Namen kann auf das Element
    zugegriffen werden. (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
</ul>
<p>
   Um hochgeladene Dateien einfach verarbeiten zu können, besitzt der Tag folgende Methoden, die in einem
   Document-Controller genutzt werden können:
</p>
<ul>
   <li>
      <em>hasUploadedFile()</em>: gibt <em>true</em> zurück, sofern eine Datei
      hochgeladen wurden, andernfalls <em>false</em>.
   </li>
   <li>
      <em>getFile()</em>: gibt eine Instanz der Klasse <em>FileModel</em> zurück,
      die eine hochgeladene Datei repräsentiert. Wenn keine Datei hochleladen wurden, wird
      <em>null</em> zurückgegeben.
   </li>
</ul>
<p>
   Das folgende Formular zeigt Ihnen ein Anwendungsbeispiel des Tags:
</p>
<gen:highlight type="apf-xml">
&lt;@controller
   namespace="VENDOR\..\controller\FileUploadController"
@&gt;
&lt;html:form name="upload" method="post"&gt;
   &lt;p&gt;
      &lt;label for="name"&gt;Name:&lt;/label&gt;
      &lt;form:text name="name" id="name"/&gt;
   &lt;/p&gt;
   &lt;p&gt;
      &lt;label for="image"&gt;Image:&lt;/label&gt;
      &lt;form:file name="image" id="image" accepts="jpg|image/png" maxsize="269205"/&gt;
   &lt;/p&gt;
   &lt;p&gt;
      &lt;form:button name="send" value="GO" /&gt;
      &lt;form:addvalidator
            class="MimeTypeValidator"
            control="image"
            button="send"
      /&gt;
      &lt;form:addvalidator
            class="FileSizeValidator"
            control="image"
            button="send"
      /&gt;
   &lt;/p&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Für die Verarbeitung des Formulars ist ein Document-Controller erforderlich. Dieser definiert, wie die hochgeladene
   Datei behandelt werden soll. Der nachfolgend abgebildete Quellcode gibt Ihnen eine Anregung für die Implementierung
   in Ihrer Applikation:
</p>
<gen:highlight type="php">
namespace VENDOR\..\controller;

use APF\core\pagecontroller\BaseDocumentController;
use APF\tools\filesystem\FilesystemManager;
use APF\tools\form\taglib\FileUploadTag;

class FileUploadController extends BaseDocumentController {

   public function transformContent() {

      $form = & $this->getForm('upload');

      if ($form->isSent() && $form->isValid()) {

         $name = & $form->getFormElementByName('name');

         /* @var $image FileUploadTag */
         $image = & $form->getFormElementByName('image');

         $file = $image->getFile();
         $fileName = $file->getName();
         $tmpFile = $file->getTemporaryName();
         FilesystemManager::copyFile($tmpFile, './upload/' . $fileName, true);

      } else {
         $form->transformOnPlace();
      }

   }

}
</gen:highlight>
<p>
   Zur Prüfung der hochgeladenen Datei lassen sich der <a href="#Chapter-4-1-11-MimeTypeValidator">MimeTypeValidator</a> und
   der <a href="#Chapter-4-1-12-FileSizeValidator">FileSizeValidator</a> einsetzen.
</p>
<div class="hint">
   Seitens des APF wird auch ein weiteres Tool zum Erzeugen von Datei-Uploads
   mit Vorschau-Funktion sowie prozentualer Fortschrittanzeige angeboten: der MultiFileUpload.
   Ausführliche Informationen dazu entnehmen Sie bitte der Dokumentation im Wiki:
   <a class="wiki" href="http://wiki.adventure-php-framework.org/MultiFileUpload" title="MultiFileUpload im Wiki">MultiFileUpload im Wiki</a>
</div>

<h4 id="Chapter-3-9-Checkbox"><a href="#Chapter-3-9-Checkbox">3.9. Checkbox</a></h4>
<p>
   Die Checkbox-Taglib implementierung nicht nur einen Wrapper für eine HTML-Checkbox, sondern
   inkludiert auch die Logik, die zum anhaken und abhaken einer Checkbox notwendig ist. Hierbei wird
   die Schwäche ausgebügelt, dass nicht angehakte Checkboxen speziell geprüft werden müssen.
</p>
<gen:highlight type="apf-xml">
&lt;form:checkbox name="" value="" [checked="checked"] /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name der Checkbox. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert der Checkbox.
  </li>
  <li>
    <strong>checked</strong>: Definiert, ob die Checkbox vorselektiert ist.
  </li>
</ul>

<h4 id="Chapter-3-10-Radio-Button"><a href="#Chapter-3-10-Radio-Button">3.10. Radio-Button</a></h4>
<p>
   Die Radio-Button-Taglib implementierung nicht nur einen Wrapper für einen HTML-Radio-Button,
   sondern inkludiert auch die Logik, die zum anhaken und abhaken eines Radio-Buttons notwendig ist.
   Hierbei wird die Schwäche ausgebügelt, dass nicht selektierte Radio-Buttons speziell geprüft werden
   müssen.
</p>
<gen:highlight type="apf-xml">
&lt;form:radio name="" value="" [checked="checked"]/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Radio-Buttons. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert des Radio-Buttons bzw. der aktuellen Option.
  </li>
  <li>
    <strong>checked</strong>: Zeigt an, ob der Radio-Button vorselektiert ist.
  </li>
</ul>

<h4 id="Chapter-3-11-Select"><a href="#Chapter-3-11-Select">3.11. Select-Feld</a></h4>
<p>
   Ein Select-Feld kann auf unterschiedliche Arten definiert werden: mit statischen oder dynamisch
   hinzugefügten Optionen oder Gruppen oder einer Mischung aus den genannten Möglichkeiten.
   Dynamische Optionen und Gruppen können in einem <int:link pageid="006" /> hinzugefügt
   und verarbeitet werden.
</p>
<p>
   Darüber hinaus können auch Options-Gruppen genutzt werden.
</p>
<gen:highlight type="apf-xml">
&lt;form:select name="" /&gt;

&lt;form:select name=""&gt;
  &lt;select:option value="" [selected="selected"]&gt;...&lt;/select:option&gt;
  [&lt;select:group label=""&gt;
     &lt;group:option value="" [selected="selected"]&gt;...&lt;/group:option&gt;
  &lt;/select:group&gt;]
&lt;/form:select&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Select-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert der Optionen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>  
  <li>
    <strong>selected</strong>: Soll eine Option vorausgewählt dargestellt werden, so muss das
    Attribut <em>selected</em> mit dem gleichnamigen Wert gefüllt sein.
  </li>
  <li>
    <strong>label</strong>: Beinhaltet die Beschriftung einer Gruppe von Optionen.
  </li>
</ul>

<h4 id="Chapter-3-12-Multiselect"><a href="#Chapter-3-12-Multiselect">3.12. Multiselect-Feld</a></h4>
<p>
   Wie auch das einfache Select-Feld, so ist es auch beim Multiselect-Feld möglich, dieses auf
   zwei Arten zu definieren: ohne und mit statische Optionen und Gruppen.
</p>
<gen:highlight type="apf-xml">
&lt;form:multiselect name="" /&gt;

&lt;form:multiselect name=""&gt;
  &lt;select:option value="" [selected="selected"]&gt;&lt;/select:option&gt;
  [&lt;select:group label=""&gt;
     &lt;group:option value="" [selected="selected"]&gt;...&lt;/group:option&gt;
  &lt;select:group&gt;]
&lt;/form:multiselect&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Multiselect-Felds. Über den Namen kann auf das Element
    zugegriffen werden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>value</strong>: Wert der Optionen.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>selected</strong>: Soll eine Option vorausgewählt dargestellt werden, so muss das
    Attribut <em>selected</em> mit dem gleichnamigen Wert gefüllt sein.
  </li>
  <li>
    <strong>label</strong>: Beinhaltet die Beschriftung einer Gruppe von Optionen.
  </li>  
</ul>
<div class="hint">
   Der Name des Formular-Feldes darf am Schluss kein "[]" enthalten, da es sonst zu Fehlern bei der
   Übertragung der Optionen kommt.
</div>

<h4 id="Chapter-3-13-Datum-Control"><a href="#Chapter-3-13-Datum-Control">3.13. Datums-Control</a></h4>
<p>
   Um die Erstellung von Datum-Auswahl-Menüs zu erleichtern, enthält das APF ein Date-Control. Dieses
   kann entsprechend den Anforderungen konfiguriert werden.
</p>
<gen:highlight type="apf-xml">
&lt;form:date
   name=""
   [yearrange=""]
   [offsetnames=""]
   [tab-indexes=""]
   [prepend-empty-options="true|false"]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>name</strong>: Name des Datum-Controls. Über den Namen kann auf das Element
      zugegriffen werden.
      (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
   </li>
   <li>
      <strong>yearrange</strong>: Range des Jahres-Feldes. Beispiel: <code>1990-2007</code> bzw. <code>1990-now</code>
      um alle Jahre inkl. des aktuellen anzuzeigen.
      (<strong>Zeichen</strong>: <code>[0-9-], now</code>)
   </li>
   <li>
      <strong>offsetnames</strong>: Namen der Felder für Tag, Monat und Jahr. Einzelne Felder
      müssen durch ";" getrennt werden. Beispiel: <code>Tag;Monat;Jahr</code>.
      (<strong>Zeichen</strong>: <code>[A-Za-z;]</code>)
   </li>
   <li>
      <strong>tab-indexes</strong>: Das Datums-Control besteht aus drei Auswahl-Feldern. Mit diesem Attribut lassen
      sich die <em>tabindex</em>-Attribute der einzelnen Felder individuell festlegen. Beispiel: <code>1;2;3</code>.
      (<strong>Zeichen</strong>: <code>[0-9;]</code>)
   </li>
   <li>
      <strong>prepend-empty-options</strong>: Wird das Attribut mit dem Wert <em>true</em> gefüllt, wird das Control
      beim ersten Aufrufen mit leeren Optionen dargestellt. Sofern das Feld mit einem Validator belegt wird, zwingt dies
      den Benutzer zu einer aktiven Auswahl.
      (<strong>Zeichen</strong>: <code>true|false</code>)
   </li>
</ul>

<h4 id="Chapter-3-14-Marker"><a href="#Chapter-3-14-Marker">3.14. Marker</a></h4>
<p>
   Wie im Kapitel <int:link pageid="114" anchor="Chapter-6-Dynamische-Formulare">Dynamische Formulare</int:link>
   beschrieben, kann der Tag <em>&lt;form:marker /&gt;</em>-Tag zur Positionierung von
   dynamischen Formular-Elementen genutzt werden. Der Tag selbst erzeugt dabei keine Ausgabe.
</p>
<gen:highlight type="apf-xml">
&lt;form:marker name="" /&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Markers. Dieser dient zur Adressierung desselben.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
</ul>

<h4 id="Chapter-3-15-Listener"><a href="#Chapter-3-15-Listener">3.15. Listener</a></h4>
<p>
   Der Listener-Tag ist Teil des Validierungs-Konzeptes. Er hört auf das Event eines Validators und
   zeigt seinen Inhalt an, sofern das referenzierte Formular-Element nicht erfolgreich validiert werden
   kann. Im Tag selbst können beliebiger Text und weitere Tags definiert werden, die zur
   Ausgabe-Formatierung heran gezogen werden können. Details zur Validierung, können dem Kapitel 4
   entnommen werden.
</p>
<gen:highlight type="apf-xml">
&lt;form:listener [name=""] control="..." [validator="..." ]&gt;
  ...
  [&lt;html:getstring namespace="" config="" entry="" /&gt;]
  [&lt;html:placeholder name="" /&gt;]
  [&lt;core:addtaglib class="" prefix="" name=""/&gt;]
  ...
&lt;/form:listener&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>control</strong>: Name des Formular-Elements auf dessen fehlgeschlagene Validierung 
    der Inhalt angezeigt werden soll.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
  <li>
    <strong>name</strong>: Name des Listeners. Dient zur Adressierung des Elements innerhalb des
    Formulars.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_-]</code>)
  </li>
  <li>
     <strong>validator</strong>: Name des Validators, der den Listener bei fehlgeschlagener
     Validierung aktivieren darf.
  </li>
</ul>
<p>
   Details zum Platzhalter-Tag können Sie unter
   <int:link pageid="046" anchor="Chapter-2-1-Placeholder">&lt;html:placeholder /&gt;</int:link> nachlesen, die
   Ausgabe von Sprachabhängigen Werten lässt sich über den
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>-Tag realisieren.
</p>
<p>
   Sollte die vorhandene Funktionalität nicht ausreichen, lassen sich eigene Tags sehr einfach per
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link> hinzufügen.
</p>
<p>
   Zur Befüllung eines Platzhalters in einem Document-Controller kann folgender Code verwendet werden:
</p>
<em>Template:</em>
<gen:highlight type="apf-xml">
&lt;html:form name="name_form" method="post"&gt;
   &lt;form:listener name="name-listener" control="name"&gt;
      Please fill in the &lt;html:placeholder name="field-name" /&gt; field!
   &lt;/form:listener&gt;
   &lt;form:text name="name" /&gt;
   &lt;form:button name="send" value="Send" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TextLengthValidator"
      control="name"
      button="send"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<em>Controller:</em>
<gen:highlight type="php">
class FormController extends BaseDocumentController {
   public function transformContent(){
      $form = &$this->getForm('name-form');
      $listener = &$form->getFormElementByName('name-listener');
      $listener->setPlaceHolder('field-name', 'name');
   }
}
</gen:highlight>
<p>
   Das Attribut <em>validator</em> kann dann verwendet werden, wenn für das relevante
   Formular-Feld <a href="#">spezielle Validator-Listener</a>
   definitiert sind. Ein Anwendungs-Beispiel ist die Prüfung eines E-Mail-Feldes, für das
   jeweils eine eigene Meldung für eine fehlende E-Mail-Adresse und eine syntaktisch nicht
   korrekte Eingabe ausgegeben werden soll. Hierzu kann folgendes Template genutzt werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="email_form" method="post"&gt;
   &lt;form:listener control="email" validator="APF\tools\form\validator\TextLengthValidator"&gt;
      Please fill in the email field!
   &lt;/form:listener&gt;
   &lt;form:listener control="email" validator="APF\tools\form\validator\EMailValidator"&gt;
      Please fill in the email field with a correct email address!
   &lt;/form:listener&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TextLengthValidator"
      control="name"
      button="send"
      type="special"
   /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\EMailValidator"
      control="email"
      button="send"
      type="special"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<div class="warn">
   Bitte beachten Sie, dass Validatoren, die für das Attribut <em>type</em> den Wert
   <em>special</em> enthalten nur spezielle Validator-Listener benachrichtigen. Sofern die oben
   ausgegebenen Validator-Meldungen noch mit einer Markierung versehen werden sollen, bietet sich an,
   einen <em>EMailValidator</em> zu definieren, deren Listener als Rahmen-gebende Elemente fungieren:
<gen:highlight type="apf-xml">
&lt;html:form name="email_form" method="post"&gt;
   &lt;form:listener control="email"&gt;
      &lt;div class="error-container"&gt;
   &lt;/form:listener&gt;
   &lt;form:listener control="email" validator="APF\tools\form\validator\TextLengthValidator"&gt;
      Please fill in the email field!
   &lt;/form:listener&gt;
   &lt;form:listener control="email" validator="APF\tools\form\validator\EMailValidator"&gt;
      Please fill in the email field with a correct email address!
   &lt;/form:listener&gt;
   &lt;form:listener control="email"&gt;
      &lt;/div&gt;
   &lt;/form:listener&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TextLengthValidator"
      control="name"
      button="send"
      type="special"
   /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\EMailValidator"
      control="email"
      button="send"
      type="special"
   /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\EMailValidator"
      control="email"
      button="send"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
</div>

<h4 id="Chapter-3-16-Error"><a href="#Chapter-3-16-Error">3.16. Anzeige von Formular-Fehlern</a></h4>
<p>
   Der in Kapitel 3.18 beschriebene Tag kann dazu benutzt werden, automatisiert Fehlermeldungen eines
   definierten Formular-Feldes zu erzeugen. Der <nobr><strong>&lt;form:error /&gt;</strong></nobr>-Tag
   ist für Fehlermeldungen vorbehalten, die das gesamte Formular betreffen. Wird eines der Felder als
   nicht valide markiert, so wird der Inhalt des Tags - sofern in der Formular-Definition vorhanden -
   ausgegeben.
</p>
<gen:highlight type="apf-xml">
&lt;form:error [name=""]&gt;
  ...
  [&lt;html:getstring namespace="" config="" entry="" /&gt;]
  [&lt;html:placeholder name="" /&gt;]
  [&lt;core:addtaglib class="" prefix="" name="" /&gt;]
  ...
&lt;/form:error&gt;
</gen:highlight>
<p>
   Details zum Platzhalter-Tag können Sie unter
   <int:link pageid="046" anchor="Chapter-2-1-Placeholder">&lt;html:placeholder /&gt;</int:link> nachlesen, die
   Ausgabe von Sprachabhängigen Werten lässt sich über den
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>-Tag realisieren.
</p>
<p>
   Sollte die vorhandene Funktionalität nicht ausreichen, lassen sich eigene Tags sehr einfach per
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link> hinzufügen.
</p>

<h4 id="Chapter-3-17-Success"><a href="#Chapter-3-17-Success">3.17. Anzeige von Formular-Erfolgsmeldungen</a></h4>
<p>
   Der in Kapitel 3.19 beschriebene Tag kann dazu benutzt werden, automatisiert Fehlermeldungen
   bezogen auf ein komplettes Formular anzugeigen. Oft ist es jedoch notwendig, auch im Erfolgsfall eine
   Meldung auszugeben. Der <nobr><strong>&lt;form:success /&gt;</strong></nobr>-Tag stellt einen Inhalt
   dar, wenn alle Felder des Formulars als valide gekennzeichnet werden. Die Definition gestaltet sich
   wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;form:success [name=""]&gt;
  ...
  [&lt;html:getstring namespace="" config="" entry="" /&gt;]
  [&lt;html:placeholder name="" /&gt;]
  [&lt;core:addtaglib class="" prefix="" name="" /&gt;]
  ...
&lt;/form:success&gt;
</gen:highlight>
<p>
   Details zum Platzhalter-Tag können Sie unter
   <int:link pageid="046" anchor="Chapter-2-1-Placeholder">&lt;html:placeholder /&gt;</int:link> nachlesen, die
   Ausgabe von Sprachabhängigen Werten lässt sich über den
   <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>-Tag realisieren.
</p>
<p>
   Sollte die vorhandene Funktionalität nicht ausreichen, lassen sich eigene Tags sehr einfach per
   <int:link pageid="046" anchor="Chapter-1-1-Addtaglib">&lt;core:addtaglib /&gt;</int:link> hinzufügen.
</p>
      
<h4 id="Chapter-3-18-TimeCaptcha"><a href="#Chapter-3-18-TimeCaptcha">3.18. TimeCaptcha</a></h4>
<p>
   Mit dem <strong>TimeCaptcha</strong> kann ein Formular in Kombination mit dem 
   <a href="#Chapter-4-1-14-TimeCaptchaValidator">TimeCaptchaValidator</a> vor (Spam-)Bots
   geschützt werden. Hierzu speichert die Taglib den Zeitpunkt der Erstellung in der Session
   und macht diesen für den genannten Validator zur Auswertung verfügbar.
</p>
<p>
   Die minimale Zeitspanne, die Benutzer zum Ausfüllen des Formulars brauchen sollte, kann
   durch Angabe des optionalen Attributs <em>seconds</em> beeinflusst werden. Der Wert muss eine
   ganzzahlige Angabe des Zeitraums beinhalten.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:timecaptcha name="timecaptcha" [seconds="3"]/&gt;
   ...
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-3-19-CSRF-Schutz"><a href="#Chapter-3-19-CSRF-Schutz">3.19. CSRF-Schutz</a></h4>
<p>
   Diese Taglib erzeugt ein verstecktes Feld, das einen generierten Hash enthält. Das Formular wird
   als ungültig gekennzeichnet, wenn sich der im Request enthaltene Hash von einem neu generiertem
   unterscheidet. Damit ist es möglich, ein Formular vor CSRF-Attacken zu schützen.
</p>
<div class="hint">
   Der mitgelieferte <em>CSRFHashValidator</em> muss nicht manuell hinzugefügt werden, da dies
   bereits in der Taglib geschieht.
</div>
<p>
   Zur Generierung des Hashs wird das Provider Pattern genutzt, wodurch der Algoritgmus leicht
   ausgetauscht werden kann. Die Provider-Klasse muss dafür das <em>CSRFHashProvider</em>-Interface
   implementieren, welches die Methode <em>generateHash()</em> vorsieht.
</p>
<p>
   Die folgende Code-Box zeigt den mit dem Release mitgelieferten Provider:
</p>
<gen:highlight type="php">
class EncryptedSIDHashProvider extends APFObject implements CSRFHashProvider {
   public function generateHash($salt) {
      if(!defined('SID')) {
         session_start();
      }

      return md5($salt.SID);
   }
}   
</gen:highlight>
<p>
   Der zu verwendende Provider wird mit dem Attribut <em>class</em> angegeben. Ist kein Wert gesetzt, wird der
   Standardprovider genutzt, welcher einen MD5 Hash von der SID und dem angegebenem Salt liefert.
</p>
<gen:highlight type="apf-xml">
&lt;form:csrfhash
   salt=""
   name=""
   [class=""]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>salt</strong>: Der Salt, der zur sicheren Berechnung des Hash eingesetzt wird.
  </li>
  <li>
     <strong>name</strong>: Der Name des Feldes (<strong>Zeichen</strong>: [A-Za-z0-9_]).
  </li>
  <li>
     <strong>class</strong>: Der voll-qualifizierte Klassen-Name der Provider-Implementierung.
     (<strong>Zeichen</strong>: <code>[A-Za-z0-9_\]</code>)
  </li>
</ul>

<h4 id="Chapter-3-20-Zeit-Control"><a href="#Chapter-3-20-Zeit-Control">3.20. Zeit-Control</a></h4>
<p>
   Um die Erstellung von Zeit-Auswahl-Menüs zu erleichtern, enthält das APF ein Time-Control.
   Dieses kann entsprechend den Anforderungen konfiguriert werden:
</p>
<gen:highlight type="apf-xml">
&lt;form:time
   name=""
   [hoursrange=""]
   [offsetnames=""]
   [showseconds="true|false"]
   [minutesinterval=""]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>name</strong>: Name des Time-Controls. Über den Namen kann auf das Element zugegriffen
    werden.
    (<strong>Zeichen</strong>: [A-Za-z0-9-_])
  </li>
  <li>
     <strong>hoursrange</strong>: Range des Stunden-Feldes. Beispiel: <em>08-21</em>.
     (<strong>Zeichen</strong>: [0-9-])
  </li>
  <li>
     <strong>offsetnames</strong>: Namen der Felder für Stunden, Minuten und Sekunden. Einzelne
     Felder müssen durch ";" getrennt werden. Beispiel: <em>Stunde;Minute;Sekunde</em>.
     (<strong>Zeichen</strong>: [A-Za-z;])
  </li>
  <li>
     <strong>showseconds</strong>: Hier kann festgelegt werden ob bei der Ausgabe auch ein 
     Sekunden-Feld angezeigt werden soll.
  </li>
  <li>
     <strong>minutesinterval</strong>: Mit diesem Attribut kann definiert werden in welchem Abstand
     die auswählbaren Minuten vorhanden sind. Man sollte aber darauf achten, dass 60 durch den Wert
     sinnvoll teilbar ist. Beispiel: 5, 10 oder 15.
  </li>
</ul>

<h4 id="Chapter-3-21-MultiFileUpload"><a href="#Chapter-3-21-MultiFileUpload">3.21. MultiFileUpload</a></h4>
<p>
   Neben dem einfachen Datei-Upload gibt es ein weitere nützliches Tool: den MultiFileUpload. Alle
   wichtigen Informationen diesbezüglich entnehmen Sie bitte dem Wiki-Beitrag:
   <a class="wiki" href="http://wiki.adventure-php-framework.org/MultiFileUpload" title="MultiFileUpload im Wiki">MultiFileUpload im Wiki</a>
</p>

<h4 id="Chapter-3-22-Label"><a href="#Chapter-3-22-Label">3.22. Label</a></h4>
<p>
   Beschriftung eines Formular-Elements können ebenso als APF-Tag definiert werden.
</p>
<p>
   Der Label-Tag hat folgende Signatur:
</p>
<gen:highlight type="apf-xml">
&lt;form:label for=""&gt;
   [...]
   [&lt;label:getstring [name=""] namespace="" config="" entry="" /&gt;]
&lt;/form:label&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
   <li>
      <strong>for</strong>: HTML-Id des Formular-Elements auf das sich die Beschriftung bezieht.
      (<strong>Zeichen</strong>: [A-Za-z0-9-_])
   </li>
   <li>
      <strong>Inhalt</strong>: Der Inhalt des Tags kann entweder durch einen statischen Text oder mit Hilfe eines
      <em>&lt;label:getstring /&gt;</em>-Tags definiert werden.
   </li>
</ul>
<div class="hint">
   Details zur Definition der für den <em>&lt;button:getstring /&gt;</em>-Tag notwendigen Konfigurations-Dateien
   können der Dokumentation des Tags <int:link pageid="046" anchor="Chapter-2-2-Getstring">&lt;html:getstring /&gt;</int:link>
   entnommen werden.
</div>

<h4 id="Chapter-3-23-Group"><a href="#Chapter-3-23-Group">3.23. Group</a></h4>
<p>
   Mit Hilfe des <em>&lt;form:group /&gt;</em>-Tags lassen sich alle im <a href="#Chapter-3-Mitgelieferte-Tags">Kapitel 3</a>
   aufgeführten Formular-Elemente gruppieren. Dies kann Ihnen beispielsweise helfen, mehrere Formular-Elemente inklusive
   des zugehörigen Markup bei Bedarf ohne aufwändige Logik im Controller auszublenden.
</p>
<div class="hint">
   Eine Gruppe von Formular-Elementen kann weitere Gruppen enthalten. So lassen sich sehr einfach quasi-dynamische
   Formulare erstellen, die sich im Controller je nach Anwendungsfall steuern lassen.
</div>
<p>
   Der Formular-Element-Gruppen-Tag besitzt folgende Signatur:
</p>
<gen:highlight type="apf-xml">
&lt;form:group name="" [id=""] [hidden="true|false"]&gt;
   ...
&lt;/form:group&gt;
</gen:highlight>
<p>
   Die Attribute <em>name</em> bzw. <em>id</em> können genutzt werden um eine Gruppe innerhalb eines Controllers zu
   beziehen. Der Tag selbst erzeugt keine eigene Ausgabe, er zeigt lediglich die darin befindlichen Fomular-Elemente und
   das HTML an.
</p>
<p>
    Mit Hilfe des Attributs <em>hidden</em> lässt sich die Gruppe direkt im Template ausblenden. Dies ist hilfreich,
    wenn das Formular aus mehreren Gruppen besteht, die nur bei Bedarf eingeblendet werden sollen.
</p>
<p>
   Die folgende Code-Box zeigt eine Checkbox sowie eine Gruppe mit einem Textfeld und dem zugehörigen Label:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="group-example"&gt;

   &lt;form:checkbox name="hide-group" /&gt; Gruppe ausblenden?

   &lt;form:group name="grouped-text"&gt;
      &lt;p&gt;
         &lt;form:label&gt;Vorname&lt;/form:label&gt;
         &lt;form:text name="surname" /&gt;
      &lt;/p&gt;
   &lt;/form:group&gt;

   &lt;form:button name="send" value="Absenden" /&gt;

&lt;/html:form&gt;
</gen:highlight>
<p>
   Im nachfolgende gezeigten Controller lässt sich das Feld zur Eingabe des Vornamens sehr einfach über das Ausblenden
   der Gruppe realisieren:
</p>
<gen:highlight type="php">
class SignUpController extends BaseDocumentController {

   public function transformContent() {
      $form = & $this->getForm('group-example');

      $groupSwitch = & $form->getFormElementByName('hide-group');
      if ($groupSwitch->isChecked()) {
         $form->getFormElementByName('grouped-text')->hide();
      }

      $form->transformOnPlace();
   }
}
</gen:highlight>
<p>
   Weitere Hinweise zur Verwendung von Formular-Element-Gruppen finden Sie unter <int:link pageid="114" anchor="Chapter-8-3-Ausblenden-von-Gruppen" />.
</p>

<h3 id="Chapter-4-Validierung"><a href="#Chapter-4-Validierung">4. Validierung</a></h3>
<p>
   Validatoren werden über ein eigenes Tag, das nach dem
   <a class="external" href="http://de.wikipedia.org/wiki/Observer_%28Entwurfsmuster%29" title="Observer-Pattern ">Observer-Pattern</a>
   implementiert ist, an das einzelne Element gebunden. So ist es möglich, mehrere Validatoren auf ein
   Feld anzusetzen, eigene Validatoren zu schreiben und mit einer Observer-Definition mehrere Felder
   zu gleichermaßen zu validieren.
</p>
<p>Die Definition einer Validierung eines Formular-Feldes gestaltet sich dabei wie folgt:</p>
<gen:highlight type="apf-xml">
&lt;form:addvalidator
   class=""
   button=""
   control=""
   [type="special"]
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>class</strong>: Der voll-qualifizierte Klassen-Name der Tag-Implementierung.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9_\]</code>)
  </li>
  <li>
    <strong>button</strong>: Name des Buttons, der die Validierung auslösen soll. Die Validierung
    ist immer an das Event <em>isSent</em> eines Buttons oder Image-Buttons gebunden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>control</strong>: Name des Formular-Controls auf das die Validierung Anwendung finden
    soll. Sollen mehrere Controls mit der im Tag definierten Validierung belegt werden, so enthält
    das Attribut alle mit Pipe getrennte Feld-Namen (z.B. <em>sender|recipient|subject</em>).
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_|]</code>)
  </li>
  <li>
     <strong>type</strong>: Sofern das optionale Attribut vorhanden und auf den Wert <em>special</em>
     gesetzt ist, werden nur noch Listener informiert, die im Attribut <em>validator</em> den Namen
     (=Klassen-Namen) des mit dem Tag definierten Validators enthalten. 
     (<strong>Zeichen</strong>: <code>special</code>)
  </li>
</ul>
<div class="hint">
   Hinweise zu speziellen Validator-Listenern findet sich auch im Wiki-Artikel
   <a class="wiki" href="http://wiki.adventure-php-framework.org/Spezielle_Validator-Listener" title="Spezielle Validator-Listener">Spezielle Validator-Listener</a>.
</div>
<p>
   Die Markierung von invaliden Formular-Elementen erfolgt auf Basis von CSS-Klassen. Dies ermöglicht flexiblere
   Formatierung pro Formular oder Anwendungsfall. Das Proposal zur Implementierung kann unter
   <a class="wiki" href="http://wiki.adventure-php-framework.org/Weiterentwicklung_Formular-Validierung" title="Weiterentwicklung Formular-Validierung">Weiterentwicklung Formular-Validierung</a>
   nachgelesen werden.
</p>
<p>
   Im Standard-Fall werden von Validatoren als fehlerhaft markierte Felder mit der CSS-Klasse
   <em>apf-form-error</em> ausgestattet. Ist dies nicht erwünscht, kann diese Klasse durch Setzen
   des Attributs <em>valmarkerclass</em> beim jeweiligen Formular-Element beeinflusst werden:
</p>
<gen:highlight type="apf-xml">
&lt;form:text
   name="age"
   valmarkerclass="special-val-marker"
/&gt;
</gen:highlight>
<p>
   Um alle fehlerhaften Formular-Elemente innerhalb eines Web-Projekts mit einem roten Rahmen zu
   versehen, muss das CSS folgende Klassen-Definition enthalten:
</p>
<gen:highlight type="css">
.apf-form-error {
   border: 2px solid red;
}
</gen:highlight>
<p>
   Die speziellen Klassen-Definitionen müssen ebenfalls im CSS abgebildet werden. Andernfalls wird
   ein als invalid gekennzeichnetes Feld u.U. optisch nicht als solches hervorgehoben.
</p>

<h4 id="Chapter-4-1-Verfuegbare-Validatoren"><a href="#Chapter-4-1-Verfuegbare-Validatoren">4.1. Verfügbare Validatoren</a></h4>
<p>
   Das APF liefert eine Reihe von Validatoren mit. Diese decken üblicherweise den Großteil der Anforderungen ab.
   Sollten diese nicht genügen, können eigene Validatoren implementiert werden. Dies ist im nächsten Kapitel beschrieben.
</p>
<div class="warn">
   Bitte beachten Sie, dass <em>&lt;form:addvalidator /&gt;</em>-Tags im Template stets nach der zugehörigen
   <em>&lt;form:button /&gt;</em>- bzw. <em>&lt;form:imagebutton /&gt;</em>-Definition platziert ist. Dies ist
   erforderlich, damit der angegebene Validator den referenzierten Button auflösen kann.
</div>
<div class="hint">
   Validatoren können auch als optional deklariert werden. Dazu muss das optional zu validierende Formular-Feld das
   Attribut <em>optional</em> mit dem Wert <em>true</em> besitzten:
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="age" optional="true"/&gt;
   &lt;form:button name="send" value="Send" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\IntegerValidator"
      button="send"
      control="age"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
   Bitte beachten Sie, dass optionale Validatoren aktuell nur für Text-Felder implementiert sind,
   da Select- und Checkbox-Felder hinsichtlich ihrer Verwendung nach Meinung der APF-Entwickler
   keine optionale Validierung benötigen.
</div>
<div class="hint">
   Der Großteil der verfügbaren Formular-Validatoren basiert auf den mit dem APF mitgelieferten Validatoren. Details
   hierzu finden Sie auf der Seite <int:link pageid="160" />.
</div>
<p>Aktuell sind folgende Validatoren im Release verfügbar:</p>

<h5 id="Chapter-4-1-1-TextLengthValidator"><a href="#Chapter-4-1-1-TextLengthValidator">4.1.1. TextLengthValidator</a></h5>
<p>
   Der <strong>TextLengthValidator</strong> überprüft ein Text-Formular-Feld (Text-Feld,
   Passwort-Feld, Text-Area), ob der enthaltene Text eine Mindestlänge aufweist. Standardmäßig
   wird von einer Länge von mindestens 3 Zeichen ausgegangen, die vom Benutzer eingegeben werden
   müssen, ehe das Feld als gültig markiert wird. Sofern eine andere Text-Länge als
   valide Eingabe erwünscht ist, kann dies im referenzierten Text-Feld mit den Attributen
   <strong>minlength</strong> und <strong>maxlength</strong> angegeben werden:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="firstname" /&gt;
   &lt;form:text name="lastname" minlength="5" /&gt;
   &lt;form:password name="pass" /&gt;
   &lt;form:area name="comment" minlength="20" maxlength="200"/&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TextLengthValidator"
      button="send"
      control="firstname|lastname|pass|comment"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>
<p>
   Im abgebildeten Code-Block wird das Formular-Control <strong>firstname</strong> auf einen Text
   mit einer Zeichenlänge &gt;=3 validiert, im Feld <strong>lastname</strong> müssen
   mindestens 5 aber höchstens 200 Zeichen enthalten sein.
</p>
<p>
   Es ist ebenso möglich, eine strikte Validierung der Textlänge zu aktivieren. Hierzu kann im referenzierten Text-Feld
   das Attribut <strong>mode</strong> mit dem Wert <em>strict</em> versehen werden. Ab diesem Zeitpunkt wendet der
   Validator die Funktion <em>trim()</em> auf die Eingabe an und erkennt nur Inhalte an, die nicht lediglich aus
   Leerzeichen bestehen.
</p>

<h5 id="Chapter-4-1-2-NumberValidator"><a href="#Chapter-4-1-2-NumberValidator">4.1.2. NumberValidator</a></h5>
<p>
   Der <strong>NumberValidator</strong> prüft, ob ein Text-Feld eine gültige Nummer enthält. Hierzu
   wird die PHP-Funktion <em>is_numeric()</em> genutzt.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="number" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\NumberValidator"
      button="send"
      control="number"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-3-EMailValidator"><a href="#Chapter-4-1-3-EMailValidator">4.1.3. EMailValidator</a></h5>
<p>
   Der <strong>EMailValidator</strong> prüft, ob im referenzierten ein Form-Control eine gültige
   E-Mail-Addresse steht. Hierzu wird der Inhalt des Text-Feldes gegen einen regulären Ausdruck
   geprüft.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\EMailValidator"
      button="send"
      control="email"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-4-PhoneAndFaxValidator"><a href="#Chapter-4-1-4-PhoneAndFaxValidator">4.1.4. PhoneAndFaxValidator</a></h5>
<p>
   Der <strong>PhoneAndFaxValidator</strong> prüft, ob ein Formular-Feld eine gültige Telefon-
   oder Fax-Nummer enthält. Hierzu wird der Inhalt des Text-Feldes gegen einen regulären Ausdruck
   geprüft.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="phone" /&gt;
   &lt;form:text name="fax" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\PhoneAndFaxValidator"
      button="send"
      control="phone|fax"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-5-FieldCompareValidator"><a href="#Chapter-4-1-5-FieldCompareValidator">4.1.5. FieldCompareValidator</a></h5>
<p>
   Mit dem <strong>FieldCompareValidator</strong> ist es möglich, den Inhalt zweiter Felder mit
   einander zu vergleichen. Stimmen sie nicht überein, werden die beiden Felder auf <em>invalid</em>
   gesetzt.
</p>
<p>
   Da ein Validator immer auf ein konkretes Control gesetzt wird, muss das Haupt-Feld definieren,
   welches Formular-Element als Referenz-Feld genutzt wird. Hierzu definiert dieses das Attribut
   <strong>ref</strong>, das den Namen des Referenz-Feldes enthält.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:password name="pass" ref="pass2" /&gt;
   &lt;form:password name="pass2" /&gt;
   &lt;form:button name="login" value="login" /&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\FieldCompareValidator"
      control="pass"
      button="login"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-6-SimpleBirthdayValidator"><a href="#Chapter-4-1-6-SimpleBirthdayValidator">4.1.6. SimpleBirthdayValidator</a></h5>
<p>
   Der <strong>SimpleBirthdayValidator</strong> prüft ein Text-Feld auf ein korrektes Datum der Form
   <strong>dd.MM.YYYY</strong>.
</p>
<div class="hint">
   Der Validator kann nur mit &quot;normalen&quot; Text-Feldern verwendet werden. Sofern ein
   Date-Control validiert werden soll, muss der
   <a href="#Chapter-4-1-10-SimpleDateControlValidator">SimpleDateControlValidator</a>
   genutzt oder ein eigener Validator implementiert werden.
</div>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="birthday" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\SimpleBirthdayValidator"
      button="send"
      control="birthday"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-7-SimpleSelectControlValidator"><a href="#Chapter-4-1-7-SimpleSelectControlValidator">4.1.7. SimpleSelectControlValidator</a></h5>
<p>
   Der <strong>SimpleSelectControlValidator</strong> ist für die Prüfung von statischen und
   dynamischen Select-Formular-Feldern geeignet. Er prüft ein Select-Feld, ob der ausgewählte Inhalt
   nicht leer ist.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:select name="color"&gt;
      &lt;select:option value=""&gt;&lt;/select:option&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:select&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\SimpleSelectControlValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-8-MultiSelectFieldValidator"><a href="#Chapter-4-1-8-MultiSelectFieldValidator">4.1.8. MultiSelectFieldValidator</a></h5>
<p>
   Der <strong>MultiSelectFieldValidator</strong> ist das Pendant zum
   <strong>SimpleSelectControlValidator</strong>. Er prüft Multi-Select-Felder auf eine nicht leere
   Auswahl.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:multiselect name="colors"&gt;
      &lt;select:option value="red"&gt;Red color&lt;/select:option&gt;
      &lt;select:option value="green"&gt;Green color&lt;/select:option&gt;
   &lt;/form:multiselect&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\MultiSelectFieldValidator"
      button="send"
      control="colors"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-9-SimpleRadioControlValidator"><a href="#Chapter-4-1-9-SimpleRadioControlValidator">4.1.9. SimpleRadioControlValidator</a></h5>
<p>
   Mit dem <strong>SimpleRadioControlValidator</strong> kann ein Radio-Button, bzw. eine ganze Gruppe
   validiert werden. Anforderung des Validators ist, das eine Option der Gruppe ausgewählt ist. Der
   Validator ist sowohl für dynamische als auch für statische Formular-Definitionen geeignet.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:radio id="red" name="color" /&gt; Red color
   &lt;form:radio id="green" name="color" /&gt; Green color
   &lt;form:radio id="blue" name="color" /&gt; Blue color
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\SimpleRadioControlValidator"
      button="send"
      control="color"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-10-SimpleDateControlValidator"><a href="#Chapter-4-1-10-SimpleDateControlValidator">4.1.10. SimpleDateControlValidator</a></h5>
<p>
   Der <strong>SimpleDateControlValidator</strong> validiert ein Date-Control (siehe Kapitel 3.14.).
   Er erwartet, dass das dort ausgewählte Datum größer als das heutige ist.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:date name="birthday" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\SimpleDateControlValidator"
      button="send"
      control="birthday"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-11-MimeTypeValidator"><a href="#Chapter-4-1-11-MimeTypeValidator">4.1.11. MimeTypeValidator</a></h5>
<p>
   Der <strong>MimeTypeValidator</strong> prüft, ob der MIME-Typ der hochgeladenen Datei in
   der Liste der akzeptierten Typen zu finden ist. Die Liste der zugelassenen Datei-Typen wird als
   Pipe-separierte Liste im Attribut <em>accepts</em> des zu validierenden Formular-Elements
   erwartet. 
</p>
<p>
   Die Evaluierung der Datei-Typen wird <strong>ab PHP 5.3</strong> mit Hilfe der 
   <em>finfo</em>-Funktionen durchgeführt, für alle früheren Versionen wird die
   Information genutzt, die von PHP im Offset <em>type</em> des <em>$_FILES</em>-Array zur
   Verfügung gestellt wird (siehe auch 
   <a class="external" href="http://de.php.net/manual/en/reserved.variables.files.php" title="$_FILES">$_FILES</a>
   im PHP-Manual).
</p>
<div class="warn">
   Aus der Bestimmung der Inhalts-Typen kann sich eine Änderung der Definition der akzeptierten
   Medien ergeben. Ab der PHP Version 5.3 können die akzeptierten Typen in der
   MIME-Typen-Schreibweise (z.B. <em>application/pdf</em>) definiert werden, in PHP Versionen < 5.3
   lediglich über die Endung (z.B. <em>pdf</em>).
</div>
<p>
   Im folgenden Formular akzeptiert ein Dateiupload-Feld lediglich PDF-Dateien. Das Formular wird
   solange als invalid gekennzeichnet, bis der Benutzer das richtige Datei-Format gewählt hat:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="upload" method="post"&gt;
   <fieldset>
      <label for="pdf">PDF file:</label>
      &lt;form:file name="pdf" id="pdf" accepts="pdf|application/pdf" /&gt;
      &lt;form:button name="send" value="GO" /&gt;
      &lt;form:addvalidator
         class="APF\tools\form\validator\MimeTypeValidator"
         control="pdf"
         button="send"
      /&gt;
   </fieldset>
&lt;/html:form&gt;
</gen:highlight>
<p>
   Wie dem Attribut <em>accepts</em> zu entnehmen ist, wurden hier aus Gründen der
   Kompatibilität beide Schreibweisen der Type-Definitionen eingefügt um bei einem
   Version-Upgrade weiter die gewünschte Funktion zu erhalten.
</p>

<h5 id="Chapter-4-1-12-FileSizeValidator"><a href="#Chapter-4-1-12-FileSizeValidator">4.1.12. FileSizeValidator</a></h5>
<p>
   Der <strong>FileSizeValidator</strong> prüft die hochgeladene Datei auf ihre
   Datei-Größe. Hierzu werden die optionalen Attribute <em>minsize</em> und <em>maxsize</em>
   genutzt um den Bereich der erlaubten Datei-Größe <strong>in Bytes</strong> zu definieren.
</p>
<p>
   Ist das Attribut <em>minsize</em> im zu validierenden Formular-Element nicht definiert, wird ein
   Wert von <em>0</em> angenommen. Es ist damit möglich, 0-Byte-Dateien hochzuladen. Ist das
   Attribut <em>maxsize</em> nicht definiert, wird eine maximale Größe von <em>1024000</em>
   (=1 MB) zugelassen.
</p>
<p>
   Im folgenden Formular werden nur Dateien zugelassen, die eine Mindest-Größe von
   <em>20kB</em> und eine maximale Größe von <em>500kB</em> haben:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="upload" method="post"&gt;
   <fieldset>
      <label for="image">Image:</label>
      &lt;form:file name="image" id="image" minsize="20480" maxsize="512000" /&gt;
      &lt;form:button name="send" value="GO" /&gt;
      &lt;form:addvalidator
         class="APF\tools\form\validator\FileSizeValidator"
         control="image"
         button="send"
      /&gt;
   </fieldset>
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-13-CheckboxValidator"><a href="#Chapter-4-1-13-CheckboxValidator">4.1.13. CheckboxValidator</a></h5>
<p>
   Der <strong>CheckboxValidator</strong> prüft, ob eine Checkbox aktiviert wurde. Ist diese
   nicht der Fall, wird das Feld als invalid markiert.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="upload" method="post"&gt;
   <fieldset>
      ...
      &lt;form:checkbox name="agb" value="agb" /&gt; Akzeptiere die AGBs.
      &lt;form:button name="send" value="GO" /&gt;
      &lt;form:addvalidator
         class="APF\tools\form\validator\CheckboxValidator"
         button="send"
         control="agb"
      /&gt;
   </fieldset>
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-14-TimeCaptchaValidator"><a href="#Chapter-4-1-14-TimeCaptchaValidator">4.1.14. TimeCaptchaValidator</a></h5>
<p>
   Mit dem <strong>TimeCaptchaValidator</strong> kann ein Formular in Kombination mit dem
   <a href="#Chapter-3-18-TimeCaptcha">&lt;form:timecaptcha /&gt;</a> vor (Spam-)Bots geschützt
   werden. Der Validator prüft die Zeit, welche zum Ausfüllen des Formulars gebraucht wurde.
   Da Bots Formulare meistens binnen Sekundenbruchteilen ausfüllen, genügt es
   standartmäßig alle Formulare, welche in weniger als 2 Sekunden ebgeschickt wurden als
   invalid zu kennzeichnen. Dieser Wert kann durch Angabe des optionalen <em>seconds</em> Parameters
   in der Taglib-Definition beeinflusst werden.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:timecaptcha name="timecaptcha"/&gt;
   &lt;form:button name="send" value="Send"/&lt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\TimeCaptchaValidator"
      button="send"
      control="timecaptcha"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-15-IntegerValidator"><a href="#Chapter-4-1-15-IntegerValidator">4.1.15. IntegerValidator</a></h5>
<p>
   Der <em>IntegerValidator</em> validiert, ob die Eingabe einen validen Integer-Wert enthält:
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="age" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\IntegerValidator"
      button="send"
      control="age"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-16-NumberScopeValidator"><a href="#Chapter-4-1-16-NumberScopeValidator">4.1.16. NumberScopeValidator</a></h5>
<p>
   Der <em>NumberScopeValidator</em> validiert ein Eingabefeld auf eine ganze Zahl in einem definierten Bereich. Der
   Standard-Bereich geht von <em>0</em> bis <em>65535</em> (maximale Zahl für 16-Bit Integer). Die untere und obere
   Grenze kann mit Hilfe der Attribute <em>minvalue</em> und <em>maxvalue</em> am jeweiligen Formular-Feld definiert
   werden. Der untere oder obere Bereich kann jweils mit dem Wert <em>null</em> auf unendlich gesetzt werden.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="age" minvalue="10" maxvalue="100" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\NumberScopeValidator"
      button="send"
      control="age"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-4-1-17-UriValidator"><a href="#Chapter-4-1-17-UriValidator">4.1.17. UriValidator</a></h5>
<p>
   Der <em>UriValidator</em> validiert ein Eingabefeld auf eine valide URI. 
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="url" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addvalidator
      class="APF\tools\form\validator\UriValidator"
      button="send"
      control="url"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-4-2-Aufbau-von-Validatoren"><a href="#Chapter-4-2-Aufbau-von-Validatoren">4.2. Aufbau von Validatoren</a></h4>
<p>
   Validatoren sind Klassen, die von <strong>AbstractFormValidator</strong> erben. Diese definiert das
   Interface aller Formular-Validatoren. Das ist notwendig, damit diese als Observer an alle
   Formular-Elemente geheftet werden können.
</p>
<p>
   Das Interface eines Validators hat folgende gestalt:
</p>
<gen:highlight type="php">
abstract class AbstractFormValidator extends APFObject {

   protected $control;
   protected $button;

   public function __construct(AbstractFormControl &$control, AbstractFormControl &$button){
      $this->control = &$control;
      $this->button = &$button;
   }

   public abstract function validate($input);

   public abstract function notify();

   public function isActive(){
      return $this->button->isSent();
   }

}
</gen:highlight>
<p>
   Über den Konstruktor werden das zu validierende Form-Control und der Button, der als Trigger
   fungiert injiziert. Die Methode <strong>validate()</strong> wird vom Formular-Element mit dem zu
   validierenden Inhalt versorgt und muss den Validierungs-Code enthalten. Als Rückgabe wird
   <em>true</em> im Erfolgsfall und <em>false</em> im Fehlerfall erwartet.
</p>
<p>
   Die Methode <strong>notify()</strong> wird aufgerufen, wenn ein Formular-Element nicht erfolgreich
   validiert werden konnte. Dieses kann dazu dienen, die Formular-Elemente mit weiteren
   CSS-Formatierungen zu versehen, Platzhalter zu füllen oder Änderungen am DOM-Baum vorzunehmen.
   Die übliche Vorgehensweise ist, das Feld entsprechen zu markieren und die registrierten Listener
   zu benachrichtigen.
</p>
<p>
   Die Klassen-Variablen <strong>$control</strong> und <strong>$button</strong> enthalten jeweils
   die Instanz des zu validieren Formular-Elements und den Button, der als Trigger verwendet wird.
</p>
<p>
   Voraussetzung für die Funktion von Validatoren ist, dass ein Formular-Element die Validierung
   unterstützt. Hierzu muss in jedem Formular-Control die Methode <strong>addValidator()</strong>
   implementiert sein. Diese in der Klasse <strong>AbstractFormControl</strong> definierte Methode hat
   folgende Signatur:
</p>
<gen:highlight type="php">
public function addValidator(AbstractFormValidator &$validator){
   if($validator->isActive()){
      if(!$validator->validate($this->getAttribute('value'))){
         $validator->notify();
      }
   }
}
</gen:highlight>
<p>
   Wie im Code-Snippet zu sehen ist, nimmt die Methode eine Instanz eines Validators entgegen, führt
   diesen - falls als aktiv gekennzeichnet - aus und involviert die <strong>notify()</strong>-Methode
   bei nicht erfolgreicher Validierung.
</p>
<p>
   Wie ebenfalls zu erkennen ist, wird dem Validator <em>by default</em> das Tag-Attribut
   <strong>value</strong> übergeben, was nur für Text-Felder gültig ist. Aus diesem Grund
   überschreiben Nicht-Text-Felder diese Methode und übergeben dem Validator den relevanten
   Inhalt.
</p>

<h4 id="Chapter-4-3-Implementierung-von-Validatoren"><a href="#Chapter-4-3-Implementierung-von-Validatoren">4.3. Implementierung von Validatoren</a></h4>
<p>
   Wie bereits im letzten Kapitel angesprochen, muss ein Validator von der Klasse
   <strong>AbstractFormValidator</strong> erben. Das APF enthält daneben noch einige weitere
   Basis-Klassen, die für die Implementierung von Validatoren verwendet werden können. Diese sind:
</p>
<ul>
   <li><strong>TextFieldValidator:</strong> Basis für alle Text-Feld Validatoren</li>
   <li><strong>SelectFieldValidator:</strong> Basis für alle Select-Feld Validatoren</li>
</ul>
<p>
   Diese sehen bereits vor, welche Änderungen am Formular-Element im Fehlerfall vorgenommen werden
   und welche Listener zu benachrichtigen sind.
</p>
<p>
   Für die Implementierung eines eigenen Validators muss folgendes beachtet werden:
</p>
<ul>
   <li>Der Validator muss von von der Klasse <strong>AbstractFormValidator</strong> erben.</li>
   <li>
      Mit Hilfe der Methode <strong>markAsInvalid()</strong> kann ein Formular-Element als
      invalide gekennzeichnet werden.
   </li>
   <li>
      Mit Hilfe der Methode <strong>notifyValidationListeners()</strong> können die Listener 
      eines übergebenen Elements benachrichtigt werden.
   </li>
   <li>
      Über den Button (Methode: <strong>isSent()</strong>)kann der Entwickler abfragen, ob das
      Formular mit Klick auf diesen abgesendet wurde.
   </li>
</ul>

<h3 id="Chapter-5-Filter"><a href="#Chapter-5-Filter">5. Filter</a></h3>
<p>
   Ähnlich der Struktur der Validatoren werden auch Filter als Observer auf ein Formular-Element angewendet.
</p>
<div class="hint">
   Die Filterung von Formular-Felder wird <strong>vor</strong> der Validierung ausgeführt um zu
   verhindern, dass Eingaben, die durch einen Filter entfernt werden, eine positive Validierung
   erzeugen. Dies ist insbesondere beim <strong>TextLengthValidator</strong> relevant.
</div>
<p>
   Die Definition der Filterung eines Formular-Feldes gestaltet sich dabei wie folgt:
</p>
<gen:highlight type="apf-xml">
&lt;form:addfilter
   class=""
   button=""
   control=""
/&gt;
</gen:highlight>
<strong>Beschreibung der Attribute:</strong>
<ul>
  <li>
    <strong>class</strong>: Der voll-qualifizierte Klassen-Name der Filter-Implementierung.
     (<strong>Zeichen</strong>: <code>[A-Za-z0-9_\]</code>)
  </li>
  <li>
    <strong>button</strong>: Name des Buttons, der die Filterung auslösen soll. Die Filterung
    ist immer an das Event <em>isSent</em> eines Buttons oder Image-Buttons gebunden.
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_]</code>)
  </li>
  <li>
    <strong>control</strong>: Name des Formular-Controls auf das die Filterung Anwendung finden
    soll. Sollen mehrere Controls mit der im Tag definierten Filterung belegt werden, so enthält
    das Attribut alle mit Pipe getrennte Feld-Namen (z.B. <em>sender|recipient|subject</em>).
    (<strong>Zeichen</strong>: <code>[A-Za-z0-9-_|]</code>)
  </li>
</ul>
<div class="warn">
   Bitte beachten Sie, dass die Filterung von Werten lediglich innerhalb der Formular-Elemente greift. Die Werte in den
   Superglobals <em>$_GET</em>, <em>$_POST</em> und <em>$_REQUEST</em> bleiben davon unberührt. Es empfiehlt sich daher
   dringend, Inhalte direkt aus den Formular-Komponenten zu beziehen.
</div>

<h4 id="Chapter-5-1-Verfuegbare-Filter"><a href="#Chapter-5-1-Verfuegbare-Filter">5.1. Verfügbare Filter</a></h4>
<p>
   Das APF liefert eine Reihe von Filter mitgeliefert. Diese decken üblicherweise den Großteil der Anforderungen ab.
   Sollten diese nicht genügen, können eigene Filter implementiert werden. Dies ist im nächsten Kapitel beschrieben.
</p>
<div class="warn">
   Bitte beachten Sie, dass <em>&lt;form:addfilter /&gt;</em>-Tags im Template stets nach der zugehörigen
   <em>&lt;form:button /&gt;</em>- bzw. <em>&lt;form:imagebutton /&gt;</em>-Definition platziert ist. Dies ist
   erforderlich, damit der angegebene Filter den referenzierten Button auflösen kann.
</div>
<div class="hint">
   <p>
      Regulären Ausdrücke zahlreicher Filter lassen sich über das Tag-Attribut <em>filter-expr</em> des zu filternden
      Formular-Elements steuern. Dies hilft beispielsweise Zeichensatz-Probleme wie im
      <a linkrewrite="false" class="forum" href="http://forum.adventure-php-framework.org/viewtopic.php?f=10&amp;t=643#p6275">Forum</a>
      diskutiert vermeiden. 
   </p>
   <p>
      Folgende Filter unterstützen das Überschreiben des Filter-Ausdrucks:
   </p>
   <ul>
      <li>SpecialCharacterFilter</li>
      <li>OnlyNumbersFilter</li>
      <li>OnlyLettersFilter</li>
      <li>OnlyIntegersFilter</li>
      <li>NoSpecialCharactersFilter</li>
      <li>EMailFilter</li>
   </ul>
   <p>
      Darüber hinaus verwenden Zeichensatz-sensitive Funktions-Aufrufe der Filter nun den per
      <int:link pageid="067" /> global konfigurierten Zeichensatz. 
   </p>
</div>
<p>
   Aktuell sind folgende Filter im Release verfügbar:
</p>

<h5 id="Chapter-5-1-1-EMailFilter"><a href="#Chapter-5-1-1-EMailFilter">5.1.1. EMailFilter</a></h5>
<p>
   Der <strong>EMailFilter</strong> entfernt alle Zeichen, die für eine E-Mail-Adresse nicht relevant
   sind.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="email" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\EMailFilter"
      button="send"
      control="email"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-2-NoSpecialCharactersFilter"><a href="#Chapter-5-1-2-NoSpecialCharactersFilter">5.1.2. NoSpecialCharactersFilter</a></h5>
<p>
   Der <strong>NoSpecialCharactersFilter</strong> filtert alle Zeichen, die nicht dem regulären
   Ausdruck <strong>[^0-9A-Za-z-_\.& ]</strong> genügen.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="simplechars" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\NoSpecialCharactersFilter"
      button="send"
      control="simplechars"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-3-OnlyHTMLEntitiesFilter"><a href="#Chapter-5-1-3-OnlyHTMLEntitiesFilter">5.1.3. OnlyHTMLEntitiesFilter</a></h5>
<p>
   Mit dem <strong>OnlyHTMLEntitiesFilter</strong> kann erreicht werden, dass Sonderzeichen in ihre
   HTML Entity Entsprechungen umgewandelt werden. Hierbei muss jedoch beachtet werden, dass bei
   mehrmaligem Abschicken, Mehrfach-Codierungen möglich sind.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="htmlentitiestext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\OnlyHTMLEntitiesFilter"
      button="send"
      control="htmlentitiestext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-4-OnlyIntegersFilter"><a href="#Chapter-5-1-4-OnlyIntegersFilter">5.1.4. OnlyIntegersFilter</a></h5>
<p>
   Der <strong>OnlyIntegersFilter</strong> lässt nur Ziffern zu und filtert alle anderen Zeichen.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="zipcode" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\OnlyIntegersFilter"
      button="send"
      control="zipcode"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-5-OnlyLettersFilter"><a href="#Chapter-5-1-5-OnlyLettersFilter">5.1.5. OnlyLettersFilter</a></h5>
<p>
   Mit dem <strong>OnlyLettersFilter</strong> werden nur Standard-Zeichen des Alphabets zugelassen.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="productcode" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\OnlyLettersFilter"
      button="send"
      control="productcode"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-6-OnlyNumbersFilter"><a href="#Chapter-5-1-6-OnlyNumbersFilter">5.1.6. OnlyNumbersFilter</a></h5>
<p>
   Der <strong>OnlyNumbersFilter</strong> lässt nur Ziffern und Interpunktionen zu, die für die
   Trennung von 1000er Blöcken und Nachkommastellen notwendig sind.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:text name="productprice" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\OnlyNumbersFilter"
      button="send"
      control="productprice"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-7-SpecialCharacterFilter"><a href="#Chapter-5-1-7-SpecialCharacterFilter">5.1.7. SpecialCharacterFilter</a></h5>
<p>
   Mit dem <strong>SpecialCharacterFilter</strong> werden nur Zeichen zugelassen, die im normalen
   Satzbau notwendig sind.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="simpletext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\SpecialCharacterFilter"
      button="send"
      control="simpletext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-8-String2LowerFilter"><a href="#Chapter-5-1-8-String2LowerFilter">5.1.8. String2LowerFilter</a></h5>
<p>
   Der <strong>String2LowerFilter</strong> wandelt alle Buchstaben in Klein-Buchstaben um.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="lowertext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\String2LowerFilter"
      button="send"
      control="lowertext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-9-String2UpperFilter"><a href="#Chapter-5-1-9-String2UpperFilter">5.1.9. String2UpperFilter</a></h5>
<p>
   Der <strong>String2UpperFilter</strong> wandelt alle Buchstaben in Groß-Buchstaben um.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="uppertext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\String2LowerFilter"
      button="send"
      control="uppertext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-10-StripTagsFilter"><a href="#Chapter-5-1-10-StripTagsFilter">5.1.10. StripTagsFilter</a></h5>
<p>
   Mit dem <strong>StripTagsFilter</strong> werden alle HTML- und PHP-Code-Fragmente aus dem Text
   entfernt. Dieser eignet sich gut für Felder, in denen viel Freitext eingegeben werden kann.
</p>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="notagstext" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\StripTagsFilter"
      button="send"
      control="notagstext"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h5 id="Chapter-5-1-11-FloatFilter"><a href="#Chapter-5-1-11-FloatFilter">5.1.11. FloatFilter</a></h5>
<p>
   Der <strong>FloatFilter</strong> kann dazu genutzt werden, um Inhalte eines Text-Feldes in eine
   Fließkomma-Zahl umzuwandeln.
</p>
<div class="hint">
   Dieser Filter ist vor Allem dann interessant, wenn Text-Felder zur Eingabe von Fließkomma-Zahlen
   angeboten werden. Damit entfällt bei der Verarbeitung die Konvertierung und erleichtert die
   Validierung.
</div>
<gen:highlight type="apf-xml">
&lt;html:form name="..."&gt;
   &lt;form:area name="length" /&gt;
   &lt;form:button name="send" value="Send"/&gt;
   &lt;form:addfilter
      class="APF\tools\form\filter\FloatFilter"
      button="send"
      control="length"
   /&gt;
&lt;/html:form&gt;
</gen:highlight>

<h4 id="Chapter-5-2-Aufbau-von-Filtern"><a href="#Chapter-5-2-Aufbau-von-Filtern">5.2. Aufbau von Filtern</a></h4>
<p>
   Formular-Filter sind eine Spezialisierung der APF-Filter-API. Als Interface steht die abstrakte
   Klasse <strong>AbstractFormFilter</strong> zur Verfügung, die alle konkreten Formular-Filter
   implementieren müssen.
</p>
<p>
   Ähnlich den im Kapitel 4.2 beschrieben Formular-Validatoren, müssen Formular-Validatoren einige
   Formular-spezifische Methoden implementieren. Die Klasse <strong>AbstractFormFilter</strong> hat
   folgenden Aufbau:
</p>
<gen:highlight type="php">
abstract class AbstractFormFilter extends AbstractFilter {

   protected $control;
   protected $button;

   public function __construct(AbstractFormControl &$control, AbstractFormControl &$button){
      $this->control = &$control;
      $this->button = &$button;
   }

   public function isActive(){
      return $this->button->isSent();
   }

}
</gen:highlight>
<p>
   Über den Konstruktor werden das zu filternde Form-Control und der Button, der als Trigger
   fungiert injiziert. Die Methode <strong>filter()</strong> wird vom Formular-Element mit dem zu
   filternden Inhalt versorgt und muss den Filter-Code enthalten. Als Rückgabe wird der gefilterte
   Wert erwartet.
</p>
<p>
   Die Methode <strong>isActive()</strong> dienen dazu, dem Filter zu fragen, ob er ausgeführt werden
   darf.
</p>
<p>
   Die Klassen-Variablen <strong>$control</strong> und <strong>$button</strong> enthalten jeweils
   die Instanz des zu validieren Formular-Elements und den Button, der als Trigger verwendet wird.
</p>
<p>
   Voraussetzung für die Funktion von Filtern ist, dass ein Formular-Element dies unterstützt.
   Hierzu muss in jedem Formular-Control die Methode <strong>addFilter()</strong>
   implementiert sein. Diese in der Klasse <strong>AbstractFormControl</strong> definierte Methode hat
   folgende Signatur:
</p>
<gen:highlight type="php">
public function addFilter(AbstractFormFilter &$filter){
   if($filter->isActive()){
      $value = $this->getAttribute('value');
      $filteredValue = $filter->filter($value);
      $this->setAttribute('value',$filteredValue);
   }
}
</gen:highlight>
<p>
   Wie im Code-Snippet zu sehen ist, nimmt die Methode eine Instanz eines Filters entgegen, führt
   diesen - falls als aktiv gekennzeichnet - aus.
</p>
<p>
   Wie ebenfalls zu erkennen ist, wird dem Filter <em>by default</em> das Tag-Attribut
   <strong>value</strong> übergeben, was nur für Text-Felder gültig ist. Aus diesem Grund
   überschreiben Nicht-Text-Felder diese Methode und übergeben dem Filter den relevanten
   Inhalt.
</p>
<div class="hint">
   Filter finden üblicherweise nur bei Text-Feldern Anwendung. Für Felder mit komplexeren
   Datenstrukturen kann es Sinn machen einen Filter zu schreiben, im Fall der Select-Felder ist es
   jedoch für die Sicherheit nicht von Bedeutung. Aus diesem Grund liefert das APF für Select-Felder
   keine Filter mit.
</div>

<h4 id="Chapter-5-3-Implementierung-von-Filtern"><a href="#Chapter-5-3-Implementierung-von-Filtern">5.3. Implementierung von Filtern</a></h4>
<p>
   Wie bereits im letzten Kapitel angesprochen, muss ein Filter von der Klasse
   <strong>AbstractFormFilter</strong> erben.
</p>
<p>
   Für die Implementierung eines eigenen Filters muss folgendes beachtet werden:
</p>
<ul>
   <li>Der Filter muss von von der Klasse <strong>AbstractFormFilter</strong> erben.</li>
   <li>
      Über den Button (Methode: <strong>isSent()</strong>) kann der Entwickler abfragen, ob das
      Formular mit Klick auf diesen abgesendet wurde.
   </li>
   <li>
      Die Methode <strong>isActive()</strong> kann üblicherweise von
      <strong>AbstractFormFilter</strong> übernommen werden.
   </li>
</ul>
<div class="hint">
   Auf Grund der Besonderheit, dass mit PHP >=5.2.10, bzw. >=5.3.0 die Signaturen von
   überschriebenen abstrakten Methoden Zeichen-identisch sein müssen, muss darauf geachtet werden,
   dass die Funktion <em>public function filter($input)</em> in der Filter-Implementierung exakt so
   definiert wurde!
</div>

<h3 id="Chapter-6-Verwendung-von-Formularen"><a href="#Chapter-6-Verwendung-von-Formularen">6. Verwendung von Formularen</a></h3>
<p>
   Die Verwendung von Formularen und die Verarbeitung mit Hilfe von Document Controllern ist im Kapitel
   <int:link pageid="114" /> näher beschrieben. Diese Seite soll lediglich als Referenz für die vorhandenen Taglibs
   und die Implementierung von Validatoren und Filtern dienen. Weiter wird auf die Erstellung von
   dynamischen Formularen eingegangen.
</p>

<core:importdesign namespace="APF\modules\comments\pres\templates" template="comment" categorykey="de_113" />